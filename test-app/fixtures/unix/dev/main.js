/*!
 * 
 * [Dojo](https://dojo.io/)
 * Copyright [JS Foundation](https://js.foundation/) & contributors
 * [New BSD license](https://github.com/dojo/meta/blob/master/LICENSE)
 * All rights reserved
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("main", [], factory);
	else if(typeof exports === 'object')
		exports["main"] = factory();
	else
		root["main"] = factory();
})(this, function() {
return dojoWebpackJsonptest_app(["main"],{

/***/ "./node_modules/@dojo/core/Destroyable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var lang_1 = __webpack_require__("./node_modules/@dojo/core/lang.js");
var Promise_1 = __webpack_require__("./node_modules/@dojo/shim/Promise.js");
/**
 * No operation function to replace own once instance is destoryed
 */
function noop() {
    return Promise_1.default.resolve(false);
}
/**
 * No op function used to replace own, once instance has been destoryed
 */
function destroyed() {
    throw new Error('Call made to destroyed method');
}
var Destroyable = /** @class */ (function () {
    /**
     * @constructor
     */
    function Destroyable() {
        this.handles = [];
    }
    /**
     * Register handles for the instance that will be destroyed when `this.destroy` is called
     *
     * @param {Handle} handle The handle to add for the instance
     * @returns {Handle} a handle for the handle, removes the handle for the instance and calls destroy
     */
    Destroyable.prototype.own = function (handles) {
        var handle = Array.isArray(handles) ? lang_1.createCompositeHandle.apply(void 0, tslib_1.__spread(handles)) : handles;
        var _handles = this.handles;
        _handles.push(handle);
        return {
            destroy: function () {
                _handles.splice(_handles.indexOf(handle));
                handle.destroy();
            }
        };
    };
    /**
     * Destrpys all handers registered for the instance
     *
     * @returns {Promise<any} a promise that resolves once all handles have been destroyed
     */
    Destroyable.prototype.destroy = function () {
        var _this = this;
        return new Promise_1.default(function (resolve) {
            _this.handles.forEach(function (handle) {
                handle && handle.destroy && handle.destroy();
            });
            _this.destroy = noop;
            _this.own = destroyed;
            resolve(true);
        });
    };
    return Destroyable;
}());
exports.Destroyable = Destroyable;
exports.default = Destroyable;


/***/ }),

/***/ "./node_modules/@dojo/core/Evented.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var Map_1 = __webpack_require__("./node_modules/@dojo/shim/Map.js");
var aspect_1 = __webpack_require__("./node_modules/@dojo/core/aspect.js");
var Destroyable_1 = __webpack_require__("./node_modules/@dojo/core/Destroyable.js");
/**
 * Handles an array of handles
 *
 * @param handles an array of handles
 * @returns a single Handle for handles passed
 */
function handlesArraytoHandle(handles) {
    return {
        destroy: function () {
            handles.forEach(function (handle) { return handle.destroy(); });
        }
    };
}
/**
 * Map of computed regular expressions, keyed by string
 */
var regexMap = new Map_1.default();
/**
 * Determines is the event type glob has been matched
 *
 * @returns boolean that indicates if the glob is matched
 */
function isGlobMatch(globString, targetString) {
    if (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {
        var regex = void 0;
        if (regexMap.has(globString)) {
            regex = regexMap.get(globString);
        }
        else {
            regex = new RegExp("^" + globString.replace(/\*/g, '.*') + "$");
            regexMap.set(globString, regex);
        }
        return regex.test(targetString);
    }
    else {
        return globString === targetString;
    }
}
exports.isGlobMatch = isGlobMatch;
/**
 * Event Class
 */
var Evented = /** @class */ (function (_super) {
    tslib_1.__extends(Evented, _super);
    function Evented() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * map of listeners keyed by event type
         */
        _this.listenersMap = new Map_1.default();
        return _this;
    }
    Evented.prototype.emit = function (event) {
        var _this = this;
        this.listenersMap.forEach(function (method, type) {
            // Since `type` is generic, the compiler doesn't know what type it is and `isGlobMatch` requires `string | symbol`
            if (isGlobMatch(type, event.type)) {
                method.call(_this, event);
            }
        });
    };
    Evented.prototype.on = function (type, listener) {
        var _this = this;
        if (Array.isArray(listener)) {
            var handles = listener.map(function (listener) { return aspect_1.on(_this.listenersMap, type, listener); });
            return handlesArraytoHandle(handles);
        }
        else {
            return aspect_1.on(this.listenersMap, type, listener);
        }
    };
    return Evented;
}(Destroyable_1.Destroyable));
exports.Evented = Evented;
exports.default = Evented;


/***/ }),

/***/ "./node_modules/@dojo/core/aspect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var WeakMap_1 = __webpack_require__("./node_modules/@dojo/shim/WeakMap.js");
var lang_1 = __webpack_require__("./node_modules/@dojo/core/lang.js");
/**
 * An internal type guard that determines if an value is MapLike or not
 *
 * @param value The value to guard against
 */
function isMapLike(value) {
    return value && typeof value.get === 'function' && typeof value.set === 'function';
}
/**
 * A weak map of dispatchers used to apply the advice
 */
var dispatchAdviceMap = new WeakMap_1.default();
/**
 * A UID for tracking advice ordering
 */
var nextId = 0;
/**
 * Internal function that advises a join point
 *
 * @param dispatcher The current advice dispatcher
 * @param type The type of before or after advice to apply
 * @param advice The advice to apply
 * @param receiveArguments If true, the advice will receive the arguments passed to the join point
 * @return The handle that will remove the advice
 */
function adviseObject(dispatcher, type, advice, receiveArguments) {
    var previous = dispatcher && dispatcher[type];
    var advised = {
        id: nextId++,
        advice: advice,
        receiveArguments: receiveArguments
    };
    if (previous) {
        if (type === 'after') {
            // add the listener to the end of the list
            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
            while (previous.next && (previous = previous.next)) { }
            previous.next = advised;
            advised.previous = previous;
        }
        else {
            // add to the beginning
            if (dispatcher) {
                dispatcher.before = advised;
            }
            advised.next = previous;
            previous.previous = advised;
        }
    }
    else {
        dispatcher && (dispatcher[type] = advised);
    }
    advice = previous = undefined;
    return lang_1.createHandle(function () {
        var _a = advised || {}, _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;
        if (dispatcher && !previous && !next) {
            dispatcher[type] = undefined;
        }
        else {
            if (previous) {
                previous.next = next;
            }
            else {
                dispatcher && (dispatcher[type] = next);
            }
            if (next) {
                next.previous = previous;
            }
        }
        if (advised) {
            delete advised.advice;
        }
        dispatcher = advised = undefined;
    });
}
/**
 * Advise a join point (function) with supplied advice
 *
 * @param joinPoint The function to be advised
 * @param type The type of advice to be applied
 * @param advice The advice to apply
 */
function adviseJoinPoint(joinPoint, type, advice) {
    var dispatcher;
    if (type === 'around') {
        dispatcher = getJoinPointDispatcher(advice.apply(this, [joinPoint]));
    }
    else {
        dispatcher = getJoinPointDispatcher(joinPoint);
        // cannot have undefined in map due to code logic, using !
        var adviceMap = dispatchAdviceMap.get(dispatcher);
        if (type === 'before') {
            (adviceMap.before || (adviceMap.before = [])).unshift(advice);
        }
        else {
            (adviceMap.after || (adviceMap.after = [])).push(advice);
        }
    }
    return dispatcher;
}
/**
 * An internal function that resolves or creates the dispatcher for a given join point
 *
 * @param target The target object or map
 * @param methodName The name of the method that the dispatcher should be resolved for
 * @return The dispatcher
 */
function getDispatcherObject(target, methodName) {
    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];
    var dispatcher;
    if (!existing || existing.target !== target) {
        /* There is no existing dispatcher, therefore we will create one */
        dispatcher = function () {
            var executionId = nextId;
            var args = arguments;
            var results;
            var before = dispatcher.before;
            while (before) {
                if (before.advice) {
                    args = before.advice.apply(this, args) || args;
                }
                before = before.next;
            }
            if (dispatcher.around && dispatcher.around.advice) {
                results = dispatcher.around.advice(this, args);
            }
            var after = dispatcher.after;
            while (after && after.id !== undefined && after.id < executionId) {
                if (after.advice) {
                    if (after.receiveArguments) {
                        var newResults = after.advice.apply(this, args);
                        results = newResults === undefined ? results : newResults;
                    }
                    else {
                        results = after.advice.call(this, results, args);
                    }
                }
                after = after.next;
            }
            return results;
        };
        if (isMapLike(target)) {
            target.set(methodName, dispatcher);
        }
        else {
            target && (target[methodName] = dispatcher);
        }
        if (existing) {
            dispatcher.around = {
                advice: function (target, args) {
                    return existing.apply(target, args);
                }
            };
        }
        dispatcher.target = target;
    }
    else {
        dispatcher = existing;
    }
    return dispatcher;
}
/**
 * Returns the dispatcher function for a given joinPoint (method/function)
 *
 * @param joinPoint The function that is to be advised
 */
function getJoinPointDispatcher(joinPoint) {
    function dispatcher() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // cannot have undefined in map due to code logic, using !
        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;
        if (before) {
            args = before.reduce(function (previousArgs, advice) {
                var currentArgs = advice.apply(_this, previousArgs);
                return currentArgs || previousArgs;
            }, args);
        }
        var result = joinPoint.apply(this, args);
        if (after) {
            result = after.reduce(function (previousResult, advice) {
                return advice.apply(_this, [previousResult].concat(args));
            }, result);
        }
        return result;
    }
    /* We want to "clone" the advice that has been applied already, if this
     * joinPoint is already advised */
    if (dispatchAdviceMap.has(joinPoint)) {
        // cannot have undefined in map due to code logic, using !
        var adviceMap = dispatchAdviceMap.get(joinPoint);
        var before_1 = adviceMap.before, after_1 = adviceMap.after;
        if (before_1) {
            before_1 = before_1.slice(0);
        }
        if (after_1) {
            after_1 = after_1.slice(0);
        }
        dispatchAdviceMap.set(dispatcher, {
            joinPoint: adviceMap.joinPoint,
            before: before_1,
            after: after_1
        });
    }
    else {
        /* Otherwise, this is a new joinPoint, so we will create the advice map afresh */
        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });
    }
    return dispatcher;
}
/**
 * Apply advice *after* the supplied joinPoint (function)
 *
 * @param joinPoint A function that should have advice applied to
 * @param advice The after advice
 */
function afterJoinPoint(joinPoint, advice) {
    return adviseJoinPoint(joinPoint, 'after', advice);
}
/**
 * Attaches "after" advice to be executed after the original method.
 * The advising function will receive the original method's return value and arguments object.
 * The value it returns will be returned from the method when it is called (even if the return value is undefined).
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the original method's return value and arguments object
 * @return A handle which will remove the aspect when destroy is called
 */
function afterObject(target, methodName, advice) {
    return adviseObject(getDispatcherObject(target, methodName), 'after', advice);
}
function after(joinPointOrTarget, methodNameOrAdvice, objectAdvice) {
    if (typeof joinPointOrTarget === 'function') {
        return afterJoinPoint(joinPointOrTarget, methodNameOrAdvice);
    }
    else {
        return afterObject(joinPointOrTarget, methodNameOrAdvice, objectAdvice);
    }
}
exports.after = after;
/**
 * Apply advice *around* the supplied joinPoint (function)
 *
 * @param joinPoint A function that should have advice applied to
 * @param advice The around advice
 */
function aroundJoinPoint(joinPoint, advice) {
    return adviseJoinPoint(joinPoint, 'around', advice);
}
exports.aroundJoinPoint = aroundJoinPoint;
/**
 * Attaches "around" advice around the original method.
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the original function
 * @return A handle which will remove the aspect when destroy is called
 */
function aroundObject(target, methodName, advice) {
    var dispatcher = getDispatcherObject(target, methodName);
    var previous = dispatcher.around;
    var advised;
    if (advice) {
        advised = advice(function () {
            if (previous && previous.advice) {
                return previous.advice(this, arguments);
            }
        });
    }
    dispatcher.around = {
        advice: function (target, args) {
            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);
        }
    };
    return lang_1.createHandle(function () {
        advised = dispatcher = undefined;
    });
}
exports.aroundObject = aroundObject;
function around(joinPointOrTarget, methodNameOrAdvice, objectAdvice) {
    if (typeof joinPointOrTarget === 'function') {
        return aroundJoinPoint(joinPointOrTarget, methodNameOrAdvice);
    }
    else {
        return aroundObject(joinPointOrTarget, methodNameOrAdvice, objectAdvice);
    }
}
exports.around = around;
/**
 * Apply advice *before* the supplied joinPoint (function)
 *
 * @param joinPoint A function that should have advice applied to
 * @param advice The before advice
 */
function beforeJoinPoint(joinPoint, advice) {
    return adviseJoinPoint(joinPoint, 'before', advice);
}
exports.beforeJoinPoint = beforeJoinPoint;
/**
 * Attaches "before" advice to be executed before the original method.
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the same arguments as the original, and may return new arguments
 * @return A handle which will remove the aspect when destroy is called
 */
function beforeObject(target, methodName, advice) {
    return adviseObject(getDispatcherObject(target, methodName), 'before', advice);
}
exports.beforeObject = beforeObject;
function before(joinPointOrTarget, methodNameOrAdvice, objectAdvice) {
    if (typeof joinPointOrTarget === 'function') {
        return beforeJoinPoint(joinPointOrTarget, methodNameOrAdvice);
    }
    else {
        return beforeObject(joinPointOrTarget, methodNameOrAdvice, objectAdvice);
    }
}
exports.before = before;
/**
 * Attaches advice to be executed after the original method.
 * The advising function will receive the same arguments as the original method.
 * The value it returns will be returned from the method when it is called *unless* its return value is undefined.
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the same arguments as the original method
 * @return A handle which will remove the aspect when destroy is called
 */
function on(target, methodName, advice) {
    return adviseObject(getDispatcherObject(target, methodName), 'after', advice, true);
}
exports.on = on;


/***/ }),

/***/ "./node_modules/@dojo/core/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
tslib_1.__exportStar(__webpack_require__("./node_modules/@dojo/shim/support/has.js"), exports);
exports.default = has_1.default;
has_1.add('object-assign', typeof global_1.default.Object.assign === 'function', true);
has_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined', true);
has_1.add('formdata', typeof global_1.default.FormData !== 'undefined', true);
has_1.add('filereader', typeof global_1.default.FileReader !== 'undefined', true);
has_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined', true);
has_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype, true);
has_1.add('blob', function () {
    if (!has_1.default('xhr2')) {
        return false;
    }
    var request = new global_1.default.XMLHttpRequest();
    request.open('GET', 'http://www.google.com', true);
    request.responseType = 'blob';
    request.abort();
    return request.responseType === 'blob';
}, true);
has_1.add('node-buffer', 'Buffer' in global_1.default && typeof global_1.default.Buffer === 'function', true);
has_1.add('fetch', 'fetch' in global_1.default && typeof global_1.default.fetch === 'function', true);
has_1.add('web-worker-xhr-upload', new Promise(function (resolve) {
    try {
        if (global_1.default.Worker !== undefined && global_1.default.URL && global_1.default.URL.createObjectURL) {
            var blob = new Blob([
                "(function () {\nself.addEventListener('message', function () {\n\tvar xhr = new XMLHttpRequest();\n\ttry {\n\t\txhr.upload;\n\t\tpostMessage('true');\n\t} catch (e) {\n\t\tpostMessage('false');\n\t}\n});\n\t\t})()"
            ], { type: 'application/javascript' });
            var worker = new Worker(URL.createObjectURL(blob));
            worker.addEventListener('message', function (_a) {
                var result = _a.data;
                resolve(result === 'true');
            });
            worker.postMessage({});
        }
        else {
            resolve(false);
        }
    }
    catch (e) {
        // IE11 on Winodws 8.1 encounters a security error.
        resolve(false);
    }
}), true);


/***/ }),

/***/ "./node_modules/@dojo/core/lang.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var object_1 = __webpack_require__("./node_modules/@dojo/shim/object.js");
var object_2 = __webpack_require__("./node_modules/@dojo/shim/object.js");
exports.assign = object_2.assign;
var slice = Array.prototype.slice;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Type guard that ensures that the value can be coerced to Object
 * to weed out host objects that do not derive from Object.
 * This function is used to check if we want to deep copy an object or not.
 * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will
 * change the value returned by `toString`. This is a rare edge case that is difficult to handle,
 * so it is not handled here.
 * @param  value The value to check
 * @return       If the value is coercible into an Object
 */
function shouldDeepCopyObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
function copyArray(array, inherited) {
    return array.map(function (item) {
        if (Array.isArray(item)) {
            return copyArray(item, inherited);
        }
        return !shouldDeepCopyObject(item)
            ? item
            : _mixin({
                deep: true,
                inherited: inherited,
                sources: [item],
                target: {}
            });
    });
}
function _mixin(kwArgs) {
    var deep = kwArgs.deep;
    var inherited = kwArgs.inherited;
    var target = kwArgs.target;
    var copied = kwArgs.copied || [];
    var copiedClone = tslib_1.__spread(copied);
    for (var i = 0; i < kwArgs.sources.length; i++) {
        var source = kwArgs.sources[i];
        if (source === null || source === undefined) {
            continue;
        }
        for (var key in source) {
            if (inherited || hasOwnProperty.call(source, key)) {
                var value = source[key];
                if (copiedClone.indexOf(value) !== -1) {
                    continue;
                }
                if (deep) {
                    if (Array.isArray(value)) {
                        value = copyArray(value, inherited);
                    }
                    else if (shouldDeepCopyObject(value)) {
                        var targetValue = target[key] || {};
                        copied.push(source);
                        value = _mixin({
                            deep: true,
                            inherited: inherited,
                            sources: [value],
                            target: targetValue,
                            copied: copied
                        });
                    }
                }
                target[key] = value;
            }
        }
    }
    return target;
}
function create(prototype) {
    var mixins = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        mixins[_i - 1] = arguments[_i];
    }
    if (!mixins.length) {
        throw new RangeError('lang.create requires at least one mixin object.');
    }
    var args = mixins.slice();
    args.unshift(Object.create(prototype));
    return object_1.assign.apply(null, args);
}
exports.create = create;
function deepAssign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: true,
        inherited: false,
        sources: sources,
        target: target
    });
}
exports.deepAssign = deepAssign;
function deepMixin(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: true,
        inherited: true,
        sources: sources,
        target: target
    });
}
exports.deepMixin = deepMixin;
/**
 * Creates a new object using the provided source's prototype as the prototype for the new object, and then
 * deep copies the provided source's values into the new target.
 *
 * @param source The object to duplicate
 * @return The new object
 */
function duplicate(source) {
    var target = Object.create(Object.getPrototypeOf(source));
    return deepMixin(target, source);
}
exports.duplicate = duplicate;
/**
 * Determines whether two values are the same value.
 *
 * @param a First value to compare
 * @param b Second value to compare
 * @return true if the values are the same; false otherwise
 */
function isIdentical(a, b) {
    return (a === b ||
        /* both values are NaN */
        (a !== a && b !== b));
}
exports.isIdentical = isIdentical;
/**
 * Returns a function that binds a method to the specified object at runtime. This is similar to
 * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.
 * As a result, the function returned by `lateBind` will always call the function currently assigned to
 * the specified property on the object as of the moment the function it returns is called.
 *
 * @param instance The context object
 * @param method The name of the method on the context object to bind to itself
 * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list
 * @return The bound function
 */
function lateBind(instance, method) {
    var suppliedArgs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        suppliedArgs[_i - 2] = arguments[_i];
    }
    return suppliedArgs.length
        ? function () {
            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;
            // TS7017
            return instance[method].apply(instance, args);
        }
        : function () {
            // TS7017
            return instance[method].apply(instance, arguments);
        };
}
exports.lateBind = lateBind;
function mixin(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: false,
        inherited: true,
        sources: sources,
        target: target
    });
}
exports.mixin = mixin;
/**
 * Returns a function which invokes the given function with the given arguments prepended to its argument list.
 * Like `Function.prototype.bind`, but does not alter execution context.
 *
 * @param targetFunction The function that needs to be bound
 * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list
 * @return The bound function
 */
function partial(targetFunction) {
    var suppliedArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        suppliedArgs[_i - 1] = arguments[_i];
    }
    return function () {
        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;
        return targetFunction.apply(this, args);
    };
}
exports.partial = partial;
/**
 * Returns an object with a destroy method that, when called, calls the passed-in destructor.
 * This is intended to provide a unified interface for creating "remove" / "destroy" handlers for
 * event listeners, timers, etc.
 *
 * @param destructor A function that will be called when the handle's `destroy` method is invoked
 * @return The handle object
 */
function createHandle(destructor) {
    return {
        destroy: function () {
            this.destroy = function () { };
            destructor.call(this);
        }
    };
}
exports.createHandle = createHandle;
/**
 * Returns a single handle that can be used to destroy multiple handles simultaneously.
 *
 * @param handles An array of handles with `destroy` methods
 * @return The handle object
 */
function createCompositeHandle() {
    var handles = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        handles[_i] = arguments[_i];
    }
    return createHandle(function () {
        for (var i = 0; i < handles.length; i++) {
            handles[i].destroy();
        }
    });
}
exports.createCompositeHandle = createCompositeHandle;


/***/ }),

/***/ "./node_modules/@dojo/core/load/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
function isPlugin(value) {
    return Boolean(value) && typeof value.load === 'function';
}
exports.isPlugin = isPlugin;
function useDefault(modules) {
    if (iterator_1.isArrayLike(modules)) {
        var processedModules = [];
        for (var i = 0; i < modules.length; i++) {
            var module_1 = modules[i];
            processedModules.push(module_1.__esModule && module_1.default ? module_1.default : module_1);
        }
        return processedModules;
    }
    else if (iterator_1.isIterable(modules)) {
        var processedModules = [];
        try {
            for (var modules_1 = tslib_1.__values(modules), modules_1_1 = modules_1.next(); !modules_1_1.done; modules_1_1 = modules_1.next()) {
                var module_2 = modules_1_1.value;
                processedModules.push(module_2.__esModule && module_2.default ? module_2.default : module_2);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (modules_1_1 && !modules_1_1.done && (_a = modules_1.return)) _a.call(modules_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return processedModules;
    }
    else {
        return modules.__esModule && modules.default ? modules.default : modules;
    }
    var e_1, _a;
}
exports.useDefault = useDefault;


/***/ }),

/***/ "./node_modules/@dojo/core/uuid.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a v4 compliant UUID.
 *
 * @returns {string}
 */
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
exports.default = uuid;


/***/ }),

/***/ "./node_modules/@dojo/has/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {
Object.defineProperty(exports, "__esModule", { value: true });
function isFeatureTestThenable(value) {
    return value && value.then;
}
/**
 * A cache of results of feature tests
 */
exports.testCache = {};
/**
 * A cache of the un-resolved feature tests
 */
exports.testFunctions = {};
/**
 * A cache of unresolved thenables (probably promises)
 * @type {{}}
 */
var testThenables = {};
/**
 * A reference to the global scope (`window` in a browser, `global` in NodeJS)
 */
var globalScope = (function () {
    /* istanbul ignore else */
    if (typeof window !== 'undefined') {
        // Browsers
        return window;
    }
    else if (typeof global !== 'undefined') {
        // Node
        return global;
    }
    else if (typeof self !== 'undefined') {
        // Web workers
        return self;
    }
    /* istanbul ignore next */
    return {};
})();
/* Grab the staticFeatures if there are available */
var staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;
/* Cleaning up the DojoHasEnviornment */
if ('DojoHasEnvironment' in globalScope) {
    delete globalScope.DojoHasEnvironment;
}
/**
 * Custom type guard to narrow the `staticFeatures` to either a map or a function that
 * returns a map.
 *
 * @param value The value to guard for
 */
function isStaticFeatureFunction(value) {
    return typeof value === 'function';
}
/**
 * The cache of asserted features that were available in the global scope when the
 * module loaded
 */
var staticCache = staticFeatures
    ? isStaticFeatureFunction(staticFeatures) ? staticFeatures.apply(globalScope) : staticFeatures
    : {};/* Providing an empty cache, if none was in the environment

/**
* AMD plugin function.
*
* Conditional loads modules based on a has feature test value.
*
* @param resourceId Gives the resolved module id to load.
* @param require The loader require function with respect to the module that contained the plugin resource in its
*                dependency list.
* @param load Callback to loader that consumes result of plugin demand.
*/
function load(resourceId, require, load, config) {
    resourceId ? require([resourceId], load) : load();
}
exports.load = load;
/**
 * AMD plugin function.
 *
 * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test
 * value(s).
 *
 * @param resourceId The id of the module
 * @param normalize Resolves a relative module id into an absolute module id
 */
function normalize(resourceId, normalize) {
    var tokens = resourceId.match(/[\?:]|[^:\?]*/g) || [];
    var i = 0;
    function get(skip) {
        var term = tokens[i++];
        if (term === ':') {
            // empty string module name, resolves to null
            return null;
        }
        else {
            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
            if (tokens[i++] === '?') {
                if (!skip && has(term)) {
                    // matched the feature, get the first value from the options
                    return get();
                }
                else {
                    // did not match, get the second value, passing over the first
                    get(true);
                    return get(skip);
                }
            }
            // a module
            return term;
        }
    }
    var id = get();
    return id && normalize(id);
}
exports.normalize = normalize;
/**
 * Check if a feature has already been registered
 *
 * @param feature the name of the feature
 */
function exists(feature) {
    var normalizedFeature = feature.toLowerCase();
    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);
}
exports.exists = exists;
/**
 * Register a new test for a named feature.
 *
 * @example
 * has.add('dom-addeventlistener', !!document.addEventListener);
 *
 * @example
 * has.add('touch-events', function () {
 *    return 'ontouchstart' in document
 * });
 *
 * @param feature the name of the feature
 * @param value the value reported of the feature, or a function that will be executed once on first test
 * @param overwrite if an existing value should be overwritten. Defaults to false.
 */
function add(feature, value, overwrite) {
    if (overwrite === void 0) { overwrite = false; }
    var normalizedFeature = feature.toLowerCase();
    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {
        throw new TypeError("Feature \"" + feature + "\" exists and overwrite not true.");
    }
    if (typeof value === 'function') {
        exports.testFunctions[normalizedFeature] = value;
    }
    else if (isFeatureTestThenable(value)) {
        testThenables[feature] = value.then(function (resolvedValue) {
            exports.testCache[feature] = resolvedValue;
            delete testThenables[feature];
        }, function () {
            delete testThenables[feature];
        });
    }
    else {
        exports.testCache[normalizedFeature] = value;
        delete exports.testFunctions[normalizedFeature];
    }
}
exports.add = add;
/**
 * Return the current value of a named feature.
 *
 * @param feature The name (if a string) or identifier (if an integer) of the feature to test.
 */
function has(feature) {
    var result;
    var normalizedFeature = feature.toLowerCase();
    if (normalizedFeature in staticCache) {
        result = staticCache[normalizedFeature];
    }
    else if (exports.testFunctions[normalizedFeature]) {
        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);
        delete exports.testFunctions[normalizedFeature];
    }
    else if (normalizedFeature in exports.testCache) {
        result = exports.testCache[normalizedFeature];
    }
    else if (feature in testThenables) {
        return false;
    }
    else {
        throw new TypeError("Attempt to detect unregistered has feature \"" + feature + "\"");
    }
    return result;
}
exports.default = has;
/*
 * Out of the box feature tests
 */
/* Environments */
/* Used as a value to provide a debug only code path */
add('debug', true);
/* Detects if the environment is "browser like" */
add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');
/* Detects if the environment appears to be NodeJS */
add('host-node', function () {
    if (typeof process === 'object' && process.versions && process.versions.node) {
        return process.versions.node;
    }
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@dojo/i18n/cldr/load.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// required for Globalize/Cldr to properly resolve locales in the browser.
__webpack_require__("./node_modules/cldrjs/dist/cldr/unresolved.js");
var Promise_1 = __webpack_require__("./node_modules/@dojo/shim/Promise.js");
var Globalize = __webpack_require__("./node_modules/globalize/dist/node-main.js");
var locales_1 = __webpack_require__("./node_modules/@dojo/i18n/cldr/locales.js");
var main_1 = __webpack_require__("./node_modules/@dojo/i18n/util/main.js");
/**
 * A list of all required CLDR packages for an individual locale.
 */
exports.mainPackages = Object.freeze([
    'dates/calendars/gregorian',
    'dates/fields',
    'dates/timeZoneNames',
    'numbers',
    'numbers/currencies',
    'units'
]);
/**
 * A list of all required CLDR supplement packages.
 */
exports.supplementalPackages = Object.freeze([
    'currencyData',
    'likelySubtags',
    'numberingSystems',
    'plurals-type-cardinal',
    'plurals-type-ordinal',
    'timeData',
    'weekData'
]);
/**
 * @private
 * A simple map containing boolean flags indicating whether a particular CLDR package has been loaded.
 */
var loadCache = {
    main: Object.create(null),
    supplemental: generateSupplementalCache()
};
/**
 * @private
 * Generate the locale-specific data cache from a list of keys. Nested objects will be generated from
 * slash-separated strings.
 *
 * @param cache
 * An empty locale cache object.
 *
 * @param keys
 * The list of keys.
 */
function generateLocaleCache(cache, keys) {
    return keys.reduce(function (tree, key) {
        var parts = key.split('/');
        if (parts.length === 1) {
            tree[key] = false;
            return tree;
        }
        parts.reduce(function (tree, key, i) {
            if (typeof tree[key] !== 'object') {
                tree[key] = i === parts.length - 1 ? false : Object.create(null);
            }
            return tree[key];
        }, tree);
        return tree;
    }, cache);
}
/**
 * @private
 * Generate the supplemental data cache.
 */
function generateSupplementalCache() {
    return exports.supplementalPackages.reduce(function (map, key) {
        map[key] = false;
        return map;
    }, Object.create(null));
}
/**
 * @private
 * Recursively determine whether a list of packages have been loaded for the specified CLDR group.
 *
 * @param group
 * The CLDR group object (e.g., the supplemental data, or a specific locale group)
 *
 * @param args
 * A list of keys to recursively check from left to right. For example, if [ "en", "numbers" ],
 * then `group.en.numbers` must exist for the test to pass.
 *
 * @return
 * `true` if the deepest value exists; `false` otherwise.
 */
function isLoadedForGroup(group, args) {
    return args.every(function (arg) {
        var next = group[arg];
        group = next;
        return Boolean(next);
    });
}
/**
 * @private
 * Recursively flag as loaded all recognized keys on the provided CLDR data object.
 *
 * @param cache
 * The load cache (either the entire object, or a nested segment of it).
 *
 * @param localeData
 * The CLDR data object being loaded (either the entire object, or a nested segment of it).
 */
function registerLocaleData(cache, localeData) {
    Object.keys(localeData).forEach(function (key) {
        if (key in cache) {
            var value = cache[key];
            if (typeof value === 'boolean') {
                cache[key] = true;
            }
            else {
                registerLocaleData(value, localeData[key]);
            }
        }
    });
}
/**
 * @private
 * Flag all supplied CLDR packages for a specific locale as loaded.
 *
 * @param data
 * The `main` locale data.
 */
function registerMain(data) {
    if (!data) {
        return;
    }
    Object.keys(data).forEach(function (locale) {
        if (locales_1.default.indexOf(locale) < 0) {
            return;
        }
        var loadedData = loadCache.main[locale];
        if (!loadedData) {
            loadedData = loadCache.main[locale] = generateLocaleCache(Object.create(null), exports.mainPackages);
        }
        registerLocaleData(loadedData, data[locale]);
    });
}
/**
 * @private
 * Flag all supplied CLDR supplemental packages as loaded.
 *
 * @param data
 * The supplemental data.
 */
function registerSupplemental(data) {
    if (!data) {
        return;
    }
    var supplemental = loadCache.supplemental;
    Object.keys(data).forEach(function (key) {
        if (key in supplemental) {
            supplemental[key] = true;
        }
    });
}
/**
 * Determine whether a particular CLDR package has been loaded.
 *
 * Example: to check that `supplemental.likelySubtags` has been loaded, `isLoaded` would be called as
 * `isLoaded('supplemental', 'likelySubtags')`.
 *
 * @param groupName
 * The group to check; either "main" or "supplemental".
 *
 * @param ...args
 * Any remaining keys in the path to the desired package.
 *
 * @return
 * `true` if the deepest value exists; `false` otherwise.
 */
function isLoaded(groupName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var group = loadCache[groupName];
    if (groupName === 'main' && args.length > 0) {
        var locale = args[0];
        if (!main_1.validateLocale(locale)) {
            return false;
        }
        args = args.slice(1);
        return main_1.generateLocales(locale).some(function (locale) {
            var next = group[locale];
            return next ? isLoadedForGroup(next, args) : false;
        });
    }
    return isLoadedForGroup(group, args);
}
exports.isLoaded = isLoaded;
/**
 * Load the specified CLDR data with the i18n ecosystem.
 *
 * @param data
 * A data object containing `main` and/or `supplemental` objects with CLDR data.
 */
function loadCldrData(data) {
    registerMain(data.main);
    registerSupplemental(data.supplemental);
    Globalize.load(data);
    return Promise_1.default.resolve();
}
exports.default = loadCldrData;
/**
 * Clear the load cache, either the entire cache for the specified group. After calling this method,
 * `isLoaded` will return false for keys within the specified group(s).
 *
 * @param group
 * An optional group name. If not provided, then both the "main" and "supplemental" caches will be cleared.
 */
function reset(group) {
    if (group !== 'supplemental') {
        loadCache.main = Object.create(null);
    }
    if (group !== 'main') {
        loadCache.supplemental = generateSupplementalCache();
    }
}
exports.reset = reset;


/***/ }),

/***/ "./node_modules/@dojo/i18n/cldr/locales.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A list of `cldr-data/main` directories used to load the correct CLDR data for a given locale.
 */
var localesList = [
    'af-NA',
    'af',
    'agq',
    'ak',
    'am',
    'ar-AE',
    'ar-BH',
    'ar-DJ',
    'ar-DZ',
    'ar-EG',
    'ar-EH',
    'ar-ER',
    'ar-IL',
    'ar-IQ',
    'ar-JO',
    'ar-KM',
    'ar-KW',
    'ar-LB',
    'ar-LY',
    'ar-MA',
    'ar-MR',
    'ar-OM',
    'ar-PS',
    'ar-QA',
    'ar-SA',
    'ar-SD',
    'ar-SO',
    'ar-SS',
    'ar-SY',
    'ar-TD',
    'ar-TN',
    'ar-YE',
    'ar',
    'as',
    'asa',
    'ast',
    'az-Cyrl',
    'az-Latn',
    'az',
    'bas',
    'be',
    'bem',
    'bez',
    'bg',
    'bm',
    'bn-IN',
    'bn',
    'bo-IN',
    'bo',
    'br',
    'brx',
    'bs-Cyrl',
    'bs-Latn',
    'bs',
    'ca-AD',
    'ca-ES-VALENCIA',
    'ca-FR',
    'ca-IT',
    'ca',
    'ce',
    'cgg',
    'chr',
    'ckb-IR',
    'ckb',
    'cs',
    'cu',
    'cy',
    'da-GL',
    'da',
    'dav',
    'de-AT',
    'de-BE',
    'de-CH',
    'de-IT',
    'de-LI',
    'de-LU',
    'de',
    'dje',
    'dsb',
    'dua',
    'dyo',
    'dz',
    'ebu',
    'ee-TG',
    'ee',
    'el-CY',
    'el',
    'en-001',
    'en-150',
    'en-AG',
    'en-AI',
    'en-AS',
    'en-AT',
    'en-AU',
    'en-BB',
    'en-BE',
    'en-BI',
    'en-BM',
    'en-BS',
    'en-BW',
    'en-BZ',
    'en-CA',
    'en-CC',
    'en-CH',
    'en-CK',
    'en-CM',
    'en-CX',
    'en-CY',
    'en-DE',
    'en-DG',
    'en-DK',
    'en-DM',
    'en-ER',
    'en-FI',
    'en-FJ',
    'en-FK',
    'en-FM',
    'en-GB',
    'en-GD',
    'en-GG',
    'en-GH',
    'en-GI',
    'en-GM',
    'en-GU',
    'en-GY',
    'en-HK',
    'en-IE',
    'en-IL',
    'en-IM',
    'en-IN',
    'en-IO',
    'en-JE',
    'en-JM',
    'en-KE',
    'en-KI',
    'en-KN',
    'en-KY',
    'en-LC',
    'en-LR',
    'en-LS',
    'en-MG',
    'en-MH',
    'en-MO',
    'en-MP',
    'en-MS',
    'en-MT',
    'en-MU',
    'en-MW',
    'en-MY',
    'en-NA',
    'en-NF',
    'en-NG',
    'en-NL',
    'en-NR',
    'en-NU',
    'en-NZ',
    'en-PG',
    'en-PH',
    'en-PK',
    'en-PN',
    'en-PR',
    'en-PW',
    'en-RW',
    'en-SB',
    'en-SC',
    'en-SD',
    'en-SE',
    'en-SG',
    'en-SH',
    'en-SI',
    'en-SL',
    'en-SS',
    'en-SX',
    'en-SZ',
    'en-TC',
    'en-TK',
    'en-TO',
    'en-TT',
    'en-TV',
    'en-TZ',
    'en-UG',
    'en-UM',
    'en-US-POSIX',
    'en-VC',
    'en-VG',
    'en-VI',
    'en-VU',
    'en-WS',
    'en-ZA',
    'en-ZM',
    'en-ZW',
    'en',
    'eo',
    'es-419',
    'es-AR',
    'es-BO',
    'es-BR',
    'es-CL',
    'es-CO',
    'es-CR',
    'es-CU',
    'es-DO',
    'es-EA',
    'es-EC',
    'es-GQ',
    'es-GT',
    'es-HN',
    'es-IC',
    'es-MX',
    'es-NI',
    'es-PA',
    'es-PE',
    'es-PH',
    'es-PR',
    'es-PY',
    'es-SV',
    'es-US',
    'es-UY',
    'es-VE',
    'es',
    'et',
    'eu',
    'ewo',
    'fa-AF',
    'fa',
    'ff-CM',
    'ff-GN',
    'ff-MR',
    'ff',
    'fi',
    'fil',
    'fo-DK',
    'fo',
    'fr-BE',
    'fr-BF',
    'fr-BI',
    'fr-BJ',
    'fr-BL',
    'fr-CA',
    'fr-CD',
    'fr-CF',
    'fr-CG',
    'fr-CH',
    'fr-CI',
    'fr-CM',
    'fr-DJ',
    'fr-DZ',
    'fr-GA',
    'fr-GF',
    'fr-GN',
    'fr-GP',
    'fr-GQ',
    'fr-HT',
    'fr-KM',
    'fr-LU',
    'fr-MA',
    'fr-MC',
    'fr-MF',
    'fr-MG',
    'fr-ML',
    'fr-MQ',
    'fr-MR',
    'fr-MU',
    'fr-NC',
    'fr-NE',
    'fr-PF',
    'fr-PM',
    'fr-RE',
    'fr-RW',
    'fr-SC',
    'fr-SN',
    'fr-SY',
    'fr-TD',
    'fr-TG',
    'fr-TN',
    'fr-VU',
    'fr-WF',
    'fr-YT',
    'fr',
    'fur',
    'fy',
    'ga',
    'gd',
    'gl',
    'gsw-FR',
    'gsw-LI',
    'gsw',
    'gu',
    'guz',
    'gv',
    'ha-GH',
    'ha-NE',
    'ha',
    'haw',
    'he',
    'hi',
    'hr-BA',
    'hr',
    'hsb',
    'hu',
    'hy',
    'id',
    'ig',
    'ii',
    'is',
    'it-CH',
    'it-SM',
    'it',
    'ja',
    'jgo',
    'jmc',
    'ka',
    'kab',
    'kam',
    'kde',
    'kea',
    'khq',
    'ki',
    'kk',
    'kkj',
    'kl',
    'kln',
    'km',
    'kn',
    'ko-KP',
    'ko',
    'kok',
    'ks',
    'ksb',
    'ksf',
    'ksh',
    'kw',
    'ky',
    'lag',
    'lb',
    'lg',
    'lkt',
    'ln-AO',
    'ln-CF',
    'ln-CG',
    'ln',
    'lo',
    'lrc-IQ',
    'lrc',
    'lt',
    'lu',
    'luo',
    'luy',
    'lv',
    'mas-TZ',
    'mas',
    'mer',
    'mfe',
    'mg',
    'mgh',
    'mgo',
    'mk',
    'ml',
    'mn',
    'mr',
    'ms-BN',
    'ms-SG',
    'ms',
    'mt',
    'mua',
    'my',
    'mzn',
    'naq',
    'nb-SJ',
    'nb',
    'nd',
    'nds-NL',
    'nds',
    'ne-IN',
    'ne',
    'nl-AW',
    'nl-BE',
    'nl-BQ',
    'nl-CW',
    'nl-SR',
    'nl-SX',
    'nl',
    'nmg',
    'nn',
    'nnh',
    'nus',
    'nyn',
    'om-KE',
    'om',
    'or',
    'os-RU',
    'os',
    'pa-Arab',
    'pa-Guru',
    'pa',
    'pl',
    'prg',
    'ps',
    'pt-AO',
    'pt-CH',
    'pt-CV',
    'pt-GQ',
    'pt-GW',
    'pt-LU',
    'pt-MO',
    'pt-MZ',
    'pt-PT',
    'pt-ST',
    'pt-TL',
    'pt',
    'qu-BO',
    'qu-EC',
    'qu',
    'rm',
    'rn',
    'ro-MD',
    'ro',
    'rof',
    'root',
    'ru-BY',
    'ru-KG',
    'ru-KZ',
    'ru-MD',
    'ru-UA',
    'ru',
    'rw',
    'rwk',
    'sah',
    'saq',
    'sbp',
    'se-FI',
    'se-SE',
    'se',
    'seh',
    'ses',
    'sg',
    'shi-Latn',
    'shi-Tfng',
    'shi',
    'si',
    'sk',
    'sl',
    'smn',
    'sn',
    'so-DJ',
    'so-ET',
    'so-KE',
    'so',
    'sq-MK',
    'sq-XK',
    'sq',
    'sr-Cyrl-BA',
    'sr-Cyrl-ME',
    'sr-Cyrl-XK',
    'sr-Cyrl',
    'sr-Latn-BA',
    'sr-Latn-ME',
    'sr-Latn-XK',
    'sr-Latn',
    'sr',
    'sv-AX',
    'sv-FI',
    'sv',
    'sw-CD',
    'sw-KE',
    'sw-UG',
    'sw',
    'ta-LK',
    'ta-MY',
    'ta-SG',
    'ta',
    'te',
    'teo-KE',
    'teo',
    'th',
    'ti-ER',
    'ti',
    'tk',
    'to',
    'tr-CY',
    'tr',
    'twq',
    'tzm',
    'ug',
    'uk',
    'ur-IN',
    'ur',
    'uz-Arab',
    'uz-Cyrl',
    'uz-Latn',
    'uz',
    'vai-Latn',
    'vai-Vaii',
    'vai',
    'vi',
    'vo',
    'vun',
    'wae',
    'xog',
    'yav',
    'yi',
    'yo-BJ',
    'yo',
    'yue',
    'zgh',
    'zh-Hans-HK',
    'zh-Hans-MO',
    'zh-Hans-SG',
    'zh-Hans',
    'zh-Hant-HK',
    'zh-Hant-MO',
    'zh-Hant',
    'zh',
    'zu'
];
exports.default = localesList;


/***/ }),

/***/ "./node_modules/@dojo/i18n/i18n.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
/* tslint:disable:interface-name */
__webpack_require__("./node_modules/@dojo/shim/Promise.js"); // ensure Promise.all exists
var Evented_1 = __webpack_require__("./node_modules/@dojo/core/Evented.js");
var has_1 = __webpack_require__("./node_modules/@dojo/core/has.js");
var lang_1 = __webpack_require__("./node_modules/@dojo/core/lang.js");
var util_1 = __webpack_require__("./node_modules/@dojo/core/load/util.js");
var uuid_1 = __webpack_require__("./node_modules/@dojo/core/uuid.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var Map_1 = __webpack_require__("./node_modules/@dojo/shim/Map.js");
var Observable_1 = __webpack_require__("./node_modules/@dojo/shim/Observable.js");
var Globalize = __webpack_require__("./node_modules/globalize/dist/globalize/message.js");
var load_1 = __webpack_require__("./node_modules/@dojo/i18n/cldr/load.js");
var main_1 = __webpack_require__("./node_modules/@dojo/i18n/util/main.js");
var TOKEN_PATTERN = /\{([a-z0-9_]+)\}/gi;
var bundleMap = new Map_1.default();
var formatterMap = new Map_1.default();
var localeProducer = new Evented_1.default();
var rootLocale;
/**
 * Return the bundle's unique identifier, creating one if it does not already exist.
 *
 * @param bundle A message bundle
 * @return The bundle's unique identifier
 */
function getBundleId(bundle) {
    if (bundle.id) {
        return bundle.id;
    }
    var id = uuid_1.default();
    Object.defineProperty(bundle, 'id', {
        value: id
    });
    return id;
}
/**
 * @private
 * Return a function that formats an ICU-style message, and takes an optional value for token replacement.
 *
 * Usage:
 * const formatter = getMessageFormatter(bundle, 'guestInfo', 'fr');
 * const message = formatter({
 *   host: 'Miles',
 *   gender: 'male',
 *   guest: 'Oscar',
 *   guestCount: '15'
 * });
 *
 * @param id
 * The message's bundle id.
 *
 * @param key
 * The message's key.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The message formatter.
 */
function getIcuMessageFormatter(id, key, locale) {
    locale = main_1.normalizeLocale(locale || getRootLocale());
    var formatterKey = locale + ":" + id + ":" + key;
    var formatter = formatterMap.get(formatterKey);
    if (formatter) {
        return formatter;
    }
    var globalize = locale !== getRootLocale() ? new Globalize(main_1.normalizeLocale(locale)) : Globalize;
    formatter = globalize.messageFormatter(id + "/" + key);
    var cached = bundleMap.get(id);
    if (cached && cached.get(locale)) {
        formatterMap.set(formatterKey, formatter);
    }
    return formatter;
}
/**
 * @private
 * Load the specified locale-specific bundles, mapping the default exports to simple `Messages` objects.
 */
function loadLocaleBundles(locales, supported) {
    return Promise.all(supported.map(function (locale) { return locales[locale](); })).then(function (bundles) {
        return bundles.map(function (bundle) { return util_1.useDefault(bundle); });
    });
}
/**
 * @private
 * Return the root locale. Defaults to the system locale.
 */
function getRootLocale() {
    return rootLocale || exports.systemLocale;
}
/**
 * @private
 * Retrieve a list of supported locales that can provide messages for the specified locale.
 *
 * @param locale
 * The target locale.
 *
 * @param supported
 * The locales that are supported by the bundle.
 *
 * @return
 * A list of supported locales that match the target locale.
 */
function getSupportedLocales(locale, supported) {
    if (supported === void 0) { supported = []; }
    return main_1.generateLocales(locale).filter(function (locale) { return supported.indexOf(locale) > -1; });
}
/**
 * @private
 * Inject messages for the specified locale into the i18n system.
 *
 * @param id
 * The bundle's unique identifier
 *
 * @param messages
 * The messages to inject
 *
 * @param locale
 * An optional locale. If not specified, then it is assumed that the messages are the defaults for the given
 * bundle path.
 */
function loadMessages(id, messages, locale) {
    if (locale === void 0) { locale = 'root'; }
    var cached = bundleMap.get(id);
    if (!cached) {
        cached = new Map_1.default();
        bundleMap.set(id, cached);
    }
    cached.set(locale, messages);
    Globalize.loadMessages((_a = {},
        _a[locale] = (_b = {},
            _b[id] = messages,
            _b),
        _a));
    var _a, _b;
}
/**
 * Return a formatted message.
 *
 * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
 * the ICU message format is supported. Otherwise, a simple token-replacement mechanism is used.
 *
 * Usage:
 * formatMessage(bundle, 'guestInfo', {
 *   host: 'Bill',
 *   guest: 'John'
 * }, 'fr');
 *
 * @param bundle
 * The bundle containing the target message.
 *
 * @param key
 * The message's key.
 *
 * @param options
 * An optional value used by the formatter to replace tokens with values.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The formatted message.
 */
function formatMessage(bundle, key, options, locale) {
    return getMessageFormatter(bundle, key, locale)(options);
}
exports.formatMessage = formatMessage;
/**
 * Return the cached messages for the specified bundle and locale. If messages have not been previously loaded for the
 * specified locale, no value will be returned.
 *
 * @param bundle
 * The default bundle that is used to determine where the locale-specific bundles are located.
 *
 * @param locale
 * The locale of the desired messages.
 *
 * @return The cached messages object, if it exists.
 */
function getCachedMessages(bundle, locale) {
    var _a = bundle.id, id = _a === void 0 ? getBundleId(bundle) : _a, locales = bundle.locales, messages = bundle.messages;
    var cached = bundleMap.get(id);
    if (!cached) {
        loadMessages(id, messages);
    }
    else {
        var localeMessages = cached.get(locale);
        if (localeMessages) {
            return localeMessages;
        }
    }
    var supportedLocales = getSupportedLocales(locale, locales && Object.keys(locales));
    if (!supportedLocales.length) {
        return messages;
    }
    if (cached) {
        return cached.get(supportedLocales[supportedLocales.length - 1]);
    }
}
exports.getCachedMessages = getCachedMessages;
/**
 * Return a function that formats a specific message, and takes an optional value for token replacement.
 *
 * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
 * the returned function will have ICU message format support. Otherwise, the returned function will perform a simple
 * token replacement on the message string.
 *
 * Usage:
 * const formatter = getMessageFormatter(bundle, 'guestInfo', 'fr');
 * const message = formatter({
 *   host: 'Miles',
 *   gender: 'male',
 *   guest: 'Oscar',
 *   guestCount: '15'
 * });
 *
 * @param bundle
 * The bundle containing the target message.
 *
 * @param key
 * The message's key.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The message formatter.
 */
function getMessageFormatter(bundle, key, locale) {
    var _a = bundle.id, id = _a === void 0 ? getBundleId(bundle) : _a;
    if (load_1.isLoaded('supplemental', 'likelySubtags') && load_1.isLoaded('supplemental', 'plurals-type-cardinal')) {
        return getIcuMessageFormatter(id, key, locale);
    }
    var cached = bundleMap.get(id);
    var messages = cached ? cached.get(locale || getRootLocale()) || cached.get('root') : null;
    if (!messages) {
        throw new Error("The bundle has not been registered.");
    }
    return function (options) {
        if (options === void 0) { options = Object.create(null); }
        return messages[key].replace(TOKEN_PATTERN, function (token, property) {
            var value = options[property];
            if (typeof value === 'undefined') {
                throw new Error("Missing property " + property);
            }
            return value;
        });
    };
}
exports.getMessageFormatter = getMessageFormatter;
/**
 * Load locale-specific messages for the specified bundle and locale.
 *
 * @param bundle
 * The default bundle that is used to determine where the locale-specific bundles are located.
 *
 * @param locale
 * An optional locale. If no locale is provided, then the current locale is assumed.
 *
 * @return A promise to the locale-specific messages.
 */
function i18n(bundle, locale) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var currentLocale, cachedMessages, locales, supportedLocales, bundles;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentLocale = locale ? main_1.normalizeLocale(locale) : getRootLocale();
                    cachedMessages = getCachedMessages(bundle, currentLocale);
                    if (cachedMessages) {
                        return [2 /*return*/, cachedMessages];
                    }
                    locales = bundle.locales;
                    supportedLocales = getSupportedLocales(currentLocale, Object.keys(locales));
                    return [4 /*yield*/, loadLocaleBundles(locales, supportedLocales)];
                case 1:
                    bundles = _a.sent();
                    return [2 /*return*/, bundles.reduce(function (previous, partial) {
                            var localeMessages = lang_1.assign({}, previous, partial);
                            loadMessages(getBundleId(bundle), Object.freeze(localeMessages), currentLocale);
                            return localeMessages;
                        }, bundle.messages)];
            }
        });
    });
}
Object.defineProperty(i18n, 'locale', {
    get: getRootLocale
});
exports.default = i18n;
/**
 * Invalidate the cache for a particular bundle, or invalidate the entire cache. Note that cached messages for all
 * locales for a given bundle will be cleared.
 *
 * @param bundle
 * An optional bundle to invalidate. If no bundle is provided, then the cache is cleared for all bundles.
 */
function invalidate(bundle) {
    if (bundle) {
        bundle.id && bundleMap.delete(bundle.id);
    }
    else {
        bundleMap.clear();
    }
}
exports.invalidate = invalidate;
/**
 * Register an observer to be notified when the root locale changes.
 *
 * @param observer
 * The observer whose `next` method will receive the locale string on updates, and whose `error` method will receive
 * an Error object if the locale switch fails.
 *
 * @return
 * A subscription object that can be used to unsubscribe from updates.
 */
exports.observeLocale = (function () {
    var localeSource = new Observable_1.default(function (observer) {
        var handles = [
            localeProducer.on('change', function (event) {
                observer.next(event.target);
            })
        ];
        return function () {
            handles.forEach(function (handle) {
                handle.destroy();
            });
        };
    });
    return function (observer) {
        return localeSource.subscribe(observer);
    };
})();
/**
 * Pre-load locale-specific messages into the i18n system.
 *
 * @param bundle
 * The default bundle that is used to merge locale-specific messages with the default messages.
 *
 * @param messages
 * The messages to cache.
 *
 * @param locale
 * The locale for the messages
 */
function setLocaleMessages(bundle, localeMessages, locale) {
    var messages = lang_1.assign({}, bundle.messages, localeMessages);
    loadMessages(getBundleId(bundle), Object.freeze(messages), locale);
}
exports.setLocaleMessages = setLocaleMessages;
/**
 * Change the root locale, and notify any registered observers.
 *
 * @param locale
 * The new locale.
 */
function switchLocale(locale) {
    var previous = rootLocale;
    rootLocale = locale ? main_1.normalizeLocale(locale) : '';
    if (previous !== rootLocale) {
        if (load_1.isLoaded('supplemental', 'likelySubtags')) {
            Globalize.load({
                main: (_a = {},
                    _a[rootLocale] = {},
                    _a)
            });
            Globalize.locale(rootLocale);
        }
        localeProducer.emit({ type: 'change', target: rootLocale });
    }
    var _a;
}
exports.switchLocale = switchLocale;
/**
 * The default environment locale.
 *
 * It should be noted that while the system locale will be normalized to a single
 * format when loading message bundles, this value represents the unaltered
 * locale returned directly by the environment.
 */
exports.systemLocale = (function () {
    var systemLocale = 'en';
    if (has_1.default('host-browser')) {
        var navigator_1 = global_1.default.navigator;
        systemLocale = navigator_1.language || navigator_1.userLanguage;
    }
    else if (has_1.default('host-node')) {
        systemLocale = process.env.LANG || systemLocale;
    }
    return main_1.normalizeLocale(systemLocale);
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@dojo/i18n/util/main.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Matches an ISO 639.1/639.2 compatible language, followed by optional subtags.
var VALID_LOCALE_PATTERN = /^[a-z]{2,3}(-[a-z0-9\-\_]+)?$/i;
/**
 * Retrieve a list of locales that can provide substitute for the specified locale
 * (including itself).
 *
 * For example, if 'fr-CA' is specified, then `[ 'fr', 'fr-CA' ]` is returned.
 *
 * @param locale
 * The target locale.
 *
 * @return
 * A list of locales that match the target locale.
 */
function generateLocales(locale) {
    var normalized = exports.normalizeLocale(locale);
    var parts = normalized.split('-');
    var current = parts[0];
    var result = [current];
    for (var i = 0; i < parts.length - 1; i += 1) {
        current += '-' + parts[i + 1];
        result.push(current);
    }
    return result;
}
exports.generateLocales = generateLocales;
/**
 * Normalize a locale so that it can be converted to a bundle path.
 *
 * @param locale
 * The target locale.
 *
 * @return The normalized locale.
 */
exports.normalizeLocale = (function () {
    function removeTrailingSeparator(value) {
        return value.replace(/(\-|_)$/, '');
    }
    function normalize(locale) {
        if (locale.indexOf('.') === -1) {
            return removeTrailingSeparator(locale);
        }
        return locale
            .split('.')
            .slice(0, -1)
            .map(function (part) {
            return removeTrailingSeparator(part).replace(/_/g, '-');
        })
            .join('-');
    }
    return function (locale) {
        var normalized = normalize(locale);
        if (!validateLocale(normalized)) {
            throw new Error(normalized + " is not a valid locale.");
        }
        return normalized;
    };
})();
/**
 * Validates that the provided locale at least begins with a ISO 639.1/639.2 comptabile language subtag,
 * and that any additional subtags contain only valid characters.
 *
 * While locales should adhere to the guidelines set forth by RFC 5646 (https://tools.ietf.org/html/rfc5646),
 * only the language subtag is strictly enforced.
 *
 * @param locale
 * The locale to validate.
 *
 * @return
 * `true` if the locale is valid; `false` otherwise.
 */
function validateLocale(locale) {
    return VALID_LOCALE_PATTERN.test(locale);
}
exports.validateLocale = validateLocale;


/***/ }),

/***/ "./node_modules/@dojo/shim/Map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var object_1 = __webpack_require__("./node_modules/@dojo/shim/object.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.Map = global_1.default.Map;
if (!has_1.default('es6-map')) {
    exports.Map = (_a = /** @class */ (function () {
            function Map(iterable) {
                this._keys = [];
                this._values = [];
                this[Symbol.toStringTag] = 'Map';
                if (iterable) {
                    if (iterator_1.isArrayLike(iterable)) {
                        for (var i = 0; i < iterable.length; i++) {
                            var value = iterable[i];
                            this.set(value[0], value[1]);
                        }
                    }
                    else {
                        try {
                            for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                                var value = iterable_1_1.value;
                                this.set(value[0], value[1]);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                }
                var e_1, _a;
            }
            /**
             * An alternative to Array.prototype.indexOf using Object.is
             * to check for equality. See http://mzl.la/1zuKO2V
             */
            Map.prototype._indexOfKey = function (keys, key) {
                for (var i = 0, length_1 = keys.length; i < length_1; i++) {
                    if (object_1.is(keys[i], key)) {
                        return i;
                    }
                }
                return -1;
            };
            Object.defineProperty(Map.prototype, "size", {
                get: function () {
                    return this._keys.length;
                },
                enumerable: true,
                configurable: true
            });
            Map.prototype.clear = function () {
                this._keys.length = this._values.length = 0;
            };
            Map.prototype.delete = function (key) {
                var index = this._indexOfKey(this._keys, key);
                if (index < 0) {
                    return false;
                }
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
                return true;
            };
            Map.prototype.entries = function () {
                var _this = this;
                var values = this._keys.map(function (key, i) {
                    return [key, _this._values[i]];
                });
                return new iterator_1.ShimIterator(values);
            };
            Map.prototype.forEach = function (callback, context) {
                var keys = this._keys;
                var values = this._values;
                for (var i = 0, length_2 = keys.length; i < length_2; i++) {
                    callback.call(context, values[i], keys[i], this);
                }
            };
            Map.prototype.get = function (key) {
                var index = this._indexOfKey(this._keys, key);
                return index < 0 ? undefined : this._values[index];
            };
            Map.prototype.has = function (key) {
                return this._indexOfKey(this._keys, key) > -1;
            };
            Map.prototype.keys = function () {
                return new iterator_1.ShimIterator(this._keys);
            };
            Map.prototype.set = function (key, value) {
                var index = this._indexOfKey(this._keys, key);
                index = index < 0 ? this._keys.length : index;
                this._keys[index] = key;
                this._values[index] = value;
                return this;
            };
            Map.prototype.values = function () {
                return new iterator_1.ShimIterator(this._values);
            };
            Map.prototype[Symbol.iterator] = function () {
                return this.entries();
            };
            return Map;
        }()),
        _a[Symbol.species] = _a,
        _a);
}
exports.default = exports.Map;
var _a;


/***/ }),

/***/ "./node_modules/@dojo/shim/Observable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.Observable = global_1.default.Observable;
if (!has_1.default('es-observable')) {
    /*
     * Create a subscription observer for a given observer, and return the subscription.  The "logic" for Observerables
     * is in here!
     */
    var startSubscription_1 = function startSubscription(executor, observer) {
        var closed = false;
        var cleanUp;
        function unsubscribe() {
            if (!closed) {
                closed = true;
                if (cleanUp) {
                    cleanUp();
                }
            }
        }
        function start(subscriptionObserver) {
            if (observer.start) {
                observer.start(subscription);
            }
            if (closed) {
                return;
            }
            try {
                var result = executor(subscriptionObserver);
                if (typeof result === 'function') {
                    cleanUp = result;
                }
                else if (result && 'unsubscribe' in result) {
                    cleanUp = result.unsubscribe;
                }
                else if (result !== undefined && result !== null) {
                    throw new TypeError('Subscriber must return a callable or subscription');
                }
                if (closed) {
                    if (cleanUp) {
                        cleanUp();
                    }
                }
            }
            catch (e) {
                error(e);
            }
        }
        function next(value) {
            if (closed) {
                return;
            }
            var next = observer.next;
            try {
                if (typeof next === 'function') {
                    return next(value);
                }
                else if (next !== undefined && next !== null) {
                    throw new TypeError('Observer.next is not a function');
                }
            }
            catch (e) {
                error(e);
            }
        }
        function error(errorValue) {
            if (!closed) {
                var cleanUpError = undefined;
                try {
                    unsubscribe();
                }
                catch (e) {
                    cleanUpError = e;
                }
                var observerError = observer.error;
                if (observerError !== undefined && observerError !== null) {
                    if (typeof observerError === 'function') {
                        var errorResult = observerError(errorValue);
                        if (cleanUpError !== undefined) {
                            throw cleanUpError;
                        }
                        return errorResult;
                    }
                    else {
                        throw new TypeError('Observer.error is not a function');
                    }
                }
                else if (observer.complete) {
                    return observer.complete(errorValue);
                }
                else {
                    throw errorValue;
                }
            }
            else {
                throw errorValue;
            }
        }
        function complete(completeValue) {
            if (!closed) {
                var cleanUpError = undefined;
                try {
                    unsubscribe();
                }
                catch (e) {
                    cleanUpError = e;
                }
                var observerComplete = observer.complete;
                if (observerComplete !== undefined && observerComplete !== null) {
                    if (typeof observerComplete === 'function') {
                        var completeResult = observerComplete(completeValue);
                        if (cleanUpError !== undefined) {
                            throw cleanUpError;
                        }
                        return completeResult;
                    }
                    else {
                        throw new TypeError('Observer.complete is not a function');
                    }
                }
                else if (cleanUpError) {
                    throw cleanUpError;
                }
            }
        }
        var subscription = Object.create(Object.create({}, {
            closed: {
                enumerable: false,
                configurable: true,
                get: function () {
                    return closed;
                }
            },
            unsubscribe: {
                enumerable: false,
                configurable: true,
                writable: true,
                value: unsubscribe
            }
        }));
        var prototype = Object.create({}, {
            next: {
                enumerable: false,
                writable: true,
                value: next,
                configurable: true
            },
            error: {
                enumerable: false,
                writable: true,
                value: error,
                configurable: true
            },
            complete: {
                enumerable: false,
                writable: true,
                value: complete,
                configurable: true
            },
            closed: {
                enumerable: false,
                configurable: true,
                get: function () {
                    return closed;
                }
            }
        });
        // create the SubscriptionObserver and kick things off
        start(Object.create(prototype));
        // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber
        return subscription;
    };
    exports.Observable = (function () {
        function nonEnumerable(target, key, descriptor) {
            descriptor.enumerable = false;
        }
        var Observable = /** @class */ (function () {
            function Observable(subscriber) {
                if (typeof subscriber !== 'function') {
                    throw new TypeError('subscriber is not a function');
                }
                this._executor = subscriber;
            }
            Observable.prototype[_a = Symbol.observable] = function () {
                return this;
            };
            Observable.prototype.subscribe = function (observerOrNext) {
                var listeners = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    listeners[_i - 1] = arguments[_i];
                }
                var _a = tslib_1.__read(tslib_1.__spread(listeners), 2), onError = _a[0], onComplete = _a[1];
                if (!observerOrNext ||
                    typeof observerOrNext === 'number' ||
                    typeof observerOrNext === 'string' ||
                    typeof observerOrNext === 'boolean') {
                    throw new TypeError('parameter must be a function or an observer');
                }
                var observer;
                if (typeof observerOrNext === 'function') {
                    observer = {
                        next: observerOrNext
                    };
                    if (typeof onError === 'function') {
                        observer.error = onError;
                    }
                    if (typeof onComplete === 'function') {
                        observer.complete = onComplete;
                    }
                }
                else {
                    observer = observerOrNext;
                }
                return startSubscription_1(this._executor, observer);
            };
            Observable.of = function () {
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                var constructor;
                if (typeof this !== 'function') {
                    constructor = Observable;
                }
                else {
                    constructor = this;
                }
                return new constructor(function (observer) {
                    try {
                        for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                            var o = items_1_1.value;
                            observer.next(o);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    observer.complete();
                    var e_1, _a;
                });
            };
            Observable.from = function (item) {
                if (item === null || item === undefined) {
                    throw new TypeError('item cannot be null or undefined');
                }
                var constructor;
                if (typeof this !== 'function') {
                    constructor = Observable;
                }
                else {
                    constructor = this;
                }
                var observableSymbol = item[Symbol.observable];
                if (observableSymbol !== undefined) {
                    if (typeof observableSymbol !== 'function') {
                        throw new TypeError('Symbol.observable must be a function');
                    }
                    var result = observableSymbol.call(item);
                    if (result === undefined ||
                        result === null ||
                        typeof result === 'number' ||
                        typeof result === 'boolean' ||
                        typeof result === 'string') {
                        throw new TypeError('Return value of Symbol.observable must be object');
                    }
                    if ((result.constructor && result.constructor === this) || result instanceof Observable) {
                        return result;
                    }
                    else if (result.subscribe) {
                        return new constructor(result.subscribe);
                    }
                    else {
                        if (constructor.of) {
                            return constructor.of(result);
                        }
                        else {
                            return Observable.of(result);
                        }
                    }
                }
                else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {
                    return new constructor(function (observer) {
                        if (iterator_1.isArrayLike(item)) {
                            for (var i = 0; i < item.length; i++) {
                                observer.next(item[i]);
                            }
                        }
                        else {
                            try {
                                for (var item_1 = tslib_1.__values(item), item_1_1 = item_1.next(); !item_1_1.done; item_1_1 = item_1.next()) {
                                    var o = item_1_1.value;
                                    observer.next(o);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (item_1_1 && !item_1_1.done && (_a = item_1.return)) _a.call(item_1);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        observer.complete();
                        var e_2, _a;
                    });
                }
                else {
                    throw new TypeError('Parameter is neither Observable nor Iterable');
                }
            };
            tslib_1.__decorate([
                nonEnumerable
            ], Observable.prototype, _a, null);
            tslib_1.__decorate([
                nonEnumerable
            ], Observable.prototype, "subscribe", null);
            tslib_1.__decorate([
                nonEnumerable
            ], Observable, "of", null);
            tslib_1.__decorate([
                nonEnumerable
            ], Observable, "from", null);
            return Observable;
            var _a;
        }());
        return Observable;
    })();
}
exports.default = exports.Observable;


/***/ }),

/***/ "./node_modules/@dojo/shim/Promise.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var queue_1 = __webpack_require__("./node_modules/@dojo/shim/support/queue.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
exports.ShimPromise = global_1.default.Promise;
exports.isThenable = function isThenable(value) {
    return value && typeof value.then === 'function';
};
if (!has_1.default('es6-promise')) {
    global_1.default.Promise = exports.ShimPromise = (_a = /** @class */ (function () {
            /**
             * Creates a new Promise.
             *
             * @constructor
             *
             * @param executor
             * The executor function is called immediately when the Promise is instantiated. It is responsible for
             * starting the asynchronous operation when it is invoked.
             *
             * The executor must call either the passed `resolve` function when the asynchronous operation has completed
             * successfully, or the `reject` function when the operation fails.
             */
            function Promise(executor) {
                var _this = this;
                /**
                 * The current state of this promise.
                 */
                this.state = 1 /* Pending */;
                this[Symbol.toStringTag] = 'Promise';
                /**
                 * If true, the resolution of this promise is chained ("locked in") to another promise.
                 */
                var isChained = false;
                /**
                 * Whether or not this promise is in a resolved state.
                 */
                var isResolved = function () {
                    return _this.state !== 1 /* Pending */ || isChained;
                };
                /**
                 * Callbacks that should be invoked once the asynchronous operation has completed.
                 */
                var callbacks = [];
                /**
                 * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,
                 * enqueues callbacks for execution on the next event loop turn.
                 */
                var whenFinished = function (callback) {
                    if (callbacks) {
                        callbacks.push(callback);
                    }
                };
                /**
                 * Settles this promise.
                 *
                 * @param newState The resolved state for this promise.
                 * @param {T|any} value The resolved value for this promise.
                 */
                var settle = function (newState, value) {
                    // A promise can only be settled once.
                    if (_this.state !== 1 /* Pending */) {
                        return;
                    }
                    _this.state = newState;
                    _this.resolvedValue = value;
                    whenFinished = queue_1.queueMicroTask;
                    // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to
                    // wait an extra turn.
                    if (callbacks && callbacks.length > 0) {
                        queue_1.queueMicroTask(function () {
                            if (callbacks) {
                                var count = callbacks.length;
                                for (var i = 0; i < count; ++i) {
                                    callbacks[i].call(null);
                                }
                                callbacks = null;
                            }
                        });
                    }
                };
                /**
                 * Resolves this promise.
                 *
                 * @param newState The resolved state for this promise.
                 * @param {T|any} value The resolved value for this promise.
                 */
                var resolve = function (newState, value) {
                    if (isResolved()) {
                        return;
                    }
                    if (exports.isThenable(value)) {
                        value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));
                        isChained = true;
                    }
                    else {
                        settle(newState, value);
                    }
                };
                this.then = function (onFulfilled, onRejected) {
                    return new Promise(function (resolve, reject) {
                        // whenFinished initially queues up callbacks for execution after the promise has settled. Once the
                        // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the
                        // event loop.
                        whenFinished(function () {
                            var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;
                            if (typeof callback === 'function') {
                                try {
                                    resolve(callback(_this.resolvedValue));
                                }
                                catch (error) {
                                    reject(error);
                                }
                            }
                            else if (_this.state === 2 /* Rejected */) {
                                reject(_this.resolvedValue);
                            }
                            else {
                                resolve(_this.resolvedValue);
                            }
                        });
                    });
                };
                try {
                    executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));
                }
                catch (error) {
                    settle(2 /* Rejected */, error);
                }
            }
            Promise.all = function (iterable) {
                return new this(function (resolve, reject) {
                    var values = [];
                    var complete = 0;
                    var total = 0;
                    var populating = true;
                    function fulfill(index, value) {
                        values[index] = value;
                        ++complete;
                        finish();
                    }
                    function finish() {
                        if (populating || complete < total) {
                            return;
                        }
                        resolve(values);
                    }
                    function processItem(index, item) {
                        ++total;
                        if (exports.isThenable(item)) {
                            // If an item Promise rejects, this Promise is immediately rejected with the item
                            // Promise's rejection error.
                            item.then(fulfill.bind(null, index), reject);
                        }
                        else {
                            Promise.resolve(item).then(fulfill.bind(null, index));
                        }
                    }
                    var i = 0;
                    try {
                        for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                            var value = iterable_1_1.value;
                            processItem(i, value);
                            i++;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    populating = false;
                    finish();
                    var e_1, _a;
                });
            };
            Promise.race = function (iterable) {
                return new this(function (resolve, reject) {
                    try {
                        for (var iterable_2 = tslib_1.__values(iterable), iterable_2_1 = iterable_2.next(); !iterable_2_1.done; iterable_2_1 = iterable_2.next()) {
                            var item = iterable_2_1.value;
                            if (item instanceof Promise) {
                                // If a Promise item rejects, this Promise is immediately rejected with the item
                                // Promise's rejection error.
                                item.then(resolve, reject);
                            }
                            else {
                                Promise.resolve(item).then(resolve);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) _a.call(iterable_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    var e_2, _a;
                });
            };
            Promise.reject = function (reason) {
                return new this(function (resolve, reject) {
                    reject(reason);
                });
            };
            Promise.resolve = function (value) {
                return new this(function (resolve) {
                    resolve(value);
                });
            };
            Promise.prototype.catch = function (onRejected) {
                return this.then(undefined, onRejected);
            };
            return Promise;
        }()),
        _a[Symbol.species] = exports.ShimPromise,
        _a);
}
exports.default = exports.ShimPromise;
var _a;


/***/ }),

/***/ "./node_modules/@dojo/shim/Symbol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var util_1 = __webpack_require__("./node_modules/@dojo/shim/support/util.js");
exports.Symbol = global_1.default.Symbol;
if (!has_1.default('es6-symbol')) {
    /**
     * Throws if the value is not a symbol, used internally within the Shim
     * @param  {any}    value The value to check
     * @return {symbol}       Returns the symbol or throws
     */
    var validateSymbol_1 = function validateSymbol(value) {
        if (!isSymbol(value)) {
            throw new TypeError(value + ' is not a symbol');
        }
        return value;
    };
    var defineProperties_1 = Object.defineProperties;
    var defineProperty_1 = Object.defineProperty;
    var create_1 = Object.create;
    var objPrototype_1 = Object.prototype;
    var globalSymbols_1 = {};
    var getSymbolName_1 = (function () {
        var created = create_1(null);
        return function (desc) {
            var postfix = 0;
            var name;
            while (created[String(desc) + (postfix || '')]) {
                ++postfix;
            }
            desc += String(postfix || '');
            created[desc] = true;
            name = '@@' + desc;
            // FIXME: Temporary guard until the duplicate execution when testing can be
            // pinned down.
            if (!Object.getOwnPropertyDescriptor(objPrototype_1, name)) {
                defineProperty_1(objPrototype_1, name, {
                    set: function (value) {
                        defineProperty_1(this, name, util_1.getValueDescriptor(value));
                    }
                });
            }
            return name;
        };
    })();
    var InternalSymbol_1 = function Symbol(description) {
        if (this instanceof InternalSymbol_1) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        return Symbol(description);
    };
    exports.Symbol = global_1.default.Symbol = function Symbol(description) {
        if (this instanceof Symbol) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        var sym = Object.create(InternalSymbol_1.prototype);
        description = description === undefined ? '' : String(description);
        return defineProperties_1(sym, {
            __description__: util_1.getValueDescriptor(description),
            __name__: util_1.getValueDescriptor(getSymbolName_1(description))
        });
    };
    /* Decorate the Symbol function with the appropriate properties */
    defineProperty_1(exports.Symbol, 'for', util_1.getValueDescriptor(function (key) {
        if (globalSymbols_1[key]) {
            return globalSymbols_1[key];
        }
        return (globalSymbols_1[key] = exports.Symbol(String(key)));
    }));
    defineProperties_1(exports.Symbol, {
        keyFor: util_1.getValueDescriptor(function (sym) {
            var key;
            validateSymbol_1(sym);
            for (key in globalSymbols_1) {
                if (globalSymbols_1[key] === sym) {
                    return key;
                }
            }
        }),
        hasInstance: util_1.getValueDescriptor(exports.Symbol.for('hasInstance'), false, false),
        isConcatSpreadable: util_1.getValueDescriptor(exports.Symbol.for('isConcatSpreadable'), false, false),
        iterator: util_1.getValueDescriptor(exports.Symbol.for('iterator'), false, false),
        match: util_1.getValueDescriptor(exports.Symbol.for('match'), false, false),
        observable: util_1.getValueDescriptor(exports.Symbol.for('observable'), false, false),
        replace: util_1.getValueDescriptor(exports.Symbol.for('replace'), false, false),
        search: util_1.getValueDescriptor(exports.Symbol.for('search'), false, false),
        species: util_1.getValueDescriptor(exports.Symbol.for('species'), false, false),
        split: util_1.getValueDescriptor(exports.Symbol.for('split'), false, false),
        toPrimitive: util_1.getValueDescriptor(exports.Symbol.for('toPrimitive'), false, false),
        toStringTag: util_1.getValueDescriptor(exports.Symbol.for('toStringTag'), false, false),
        unscopables: util_1.getValueDescriptor(exports.Symbol.for('unscopables'), false, false)
    });
    /* Decorate the InternalSymbol object */
    defineProperties_1(InternalSymbol_1.prototype, {
        constructor: util_1.getValueDescriptor(exports.Symbol),
        toString: util_1.getValueDescriptor(function () {
            return this.__name__;
        }, false, false)
    });
    /* Decorate the Symbol.prototype */
    defineProperties_1(exports.Symbol.prototype, {
        toString: util_1.getValueDescriptor(function () {
            return 'Symbol (' + validateSymbol_1(this).__description__ + ')';
        }),
        valueOf: util_1.getValueDescriptor(function () {
            return validateSymbol_1(this);
        })
    });
    defineProperty_1(exports.Symbol.prototype, exports.Symbol.toPrimitive, util_1.getValueDescriptor(function () {
        return validateSymbol_1(this);
    }));
    defineProperty_1(exports.Symbol.prototype, exports.Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));
    defineProperty_1(InternalSymbol_1.prototype, exports.Symbol.toPrimitive, util_1.getValueDescriptor(exports.Symbol.prototype[exports.Symbol.toPrimitive], false, false, true));
    defineProperty_1(InternalSymbol_1.prototype, exports.Symbol.toStringTag, util_1.getValueDescriptor(exports.Symbol.prototype[exports.Symbol.toStringTag], false, false, true));
}
/**
 * A custom guard function that determines if an object is a symbol or not
 * @param  {any}       value The value to check to see if it is a symbol or not
 * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)
 */
function isSymbol(value) {
    return (value && (typeof value === 'symbol' || value['@@toStringTag'] === 'Symbol')) || false;
}
exports.isSymbol = isSymbol;
/**
 * Fill any missing well known symbols if the native Symbol is missing them
 */
[
    'hasInstance',
    'isConcatSpreadable',
    'iterator',
    'species',
    'replace',
    'search',
    'split',
    'match',
    'toPrimitive',
    'toStringTag',
    'unscopables',
    'observable'
].forEach(function (wellKnown) {
    if (!exports.Symbol[wellKnown]) {
        Object.defineProperty(exports.Symbol, wellKnown, util_1.getValueDescriptor(exports.Symbol.for(wellKnown), false, false));
    }
});
exports.default = exports.Symbol;


/***/ }),

/***/ "./node_modules/@dojo/shim/WeakMap.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.WeakMap = global_1.default.WeakMap;
if (!has_1.default('es6-weakmap')) {
    var DELETED_1 = {};
    var getUID_1 = function getUID() {
        return Math.floor(Math.random() * 100000000);
    };
    var generateName_1 = (function () {
        var startId = Math.floor(Date.now() % 100000000);
        return function generateName() {
            return '__wm' + getUID_1() + (startId++ + '__');
        };
    })();
    exports.WeakMap = /** @class */ (function () {
        function WeakMap(iterable) {
            this[Symbol.toStringTag] = 'WeakMap';
            Object.defineProperty(this, '_name', {
                value: generateName_1()
            });
            this._frozenEntries = [];
            if (iterable) {
                if (iterator_1.isArrayLike(iterable)) {
                    for (var i = 0; i < iterable.length; i++) {
                        var item = iterable[i];
                        this.set(item[0], item[1]);
                    }
                }
                else {
                    try {
                        for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                            var _a = tslib_1.__read(iterable_1_1.value, 2), key = _a[0], value = _a[1];
                            this.set(key, value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (iterable_1_1 && !iterable_1_1.done && (_b = iterable_1.return)) _b.call(iterable_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            var e_1, _b;
        }
        WeakMap.prototype._getFrozenEntryIndex = function (key) {
            for (var i = 0; i < this._frozenEntries.length; i++) {
                if (this._frozenEntries[i].key === key) {
                    return i;
                }
            }
            return -1;
        };
        WeakMap.prototype.delete = function (key) {
            if (key === undefined || key === null) {
                return false;
            }
            var entry = key[this._name];
            if (entry && entry.key === key && entry.value !== DELETED_1) {
                entry.value = DELETED_1;
                return true;
            }
            var frozenIndex = this._getFrozenEntryIndex(key);
            if (frozenIndex >= 0) {
                this._frozenEntries.splice(frozenIndex, 1);
                return true;
            }
            return false;
        };
        WeakMap.prototype.get = function (key) {
            if (key === undefined || key === null) {
                return undefined;
            }
            var entry = key[this._name];
            if (entry && entry.key === key && entry.value !== DELETED_1) {
                return entry.value;
            }
            var frozenIndex = this._getFrozenEntryIndex(key);
            if (frozenIndex >= 0) {
                return this._frozenEntries[frozenIndex].value;
            }
        };
        WeakMap.prototype.has = function (key) {
            if (key === undefined || key === null) {
                return false;
            }
            var entry = key[this._name];
            if (Boolean(entry && entry.key === key && entry.value !== DELETED_1)) {
                return true;
            }
            var frozenIndex = this._getFrozenEntryIndex(key);
            if (frozenIndex >= 0) {
                return true;
            }
            return false;
        };
        WeakMap.prototype.set = function (key, value) {
            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {
                throw new TypeError('Invalid value used as weak map key');
            }
            var entry = key[this._name];
            if (!entry || entry.key !== key) {
                entry = Object.create(null, {
                    key: { value: key }
                });
                if (Object.isFrozen(key)) {
                    this._frozenEntries.push(entry);
                }
                else {
                    Object.defineProperty(key, this._name, {
                        value: entry
                    });
                }
            }
            entry.value = value;
            return this;
        };
        return WeakMap;
    }());
}
exports.default = exports.WeakMap;


/***/ }),

/***/ "./node_modules/@dojo/shim/global.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var globalObject = (function () {
    if (typeof global !== 'undefined') {
        // global spec defines a reference to the global object called 'global'
        // https://github.com/tc39/proposal-global
        // `global` is also defined in NodeJS
        return global;
    }
    else if (typeof window !== 'undefined') {
        // window is defined in browsers
        return window;
    }
    else if (typeof self !== 'undefined') {
        // self is defined in WebWorkers
        return self;
    }
})();
exports.default = globalObject;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@dojo/shim/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
var string_1 = __webpack_require__("./node_modules/@dojo/shim/string.js");
var staticDone = { done: true, value: undefined };
/**
 * A class that _shims_ an iterator interface on array like objects.
 */
var ShimIterator = /** @class */ (function () {
    function ShimIterator(list) {
        this._nextIndex = -1;
        if (isIterable(list)) {
            this._nativeIterator = list[Symbol.iterator]();
        }
        else {
            this._list = list;
        }
    }
    /**
     * Return the next iteration result for the Iterator
     */
    ShimIterator.prototype.next = function () {
        if (this._nativeIterator) {
            return this._nativeIterator.next();
        }
        if (!this._list) {
            return staticDone;
        }
        if (++this._nextIndex < this._list.length) {
            return {
                done: false,
                value: this._list[this._nextIndex]
            };
        }
        return staticDone;
    };
    ShimIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    return ShimIterator;
}());
exports.ShimIterator = ShimIterator;
/**
 * A type guard for checking if something has an Iterable interface
 *
 * @param value The value to type guard against
 */
function isIterable(value) {
    return value && typeof value[Symbol.iterator] === 'function';
}
exports.isIterable = isIterable;
/**
 * A type guard for checking if something is ArrayLike
 *
 * @param value The value to type guard against
 */
function isArrayLike(value) {
    return value && typeof value.length === 'number';
}
exports.isArrayLike = isArrayLike;
/**
 * Returns the iterator for an object
 *
 * @param iterable The iterable object to return the iterator for
 */
function get(iterable) {
    if (isIterable(iterable)) {
        return iterable[Symbol.iterator]();
    }
    else if (isArrayLike(iterable)) {
        return new ShimIterator(iterable);
    }
}
exports.get = get;
/**
 * Shims the functionality of `for ... of` blocks
 *
 * @param iterable The object the provides an interator interface
 * @param callback The callback which will be called for each item of the iterable
 * @param thisArg Optional scope to pass the callback
 */
function forOf(iterable, callback, thisArg) {
    var broken = false;
    function doBreak() {
        broken = true;
    }
    /* We need to handle iteration of double byte strings properly */
    if (isArrayLike(iterable) && typeof iterable === 'string') {
        var l = iterable.length;
        for (var i = 0; i < l; ++i) {
            var char = iterable[i];
            if (i + 1 < l) {
                var code = char.charCodeAt(0);
                if (code >= string_1.HIGH_SURROGATE_MIN && code <= string_1.HIGH_SURROGATE_MAX) {
                    char += iterable[++i];
                }
            }
            callback.call(thisArg, char, iterable, doBreak);
            if (broken) {
                return;
            }
        }
    }
    else {
        var iterator = get(iterable);
        if (iterator) {
            var result = iterator.next();
            while (!result.done) {
                callback.call(thisArg, result.value, iterable, doBreak);
                if (broken) {
                    return;
                }
                result = iterator.next();
            }
        }
    }
}
exports.forOf = forOf;


/***/ }),

/***/ "./node_modules/@dojo/shim/object.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var Symbol_1 = __webpack_require__("./node_modules/@dojo/shim/Symbol.js");
if (has_1.default('es6-object')) {
    var globalObject = global_1.default.Object;
    exports.assign = globalObject.assign;
    exports.getOwnPropertyDescriptor = globalObject.getOwnPropertyDescriptor;
    exports.getOwnPropertyNames = globalObject.getOwnPropertyNames;
    exports.getOwnPropertySymbols = globalObject.getOwnPropertySymbols;
    exports.is = globalObject.is;
    exports.keys = globalObject.keys;
}
else {
    exports.keys = function symbolAwareKeys(o) {
        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });
    };
    exports.assign = function assign(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        if (target == null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(target);
        sources.forEach(function (nextSource) {
            if (nextSource) {
                // Skip over if undefined or null
                exports.keys(nextSource).forEach(function (nextKey) {
                    to[nextKey] = nextSource[nextKey];
                });
            }
        });
        return to;
    };
    exports.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(o, prop) {
        if (Symbol_1.isSymbol(prop)) {
            return Object.getOwnPropertyDescriptor(o, prop);
        }
        else {
            return Object.getOwnPropertyDescriptor(o, prop);
        }
    };
    exports.getOwnPropertyNames = function getOwnPropertyNames(o) {
        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });
    };
    exports.getOwnPropertySymbols = function getOwnPropertySymbols(o) {
        return Object.getOwnPropertyNames(o)
            .filter(function (key) { return Boolean(key.match(/^@@.+/)); })
            .map(function (key) { return Symbol.for(key.substring(2)); });
    };
    exports.is = function is(value1, value2) {
        if (value1 === value2) {
            return value1 !== 0 || 1 / value1 === 1 / value2; // -0
        }
        return value1 !== value1 && value2 !== value2; // NaN
    };
}
if (has_1.default('es2017-object')) {
    var globalObject = global_1.default.Object;
    exports.getOwnPropertyDescriptors = globalObject.getOwnPropertyDescriptors;
    exports.entries = globalObject.entries;
    exports.values = globalObject.values;
}
else {
    exports.getOwnPropertyDescriptors = function getOwnPropertyDescriptors(o) {
        return exports.getOwnPropertyNames(o).reduce(function (previous, key) {
            previous[key] = exports.getOwnPropertyDescriptor(o, key);
            return previous;
        }, {});
    };
    exports.entries = function entries(o) {
        return exports.keys(o).map(function (key) { return [key, o[key]]; });
    };
    exports.values = function values(o) {
        return exports.keys(o).map(function (key) { return o[key]; });
    };
}


/***/ }),

/***/ "./node_modules/@dojo/shim/string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var util_1 = __webpack_require__("./node_modules/@dojo/shim/support/util.js");
/**
 * The minimum location of high surrogates
 */
exports.HIGH_SURROGATE_MIN = 0xd800;
/**
 * The maximum location of high surrogates
 */
exports.HIGH_SURROGATE_MAX = 0xdbff;
/**
 * The minimum location of low surrogates
 */
exports.LOW_SURROGATE_MIN = 0xdc00;
/**
 * The maximum location of low surrogates
 */
exports.LOW_SURROGATE_MAX = 0xdfff;
if (has_1.default('es6-string') && has_1.default('es6-string-raw')) {
    exports.fromCodePoint = global_1.default.String.fromCodePoint;
    exports.raw = global_1.default.String.raw;
    exports.codePointAt = util_1.wrapNative(global_1.default.String.prototype.codePointAt);
    exports.endsWith = util_1.wrapNative(global_1.default.String.prototype.endsWith);
    exports.includes = util_1.wrapNative(global_1.default.String.prototype.includes);
    exports.normalize = util_1.wrapNative(global_1.default.String.prototype.normalize);
    exports.repeat = util_1.wrapNative(global_1.default.String.prototype.repeat);
    exports.startsWith = util_1.wrapNative(global_1.default.String.prototype.startsWith);
}
else {
    /**
     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).
     * Used by startsWith, includes, and endsWith.
     *
     * @return Normalized position.
     */
    var normalizeSubstringArgs_1 = function (name, text, search, position, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        if (text == null) {
            throw new TypeError('string.' + name + ' requires a valid string to search against.');
        }
        var length = text.length;
        position = position !== position ? (isEnd ? length : 0) : position;
        return [text, String(search), Math.min(Math.max(position, 0), length)];
    };
    exports.fromCodePoint = function fromCodePoint() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
        }
        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint
        var length = arguments.length;
        if (!length) {
            return '';
        }
        var fromCharCode = String.fromCharCode;
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var index = -1;
        var result = '';
        while (++index < length) {
            var codePoint = Number(arguments[index]);
            // Code points must be finite integers within the valid range
            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint && codePoint >= 0 && codePoint <= 0x10ffff;
            if (!isValid) {
                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);
            }
            if (codePoint <= 0xffff) {
                // BMP code point
                codeUnits.push(codePoint);
            }
            else {
                // Astral code point; split in surrogate halves
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;
                var lowSurrogate = codePoint % 0x400 + exports.LOW_SURROGATE_MIN;
                codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
    exports.raw = function raw(callSite) {
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        var rawStrings = callSite.raw;
        var result = '';
        var numSubstitutions = substitutions.length;
        if (callSite == null || callSite.raw == null) {
            throw new TypeError('string.raw requires a valid callSite object with a raw value');
        }
        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {
            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');
        }
        return result;
    };
    exports.codePointAt = function codePointAt(text, position) {
        if (position === void 0) { position = 0; }
        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt
        if (text == null) {
            throw new TypeError('string.codePointAt requries a valid string.');
        }
        var length = text.length;
        if (position !== position) {
            position = 0;
        }
        if (position < 0 || position >= length) {
            return undefined;
        }
        // Get the first code unit
        var first = text.charCodeAt(position);
        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {
            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            var second = text.charCodeAt(position + 1);
            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {
                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;
            }
        }
        return first;
    };
    exports.endsWith = function endsWith(text, search, endPosition) {
        if (endPosition == null) {
            endPosition = text.length;
        }
        _a = tslib_1.__read(normalizeSubstringArgs_1('endsWith', text, search, endPosition, true), 3), text = _a[0], search = _a[1], endPosition = _a[2];
        var start = endPosition - search.length;
        if (start < 0) {
            return false;
        }
        return text.slice(start, endPosition) === search;
        var _a;
    };
    exports.includes = function includes(text, search, position) {
        if (position === void 0) { position = 0; }
        _a = tslib_1.__read(normalizeSubstringArgs_1('includes', text, search, position), 3), text = _a[0], search = _a[1], position = _a[2];
        return text.indexOf(search, position) !== -1;
        var _a;
    };
    exports.repeat = function repeat(text, count) {
        if (count === void 0) { count = 0; }
        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat
        if (text == null) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (count !== count) {
            count = 0;
        }
        if (count < 0 || count === Infinity) {
            throw new RangeError('string.repeat requires a non-negative finite count.');
        }
        var result = '';
        while (count) {
            if (count % 2) {
                result += text;
            }
            if (count > 1) {
                text += text;
            }
            count >>= 1;
        }
        return result;
    };
    exports.startsWith = function startsWith(text, search, position) {
        if (position === void 0) { position = 0; }
        search = String(search);
        _a = tslib_1.__read(normalizeSubstringArgs_1('startsWith', text, search, position), 3), text = _a[0], search = _a[1], position = _a[2];
        var end = position + search.length;
        if (end > text.length) {
            return false;
        }
        return text.slice(position, end) === search;
        var _a;
    };
}
if (has_1.default('es2017-string')) {
    exports.padEnd = util_1.wrapNative(global_1.default.String.prototype.padEnd);
    exports.padStart = util_1.wrapNative(global_1.default.String.prototype.padStart);
}
else {
    exports.padEnd = function padEnd(text, maxLength, fillString) {
        if (fillString === void 0) { fillString = ' '; }
        if (text === null || text === undefined) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (maxLength === Infinity) {
            throw new RangeError('string.padEnd requires a non-negative finite count.');
        }
        if (maxLength === null || maxLength === undefined || maxLength < 0) {
            maxLength = 0;
        }
        var strText = String(text);
        var padding = maxLength - strText.length;
        if (padding > 0) {
            strText +=
                exports.repeat(fillString, Math.floor(padding / fillString.length)) +
                    fillString.slice(0, padding % fillString.length);
        }
        return strText;
    };
    exports.padStart = function padStart(text, maxLength, fillString) {
        if (fillString === void 0) { fillString = ' '; }
        if (text === null || text === undefined) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (maxLength === Infinity) {
            throw new RangeError('string.padStart requires a non-negative finite count.');
        }
        if (maxLength === null || maxLength === undefined || maxLength < 0) {
            maxLength = 0;
        }
        var strText = String(text);
        var padding = maxLength - strText.length;
        if (padding > 0) {
            strText =
                exports.repeat(fillString, Math.floor(padding / fillString.length)) +
                    fillString.slice(0, padding % fillString.length) +
                    strText;
        }
        return strText;
    };
}


/***/ }),

/***/ "./node_modules/@dojo/shim/support/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var has_1 = __webpack_require__("./node_modules/@dojo/has/has.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
exports.default = has_1.default;
tslib_1.__exportStar(__webpack_require__("./node_modules/@dojo/has/has.js"), exports);
/* ECMAScript 6 and 7 Features */
/* Array */
has_1.add('es6-array', function () {
    return (['from', 'of'].every(function (key) { return key in global_1.default.Array; }) &&
        ['findIndex', 'find', 'copyWithin'].every(function (key) { return key in global_1.default.Array.prototype; }));
}, true);
has_1.add('es6-array-fill', function () {
    if ('fill' in global_1.default.Array.prototype) {
        /* Some versions of Safari do not properly implement this */
        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;
    }
    return false;
}, true);
has_1.add('es7-array', function () { return 'includes' in global_1.default.Array.prototype; }, true);
/* Map */
has_1.add('es6-map', function () {
    if (typeof global_1.default.Map === 'function') {
        /*
    IE11 and older versions of Safari are missing critical ES6 Map functionality
    We wrap this in a try/catch because sometimes the Map constructor exists, but does not
    take arguments (iOS 8.4)
     */
        try {
            var map = new global_1.default.Map([[0, 1]]);
            return (map.has(0) &&
                typeof map.keys === 'function' &&
                has_1.default('es6-symbol') &&
                typeof map.values === 'function' &&
                typeof map.entries === 'function');
        }
        catch (e) {
            /* istanbul ignore next: not testing on iOS at the moment */
            return false;
        }
    }
    return false;
}, true);
/* Math */
has_1.add('es6-math', function () {
    return [
        'clz32',
        'sign',
        'log10',
        'log2',
        'log1p',
        'expm1',
        'cosh',
        'sinh',
        'tanh',
        'acosh',
        'asinh',
        'atanh',
        'trunc',
        'fround',
        'cbrt',
        'hypot'
    ].every(function (name) { return typeof global_1.default.Math[name] === 'function'; });
}, true);
has_1.add('es6-math-imul', function () {
    if ('imul' in global_1.default.Math) {
        /* Some versions of Safari on ios do not properly implement this */
        return Math.imul(0xffffffff, 5) === -5;
    }
    return false;
}, true);
/* Object */
has_1.add('es6-object', function () {
    return (has_1.default('es6-symbol') &&
        ['assign', 'is', 'getOwnPropertySymbols', 'setPrototypeOf'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; }));
}, true);
has_1.add('es2017-object', function () {
    return ['values', 'entries', 'getOwnPropertyDescriptors'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; });
}, true);
/* Observable */
has_1.add('es-observable', function () { return typeof global_1.default.Observable !== 'undefined'; }, true);
/* Promise */
has_1.add('es6-promise', function () { return typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'); }, true);
/* Set */
has_1.add('es6-set', function () {
    if (typeof global_1.default.Set === 'function') {
        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */
        var set = new global_1.default.Set([1]);
        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');
    }
    return false;
}, true);
/* String */
has_1.add('es6-string', function () {
    return ([
        /* static methods */
        'fromCodePoint'
    ].every(function (key) { return typeof global_1.default.String[key] === 'function'; }) &&
        [
            /* instance methods */
            'codePointAt',
            'normalize',
            'repeat',
            'startsWith',
            'endsWith',
            'includes'
        ].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; }));
}, true);
has_1.add('es6-string-raw', function () {
    function getCallSite(callSite) {
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        var result = tslib_1.__spread(callSite);
        result.raw = callSite.raw;
        return result;
    }
    if ('raw' in global_1.default.String) {
        var b = 1;
        var callSite = getCallSite(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["a\n", ""], ["a\\n", ""])), b);
        callSite.raw = ['a\\n'];
        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\n';
        return supportsTrunc;
    }
    return false;
}, true);
has_1.add('es2017-string', function () {
    return ['padStart', 'padEnd'].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; });
}, true);
/* Symbol */
has_1.add('es6-symbol', function () { return typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol'; }, true);
/* WeakMap */
has_1.add('es6-weakmap', function () {
    if (typeof global_1.default.WeakMap !== 'undefined') {
        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */
        var key1 = {};
        var key2 = {};
        var map = new global_1.default.WeakMap([[key1, 1]]);
        Object.freeze(key1);
        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');
    }
    return false;
}, true);
/* Miscellaneous features */
has_1.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); }, true);
has_1.add('postmessage', function () {
    // If window is undefined, and we have postMessage, it probably means we're in a web worker. Web workers have
    // post message but it doesn't work how we expect it to, so it's best just to pretend it doesn't exist.
    return typeof global_1.default.window !== 'undefined' && typeof global_1.default.postMessage === 'function';
}, true);
has_1.add('raf', function () { return typeof global_1.default.requestAnimationFrame === 'function'; }, true);
has_1.add('setimmediate', function () { return typeof global_1.default.setImmediate !== 'undefined'; }, true);
/* DOM Features */
has_1.add('dom-mutationobserver', function () {
    if (has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver)) {
        // IE11 has an unreliable MutationObserver implementation where setProperty() does not
        // generate a mutation event, observers can crash, and the queue does not drain
        // reliably. The following feature test was adapted from
        // https://gist.github.com/t10ko/4aceb8c71681fdb275e33efe5e576b14
        var example = document.createElement('div');
        /* tslint:disable-next-line:variable-name */
        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
        var observer = new HostMutationObserver(function () { });
        observer.observe(example, { attributes: true });
        example.style.setProperty('display', 'block');
        return Boolean(observer.takeRecords().length);
    }
    return false;
}, true);
has_1.add('dom-webanimation', function () { return has_1.default('host-browser') && global_1.default.Animation !== undefined && global_1.default.KeyframeEffect !== undefined; }, true);
var templateObject_1;


/***/ }),

/***/ "./node_modules/@dojo/shim/support/queue.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
function executeTask(item) {
    if (item && item.isActive && item.callback) {
        item.callback();
    }
}
function getQueueHandle(item, destructor) {
    return {
        destroy: function () {
            this.destroy = function () { };
            item.isActive = false;
            item.callback = null;
            if (destructor) {
                destructor();
            }
        }
    };
}
var checkMicroTaskQueue;
var microTasks;
/**
 * Schedules a callback to the macrotask queue.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueTask = (function () {
    var destructor;
    var enqueue;
    // Since the IE implementation of `setImmediate` is not flawless, we will test for `postMessage` first.
    if (has_1.default('postmessage')) {
        var queue_1 = [];
        global_1.default.addEventListener('message', function (event) {
            // Confirm that the event was triggered by the current window and by this particular implementation.
            if (event.source === global_1.default && event.data === 'dojo-queue-message') {
                event.stopPropagation();
                if (queue_1.length) {
                    executeTask(queue_1.shift());
                }
            }
        });
        enqueue = function (item) {
            queue_1.push(item);
            global_1.default.postMessage('dojo-queue-message', '*');
        };
    }
    else if (has_1.default('setimmediate')) {
        destructor = global_1.default.clearImmediate;
        enqueue = function (item) {
            return setImmediate(executeTask.bind(null, item));
        };
    }
    else {
        destructor = global_1.default.clearTimeout;
        enqueue = function (item) {
            return setTimeout(executeTask.bind(null, item), 0);
        };
    }
    function queueTask(callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        var id = enqueue(item);
        return getQueueHandle(item, destructor &&
            function () {
                destructor(id);
            });
    }
    // TODO: Use aspect.before when it is available.
    return has_1.default('microtasks')
        ? queueTask
        : function (callback) {
            checkMicroTaskQueue();
            return queueTask(callback);
        };
})();
// When no mechanism for registering microtasks is exposed by the environment, microtasks will
// be queued and then executed in a single macrotask before the other macrotasks are executed.
if (!has_1.default('microtasks')) {
    var isMicroTaskQueued_1 = false;
    microTasks = [];
    checkMicroTaskQueue = function () {
        if (!isMicroTaskQueued_1) {
            isMicroTaskQueued_1 = true;
            exports.queueTask(function () {
                isMicroTaskQueued_1 = false;
                if (microTasks.length) {
                    var item = void 0;
                    while ((item = microTasks.shift())) {
                        executeTask(item);
                    }
                }
            });
        }
    };
}
/**
 * Schedules an animation task with `window.requestAnimationFrame` if it exists, or with `queueTask` otherwise.
 *
 * Since requestAnimationFrame's behavior does not match that expected from `queueTask`, it is not used there.
 * However, at times it makes more sense to delegate to requestAnimationFrame; hence the following method.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueAnimationTask = (function () {
    if (!has_1.default('raf')) {
        return exports.queueTask;
    }
    function queueAnimationTask(callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        var rafId = requestAnimationFrame(executeTask.bind(null, item));
        return getQueueHandle(item, function () {
            cancelAnimationFrame(rafId);
        });
    }
    // TODO: Use aspect.before when it is available.
    return has_1.default('microtasks')
        ? queueAnimationTask
        : function (callback) {
            checkMicroTaskQueue();
            return queueAnimationTask(callback);
        };
})();
/**
 * Schedules a callback to the microtask queue.
 *
 * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native
 * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask
 * registered with `queueTask` or `queueAnimationTask`.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueMicroTask = (function () {
    var enqueue;
    if (has_1.default('host-node')) {
        enqueue = function (item) {
            global_1.default.process.nextTick(executeTask.bind(null, item));
        };
    }
    else if (has_1.default('es6-promise')) {
        enqueue = function (item) {
            global_1.default.Promise.resolve(item).then(executeTask);
        };
    }
    else if (has_1.default('dom-mutationobserver')) {
        /* tslint:disable-next-line:variable-name */
        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
        var node_1 = document.createElement('div');
        var queue_2 = [];
        var observer = new HostMutationObserver(function () {
            while (queue_2.length > 0) {
                var item = queue_2.shift();
                if (item && item.isActive && item.callback) {
                    item.callback();
                }
            }
        });
        observer.observe(node_1, { attributes: true });
        enqueue = function (item) {
            queue_2.push(item);
            node_1.setAttribute('queueStatus', '1');
        };
    }
    else {
        enqueue = function (item) {
            checkMicroTaskQueue();
            microTasks.push(item);
        };
    }
    return function (callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        enqueue(item);
        return getQueueHandle(item);
    };
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@dojo/shim/support/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper function to generate a value property descriptor
 *
 * @param value        The value the property descriptor should be set to
 * @param enumerable   If the property should be enumberable, defaults to false
 * @param writable     If the property should be writable, defaults to true
 * @param configurable If the property should be configurable, defaults to true
 * @return             The property descriptor object
 */
function getValueDescriptor(value, enumerable, writable, configurable) {
    if (enumerable === void 0) { enumerable = false; }
    if (writable === void 0) { writable = true; }
    if (configurable === void 0) { configurable = true; }
    return {
        value: value,
        enumerable: enumerable,
        writable: writable,
        configurable: configurable
    };
}
exports.getValueDescriptor = getValueDescriptor;
function wrapNative(nativeFunction) {
    return function (target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return nativeFunction.apply(target, args);
    };
}
exports.wrapNative = wrapNative;


/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const i18n = __webpack_require__("./node_modules/@dojo/i18n/i18n.js");
const loadCldrData = __webpack_require__("./node_modules/@dojo/i18n/cldr/load.js").default;
const systemLocale = i18n.systemLocale;
const userLocale = systemLocale.replace(/^([a-z]{2}).*/i, '$1');
const isUserLocaleSupported = userLocale === 'en' ||
    ["es"].some(function (locale) {
        return locale === systemLocale || locale === userLocale;
    });
loadCldrData({});
i18n.switchLocale(isUserLocaleSupported ? systemLocale : 'en');


/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,src/Foo!./src/Foo.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("src/Foo").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Foo.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Bar.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("widgets").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Bar.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Baz.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("widgets").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Baz.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( root, factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory();
	} else {
		// Global
		root.Cldr = factory();
	}

}( this, function() {


	var arrayIsArray = Array.isArray || function( obj ) {
		return Object.prototype.toString.call( obj ) === "[object Array]";
	};




	var pathNormalize = function( path, attributes ) {
		if ( arrayIsArray( path ) ) {
			path = path.join( "/" );
		}
		if ( typeof path !== "string" ) {
			throw new Error( "invalid path \"" + path + "\"" );
		}
		// 1: Ignore leading slash `/`
		// 2: Ignore leading `cldr/`
		path = path
			.replace( /^\// , "" ) /* 1 */
			.replace( /^cldr\// , "" ); /* 2 */

		// Replace {attribute}'s
		path = path.replace( /{[a-zA-Z]+}/g, function( name ) {
			name = name.replace( /^{([^}]*)}$/, "$1" );
			return attributes[ name ];
		});

		return path.split( "/" );
	};




	var arraySome = function( array, callback ) {
		var i, length;
		if ( array.some ) {
			return array.some( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			if ( callback( array[ i ], i, array ) ) {
				return true;
			}
		}
		return false;
	};




	/**
	 * Return the maximized language id as defined in
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. Canonicalize.
	 * 1.1 Make sure the input locale is in canonical form: uses the right
	 * separator, and has the right casing.
	 * TODO Right casing? What df? It seems languages are lowercase, scripts are
	 * Capitalized, territory is uppercase. I am leaving this as an exercise to
	 * the user.
	 *
	 * 1.2 Replace any deprecated subtags with their canonical values using the
	 * <alias> data in supplemental metadata. Use the first value in the
	 * replacement list, if it exists. Language tag replacements may have multiple
	 * parts, such as "sh"  "sr_Latn" or mo"  "ro_MD". In such a case, the
	 * original script and/or region are retained if there is one. Thus
	 * "sh_Arab_AQ"  "sr_Arab_AQ", not "sr_Latn_AQ".
	 * TODO What <alias> data?
	 *
	 * 1.3 If the tag is grandfathered (see <variable id="$grandfathered"
	 * type="choice"> in the supplemental data), then return it.
	 * TODO grandfathered?
	 *
	 * 1.4 Remove the script code 'Zzzz' and the region code 'ZZ' if they occur.
	 * 1.5 Get the components of the cleaned-up source tag (languages, scripts,
	 * and regions), plus any variants and extensions.
	 * 2. Lookup. Lookup each of the following in order, and stop on the first
	 * match:
	 * 2.1 languages_scripts_regions
	 * 2.2 languages_regions
	 * 2.3 languages_scripts
	 * 2.4 languages
	 * 2.5 und_scripts
	 * 3. Return
	 * 3.1 If there is no match, either return an error value, or the match for
	 * "und" (in APIs where a valid language tag is required).
	 * 3.2 Otherwise there is a match = languagem_scriptm_regionm
	 * 3.3 Let xr = xs if xs is not empty, and xm otherwise.
	 * 3.4 Return the language tag composed of languager _ scriptr _ regionr +
	 * variants + extensions.
	 *
	 * @subtags [Array] normalized language id subtags tuple (see init.js).
	 */
	var coreLikelySubtags = function( Cldr, cldr, subtags, options ) {
		var match, matchFound,
			language = subtags[ 0 ],
			script = subtags[ 1 ],
			sep = Cldr.localeSep,
			territory = subtags[ 2 ],
			variants = subtags.slice( 3, 4 );
		options = options || {};

		// Skip if (language, script, territory) is not empty [3.3]
		if ( language !== "und" && script !== "Zzzz" && territory !== "ZZ" ) {
			return [ language, script, territory ].concat( variants );
		}

		// Skip if no supplemental likelySubtags data is present
		if ( typeof cldr.get( "supplemental/likelySubtags" ) === "undefined" ) {
			return;
		}

		// [2]
		matchFound = arraySome([
			[ language, script, territory ],
			[ language, territory ],
			[ language, script ],
			[ language ],
			[ "und", script ]
		], function( test ) {
			return match = !(/\b(Zzzz|ZZ)\b/).test( test.join( sep ) ) /* [1.4] */ && cldr.get( [ "supplemental/likelySubtags", test.join( sep ) ] );
		});

		// [3]
		if ( matchFound ) {
			// [3.2 .. 3.4]
			match = match.split( sep );
			return [
				language !== "und" ? language : match[ 0 ],
				script !== "Zzzz" ? script : match[ 1 ],
				territory !== "ZZ" ? territory : match[ 2 ]
			].concat( variants );
		} else if ( options.force ) {
			// [3.1.2]
			return cldr.get( "supplemental/likelySubtags/und" ).split( sep );
		} else {
			// [3.1.1]
			return;
		}
	};



	/**
	 * Given a locale, remove any fields that Add Likely Subtags would add.
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. First get max = AddLikelySubtags(inputLocale). If an error is signaled,
	 * return it.
	 * 2. Remove the variants from max.
	 * 3. Then for trial in {language, language _ region, language _ script}. If
	 * AddLikelySubtags(trial) = max, then return trial + variants.
	 * 4. If you do not get a match, return max + variants.
	 * 
	 * @maxLanguageId [Array] maxLanguageId tuple (see init.js).
	 */
	var coreRemoveLikelySubtags = function( Cldr, cldr, maxLanguageId ) {
		var match, matchFound,
			language = maxLanguageId[ 0 ],
			script = maxLanguageId[ 1 ],
			territory = maxLanguageId[ 2 ],
			variants = maxLanguageId[ 3 ];

		// [3]
		matchFound = arraySome([
			[ [ language, "Zzzz", "ZZ" ], [ language ] ],
			[ [ language, "Zzzz", territory ], [ language, territory ] ],
			[ [ language, script, "ZZ" ], [ language, script ] ]
		], function( test ) {
			var result = coreLikelySubtags( Cldr, cldr, test[ 0 ] );
			match = test[ 1 ];
			return result && result[ 0 ] === maxLanguageId[ 0 ] &&
				result[ 1 ] === maxLanguageId[ 1 ] &&
				result[ 2 ] === maxLanguageId[ 2 ];
		});

		if ( matchFound ) {
			if ( variants ) {
				match.push( variants );
			}
			return match;
		}

		// [4]
		return maxLanguageId;
	};




	/**
	 * subtags( locale )
	 *
	 * @locale [String]
	 */
	var coreSubtags = function( locale ) {
		var aux, unicodeLanguageId,
			subtags = [];

		locale = locale.replace( /_/, "-" );

		// Unicode locale extensions.
		aux = locale.split( "-u-" );
		if ( aux[ 1 ] ) {
			aux[ 1 ] = aux[ 1 ].split( "-t-" );
			locale = aux[ 0 ] + ( aux[ 1 ][ 1 ] ? "-t-" + aux[ 1 ][ 1 ] : "");
			subtags[ 4 /* unicodeLocaleExtensions */ ] = aux[ 1 ][ 0 ];
		}

		// TODO normalize transformed extensions. Currently, skipped.
		// subtags[ x ] = locale.split( "-t-" )[ 1 ];
		unicodeLanguageId = locale.split( "-t-" )[ 0 ];

		// unicode_language_id = "root"
		//   | unicode_language_subtag         
		//     (sep unicode_script_subtag)? 
		//     (sep unicode_region_subtag)?
		//     (sep unicode_variant_subtag)* ;
		//
		// Although unicode_language_subtag = alpha{2,8}, I'm using alpha{2,3}. Because, there's no language on CLDR lengthier than 3.
		aux = unicodeLanguageId.match( /^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/ );
		if ( aux === null ) {
			return [ "und", "Zzzz", "ZZ" ];
		}
		subtags[ 0 /* language */ ] = aux[ 10 ] /* root */ || aux[ 2 ] || "und";
		subtags[ 1 /* script */ ] = aux[ 4 ] || "Zzzz";
		subtags[ 2 /* territory */ ] = aux[ 6 ] || "ZZ";
		if ( aux[ 7 ] && aux[ 7 ].length ) {
			subtags[ 3 /* variant */ ] = aux[ 7 ].slice( 1 ) /* remove leading "-" */;
		}

		// 0: language
		// 1: script
		// 2: territory (aka region)
		// 3: variant
		// 4: unicodeLocaleExtensions
		return subtags;
	};




	var arrayForEach = function( array, callback ) {
		var i, length;
		if ( array.forEach ) {
			return array.forEach( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			callback( array[ i ], i, array );
		}
	};




	/**
	 * bundleLookup( minLanguageId )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @cldr [Cldr instance]
	 *
	 * @minLanguageId [String] requested languageId after applied remove likely subtags.
	 */
	var bundleLookup = function( Cldr, cldr, minLanguageId ) {
		var availableBundleMap = Cldr._availableBundleMap,
			availableBundleMapQueue = Cldr._availableBundleMapQueue;

		if ( availableBundleMapQueue.length ) {
			arrayForEach( availableBundleMapQueue, function( bundle ) {
				var existing, maxBundle, minBundle, subtags;
				subtags = coreSubtags( bundle );
				maxBundle = coreLikelySubtags( Cldr, cldr, subtags );
				minBundle = coreRemoveLikelySubtags( Cldr, cldr, maxBundle );
				minBundle = minBundle.join( Cldr.localeSep );
				existing = availableBundleMapQueue[ minBundle ];
				if ( existing && existing.length < bundle.length ) {
					return;
				}
				availableBundleMap[ minBundle ] = bundle;
			});
			Cldr._availableBundleMapQueue = [];
		}

		return availableBundleMap[ minLanguageId ] || null;
	};




	var objectKeys = function( object ) {
		var i,
			result = [];

		if ( Object.keys ) {
			return Object.keys( object );
		}

		for ( i in object ) {
			result.push( i );
		}

		return result;
	};




	var createError = function( code, attributes ) {
		var error, message;

		message = code + ( attributes && JSON ? ": " + JSON.stringify( attributes ) : "" );
		error = new Error( message );
		error.code = code;

		// extend( error, attributes );
		arrayForEach( objectKeys( attributes ), function( attribute ) {
			error[ attribute ] = attributes[ attribute ];
		});

		return error;
	};




	var validate = function( code, check, attributes ) {
		if ( !check ) {
			throw createError( code, attributes );
		}
	};




	var validatePresence = function( value, name ) {
		validate( "E_MISSING_PARAMETER", typeof value !== "undefined", {
			name: name
		});
	};




	var validateType = function( value, name, check, expected ) {
		validate( "E_INVALID_PAR_TYPE", check, {
			expected: expected,
			name: name,
			value: value
		});
	};




	var validateTypePath = function( value, name ) {
		validateType( value, name, typeof value === "string" || arrayIsArray( value ), "String or Array" );
	};




	/**
	 * Function inspired by jQuery Core, but reduced to our use case.
	 */
	var isPlainObject = function( obj ) {
		return obj !== null && "" + obj === "[object Object]";
	};




	var validateTypePlainObject = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || isPlainObject( value ), "Plain Object" );
	};




	var validateTypeString = function( value, name ) {
		validateType( value, name, typeof value === "string", "a string" );
	};




	// @path: normalized path
	var resourceGet = function( data, path ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			node = node[ path[ i ] ];
			if ( !node ) {
				return undefined;
			}
		}
		return node[ path[ i ] ];
	};




	/**
	 * setAvailableBundles( Cldr, json )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @json resolved/unresolved cldr data.
	 *
	 * Set available bundles queue based on passed json CLDR data. Considers a bundle as any String at /main/{bundle}.
	 */
	var coreSetAvailableBundles = function( Cldr, json ) {
		var bundle,
			availableBundleMapQueue = Cldr._availableBundleMapQueue,
			main = resourceGet( json, [ "main" ] );

		if ( main ) {
			for ( bundle in main ) {
				if ( main.hasOwnProperty( bundle ) && bundle !== "root" &&
							availableBundleMapQueue.indexOf( bundle ) === -1 ) {
					availableBundleMapQueue.push( bundle );
				}
			}
		}
	};



	var alwaysArray = function( somethingOrArray ) {
		return arrayIsArray( somethingOrArray ) ?  somethingOrArray : [ somethingOrArray ];
	};


	var jsonMerge = (function() {

	// Returns new deeply merged JSON.
	//
	// Eg.
	// merge( { a: { b: 1, c: 2 } }, { a: { b: 3, d: 4 } } )
	// -> { a: { b: 3, c: 2, d: 4 } }
	//
	// @arguments JSON's
	// 
	var merge = function() {
		var destination = {},
			sources = [].slice.call( arguments, 0 );
		arrayForEach( sources, function( source ) {
			var prop;
			for ( prop in source ) {
				if ( prop in destination && typeof destination[ prop ] === "object" && !arrayIsArray( destination[ prop ] ) ) {

					// Merge Objects
					destination[ prop ] = merge( destination[ prop ], source[ prop ] );

				} else {

					// Set new values
					destination[ prop ] = source[ prop ];

				}
			}
		});
		return destination;
	};

	return merge;

}());


	/**
	 * load( Cldr, source, jsons )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @source [Object]
	 *
	 * @jsons [arguments]
	 */
	var coreLoad = function( Cldr, source, jsons ) {
		var i, j, json;

		validatePresence( jsons[ 0 ], "json" );

		// Support arbitrary parameters, e.g., `Cldr.load({...}, {...})`.
		for ( i = 0; i < jsons.length; i++ ) {

			// Support array parameters, e.g., `Cldr.load([{...}, {...}])`.
			json = alwaysArray( jsons[ i ] );

			for ( j = 0; j < json.length; j++ ) {
				validateTypePlainObject( json[ j ], "json" );
				source = jsonMerge( source, json[ j ] );
				coreSetAvailableBundles( Cldr, json[ j ] );
			}
		}

		return source;
	};



	var itemGetResolved = function( Cldr, path, attributes ) {
		// Resolve path
		var normalizedPath = pathNormalize( path, attributes );

		return resourceGet( Cldr._resolved, normalizedPath );
	};




	/**
	 * new Cldr()
	 */
	var Cldr = function( locale ) {
		this.init( locale );
	};

	// Build optimization hack to avoid duplicating functions across modules.
	Cldr._alwaysArray = alwaysArray;
	Cldr._coreLoad = coreLoad;
	Cldr._createError = createError;
	Cldr._itemGetResolved = itemGetResolved;
	Cldr._jsonMerge = jsonMerge;
	Cldr._pathNormalize = pathNormalize;
	Cldr._resourceGet = resourceGet;
	Cldr._validatePresence = validatePresence;
	Cldr._validateType = validateType;
	Cldr._validateTypePath = validateTypePath;
	Cldr._validateTypePlainObject = validateTypePlainObject;

	Cldr._availableBundleMap = {};
	Cldr._availableBundleMapQueue = [];
	Cldr._resolved = {};

	// Allow user to override locale separator "-" (default) | "_". According to http://www.unicode.org/reports/tr35/#Unicode_language_identifier, both "-" and "_" are valid locale separators (eg. "en_GB", "en-GB"). According to http://unicode.org/cldr/trac/ticket/6786 its usage must be consistent throughout the data set.
	Cldr.localeSep = "-";

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved cldr data.
	 */
	Cldr.load = function() {
		Cldr._resolved = coreLoad( Cldr, Cldr._resolved, arguments );
	};

	/**
	 * .init() automatically run on instantiation/construction.
	 */
	Cldr.prototype.init = function( locale ) {
		var attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant,
			sep = Cldr.localeSep,
			unicodeLocaleExtensionsRaw = "";

		validatePresence( locale, "locale" );
		validateTypeString( locale, "locale" );

		subtags = coreSubtags( locale );

		if ( subtags.length === 5 ) {
			unicodeLocaleExtensions = subtags.pop();
			unicodeLocaleExtensionsRaw = sep + "u" + sep + unicodeLocaleExtensions;
			// Remove trailing null when there is unicodeLocaleExtensions but no variants.
			if ( !subtags[ 3 ] ) {
				subtags.pop();
			}
		}
		variant = subtags[ 3 ];

		// Normalize locale code.
		// Get (or deduce) the "triple subtags": language, territory (also aliased as region), and script subtags.
		// Get the variant subtags (calendar, collation, currency, etc).
		// refs:
		// - http://www.unicode.org/reports/tr35/#Field_Definitions
		// - http://www.unicode.org/reports/tr35/#Language_and_Locale_IDs
		// - http://www.unicode.org/reports/tr35/#Unicode_locale_identifier

		// When a locale id does not specify a language, or territory (region), or script, they are obtained by Likely Subtags.
		maxLanguageId = coreLikelySubtags( Cldr, this, subtags, { force: true } ) || subtags;
		language = maxLanguageId[ 0 ];
		script = maxLanguageId[ 1 ];
		territory = maxLanguageId[ 2 ];

		minLanguageId = coreRemoveLikelySubtags( Cldr, this, maxLanguageId ).join( sep );

		// Set attributes
		this.attributes = attributes = {
			bundle: bundleLookup( Cldr, this, minLanguageId ),

			// Unicode Language Id
			minLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,
			maxLanguageId: maxLanguageId.join( sep ) + unicodeLocaleExtensionsRaw,

			// Unicode Language Id Subtabs
			language: language,
			script: script,
			territory: territory,
			region: territory, /* alias */
			variant: variant
		};

		// Unicode locale extensions.
		unicodeLocaleExtensions && ( "-" + unicodeLocaleExtensions ).replace( /-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function( attribute, key, type ) {

			if ( key ) {

				// Extension is in the `keyword` form.
				attributes[ "u" + key ] = type;
			} else {

				// Extension is in the `attribute` form.
				attributes[ "u" + attribute ] = true;
			}
		});

		this.locale = locale;
	};

	/**
	 * .get()
	 */
	Cldr.prototype.get = function( path ) {

		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		return itemGetResolved( Cldr, path, this.attributes );
	};

	/**
	 * .main()
	 */
	Cldr.prototype.main = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		validate( "E_MISSING_BUNDLE", this.attributes.bundle !== null, {
			locale: this.locale
		});

		path = alwaysArray( path );
		return this.get( [ "main/{bundle}" ].concat( path ) );
	};

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/event.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var pathNormalize = Cldr._pathNormalize,
		validatePresence = Cldr._validatePresence,
		validateType = Cldr._validateType;

/*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

var EventEmitter;
/* jshint ignore:start */
EventEmitter = (function () {


	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (evt instanceof RegExp) {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (evt instanceof RegExp) {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	return EventEmitter;
}());
/* jshint ignore:end */



	var validateTypeFunction = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || typeof value === "function", "Function" );
	};




	var superGet, superInit,
		globalEe = new EventEmitter();

	function validateTypeEvent( value, name ) {
		validateType( value, name, typeof value === "string" || value instanceof RegExp, "String or RegExp" );
	}

	function validateThenCall( method, self ) {
		return function( event, listener ) {
			validatePresence( event, "event" );
			validateTypeEvent( event, "event" );

			validatePresence( listener, "listener" );
			validateTypeFunction( listener, "listener" );

			return self[ method ].apply( self, arguments );
		};
	}

	function off( self ) {
		return validateThenCall( "off", self );
	}

	function on( self ) {
		return validateThenCall( "on", self );
	}

	function once( self ) {
		return validateThenCall( "once", self );
	}

	Cldr.off = off( globalEe );
	Cldr.on = on( globalEe );
	Cldr.once = once( globalEe );

	/**
	 * Overload Cldr.prototype.init().
	 */
	superInit = Cldr.prototype.init;
	Cldr.prototype.init = function() {
		var ee;
		this.ee = ee = new EventEmitter();
		this.off = off( ee );
		this.on = on( ee );
		this.once = once( ee );
		superInit.apply( this, arguments );
	};

	/**
	 * getOverload is encapsulated, because of cldr/unresolved. If it's loaded
	 * after cldr/event (and note it overwrites .get), it can trigger this
	 * overload again.
	 */
	function getOverload() {

		/**
		 * Overload Cldr.prototype.get().
		 */
		superGet = Cldr.prototype.get;
		Cldr.prototype.get = function( path ) {
			var value = superGet.apply( this, arguments );
			path = pathNormalize( path, this.attributes ).join( "/" );
			globalEe.trigger( "get", [ path, value ] );
			this.ee.trigger( "get", [ path, value ] );
			return value;
		};
	}

	Cldr._eventInit = getOverload;
	getOverload();

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/supplemental.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var alwaysArray = Cldr._alwaysArray;



	var supplementalMain = function( cldr ) {

		var prepend, supplemental;
		
		prepend = function( prepend ) {
			return function( path ) {
				path = alwaysArray( path );
				return cldr.get( [ prepend ].concat( path ) );
			};
		};

		supplemental = prepend( "supplemental" );

		// Week Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Week_Data
		supplemental.weekData = prepend( "supplemental/weekData" );

		supplemental.weekData.firstDay = function() {
			return cldr.get( "supplemental/weekData/firstDay/{territory}" ) ||
				cldr.get( "supplemental/weekData/firstDay/001" );
		};

		supplemental.weekData.minDays = function() {
			var minDays = cldr.get( "supplemental/weekData/minDays/{territory}" ) ||
				cldr.get( "supplemental/weekData/minDays/001" );
			return parseInt( minDays, 10 );
		};

		// Time Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
		supplemental.timeData = prepend( "supplemental/timeData" );

		supplemental.timeData.allowed = function() {
			return cldr.get( "supplemental/timeData/{territory}/_allowed" ) ||
				cldr.get( "supplemental/timeData/001/_allowed" );
		};

		supplemental.timeData.preferred = function() {
			return cldr.get( "supplemental/timeData/{territory}/_preferred" ) ||
				cldr.get( "supplemental/timeData/001/_preferred" );
		};

		return supplemental;

	};




	var initSuper = Cldr.prototype.init;

	/**
	 * .init() automatically ran on construction.
	 *
	 * Overload .init().
	 */
	Cldr.prototype.init = function() {
		initSuper.apply( this, arguments );
		this.supplemental = supplementalMain( this );
	};

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/unresolved.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var coreLoad = Cldr._coreLoad;
	var jsonMerge = Cldr._jsonMerge;
	var pathNormalize = Cldr._pathNormalize;
	var resourceGet = Cldr._resourceGet;
	var validatePresence = Cldr._validatePresence;
	var validateTypePath = Cldr._validateTypePath;



	var bundleParentLookup = function( Cldr, locale ) {
		var normalizedPath, parent;

		if ( locale === "root" ) {
			return;
		}

		// First, try to find parent on supplemental data.
		normalizedPath = pathNormalize( [ "supplemental/parentLocales/parentLocale", locale ] );
		parent = resourceGet( Cldr._resolved, normalizedPath ) || resourceGet( Cldr._raw, normalizedPath );
		if ( parent ) {
			return parent;
		}

		// Or truncate locale.
		parent = locale.substr( 0, locale.lastIndexOf( Cldr.localeSep ) );
		if ( !parent ) {
			return "root";
		}

		return parent;
	};




	// @path: normalized path
	var resourceSet = function( data, path, value ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			if ( !node[ path[ i ] ] ) {
				node[ path[ i ] ] = {};
			}
			node = node[ path[ i ] ];
		}
		node[ path[ i ] ] = value;
	};


	var itemLookup = (function() {

	var lookup;

	lookup = function( Cldr, locale, path, attributes, childLocale ) {
		var normalizedPath, parent, value;

		// 1: Finish recursion
		// 2: Avoid infinite loop
		if ( typeof locale === "undefined" /* 1 */ || locale === childLocale /* 2 */ ) {
			return;
		}

		// Resolve path
		normalizedPath = pathNormalize( path, attributes );

		// Check resolved (cached) data first
		// 1: Due to #16, never use the cached resolved non-leaf nodes. It may not
		//    represent its leafs in its entirety.
		value = resourceGet( Cldr._resolved, normalizedPath );
		if ( value && typeof value !== "object" /* 1 */ ) {
			return value;
		}

		// Check raw data
		value = resourceGet( Cldr._raw, normalizedPath );

		if ( !value ) {
			// Or, lookup at parent locale
			parent = bundleParentLookup( Cldr, locale );
			value = lookup( Cldr, parent, path, jsonMerge( attributes, { bundle: parent }), locale );
		}

		if ( value ) {
			// Set resolved (cached)
			resourceSet( Cldr._resolved, normalizedPath, value );
		}

		return value;
	};

	return lookup;

}());


	Cldr._raw = {};

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved or unresolved cldr data.
	 * Overwrite Cldr.load().
	 */
	Cldr.load = function() {
		Cldr._raw = coreLoad( Cldr, Cldr._raw, arguments );
	};

	/**
	 * Overwrite Cldr.prototype.get().
	 */
	Cldr.prototype.get = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		// 1: use bundle as locale on item lookup for simplification purposes, because no other extended subtag is used anyway on bundle parent lookup.
		// 2: during init(), this method is called, but bundle is yet not defined. Use "" as a workaround in this very specific scenario.
		return itemLookup( Cldr, this.attributes && this.attributes.bundle /* 1 */ || "" /* 2 */, path, this.attributes );
	};

	// In case cldr/unresolved is loaded after cldr/event, we trigger its overloads again. Because, .get is overwritten in here.
	if ( Cldr._eventInit ) {
		Cldr._eventInit();
	}

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/node_main.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */

// Cldr
module.exports = __webpack_require__( "./node_modules/cldrjs/dist/cldr.js" );

// Extent Cldr with the following modules
__webpack_require__( "./node_modules/cldrjs/dist/cldr/event.js" );
__webpack_require__( "./node_modules/cldrjs/dist/cldr/supplemental.js" );
__webpack_require__( "./node_modules/cldrjs/dist/cldr/unresolved.js" );


/***/ }),

/***/ "./node_modules/globalize/dist/globalize.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"cldr/event"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ) );
	} else {

		// Global
		root.Globalize = factory( root.Cldr );
	}
}( this, function( Cldr ) {


/**
 * A toString method that outputs meaningful values for objects or arrays and
 * still performs as fast as a plain string in case variable is string, or as
 * fast as `"" + number` in case variable is a number.
 * Ref: http://jsperf.com/my-stringify
 */
var toString = function( variable ) {
	return typeof variable === "string" ? variable : ( typeof variable === "number" ? "" +
		variable : JSON.stringify( variable ) );
};




/**
 * formatMessage( message, data )
 *
 * @message [String] A message with optional {vars} to be replaced.
 *
 * @data [Array or JSON] Object with replacing-variables content.
 *
 * Return the formatted message. For example:
 *
 * - formatMessage( "{0} second", [ 1 ] ); // 1 second
 *
 * - formatMessage( "{0}/{1}", ["m", "s"] ); // m/s
 *
 * - formatMessage( "{name} <{email}>", {
 *     name: "Foo",
 *     email: "bar@baz.qux"
 *   }); // Foo <bar@baz.qux>
 */
var formatMessage = function( message, data ) {

	// Replace {attribute}'s
	message = message.replace( /{[0-9a-zA-Z-_. ]+}/g, function( name ) {
		name = name.replace( /^{([^}]*)}$/, "$1" );
		return toString( data[ name ] );
	});

	return message;
};




var objectExtend = function() {
	var destination = arguments[ 0 ],
		sources = [].slice.call( arguments, 1 );

	sources.forEach(function( source ) {
		var prop;
		for ( prop in source ) {
			destination[ prop ] = source[ prop ];
		}
	});

	return destination;
};




var createError = function( code, message, attributes ) {
	var error;

	message = code + ( message ? ": " + formatMessage( message, attributes ) : "" );
	error = new Error( message );
	error.code = code;

	objectExtend( error, attributes );

	return error;
};




// Based on http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
var stringHash = function( str ) {
	return [].reduce.call( str, function( hash, i ) {
		var chr = i.charCodeAt( 0 );
		hash = ( ( hash << 5 ) - hash ) + chr;
		return hash | 0;
	}, 0 );
};




var runtimeKey = function( fnName, locale, args, argsStr ) {
	var hash;
	argsStr = argsStr || JSON.stringify( args );
	hash = stringHash( fnName + locale + argsStr );
	return hash > 0 ? "a" + hash : "b" + Math.abs( hash );
};




var functionName = function( fn ) {
	if ( fn.name !== undefined ) {
		return fn.name;
	}

	// fn.name is not supported by IE.
	var matches = /^function\s+([\w\$]+)\s*\(/.exec( fn.toString() );

	if ( matches && matches.length > 0 ) {
		return matches[ 1 ];
	}
};




var runtimeBind = function( args, cldr, fn, runtimeArgs ) {

	var argsStr = JSON.stringify( args ),
		fnName = functionName( fn ),
		locale = cldr.locale;

	// If name of the function is not available, this is most likely due to uglification,
	// which most likely means we are in production, and runtimeBind here is not necessary.
	if ( !fnName ) {
		return fn;
	}

	fn.runtimeKey = runtimeKey( fnName, locale, null, argsStr );

	fn.generatorString = function() {
		return "Globalize(\"" + locale + "\")." + fnName + "(" + argsStr.slice( 1, -1 ) + ")";
	};

	fn.runtimeArgs = runtimeArgs;

	return fn;
};




var validate = function( code, message, check, attributes ) {
	if ( !check ) {
		throw createError( code, message, attributes );
	}
};




var alwaysArray = function( stringOrArray ) {
	return Array.isArray( stringOrArray ) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];
};




var validateCldr = function( path, value, options ) {
	var skipBoolean;
	options = options || {};

	skipBoolean = alwaysArray( options.skip ).some(function( pathRe ) {
		return pathRe.test( path );
	});

	validate( "E_MISSING_CLDR", "Missing required CLDR content `{path}`.", value || skipBoolean, {
		path: path
	});
};




var validateDefaultLocale = function( value ) {
	validate( "E_DEFAULT_LOCALE_NOT_DEFINED", "Default locale has not been defined.",
		value !== undefined, {} );
};




var validateParameterPresence = function( value, name ) {
	validate( "E_MISSING_PARAMETER", "Missing required parameter `{name}`.",
		value !== undefined, { name: name });
};




/**
 * range( value, name, minimum, maximum )
 *
 * @value [Number].
 *
 * @name [String] name of variable.
 *
 * @minimum [Number]. The lowest valid value, inclusive.
 *
 * @maximum [Number]. The greatest valid value, inclusive.
 */
var validateParameterRange = function( value, name, minimum, maximum ) {
	validate(
		"E_PAR_OUT_OF_RANGE",
		"Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].",
		value === undefined || value >= minimum && value <= maximum,
		{
			maximum: maximum,
			minimum: minimum,
			name: name,
			value: value
		}
	);
};




var validateParameterType = function( value, name, check, expected ) {
	validate(
		"E_INVALID_PAR_TYPE",
		"Invalid `{name}` parameter ({value}). {expected} expected.",
		check,
		{
			expected: expected,
			name: name,
			value: value
		}
	);
};




var validateParameterTypeLocale = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" || value instanceof Cldr,
		"String or Cldr instance"
	);
};




/**
 * Function inspired by jQuery Core, but reduced to our use case.
 */
var isPlainObject = function( obj ) {
	return obj !== null && "" + obj === "[object Object]";
};




var validateParameterTypePlainObject = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ),
		"Plain Object"
	);
};




var alwaysCldr = function( localeOrCldr ) {
	return localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr( localeOrCldr );
};




// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
var regexpEscape = function( string ) {
	return string.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1" );
};




var stringPad = function( str, count, right ) {
	var length;
	if ( typeof str !== "string" ) {
		str = String( str );
	}
	for ( length = str.length; length < count; length += 1 ) {
		str = ( right ? ( str + "0" ) : ( "0" + str ) );
	}
	return str;
};




function validateLikelySubtags( cldr ) {
	cldr.once( "get", validateCldr );
	cldr.get( "supplemental/likelySubtags" );
}

/**
 * [new] Globalize( locale|cldr )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Create a Globalize instance.
 */
function Globalize( locale ) {
	if ( !( this instanceof Globalize ) ) {
		return new Globalize( locale );
	}

	validateParameterPresence( locale, "locale" );
	validateParameterTypeLocale( locale, "locale" );

	this.cldr = alwaysCldr( locale );

	validateLikelySubtags( this.cldr );
}

/**
 * Globalize.load( json, ... )
 *
 * @json [JSON]
 *
 * Load resolved or unresolved cldr data.
 * Somewhat equivalent to previous Globalize.addCultureInfo(...).
 */
Globalize.load = function() {

	// validations are delegated to Cldr.load().
	Cldr.load.apply( Cldr, arguments );
};

/**
 * Globalize.locale( [locale|cldr] )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Set default Cldr instance if locale or cldr argument is passed.
 *
 * Return the default Cldr instance.
 */
Globalize.locale = function( locale ) {
	validateParameterTypeLocale( locale, "locale" );

	if ( arguments.length ) {
		this.cldr = alwaysCldr( locale );
		validateLikelySubtags( this.cldr );
	}
	return this.cldr;
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._alwaysArray = alwaysArray;
Globalize._createError = createError;
Globalize._formatMessage = formatMessage;
Globalize._isPlainObject = isPlainObject;
Globalize._objectExtend = objectExtend;
Globalize._regexpEscape = regexpEscape;
Globalize._runtimeBind = runtimeBind;
Globalize._stringPad = stringPad;
Globalize._validate = validate;
Globalize._validateCldr = validateCldr;
Globalize._validateDefaultLocale = validateDefaultLocale;
Globalize._validateParameterPresence = validateParameterPresence;
Globalize._validateParameterRange = validateParameterRange;
Globalize._validateParameterTypePlainObject = validateParameterTypePlainObject;
Globalize._validateParameterType = validateParameterType;

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/currency.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/*!
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	formatMessage = Globalize._formatMessage,
	numberNumberingSystem = Globalize._numberNumberingSystem,
	numberPattern = Globalize._numberPattern,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var validateParameterTypeCurrency = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" && ( /^[A-Za-z]{3}$/ ).test( value ),
		"3-letter currency code string as defined by ISO 4217"
	);
};




/**
 * supplementalOverride( currency, pattern, cldr )
 *
 * Return pattern with fraction digits overriden by supplemental currency data.
 */
var currencySupplementalOverride = function( currency, pattern, cldr ) {
	var digits,
		fraction = "",
		fractionData = cldr.supplemental([ "currencyData/fractions", currency ]) ||
			cldr.supplemental( "currencyData/fractions/DEFAULT" );

	digits = +fractionData._digits;

	if ( digits ) {
		fraction = "." + stringPad( "0", digits ).slice( 0, -1 ) + fractionData._rounding;
	}

	return pattern.replace( /\.(#+|0*[0-9]|0+[0-9]?)/g, fraction );
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




var currencyUnitPatterns = function( cldr ) {
	return objectFilter( cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr )
	]), /^unitPattern/ );
};




/**
 * codeProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyCodeProperties = function( currency, cldr ) {
	var pattern = numberPattern( "decimal", cldr );

	// The number of decimal places and the rounding for each currency is not locale-specific. Those
	// values overridden by Supplemental Currency Data.
	pattern = currencySupplementalOverride( currency, pattern, cldr );

	return {
		currency: currency,
		pattern: pattern,
		unitPatterns: currencyUnitPatterns( cldr )
	};
};




/**
 * nameFormat( formattedNumber, pluralForm, properties )
 *
 * Return the appropriate name form currency format.
 */
var currencyNameFormat = function( formattedNumber, pluralForm, properties ) {
	var displayName, unitPattern,
		displayNames = properties.displayNames || {},
		unitPatterns = properties.unitPatterns;

	displayName = displayNames[ "displayName-count-" + pluralForm ] ||
		displayNames[ "displayName-count-other" ] ||
		displayNames.displayName ||
		properties.currency;
	unitPattern = unitPatterns[ "unitPattern-count-" + pluralForm ] ||
		unitPatterns[ "unitPattern-count-other" ];

	return formatMessage( unitPattern, [ formattedNumber, displayName ]);
};




var currencyFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	var fn;

	// Return formatter when style is "code" or "name".
	if ( pluralGenerator && properties ) {
		fn = function currencyFormatter( value ) {
			validateParameterPresence( value, "value" );
			validateParameterTypeNumber( value, "value" );
			return currencyNameFormat(
				numberFormatter( value ),
				pluralGenerator( value ),
				properties
			);
		};

	// Return formatter when style is "symbol" or "accounting".
	} else {
		fn = function currencyFormatter( value ) {
			return numberFormatter( value );
		};
	}

	return fn;
};




/**
 * nameProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyNameProperties = function( currency, cldr ) {
	var properties = currencyCodeProperties( currency, cldr );

	properties.displayNames = objectFilter( cldr.main([
		"numbers/currencies",
		currency
	]), /^displayName/ );

	return properties;
};




/**
 * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and
 * box-drawing characters.
 *
 * Generated by:
 *
 * regenerate()
 *   .addRange( 0x0, 0x10FFFF )
 *   .remove( require( "unicode-7.0.0/categories/S/symbols" ) ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-7.0.0
 */
var regexpNotS = /[\0-#%-\*,-;\?-\]_a-\{\}\x7F-\xA1\xA7\xAA\xAB\xAD\xB2\xB3\xB5-\xB7\xB9-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376-\u0383\u0386-\u03F5\u03F7-\u0481\u0483-\u058C\u0590-\u0605\u0609\u060A\u060C\u060D\u0610-\u06DD\u06DF-\u06E8\u06EA-\u06FC\u06FF-\u07F5\u07F7-\u09F1\u09F4-\u09F9\u09FC-\u0AF0\u0AF2-\u0B6F\u0B71-\u0BF2\u0BFB-\u0C7E\u0C80-\u0D78\u0D7A-\u0E3E\u0E40-\u0F00\u0F04-\u0F12\u0F14\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39-\u0FBD\u0FC6\u0FCD\u0FD0-\u0FD4\u0FD9-\u109D\u10A0-\u138F\u139A-\u17DA\u17DC-\u193F\u1941-\u19DD\u1A00-\u1B60\u1B6B-\u1B73\u1B7D-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDC\u1FE0-\u1FEC\u1FF0-\u1FFC\u1FFF-\u2043\u2045-\u2051\u2053-\u2079\u207D-\u2089\u208D-\u209F\u20BE-\u20FF\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u218F\u2308-\u230B\u2329\u232A\u23FB-\u23FF\u2427-\u243F\u244B-\u249B\u24EA-\u24FF\u2768-\u2793\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2CE4\u2CEB-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u3003\u3005-\u3011\u3014-\u301F\u3021-\u3035\u3038-\u303D\u3040-\u309A\u309D-\u318F\u3192-\u3195\u31A0-\u31BF\u31E4-\u31FF\u321F-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u32FF\u3400-\u4DBF\u4E00-\uA48F\uA4C7-\uA6FF\uA717-\uA71F\uA722-\uA788\uA78B-\uA827\uA82C-\uA835\uA83A-\uAA76\uAA7A-\uAB5A\uAB5C-\uD7FF\uDC00-\uFB28\uFB2A-\uFBB1\uFBC2-\uFDFB\uFDFE-\uFE61\uFE63\uFE67\uFE68\uFE6A-\uFF03\uFF05-\uFF0A\uFF0C-\uFF1B\uFF1F-\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5F-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]|\uD800[\uDC00-\uDD36\uDD40-\uDD78\uDD8A\uDD8B\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFD-\uDFFF]|[\uD801\uD803-\uD819\uD81B-\uD82E\uD830-\uD833\uD836-\uD83A\uD83F-\uDBFF][\uDC00-\uDFFF]|\uD802[\uDC00-\uDC76\uDC79-\uDEC7\uDEC9-\uDFFF]|\uD81A[\uDC00-\uDF3B\uDF40-\uDF44\uDF46-\uDFFF]|\uD82F[\uDC00-\uDC9B\uDC9D-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD65-\uDD69\uDD6D-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDDDE-\uDDFF\uDE42-\uDE44\uDE46-\uDEFF\uDF57-\uDFFF]|\uD835[\uDC00-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFFF]|\uD83B[\uDC00-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF\uDF2D-\uDF2F\uDF7E\uDF7F\uDFCF-\uDFD3\uDFF8-\uDFFF]|\uD83D[\uDCFF\uDD4B-\uDD4F\uDD7A\uDDA4\uDE43\uDE44\uDED0-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDFFF]|[\uD800-\uDBFF]/;




/**
 * symbolProperties( currency, cldr )
 *
 * Return pattern replacing `` with the appropriate currency symbol literal.
 */
var currencySymbolProperties = function( currency, cldr, options ) {
	var currencySpacing, pattern,
		regexp = {
			"[:digit:]": /\d/,
			"[:^S:]": regexpNotS
		},
		symbol = cldr.main([
			"numbers/currencies",
			currency,
			"symbol"
		]);

	currencySpacing = [ "beforeCurrency", "afterCurrency" ].map(function( position ) {
		return cldr.main([
			"numbers",
			"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
			"currencySpacing",
			position
		]);
	});

	pattern = cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
		options.style === "accounting" ? "accounting" : "standard"
	]);

	pattern =

		// The number of decimal places and the rounding for each currency is not locale-specific.
		// Those values are overridden by Supplemental Currency Data.
		currencySupplementalOverride( currency, pattern, cldr )

		// Replace "" (\u00A4) with the appropriate symbol literal.
		.split( ";" ).map(function( pattern ) {

			return pattern.split( "\u00A4" ).map(function( part, i ) {
				var currencyMatch = regexp[ currencySpacing[ i ].currencyMatch ],
					surroundingMatch = regexp[ currencySpacing[ i ].surroundingMatch ],
					insertBetween = "";

				// For currencyMatch and surroundingMatch definitions, read [1].
				// When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.
				// 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies
				currencyMatch = currencyMatch.test( symbol.charAt( i ? symbol.length - 1 : 0 ) );
				surroundingMatch = surroundingMatch.test(
					part.charAt( i ? 0 : part.length - 1 ).replace( /[#@,.]/g, "0" )
				);

				if ( currencyMatch && part && surroundingMatch ) {
					insertBetween = currencySpacing[ i ].insertBetween;
				}

				return ( i ? insertBetween : "" ) + part + ( i ? "" : insertBetween );
			}).join( "'" + symbol + "'" );
		}).join( ";" );

	return {
		pattern: pattern
	};
};




/**
 * objectOmit( object, keys )
 *
 * Return a copy of the object, filtered to omit the blacklisted key or array of keys.
 */
var objectOmit = function( object, keys ) {
	var key,
		copy = {};

	keys = alwaysArray( keys );

	for ( key in object ) {
		if ( keys.indexOf( key ) === -1 ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [ /supplemental\/currencyData\/fractions\/[A-Za-z]{3}$/ ]
	});
}

/**
 * .currencyFormatter( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]:
 * - style: [String] "symbol" (default), "accounting", "code" or "name".
 * - see also number/format options.
 *
 * Return a function that formats a currency according to the given options and default/instance
 * locale.
 */
Globalize.currencyFormatter =
Globalize.prototype.currencyFormatter = function( currency, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn, style;

	validateParameterPresence( currency, "currency" );
	validateParameterTypeCurrency( currency, "currency" );

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};

	args = [ currency, options ];
	style = options.style || "symbol";

	validateDefaultLocale( cldr );

	// Get properties given style ("symbol" default, "code" or "name").
	cldr.on( "get", validateRequiredCldr );
	properties = ({
		accounting: currencySymbolProperties,
		code: currencyCodeProperties,
		name: currencyNameProperties,
		symbol: currencySymbolProperties
	}[ style ] )( currency, cldr, options );
	cldr.off( "get", validateRequiredCldr );

	// options = options minus style, plus raw pattern.
	options = objectOmit( options, "style" );
	options.raw = properties.pattern;

	// Return formatter when style is "symbol" or "accounting".
	if ( style === "symbol" || style === "accounting" ) {
		numberFormatter = this.numberFormatter( options );

		returnFn = currencyFormatterFn( numberFormatter );

		runtimeBind( args, cldr, returnFn, [ numberFormatter ] );

	// Return formatter when style is "code" or "name".
	} else {
		numberFormatter = this.numberFormatter( options );
		pluralGenerator = this.pluralGenerator();

		returnFn = currencyFormatterFn( numberFormatter, pluralGenerator, properties );

		runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );
	}

	return returnFn;
};

/**
 * .currencyParser( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Return the currency parser according to the given options and the default/instance locale.
 */
Globalize.currencyParser =
Globalize.prototype.currencyParser = function( /* currency, options */ ) {

	// TODO implement parser.

};

/**
 * .formatCurrency( value, currency [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Format a currency according to the given options and the default/instance locale.
 */
Globalize.formatCurrency =
Globalize.prototype.formatCurrency = function( value, currency, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.currencyFormatter( currency, options )( value );
};

/**
 * .parseCurrency( value, currency [, options] )
 *
 * @value [String]
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]: See currencyFormatter.
 *
 * Return the parsed currency or NaN when value is invalid.
 */
Globalize.parseCurrency =
Globalize.prototype.parseCurrency = function( /* value, currency, options */ ) {
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/date.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,
	formatMessage = Globalize._formatMessage,
	isPlainObject = Globalize._isPlainObject,
	looseMatching = Globalize._looseMatching,
	numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,
	numberSymbol = Globalize._numberSymbol,
	regexpEscape = Globalize._regexpEscape,
	removeLiteralQuotes = Globalize._removeLiteralQuotes,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validate = Globalize._validate,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeString = Globalize._validateParameterTypeString;


var validateParameterTypeDate = function( value, name ) {
	validateParameterType( value, name, value === undefined || value instanceof Date, "Date" );
};




var createErrorInvalidParameterValue = function( name, value ) {
	return createError( "E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", {
		name: name,
		value: value
	});
};




/**
 * Create a map between the skeleton fields and their positions, e.g.,
 * {
 *   G: 0
 *   y: 1
 *   ...
 * }
 */
var validateSkeletonFieldsPosMap = "GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx".split( "" ).reduce(function( memo, item, i ) {
	memo[ item ] = i;
	return memo;
}, {});




/**
 * validateSkeleton( skeleton )
 *
 * skeleton: Assume `j` has already been converted into a localized hour field.
 */
var validateSkeleton = function validateSkeleton( skeleton ) {
	var last,

		// Using easier to read variable.
		fieldsPosMap = validateSkeletonFieldsPosMap;

	// "The fields are from the Date Field Symbol Table in Date Format Patterns"
	// Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
	// I.e., check for invalid characters.
	skeleton.replace( /[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function( field ) {
		throw createError(
			"E_INVALID_OPTIONS", "Invalid field `{invalidField}` of skeleton `{value}`",
			{
				invalidField: field,
				type: "skeleton",
				value: skeleton
			}
		);
	});

	// "The canonical order is from top to bottom in that table; that is, yM not My".
	// http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
	// I.e., check for invalid order.
	skeleton.split( "" ).every(function( field ) {
		if ( fieldsPosMap[ field ] < last ) {
			throw createError(
				"E_INVALID_OPTIONS", "Invalid order `{invalidField}` of skeleton `{value}`",
				{
					invalidField: field,
					type: "skeleton",
					value: skeleton
				}
			);
		}
		last = fieldsPosMap[ field ];
		return true;
	});
};




/**
 * Returns a new object created by using `object`'s values as keys, and the keys as values.
 */
var objectInvert = function( object, fn ) {
	fn = fn || function( object, key, value ) {
		object[ value ] = key;
		return object;
	};
	return Object.keys( object ).reduce(function( newObject, key ) {
		return fn( newObject, key, object[ key ] );
	}, {});
};




// Invert key and values, e.g., {"e": "eEc"} ==> {"e": "e", "E": "e", "c": "e"}.
var dateExpandPatternSimilarFieldsMap = objectInvert({
	"e": "eEc",
	"L": "ML"
}, function( object, key, value ) {
	value.split( "" ).forEach(function( field ) {
		object[ field ] = key;
	});
	return object;
});




var dateExpandPatternNormalizePatternType = function( character ) {
	return dateExpandPatternSimilarFieldsMap[ character ] || character;
};




var datePatternRe = ( /([a-z])\1*|'([^']|'')+'|''|./ig );




var stringRepeat = function( str, count ) {
	var i, result = "";
	for ( i = 0; i < count; i++ ) {
		result = result + str;
	}
	return result;
};




var dateExpandPatternAugmentFormat = function( requestedSkeleton, bestMatchFormat ) {
	var i, j, matchedType, matchedLength, requestedType, requestedLength,

		// Using an easier to read variable.
		normalizePatternType = dateExpandPatternNormalizePatternType;

	requestedSkeleton = requestedSkeleton.match( datePatternRe );
	bestMatchFormat = bestMatchFormat.match( datePatternRe );

	for ( i = 0; i < bestMatchFormat.length; i++ ) {
		matchedType = bestMatchFormat[i].charAt( 0 );
		matchedLength = bestMatchFormat[i].length;
		for ( j = 0; j < requestedSkeleton.length; j++ ) {
			requestedType = requestedSkeleton[j].charAt( 0 );
			requestedLength = requestedSkeleton[j].length;
			if ( normalizePatternType( matchedType ) === normalizePatternType( requestedType ) &&
				matchedLength < requestedLength
			) {
				bestMatchFormat[i] = stringRepeat( matchedType, requestedLength );
			}
		}
	}

	return bestMatchFormat.join( "" );
};




var dateExpandPatternCompareFormats = function( formatA, formatB ) {
	var a, b, distance, lenA, lenB, typeA, typeB, i, j,

		// Using easier to read variables.
		normalizePatternType = dateExpandPatternNormalizePatternType;

	if ( formatA === formatB ) {
		return 0;
	}

	formatA = formatA.match( datePatternRe );
	formatB = formatB.match( datePatternRe );

	if ( formatA.length !== formatB.length ) {
		return -1;
	}

	distance = 1;
	for ( i = 0; i < formatA.length; i++ ) {
		a = formatA[ i ].charAt( 0 );
		typeA = normalizePatternType( a );
		typeB = null;
		for ( j = 0; j < formatB.length; j++ ) {
			b = formatB[ j ].charAt( 0 );
			typeB = normalizePatternType( b );
			if ( typeA === typeB ) {
				break;
			} else {
				typeB = null;
			}
		}
		if ( typeB === null ) {
			return -1;
		}
		lenA = formatA[ i ].length;
		lenB = formatB[ j ].length;
		distance = distance + Math.abs( lenA - lenB );

		// Most symbols have a small distance from each other, e.g., M  L; E  c; a  b  B;
		// H  k  h  K; ...
		if ( a !== b ) {
			distance += 1;
		}

		// Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.
		if ( ( lenA < 3 && lenB >= 3 ) || ( lenA >= 3 && lenB < 3 ) ) {
			distance += 20;
		}
	}
	return distance;
};




var dateExpandPatternGetBestMatchPattern = function( cldr, askedSkeleton ) {
	var availableFormats, pattern, ratedFormats, skeleton,
		path = "dates/calendars/gregorian/dateTimeFormats/availableFormats",

		// Using easier to read variables.
		augmentFormat = dateExpandPatternAugmentFormat,
		compareFormats = dateExpandPatternCompareFormats;

	pattern = cldr.main([ path, askedSkeleton ]);

	if ( askedSkeleton && !pattern ) {
		availableFormats = cldr.main([ path ]);
		ratedFormats = [];

		for ( skeleton in availableFormats ) {
			ratedFormats.push({
				skeleton: skeleton,
				pattern: availableFormats[ skeleton ],
				rate: compareFormats( askedSkeleton, skeleton )
			});
		}

		ratedFormats = ratedFormats
			.filter( function( format ) {
				return format.rate > -1;
			} )
			.sort( function( formatA, formatB ) {
				return formatA.rate - formatB.rate;
			});

		if ( ratedFormats.length ) {
			pattern = augmentFormat( askedSkeleton, ratedFormats[0].pattern );
		}
	}

	return pattern;
};




/**
 * expandPattern( options, cldr )
 *
 * @options [Object] if String, it's considered a skeleton. Object accepts:
 * - skeleton: [String] lookup availableFormat;
 * - date: [String] ( "full" | "long" | "medium" | "short" );
 * - time: [String] ( "full" | "long" | "medium" | "short" );
 * - datetime: [String] ( "full" | "long" | "medium" | "short" );
 * - raw: [String] For more info see datetime/format.js.
 *
 * @cldr [Cldr instance].
 *
 * Return the corresponding pattern.
 * Eg for "en":
 * - "GyMMMd" returns "MMM d, y G";
 * - { skeleton: "GyMMMd" } returns "MMM d, y G";
 * - { date: "full" } returns "EEEE, MMMM d, y";
 * - { time: "full" } returns "h:mm:ss a zzzz";
 * - { datetime: "full" } returns "EEEE, MMMM d, y 'at' h:mm:ss a zzzz";
 * - { raw: "dd/mm" } returns "dd/mm";
 */
var dateExpandPattern = function( options, cldr ) {
	var dateSkeleton, result, skeleton, timeSkeleton, type,

		// Using easier to read variables.
		getBestMatchPattern = dateExpandPatternGetBestMatchPattern;

	function combineDateTime( type, datePattern, timePattern ) {
		return formatMessage(
			cldr.main([
				"dates/calendars/gregorian/dateTimeFormats",
				type
			]),
			[ timePattern, datePattern ]
		);
	}

	switch ( true ) {
		case "skeleton" in options:
			skeleton = options.skeleton;

			// Preferred hour (j).
			skeleton = skeleton.replace( /j/g, function() {
				return cldr.supplemental.timeData.preferred();
			});

			validateSkeleton( skeleton );

			// Try direct map (note that getBestMatchPattern handles it).
			// ... or, try to "best match" the whole skeleton.
			result = getBestMatchPattern(
				cldr,
				skeleton
			);
			if ( result ) {
				break;
			}

			// ... or, try to "best match" the date and time parts individually.
			timeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];
			dateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];
			dateSkeleton = getBestMatchPattern(
				cldr,
				dateSkeleton
			);
			timeSkeleton = getBestMatchPattern(
				cldr,
				timeSkeleton
			);

			if ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {
				type = "full";
			} else if ( /MMMM|LLLL/.test( dateSkeleton ) ) {
				type = "long";
			} else if ( /MMM|LLL/.test( dateSkeleton ) ) {
				type = "medium";
			} else {
				type = "short";
			}

			if ( dateSkeleton && timeSkeleton ) {
				result = combineDateTime( type, dateSkeleton, timeSkeleton );
			} else {
				result = dateSkeleton || timeSkeleton;
			}

			break;

		case "date" in options:
		case "time" in options:
			result = cldr.main([
				"dates/calendars/gregorian",
				"date" in options ? "dateFormats" : "timeFormats",
				( options.date || options.time )
			]);
			break;

		case "datetime" in options:
			result = combineDateTime( options.datetime,
				cldr.main([ "dates/calendars/gregorian/dateFormats", options.datetime ]),
				cldr.main([ "dates/calendars/gregorian/timeFormats", options.datetime ])
			);
			break;

		case "raw" in options:
			result = options.raw;
			break;

		default:
			throw createErrorInvalidParameterValue({
				name: "options",
				value: options
			});
	}

	return result;
};




var dateWeekDays = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];




/**
 * firstDayOfWeek
 */
var dateFirstDayOfWeek = function( cldr ) {
	return dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );
};




/**
 * getTimeZoneName( length, type )
 */
var dateGetTimeZoneName = function( length, type, timeZone, cldr ) {
	var metaZone, result;

	if ( !timeZone ) {
		return;
	}

	result = cldr.main([
		"dates/timeZoneNames/zone",
		timeZone,
		length < 4 ? "short" : "long",
		type
	]);

	if ( result ) {
		return result;
	}

	// The latest metazone data of the metazone array.
	// TODO expand to support the historic metazones based on the given date.
	metaZone = cldr.supplemental([
		"metaZones/metazoneInfo/timezone", timeZone, 0,
		"usesMetazone/_mzone"
	]);

	return cldr.main([
		"dates/timeZoneNames/metazone",
		metaZone,
		length < 4 ? "short" : "long",
		type
	]);
};




/**
 * timezoneHourFormatShortH( hourFormat )
 *
 * @hourFormat [String]
 *
 * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.
 * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
 *
 * Example:
 * - "+HH.mm;-HH.mm" => "+H;-H"
 * - "+HH:mm;-HH:mm" => "+H;-H"
 * - "+HH:mm;HH:mm" => "+H;H" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+H:-H"
 */
var dateTimezoneHourFormatH = function( hourFormat ) {
	return hourFormat
		.split( ";" )
		.map(function( format ) {
			return format.slice( 0, format.indexOf( "H" ) + 1 );
		})
		.join( ";" );
};




/**
 * timezoneHourFormatLongHm( hourFormat )
 *
 * @hourFormat [String]
 *
 * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.
 * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
 *
 * Example (hFormat === "H"): (used for short Hm)
 * - "+HH.mm;-HH.mm" => "+H.mm;-H.mm"
 * - "+HH:mm;-HH:mm" => "+H:mm;-H:mm"
 * - "+HH:mm;HH:mm" => "+H:mm;H:mm" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+Hmm:-Hmm"
 *
 * Example (hFormat === "HH": (used for long Hm)
 * - "+HH.mm;-HH.mm" => "+HH.mm;-HH.mm"
 * - "+HH:mm;-HH:mm" => "+HH:mm;-HH:mm"
 * - "+H:mm;-H:mm"   => "+HH:mm;-HH:mm"
 * - "+HH:mm;HH:mm" => "+HH:mm;HH:mm" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+HHmm:-HHmm"
 */
var dateTimezoneHourFormatHm = function( hourFormat, hFormat ) {
	return hourFormat
		.split( ";" )
		.map(function( format ) {
			var parts = format.split( /H+/ );
			parts.splice( 1, 0, hFormat );
			return parts.join( "" );
		})
		.join( ";" );
};




var runtimeCacheDataBind = function( key, data ) {
	var fn = function() {
		return data;
	};
	fn.dataCacheKey = key;
	return fn;
};




/**
 * properties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 *
 * @cldr [Cldr instance].
 *
 * Return the properties given the pattern and cldr.
 *
 * TODO Support other calendar types.
 */
var dateFormatProperties = function( pattern, cldr, timeZone ) {
	var properties = {
			numberFormatters: {},
			pattern: pattern,
			timeSeparator: numberSymbol( "timeSeparator", cldr )
		},
		widths = [ "abbreviated", "wide", "narrow" ];

	function setNumberFormatterPattern( pad ) {
		properties.numberFormatters[ pad ] = stringPad( "", pad );
	}

	if ( timeZone ) {
		properties.timeZoneData = runtimeCacheDataBind( "iana/" + timeZone, {
			offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
			untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
			isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
		});
	}

	pattern.replace( datePatternRe, function( current ) {
		var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;

		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			properties.preferredTime = chr = cldr.supplemental.timeData.preferred();
		}

		// ZZZZ: same as "OOOO".
		if ( chr === "Z" && length === 4 ) {
			chr = "O";
			length = 4;
		}

		// z...zzz: "{shortRegion}", eg. "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "z" ) {
			standardTzName = dateGetTimeZoneName( length, "standard", timeZone, cldr );
			daylightTzName = dateGetTimeZoneName( length, "daylight", timeZone, cldr );
			if ( standardTzName ) {
				properties.standardTzName = standardTzName;
			}
			if ( daylightTzName ) {
				properties.daylightTzName = daylightTzName;
			}

			// Fall through the "O" format in case one name is missing.
			if ( !standardTzName || !daylightTzName ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			genericTzName = dateGetTimeZoneName( length, "generic", timeZone, cldr );

			// Fall back to "V" format.
			if ( !genericTzName ) {
				chr = "V";
				length = 4;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				properties.eras = cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":

				// Plain year.
				formatNumber = true;
				break;

			case "Y":

				// Year in "Week of Year"
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					if ( !properties.quarters ) {
						properties.quarters = {};
					}
					if ( !properties.quarters[ chr ] ) {
						properties.quarters[ chr ] = {};
					}
					properties.quarters[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Month
			case "M":
			case "L":
				if ( length > 2 ) {
					if ( !properties.months ) {
						properties.months = {};
					}
					if ( !properties.months[ chr ] ) {
						properties.months[ chr ] = {};
					}
					properties.months[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Week - Week of Year (w) or Week of Month (W).
			case "w":
			case "W":
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			// Day
			case "d":
			case "D":
			case "F":
				formatNumber = true;
				break;

			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {
					properties.firstDay = dateFirstDayOfWeek( cldr );
					formatNumber = true;
					break;
				}

			/* falls through */
			case "E":
				if ( !properties.days ) {
					properties.days = {};
				}
				if ( !properties.days[ chr ] ) {
					properties.days[ chr ] = {};
				}
				if ( length === 6 ) {

					// If short day names are not explicitly specified, abbreviated day names are
					// used instead.
					// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					// http://unicode.org/cldr/trac/ticket/6790
					properties.days[ chr ][ length ] = cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"short"
						]) || cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"abbreviated"
						]);
				} else {
					properties.days[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/days",
						chr === "c" ? "stand-alone" : "format",
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				properties.dayPeriods = {
					am: cldr.main(
						"dates/calendars/gregorian/dayPeriods/format/wide/am"
					),
					pm: cldr.main(
						"dates/calendars/gregorian/dayPeriods/format/wide/pm"
					)
				};
				break;

			// Hour
			case "h": // 1-12
			case "H": // 0-23
			case "K": // 0-11
			case "k": // 1-24

			// Minute
			case "m":

			// Second
			case "s":
			case "S":
			case "A":
				formatNumber = true;
				break;

			// Zone
			case "v":
				if ( length !== 1 && length !== 4 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}
				properties.genericTzName = genericTzName;
				break;

			case "V":

				if ( length === 1 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}

				if ( timeZone ) {
					if ( length === 2 ) {
						properties.timeZoneName = timeZone;
						break;
					}

					var timeZoneName,
						exemplarCity = cldr.main([
							"dates/timeZoneNames/zone", timeZone, "exemplarCity"
						]);

					if ( length === 3 ) {
						if ( !exemplarCity ) {
							exemplarCity = cldr.main([
								"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity"
							]);
						}
						timeZoneName = exemplarCity;
					}

					if ( exemplarCity && length === 4 ) {
						timeZoneName = formatMessage(
							cldr.main(
								"dates/timeZoneNames/regionFormat"
							),
							[ exemplarCity ]
						);
					}

					if ( timeZoneName ) {
						properties.timeZoneName = timeZoneName;
						break;
					}
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				properties.gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				properties.gmtZeroFormat = cldr.main( "dates/timeZoneNames/gmtZeroFormat" );

				// Unofficial deduction of the hourFormat variations.
				// Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
				aux = cldr.main( "dates/timeZoneNames/hourFormat" );
				properties.hourFormat = length < 4 ?
					[ dateTimezoneHourFormatH( aux ), dateTimezoneHourFormatHm( aux, "H" ) ] :
					dateTimezoneHourFormatHm( aux, "HH" );

			/* falls through */
			case "Z":
			case "X":
			case "x":
				setNumberFormatterPattern( 1 );
				setNumberFormatterPattern( 2 );
				break;
		}

		if ( formatNumber ) {
			setNumberFormatterPattern( length );
		}
	});

	return properties;
};




var dateFormatterFn = function( dateToPartsFormatter ) {
	return function dateFormatter( value ) {
		return dateToPartsFormatter( value ).map( function( part ) {
			return part.value;
		}).join( "" );
	};
};




/**
 * parseProperties( cldr )
 *
 * @cldr [Cldr instance].
 *
 * @timeZone [String] FIXME.
 *
 * Return parser properties.
 */
var dateParseProperties = function( cldr, timeZone ) {
	var properties = {
		preferredTimeData: cldr.supplemental.timeData.preferred()
	};

	if ( timeZone ) {
		properties.timeZoneData = runtimeCacheDataBind( "iana/" + timeZone, {
			offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
			untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
			isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
		});
	}

	return properties;
};


var ZonedDateTime = (function() {
function definePrivateProperty(object, property, value) {
  Object.defineProperty(object, property, {
    value: value
  });
}

function getUntilsIndex(original, untils) {
  var index = 0;
  var originalTime = original.getTime();

  // TODO Should we do binary search for improved performance?
  while (index < untils.length - 1 && originalTime >= untils[index]) {
    index++;
  }
  return index;
}

function setWrap(fn) {
  var offset1 = this.getTimezoneOffset();
  var ret = fn();
  this.original.setTime(new Date(this.getTime()));
  var offset2 = this.getTimezoneOffset();
  if (offset2 - offset1) {
    this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);
  }
  return ret;
}

var ZonedDateTime = function(date, timeZoneData) {
  definePrivateProperty(this, "original", new Date(date.getTime()));
  definePrivateProperty(this, "local", new Date(date.getTime()));
  definePrivateProperty(this, "timeZoneData", timeZoneData);
  definePrivateProperty(this, "setWrap", setWrap);
  if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {
    throw new Error("Invalid IANA data");
  }
  this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);
};

ZonedDateTime.prototype.clone = function() {
  return new ZonedDateTime(this.original, this.timeZoneData);
};

// Date field getters.
["getFullYear", "getMonth", "getDate", "getDay", "getHours", "getMinutes",
"getSeconds", "getMilliseconds"].forEach(function(method) {
  // Corresponding UTC method, e.g., "getUTCFullYear" if method === "getFullYear".
  var utcMethod = "getUTC" + method.substr(3);
  ZonedDateTime.prototype[method] = function() {
    return this.local[utcMethod]();
  };
});

// Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.
ZonedDateTime.prototype.valueOf =
ZonedDateTime.prototype.getTime = function() {
  return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;
};

ZonedDateTime.prototype.getTimezoneOffset = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  return this.timeZoneData.offsets[index];
};

// Date field setters.
["setFullYear", "setMonth", "setDate", "setHours", "setMinutes", "setSeconds", "setMilliseconds"].forEach(function(method) {
  // Corresponding UTC method, e.g., "setUTCFullYear" if method === "setFullYear".
  var utcMethod = "setUTC" + method.substr(3);
  ZonedDateTime.prototype[method] = function(value) {
    var local = this.local;
    // Note setWrap is needed for seconds and milliseconds just because
    // abs(value) could be >= a minute.
    return this.setWrap(function() {
      return local[utcMethod](value);
    });
  };
});

ZonedDateTime.prototype.setTime = function(time) {
  return this.local.setTime(time);
};

ZonedDateTime.prototype.isDST = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  return Boolean(this.timeZoneData.isdsts[index]);
};

ZonedDateTime.prototype.inspect = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  var abbrs = this.timeZoneData.abbrs;
  return this.local.toISOString().replace(/Z$/, "") + " " +
    (abbrs && abbrs[index] + " " || (this.getTimezoneOffset() * -1) + " ") +
    (this.isDST() ? "(daylight savings)" : "");
};

ZonedDateTime.prototype.toDate = function() {
  return new Date(this.getTime());
};

// Type cast getters.
["toISOString", "toJSON", "toUTCString"].forEach(function(method) {
  ZonedDateTime.prototype[method] = function() {
    return this.toDate()[method]();
  };
});

return ZonedDateTime;
}());


/**
 * isLeapYear( year )
 *
 * @year [Number]
 *
 * Returns an indication whether the specified year is a leap year.
 */
var dateIsLeapYear = function( year ) {
	return new Date( year, 1, 29 ).getMonth() === 1;
};




/**
 * lastDayOfMonth( date )
 *
 * @date [Date]
 *
 * Return the last day of the given date's month
 */
var dateLastDayOfMonth = function( date ) {
	return new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();
};




/**
 * startOf changes the input to the beginning of the given unit.
 *
 * For example, starting at the start of a day, resets hours, minutes
 * seconds and milliseconds to 0. Starting at the month does the same, but
 * also sets the date to 1.
 *
 * Returns the modified date
 */
var dateStartOf = function( date, unit ) {
	date = date instanceof ZonedDateTime ? date.clone() : new Date( date.getTime() );
	switch ( unit ) {
		case "year":
			date.setMonth( 0 );
		/* falls through */
		case "month":
			date.setDate( 1 );
		/* falls through */
		case "day":
			date.setHours( 0 );
		/* falls through */
		case "hour":
			date.setMinutes( 0 );
		/* falls through */
		case "minute":
			date.setSeconds( 0 );
		/* falls through */
		case "second":
			date.setMilliseconds( 0 );
	}
	return date;
};




/**
 * Differently from native date.setDate(), this function returns a date whose
 * day remains inside the month boundaries. For example:
 *
 * setDate( FebDate, 31 ): a "Feb 28" date.
 * setDate( SepDate, 31 ): a "Sep 30" date.
 */
var dateSetDate = function( date, day ) {
	var lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();

	date.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );
};




/**
 * Differently from native date.setMonth(), this function adjusts date if
 * needed, so final month is always the one set.
 *
 * setMonth( Jan31Date, 1 ): a "Feb 28" date.
 * setDate( Jan31Date, 8 ): a "Sep 30" date.
 */
var dateSetMonth = function( date, month ) {
	var originalDate = date.getDate();

	date.setDate( 1 );
	date.setMonth( month );
	dateSetDate( date, originalDate );
};




var outOfRange = function( value, low, high ) {
	return value < low || value > high;
};




/**
 * parse( value, tokens, properties )
 *
 * @value [String] string date.
 *
 * @tokens [Object] tokens returned by date/tokenizer.
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 */
var dateParse = function( value, tokens, properties ) {
	var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,
		YEAR = 0,
		MONTH = 1,
		DAY = 2,
		HOUR = 3,
		MINUTE = 4,
		SECOND = 5,
		MILLISECONDS = 6,
		date = new Date(),
		truncateAt = [],
		units = [ "year", "month", "day", "hour", "minute", "second", "milliseconds" ];

	// Create globalize date with given timezone data.
	if ( properties.timeZoneData ) {
		date = new ZonedDateTime( date, properties.timeZoneData() );
	}

	if ( !tokens.length ) {
		return null;
	}

	valid = tokens.every(function( token ) {
		var century, chr, value, length;

		if ( token.type === "literal" ) {

			// continue
			return true;
		}

		chr = token.type.charAt( 0 );
		length = token.type.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTimeData;
		}

		switch ( chr ) {

			// Era
			case "G":
				truncateAt.push( YEAR );
				era = +token.value;
				break;

			// Year
			case "y":
				value = token.value;
				if ( length === 2 ) {
					if ( outOfRange( value, 0, 99 ) ) {
						return false;
					}

					// mimic dojo/date/locale: choose century to apply, according to a sliding
					// window of 80 years before and 20 years after present year.
					century = Math.floor( date.getFullYear() / 100 ) * 100;
					value += century;
					if ( value > date.getFullYear() + 20 ) {
						value -= 100;
					}
				}
				date.setFullYear( value );
				truncateAt.push( YEAR );
				break;

			case "Y": // Year in "Week of Year"
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter (skip)
			case "Q":
			case "q":
				break;

			// Month
			case "M":
			case "L":
				if ( length <= 2 ) {
					value = token.value;
				} else {
					value = +token.value;
				}
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}

				// Setting the month later so that we have the correct year and can determine
				// the correct last day of February in case of leap year.
				month = value;
				truncateAt.push( MONTH );
				break;

			// Week (skip)
			case "w": // Week of Year.
			case "W": // Week of Month.
				break;

			// Day
			case "d":
				day = token.value;
				truncateAt.push( DAY );
				break;

			case "D":
				daysOfYear = token.value;
				truncateAt.push( DAY );
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				// Skip
				break;

			// Week day
			case "e":
			case "c":
			case "E":

				// Skip.
				// value = arrayIndexOf( dateWeekDays, token.value );
				break;

			// Period (AM or PM)
			case "a":
				amPm = token.value;
				break;

			// Hour
			case "h": // 1-12
				value = token.value;
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value === 12 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "K": // 0-11
				value = token.value;
				if ( outOfRange( value, 0, 11 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			case "k": // 1-24
				value = token.value;
				if ( outOfRange( value, 1, 24 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value === 24 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "H": // 0-23
				value = token.value;
				if ( outOfRange( value, 0, 23 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			// Minute
			case "m":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setMinutes( value );
				truncateAt.push( MINUTE );
				break;

			// Second
			case "s":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setSeconds( value );
				truncateAt.push( SECOND );
				break;

			case "A":
				date.setHours( 0 );
				date.setMinutes( 0 );
				date.setSeconds( 0 );

			/* falls through */
			case "S":
				value = Math.round( token.value * Math.pow( 10, 3 - length ) );
				date.setMilliseconds( value );
				truncateAt.push( MILLISECONDS );
				break;

			// Zone
			case "z":
			case "Z":
			case "O":
			case "v":
			case "V":
			case "X":
			case "x":
				if ( typeof token.value === "number" ) {
					timezoneOffset = token.value;
				}
				break;
		}

		return true;
	});

	if ( !valid ) {
		return null;
	}

	// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null
	// if amPm && !hour12 || !amPm && hour12.
	if ( hour && !( !amPm ^ hour12 ) ) {
		return null;
	}

	if ( era === 0 ) {

		// 1 BC = year 0
		date.setFullYear( date.getFullYear() * -1 + 1 );
	}

	if ( month !== undefined ) {
		dateSetMonth( date, month - 1 );
	}

	if ( day !== undefined ) {
		if ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {
			return null;
		}
		date.setDate( day );
	} else if ( daysOfYear !== undefined ) {
		if ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {
			return null;
		}
		date.setMonth( 0 );
		date.setDate( daysOfYear );
	}

	if ( hour12 && amPm === "pm" ) {
		date.setHours( date.getHours() + 12 );
	}

	if ( timezoneOffset !== undefined ) {
		date.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );
	}

	// Truncate date at the most precise unit defined. Eg.
	// If value is "12/31", and pattern is "MM/dd":
	// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );
	truncateAt = Math.max.apply( null, truncateAt );
	date = dateStartOf( date, units[ truncateAt ] );

	// Get date back from globalize date.
	if ( date instanceof ZonedDateTime ) {
		date = date.toDate();
	}

	return date;
};




/**
 * tokenizer( value, numberParser, properties )
 *
 * @value [String] string date.
 *
 * @numberParser [Function]
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * Returns an Array of tokens, eg. value "5 o'clock PM", pattern "h 'o''clock' a":
 * [{
 *   type: "h",
 *   lexeme: "5"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "literal",
 *   lexeme: "o'clock"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "a",
 *   lexeme: "PM",
 *   value: "pm"
 * }]
 *
 * OBS: lexeme's are always String and may return invalid ranges depending of the token type.
 * Eg. "99" for month number.
 *
 * Return an empty Array when not successfully parsed.
 */
var dateTokenizer = function( value, numberParser, properties ) {
	var digitsRe, valid,
		tokens = [],
		widths = [ "abbreviated", "wide", "narrow" ];

	digitsRe = properties.digitsRe;
	value = looseMatching( value );

	valid = properties.pattern.match( datePatternRe ).every(function( current ) {
		var aux, chr, length, numeric, tokenRe,
			token = {};

		function hourFormatParse( tokenRe, numberParser ) {
			var aux, isPositive,
				match = value.match( tokenRe );
			numberParser = numberParser || function( value ) {
				return +value;
			};

			if ( !match ) {
				return false;
			}

			isPositive = match[ 1 ];

			// hourFormat containing H only, e.g., `+H;-H`
			if ( match.length < 6 ) {
				aux = isPositive ? 1 : 3;
				token.value = numberParser( match[ aux ] ) * 60;

			// hourFormat containing H and m, e.g., `+HHmm;-HHmm`
			} else if ( match.length < 10 ) {
				aux = isPositive ? [ 1, 3 ] : [ 5, 7 ];
				token.value = numberParser( match[ aux[ 0 ] ] ) * 60 +
					numberParser( match[ aux[ 1 ] ] );

			// hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`
			} else {
				aux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];
				token.value = numberParser( match[ aux[ 0 ] ] ) * 60 +
					numberParser( match[ aux[ 1 ] ] ) +
					numberParser( match[ aux[ 2 ] ] ) / 60;
			}

			if ( isPositive ) {
				token.value *= -1;
			}

			return true;
		}

		function oneDigitIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d/
				numeric = true;
				return tokenRe = digitsRe;
			}
		}

		function oneOrTwoDigitsIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
			}
		}

		function oneOrTwoDigitsIfLengthOneOrTwo() {
			if ( length === 1 || length === 2 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
			}
		}

		function twoDigitsIfLengthTwo() {
			if ( length === 2 ) {

				// Unicode equivalent to /\d\d/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){2}" );
			}
		}

		// Brute-force test every locale entry in an attempt to match the given value.
		// Return the first found one (and set token accordingly), or null.
		function lookup( path ) {
			var array = properties[ path.join( "/" ) ];

			if ( !array ) {
				return null;
			}

			// array of pairs [key, value] sorted by desc value length.
			array.some(function( item ) {
				var valueRe = item[ 1 ];
				if ( valueRe.test( value ) ) {
					token.value = item[ 0 ];
					tokenRe = item[ 1 ];
					return true;
				}
			});
			return null;
		}

		token.type = current;
		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		if ( chr === "z" ) {
			if ( properties.standardOrDaylightTzName ) {
				token.value = null;
				tokenRe = properties.standardOrDaylightTzName;
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			if ( properties.genericTzName ) {
				token.value = null;
				tokenRe = properties.genericTzName;

			// Fall back to "V" format.
			} else {
				chr = "V";
				length = 4;
			}
		}

		if ( chr === "V" && properties.timeZoneName ) {
			token.value = length === 2 ? properties.timeZoneName : null;
			tokenRe = properties.timeZoneNameRe;
		}

		switch ( chr ) {

			// Era
			case "G":
				lookup([
					"gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":
			case "Y":
				numeric = true;

				// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...
				if ( length === 1 ) {

					// Unicode equivalent to /\d+/.
					tokenRe = new RegExp( "^(" + digitsRe.source + ")+" );
				} else if ( length === 2 ) {

					// Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits
					// year, so parser accepts both zero-padded and non-zero-padded for `yy`.
					//
					// Unicode equivalent to /\d\d?/
					tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
				} else {

					// Unicode equivalent to /\d{length,}/
					tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + ",}" );
				}
				break;

			// Quarter
			case "Q":
			case "q":

				// number l=1:{1}, l=2:{2}.
				// lookup l=3...
				oneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||
					lookup([
						"gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				//
				// Lenient parsing: skeleton "yMd" (i.e., one M) may include MM for the pattern,
				// therefore parser accepts both zero-padded and non-zero-padded for M and MM.
				// Similar for L.
				oneOrTwoDigitsIfLengthOneOrTwo() || lookup([
					"gregorian/months",
					chr === "M" ? "format" : "stand-alone",
					widths[ length - 3 ]
				]);
				break;

			// Day
			case "D":

				// number {l,3}.
				if ( length <= 3 ) {

					// Equivalent to /\d{length,3}/
					numeric = true;
					tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + ",3}" );
				}
				break;

			case "W":
			case "F":

				// number l=1:{1}.
				oneDigitIfLengthOne();
				break;

			// Week day
			case "e":
			case "c":

				// number l=1:{1}, l=2:{2}.
				// lookup for length >=3.
				if ( length <= 2 ) {
					oneDigitIfLengthOne() || twoDigitsIfLengthTwo();
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				lookup([
					"gregorian/dayPeriods/format/wide"
				]);
				break;

			// Week
			case "w":

				// number l1:{1,2}, l2:{2}.
				oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();
				break;

			// Day, Hour, Minute, or Second
			case "d":
			case "h":
			case "H":
			case "K":
			case "k":
			case "j":
			case "m":
			case "s":

				// number l1:{1,2}, l2:{2}.
				//
				// Lenient parsing:
				// - skeleton "hms" (i.e., one m) always includes mm for the pattern, i.e., it's
				//   impossible to use a different skeleton to parse non-zero-padded minutes,
				//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar
				//   for seconds s.
				// - skeleton "hms" (i.e., one h) may include h or hh for the pattern, i.e., it's
				//   impossible to use a different skeleton to parser non-zero-padded hours for some
				//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.
				//   Similar for d (in skeleton yMd).
				oneOrTwoDigitsIfLengthOneOrTwo();
				break;

			case "S":

				// number {l}.

				// Unicode equivalent to /\d{length}/
				numeric = true;
				tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + "}" );
				break;

			case "A":

				// number {l+5}.

				// Unicode equivalent to /\d{length+5}/
				numeric = true;
				tokenRe = new RegExp( "^(" + digitsRe.source + "){" + ( length + 5 ) + "}" );
				break;

			// Zone
			case "v":
			case "V":
			case "z":
				if ( tokenRe && tokenRe.test( value ) ) {
					break;
				}
				if ( chr === "V" && length === 2 ) {
					break;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( value === properties[ "timeZoneNames/gmtZeroFormat" ] ) {
					token.value = 0;
					tokenRe = properties[ "timeZoneNames/gmtZeroFormatRe" ];
				} else {
					aux = properties[ "timeZoneNames/hourFormat" ].some(function( hourFormatRe ) {
						if ( hourFormatParse( hourFormatRe, numberParser ) ) {
							tokenRe = hourFormatRe;
							return true;
						}
					});
					if ( !aux ) {
						return null;
					}
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( value === "Z" ) {
					token.value = 0;
					tokenRe = /^Z/;
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				aux = properties.x.some(function( hourFormatRe ) {
					if ( hourFormatParse( hourFormatRe ) ) {
						tokenRe = hourFormatRe;
						return true;
					}
				});
				if ( !aux ) {
					return null;
				}
				break;

			case "'":
				token.type = "literal";
				tokenRe = new RegExp( "^" + regexpEscape( removeLiteralQuotes( current ) ) );
				break;

			default:
				token.type = "literal";
				tokenRe = new RegExp( "^" + regexpEscape( current ) );
		}

		if ( !tokenRe ) {
			return false;
		}

		// Get lexeme and consume it.
		value = value.replace( tokenRe, function( lexeme ) {
			token.lexeme = lexeme;
			if ( numeric ) {
				token.value = numberParser( lexeme );
			}
			return "";
		});

		if ( !token.lexeme ) {
			return false;
		}

		if ( numeric && isNaN( token.value ) ) {
			return false;
		}

		tokens.push( token );
		return true;
	});

	if ( value !== "" ) {
		valid = false;
	}

	return valid ? tokens : [];
};




var dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {
	return function dateParser( value ) {
		var tokens;

		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		tokens = dateTokenizer( value, numberParser, tokenizerProperties );
		return dateParse( value, tokens, parseProperties ) || null;
	};
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




/**
 * tokenizerProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 *
 * @cldr [Cldr instance].
 *
 * Return Object with data that will be used by tokenizer.
 */
var dateTokenizerProperties = function( pattern, cldr, timeZone ) {
	var digitsReSource,
		properties = {
			pattern: looseMatching( pattern )
		},
		timeSeparator = numberSymbol( "timeSeparator", cldr ),
		widths = [ "abbreviated", "wide", "narrow" ];

	digitsReSource = numberNumberingSystemDigitsMap( cldr );
	digitsReSource = digitsReSource ? "[" + digitsReSource + "]" : "\\d";
	properties.digitsRe = new RegExp( digitsReSource );

	// Transform:
	// - "+H;-H" -> /\+(\d\d?)|-(\d\d?)/
	// - "+HH;-HH" -> /\+(\d\d)|-(\d\d)/
	// - "+HHmm;-HHmm" -> /\+(\d\d)(\d\d)|-(\d\d)(\d\d)/
	// - "+HH:mm;-HH:mm" -> /\+(\d\d):(\d\d)|-(\d\d):(\d\d)/
	//
	// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:
	// - "+H;-H" -> /GMT\+(\d\d?)|GMT-(\d\d?)/
	function hourFormatRe( hourFormat, gmtFormat, digitsReSource, timeSeparator ) {
		var re;

		if ( !digitsReSource ) {
			digitsReSource = "\\d";
		}
		if ( !gmtFormat ) {
			gmtFormat = "{0}";
		}

		re = hourFormat
			.replace( "+", "\\+" )

			// Unicode equivalent to (\\d\\d)
			.replace( /HH|mm|ss/g, "((" + digitsReSource + "){2})" )

			// Unicode equivalent to (\\d\\d?)
			.replace( /H|m/g, "((" + digitsReSource + "){1,2})" );

		if ( timeSeparator ) {
			re = re.replace( /:/g, timeSeparator );
		}

		re = re.split( ";" ).map(function( part ) {
			return gmtFormat.replace( "{0}", part );
		}).join( "|" );

		return new RegExp( "^" + re );
	}

	function populateProperties( path, value ) {

		// Skip
		var skipRe = /(timeZoneNames\/zone|supplemental\/metaZones|timeZoneNames\/metazone|timeZoneNames\/regionFormat|timeZoneNames\/gmtFormat)/;
		if ( skipRe.test( path ) ) {
			return;
		}

		if ( !value ) {
			return;
		}

		// The `dates` and `calendars` trim's purpose is to reduce properties' key size only.
		path = path.replace( /^.*\/dates\//, "" ).replace( /calendars\//, "" );

		// Specific filter for "gregorian/dayPeriods/format/wide".
		if ( path === "gregorian/dayPeriods/format/wide" ) {
			value = objectFilter( value, /^am|^pm/ );
		}

		// Transform object into array of pairs [key, /value/], sort by desc value length.
		if ( isPlainObject( value ) ) {
			value = Object.keys( value ).map(function( key ) {
				return [ key, new RegExp( "^" + regexpEscape( looseMatching( value[ key ] ) ) ) ];
			}).sort(function( a, b ) {
				return b[ 1 ].source.length - a[ 1 ].source.length;
			});

		// If typeof value === "string".
		} else {
			value = looseMatching( value );
		}
		properties[ path ] = value;
	}

	function regexpSourceSomeTerm( terms ) {
		return "(" + terms.filter(function( item ) {
			return item;
		}).reduce(function( memo, item ) {
			return memo + "|" + item;
		}) + ")";
	}

	cldr.on( "get", populateProperties );

	pattern.match( datePatternRe ).forEach(function( current ) {
		var aux, chr, daylightTzName, gmtFormat, length, standardTzName;

		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "Z" ) {
			if ( length < 5 ) {
				chr = "O";
				length = 4;
			} else {
				chr = "X";
				length = 5;
			}
		}

		// z...zzz: "{shortRegion}", eg. "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "z" ) {
			standardTzName = dateGetTimeZoneName( length, "standard", timeZone, cldr );
			daylightTzName = dateGetTimeZoneName( length, "daylight", timeZone, cldr );
			if ( standardTzName ) {
				standardTzName = regexpEscape( looseMatching( standardTzName ) );
			}
			if ( daylightTzName ) {
				daylightTzName = regexpEscape( looseMatching( daylightTzName ) );
			}
			if ( standardTzName || daylightTzName ) {
				properties.standardOrDaylightTzName = new RegExp(
					"^" + regexpSourceSomeTerm([ standardTzName, daylightTzName ])
				);
			}

			// Fall through the "O" format in case one name is missing.
			if ( !standardTzName || !daylightTzName ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			if ( length !== 1 && length !== 4 ) {
				throw createErrorUnsupportedFeature({
					feature: "timezone pattern `" + pattern + "`"
				});
			}
			var genericTzName = dateGetTimeZoneName( length, "generic", timeZone, cldr );
			if ( genericTzName ) {
				properties.genericTzName = new RegExp(
					"^" + regexpEscape( looseMatching( genericTzName ) )
				);
				chr = "O";

			// Fall back to "V" format.
			} else {
				chr = "V";
				length = 4;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Day
			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":

				// lookup for length >=3.
				if ( length <= 2 ) {
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				cldr.main(
					"dates/calendars/gregorian/dayPeriods/format/wide"
				);
				break;

			// Zone
			case "V":

				if ( length === 1 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}

				if ( timeZone ) {
					if ( length === 2 ) {

						// Skip looseMatching processing since timeZone is a canonical posix value.
						properties.timeZoneName = timeZone;
						properties.timeZoneNameRe = new RegExp( "^" + regexpEscape( timeZone ) );
						break;
					}

					var timeZoneName,
						exemplarCity = cldr.main([
							"dates/timeZoneNames/zone", timeZone, "exemplarCity"
						]);

					if ( length === 3 ) {
						if ( !exemplarCity ) {
							exemplarCity = cldr.main([
								"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity"
							]);
						}
						timeZoneName = exemplarCity;
					}

					if ( exemplarCity && length === 4 ) {
						timeZoneName = formatMessage(
							cldr.main(
								"dates/timeZoneNames/regionFormat"
							),
							[ exemplarCity ]
						);
					}

					if ( timeZoneName ) {
						timeZoneName = looseMatching( timeZoneName );
						properties.timeZoneName = timeZoneName;
						properties.timeZoneNameRe = new RegExp(
							"^" + regexpEscape( timeZoneName )
						);
					}
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "z":
			case "O":
				gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				cldr.main( "dates/timeZoneNames/gmtZeroFormat" );
				cldr.main( "dates/timeZoneNames/hourFormat" );
				properties[ "timeZoneNames/gmtZeroFormatRe" ] =
					new RegExp( "^" + regexpEscape( properties[ "timeZoneNames/gmtZeroFormat" ] ) );
				aux = properties[ "timeZoneNames/hourFormat" ];
				properties[ "timeZoneNames/hourFormat" ] = (
					length < 4 ?
						[ dateTimezoneHourFormatHm( aux, "H" ), dateTimezoneHourFormatH( aux ) ] :
						[ dateTimezoneHourFormatHm( aux, "HH" ) ]
				).map(function( hourFormat ) {
					return hourFormatRe(
						hourFormat,
						gmtFormat,
						digitsReSource,
						timeSeparator
					);
				});

			/* falls through */
			case "X":
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				properties.x = [
					[ "+HHmm;-HHmm", "+HH;-HH" ],
					[ "+HHmm;-HHmm" ],
					[ "+HH:mm;-HH:mm" ],
					[ "+HHmmss;-HHmmss", "+HHmm;-HHmm" ],
					[ "+HH:mm:ss;-HH:mm:ss", "+HH:mm;-HH:mm" ]
				][ length - 1 ].map(function( hourFormat ) {
					return hourFormatRe( hourFormat );
				});
		}
	});

	cldr.off( "get", populateProperties );

	return properties;
};




/**
 * dayOfWeek( date, firstDay )
 *
 * @date
 *
 * @firstDay the result of `dateFirstDayOfWeek( cldr )`
 *
 * Return the day of the week normalized by the territory's firstDay [0-6].
 * Eg for "mon":
 * - return 0 if territory is GB, or BR, or DE, or FR (week starts on "mon");
 * - return 1 if territory is US (week starts on "sun");
 * - return 2 if territory is EG (week starts on "sat");
 */
var dateDayOfWeek = function( date, firstDay ) {
	return ( date.getDay() - firstDay + 7 ) % 7;
};




/**
 * distanceInDays( from, to )
 *
 * Return the distance in days between from and to Dates.
 */
var dateDistanceInDays = function( from, to ) {
	var inDays = 864e5;
	return ( to.getTime() - from.getTime() ) / inDays;
};




/**
 * dayOfYear
 *
 * Return the distance in days of the date to the begin of the year [0-d].
 */
var dateDayOfYear = function( date ) {
	return Math.floor( dateDistanceInDays( dateStartOf( date, "year" ), date ) );
};




// Invert key and values, e.g., {"year": "yY"} ==> {"y": "year", "Y": "year"}
var dateFieldsMap = objectInvert({
	"era": "G",
	"year": "yY",
	"quarter": "qQ",
	"month": "ML",
	"week": "wW",
	"day": "dDF",
	"weekday": "ecE",
	"dayperiod": "a",
	"hour": "hHkK",
	"minute": "m",
	"second": "sSA",
	"zone": "zvVOxX"
}, function( object, key, value ) {
	value.split( "" ).forEach(function( symbol ) {
		object[ symbol ] = key;
	});
	return object;
});




/**
 * millisecondsInDay
 */
var dateMillisecondsInDay = function( date ) {

	// TODO Handle daylight savings discontinuities
	return date - dateStartOf( date, "day" );
};




/**
 * hourFormat( date, format, timeSeparator, formatNumber )
 *
 * Return date's timezone offset according to the format passed.
 * Eg for format when timezone offset is 180:
 * - "+H;-H": -3
 * - "+HHmm;-HHmm": -0300
 * - "+HH:mm;-HH:mm": -03:00
 * - "+HH:mm:ss;-HH:mm:ss": -03:00:00
 */
var dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {
	var absOffset,
		offset = date.getTimezoneOffset();

	absOffset = Math.abs( offset );
	formatNumber = formatNumber || {
		1: function( value ) {
			return stringPad( value, 1 );
		},
		2: function( value ) {
			return stringPad( value, 2 );
		}
	};

	return format

		// Pick the correct sign side (+ or -).
		.split( ";" )[ offset > 0 ? 1 : 0 ]

		// Localize time separator
		.replace( ":", timeSeparator )

		// Update hours offset.
		.replace( /HH?/, function( match ) {
			return formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );
		})

		// Update minutes offset and return.
		.replace( /mm/, function() {
			return formatNumber[ 2 ]( Math.floor( absOffset % 60 ) );
		})

		// Update minutes offset and return.
		.replace( /ss/, function() {
			return formatNumber[ 2 ]( Math.floor( absOffset % 1 * 60 ) );
		});
};




/**
 * format( date, properties )
 *
 * @date [Date instance].
 *
 * @properties
 *
 * TODO Support other calendar types.
 *
 * Disclosure: this function borrows excerpts of dojo/date/locale.
 */
var dateFormat = function( date, numberFormatters, properties ) {
	var parts = [];

	var timeSeparator = properties.timeSeparator;

	// create globalize date with given timezone data
	if ( properties.timeZoneData ) {
		date = new ZonedDateTime( date, properties.timeZoneData() );
	}

	properties.pattern.replace( datePatternRe, function( current ) {
		var aux, dateField, type, value,
			chr = current.charAt( 0 ),
			length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTime;
		}

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		// z...zzz: "{shortRegion}", e.g., "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		if ( chr === "z" ) {
			if ( date.isDST ) {
				value = date.isDST() ? properties.daylightTzName : properties.standardTzName;
			}

			// Fall back to "O" format.
			if ( !value ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				value = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];
				break;

			// Year
			case "y":

				// Plain year.
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				value = date.getFullYear();
				if ( length === 2 ) {
					value = String( value );
					value = +value.substr( value.length - 2 );
				}
				break;

			case "Y":

				// Year in "Week of Year"
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays
				value = new Date( date.getTime() );
				value.setDate(
					value.getDate() + 7 -
					dateDayOfWeek( date, properties.firstDay ) -
					properties.firstDay -
					properties.minDays
				);
				value = value.getFullYear();
				if ( length === 2 ) {
					value = String( value );
					value = +value.substr( value.length - 2 );
				}
				break;

			// Quarter
			case "Q":
			case "q":
				value = Math.ceil( ( date.getMonth() + 1 ) / 3 );
				if ( length > 2 ) {
					value = properties.quarters[ chr ][ length ][ value ];
				}
				break;

			// Month
			case "M":
			case "L":
				value = date.getMonth() + 1;
				if ( length > 2 ) {
					value = properties.months[ chr ][ length ][ value ];
				}
				break;

			// Week
			case "w":

				// Week of Year.
				// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.
				// TODO should pad on ww? Not documented, but I guess so.
				value = dateDayOfWeek( dateStartOf( date, "year" ), properties.firstDay );
				value = Math.ceil( ( dateDayOfYear( date ) + value ) / 7 ) -
					( 7 - value >= properties.minDays ? 0 : 1 );
				break;

			case "W":

				// Week of Month.
				// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.
				value = dateDayOfWeek( dateStartOf( date, "month" ), properties.firstDay );
				value = Math.ceil( ( date.getDate() + value ) / 7 ) -
					( 7 - value >= properties.minDays ? 0 : 1 );
				break;

			// Day
			case "d":
				value = date.getDate();
				break;

			case "D":
				value = dateDayOfYear( date ) + 1;
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				value = Math.floor( date.getDate() / 7 ) + 1;
				break;

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {

					// Range is [1-7] (deduced by example provided on documentation)
					// TODO Should pad with zeros (not specified in the docs)?
					value = dateDayOfWeek( date, properties.firstDay ) + 1;
					break;
				}

			/* falls through */
			case "E":
				value = dateWeekDays[ date.getDay() ];
				value = properties.days[ chr ][ length ][ value ];
				break;

			// Period (AM or PM)
			case "a":
				value = properties.dayPeriods[ date.getHours() < 12 ? "am" : "pm" ];
				break;

			// Hour
			case "h": // 1-12
				value = ( date.getHours() % 12 ) || 12;
				break;

			case "H": // 0-23
				value = date.getHours();
				break;

			case "K": // 0-11
				value = date.getHours() % 12;
				break;

			case "k": // 1-24
				value = date.getHours() || 24;
				break;

			// Minute
			case "m":
				value = date.getMinutes();
				break;

			// Second
			case "s":
				value = date.getSeconds();
				break;

			case "S":
				value = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );
				break;

			case "A":
				value = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );
				break;

			// Zone
			case "z":
				break;

			case "v":

				// v...vvv: "{shortRegion}", eg. "PT".
				// vvvv: "{regionName} {Time}",
				//       e.g., "Pacific Time".
				if ( properties.genericTzName ) {
					value = properties.genericTzName;
					break;
				}

			/* falls through */
			case "V":

				//VVVV: "{explarCity} {Time}", e.g., "Los Angeles Time"
				if ( properties.timeZoneName ) {
					value = properties.timeZoneName;
					break;
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( date.getTimezoneOffset() === 0 ) {
					value = properties.gmtZeroFormat;
				} else {

					// If O..OOO and timezone offset has non-zero minutes, show minutes.
					if ( length < 4 ) {
						aux = date.getTimezoneOffset();
						aux = properties.hourFormat[ aux % 60 - aux % 1 === 0 ? 0 : 1 ];
					} else {
						aux = properties.hourFormat;
					}

					value = dateTimezoneHourFormat(
						date,
						aux,
						timeSeparator,
						numberFormatters
					);
					value = properties.gmtFormat.replace( /\{0\}/, value );
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( date.getTimezoneOffset() === 0 ) {
					value = "Z";
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				aux = date.getTimezoneOffset();

				// If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).
				if ( length === 1 && aux % 60 - aux % 1 !== 0 ) {
					length += 1;
				}

				// If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx
				// respectively (i.e., don't show optional seconds).
				if ( ( length === 4 || length === 5 ) && aux % 1 === 0 ) {
					length -= 2;
				}

				value = [
					"+HH;-HH",
					"+HHmm;-HHmm",
					"+HH:mm;-HH:mm",
					"+HHmmss;-HHmmss",
					"+HH:mm:ss;-HH:mm:ss"
				][ length - 1 ];

				value = dateTimezoneHourFormat( date, value, ":" );
				break;

			// timeSeparator
			case ":":
				value = timeSeparator;
				break;

			// ' literals.
			case "'":
				value = removeLiteralQuotes( current );
				break;

			// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and
			// arabic characters.
			default:
				value = current;

		}
		if ( typeof value === "number" ) {
			value = numberFormatters[ length ]( value );
		}

		dateField = dateFieldsMap[ chr ];
		type = dateField ? dateField : "literal";

		// Concat two consecutive literals
		if ( type === "literal" && parts.length && parts[ parts.length - 1 ].type === "literal" ) {
			parts[ parts.length - 1 ].value += value;
			return;
		}

		parts.push( { type: type, value: value } );

	});

	return parts;

};




var dateToPartsFormatterFn = function( numberFormatters, properties ) {
	return function dateToPartsFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeDate( value, "value" );

		return dateFormat( value, numberFormatters, properties );
	};

};




function optionsHasStyle( options ) {
	return options.skeleton !== undefined ||
		options.date !== undefined ||
		options.time !== undefined ||
		options.datetime !== undefined ||
		options.raw !== undefined;
}

function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [
			/dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/,
			/dates\/calendars\/gregorian\/days\/.*\/short/,
			/dates\/timeZoneNames\/zone/,
			/dates\/timeZoneNames\/metazone/,
			/globalize-iana/,
			/supplemental\/metaZones/,
			/supplemental\/timeData\/(?!001)/,
			/supplemental\/weekData\/(?!001)/
		]
	});
}

function validateOptionsPreset( options ) {
	validateOptionsPresetEach( "date", options );
	validateOptionsPresetEach( "time", options );
	validateOptionsPresetEach( "datetime", options );
}

function validateOptionsPresetEach( type, options ) {
	var value = options[ type ];
	validate(
		"E_INVALID_OPTIONS",
		"Invalid `{{type}: \"{value}\"}`.",
		value === undefined || [ "short", "medium", "long", "full" ].indexOf( value ) !== -1,
		{ type: type, value: value }
	);
}

function validateOptionsSkeleton( pattern, skeleton ) {
	validate(
		"E_INVALID_OPTIONS",
		"Invalid `{skeleton: \"{value}\"}` based on provided CLDR.",
		skeleton === undefined || ( typeof pattern === "string" && pattern ),
		{ type: "skeleton", value: skeleton }
	);
}

function validateRequiredIana( timeZone ) {
	return function( path, value ) {

		if ( !/globalize-iana/.test( path ) ) {
			return;
		}

		validate(
			"E_MISSING_IANA_TZ",
			"Missing required IANA timezone content for `{timeZone}`: `{path}`.",
			value,
			{
				path: path.replace( /globalize-iana\//, "" ),
				timeZone: timeZone
			}
		);
	};
}

/**
 * .loadTimeZone( json )
 *
 * @json [JSON]
 *
 * Load IANA timezone data.
 */
Globalize.loadTimeZone = function( json ) {
	var customData = {
			"globalize-iana": json
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	Cldr.load( customData );
};

/**
 * .dateFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date according to the given `format` and the default/instance
 * locale.
 */
Globalize.dateFormatter =
Globalize.prototype.dateFormatter = function( options ) {
	var args, dateToPartsFormatter, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}
	args = [ options ];

	dateToPartsFormatter = this.dateToPartsFormatter( options );
	returnFn = dateFormatterFn( dateToPartsFormatter );
	runtimeBind( args, this.cldr, returnFn, [ dateToPartsFormatter ] );

	return returnFn;
};

/**
 * .dateToPartsFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date to parts according to the given `format`
 * and the default/instance
 * locale.
 */
Globalize.dateToPartsFormatter =
Globalize.prototype.dateToPartsFormatter = function( options ) {
	var args, cldr, numberFormatters, pad, pattern, properties, returnFn,
		timeZone;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}

	validateOptionsPreset( options );
	validateDefaultLocale( cldr );

	timeZone = options.timeZone;
	validateParameterTypeString( timeZone, "options.timeZone" );

	args = [ options ];

	cldr.on( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.on( "get", validateRequiredIana( timeZone ) );
	}
	pattern = dateExpandPattern( options, cldr );
	validateOptionsSkeleton( pattern, options.skeleton );
	properties = dateFormatProperties( pattern, cldr, timeZone );
	cldr.off( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.off( "get", validateRequiredIana( timeZone ) );
	}

	// Create needed number formatters.
	numberFormatters = properties.numberFormatters;
	delete properties.numberFormatters;
	for ( pad in numberFormatters ) {
		numberFormatters[ pad ] = this.numberFormatter({
			raw: numberFormatters[ pad ]
		});
	}

	returnFn = dateToPartsFormatterFn( numberFormatters, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );

	return returnFn;
};

/**
 * .dateParser( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a function that parses a string date according to the given `formats` and the
 * default/instance locale.
 */
Globalize.dateParser =
Globalize.prototype.dateParser = function( options ) {
	var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone,
		tokenizerProperties;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}

	validateOptionsPreset( options );
	validateDefaultLocale( cldr );

	timeZone = options.timeZone;
	validateParameterTypeString( timeZone, "options.timeZone" );

	args = [ options ];

	cldr.on( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.on( "get", validateRequiredIana( timeZone ) );
	}
	pattern = dateExpandPattern( options, cldr );
	validateOptionsSkeleton( pattern, options.skeleton );
	tokenizerProperties = dateTokenizerProperties( pattern, cldr, timeZone );
	parseProperties = dateParseProperties( cldr, timeZone );
	cldr.off( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.off( "get", validateRequiredIana( timeZone ) );
	}

	numberParser = this.numberParser({ raw: "0" });

	returnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );

	runtimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );

	return returnFn;
};

/**
 * .formatDate( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number according to the given options string and the default/instance locale.
 */
Globalize.formatDate =
Globalize.prototype.formatDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateFormatter( options )( value );
};

/**
 * .formatDateToParts( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number to parts according to the given options and the default/instance locale.
 */
Globalize.formatDateToParts =
Globalize.prototype.formatDateToParts = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateToPartsFormatter( options )( value );
};

/**
 * .parseDate( value, options )
 *
 * @value [String]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a Date instance or null.
 */
Globalize.parseDate =
Globalize.prototype.parseDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.dateParser( options )( value );
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/message.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	createError = Globalize._createError,
	isPlainObject = Globalize._isPlainObject,
	runtimeBind = Globalize._runtimeBind,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validate = Globalize._validate,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MessageFormat;
/* jshint ignore:start */
MessageFormat = (function() {
MessageFormat._parse = (function() {

  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function(st) {
              return { type: 'messageFormatPattern', statements: st };
            },
        peg$c2 = peg$FAILED,
        peg$c3 = "{",
        peg$c4 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c5 = null,
        peg$c6 = ",",
        peg$c7 = { type: "literal", value: ",", description: "\",\"" },
        peg$c8 = "}",
        peg$c9 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c10 = function(argIdx, efmt) {
              var res = {
                type: "messageFormatElement",
                argumentIndex: argIdx
              };
              if (efmt && efmt.length) {
                res.elementFormat = efmt[1];
              } else {
                res.output = true;
              }
              return res;
            },
        peg$c11 = "plural",
        peg$c12 = { type: "literal", value: "plural", description: "\"plural\"" },
        peg$c13 = function(t, s) {
              return { type: "elementFormat", key: t, val: s };
            },
        peg$c14 = "selectordinal",
        peg$c15 = { type: "literal", value: "selectordinal", description: "\"selectordinal\"" },
        peg$c16 = "select",
        peg$c17 = { type: "literal", value: "select", description: "\"select\"" },
        peg$c18 = function(t, p) {
              return { type: "elementFormat", key: t, val: p };
            },
        peg$c19 = function(op, pf) {
              return { type: "pluralFormatPattern", pluralForms: pf, offset: op || 0 };
            },
        peg$c20 = "offset",
        peg$c21 = { type: "literal", value: "offset", description: "\"offset\"" },
        peg$c22 = ":",
        peg$c23 = { type: "literal", value: ":", description: "\":\"" },
        peg$c24 = function(d) { return d; },
        peg$c25 = function(k, mfp) {
              return { key: k, val: mfp };
            },
        peg$c26 = function(i) { return i; },
        peg$c27 = "=",
        peg$c28 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c29 = function(pf) { return { type: "selectFormatPattern", pluralForms: pf }; },
        peg$c30 = function(p) { return p; },
        peg$c31 = "#",
        peg$c32 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c33 = function() { return {type: 'octothorpe'}; },
        peg$c34 = function(s) { return { type: "string", val: s.join('') }; },
        peg$c35 = { type: "other", description: "identifier" },
        peg$c36 = /^[0-9a-zA-Z$_]/,
        peg$c37 = { type: "class", value: "[0-9a-zA-Z$_]", description: "[0-9a-zA-Z$_]" },
        peg$c38 = /^[^ \t\n\r,.+={}]/,
        peg$c39 = { type: "class", value: "[^ \\t\\n\\r,.+={}]", description: "[^ \\t\\n\\r,.+={}]" },
        peg$c40 = function(s) { return s; },
        peg$c41 = function(chars) { return chars.join(''); },
        peg$c42 = /^[^{}#\\\0-\x1F \t\n\r]/,
        peg$c43 = { type: "class", value: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]", description: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]" },
        peg$c44 = function(x) { return x; },
        peg$c45 = "\\\\",
        peg$c46 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c47 = function() { return "\\"; },
        peg$c48 = "\\#",
        peg$c49 = { type: "literal", value: "\\#", description: "\"\\\\#\"" },
        peg$c50 = function() { return "#"; },
        peg$c51 = "\\{",
        peg$c52 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
        peg$c53 = function() { return "\u007B"; },
        peg$c54 = "\\}",
        peg$c55 = { type: "literal", value: "\\}", description: "\"\\\\}\"" },
        peg$c56 = function() { return "\u007D"; },
        peg$c57 = "\\u",
        peg$c58 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
        peg$c59 = function(h1, h2, h3, h4) {
              return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
            },
        peg$c60 = /^[0-9]/,
        peg$c61 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c62 = function(ds) {
            //the number might start with 0 but must not be interpreted as an octal number
            //Hence, the base is passed to parseInt explicitely
            return parseInt((ds.join('')), 10);
          },
        peg$c63 = /^[0-9a-fA-F]/,
        peg$c64 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c65 = { type: "other", description: "whitespace" },
        peg$c66 = function(w) { return w.join(''); },
        peg$c67 = /^[ \t\n\r]/,
        peg$c68 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsemessageFormatPattern();

      return s0;
    }

    function peg$parsemessageFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsemessageFormatElement();
      if (s2 === peg$FAILED) {
        s2 = peg$parsestring();
        if (s2 === peg$FAILED) {
          s2 = peg$parseoctothorpe();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsemessageFormatElement();
        if (s2 === peg$FAILED) {
          s2 = peg$parsestring();
          if (s2 === peg$FAILED) {
            s2 = peg$parseoctothorpe();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsemessageFormatElement() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c3;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseid();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c6;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseelementFormat();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c5;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c8;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c9); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c10(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseelementFormat() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c11) {
          s2 = peg$c11;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c6;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsepluralFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c13(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 13) === peg$c14) {
            s2 = peg$c14;
            peg$currPos += 13;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c6;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsepluralFormatPattern();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c13(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c16) {
              s2 = peg$c16;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c6;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c7); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseselectFormatPattern();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c13(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseid();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseargStylePattern();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseargStylePattern();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c18(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
      }

      return s0;
    }

    function peg$parsepluralFormatPattern() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseoffsetPattern();
      if (s1 === peg$FAILED) {
        s1 = peg$c5;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsepluralForm();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsepluralForm();
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c19(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoffsetPattern() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c20) {
          s2 = peg$c20;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c22;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsedigits();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c24(s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepluralKey();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralKey() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsedigits();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseselectFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseselectForm();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseselectForm();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c29(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseselectForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseid();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseargStylePattern() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseid();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c30(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoctothorpe() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c33();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechars();
      if (s2 === peg$FAILED) {
        s2 = peg$parsewhitespace();
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechars();
          if (s2 === peg$FAILED) {
            s2 = peg$parsewhitespace();
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseid() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c38.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c39); }
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c2;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c40(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }

      return s0;
    }

    function peg$parsechars() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechar();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c41(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (peg$c42.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c44(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c45) {
          s1 = peg$c45;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c48) {
            s1 = peg$c48;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c57) {
                  s1 = peg$c57;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c58); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsehexDigit();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsehexDigit();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parsehexDigit();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsehexDigit();
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c59(s2, s3, s4, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsedigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c62(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      if (peg$c63.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c66(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0;

      if (peg$c67.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
}()).parse;


/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript
 *  @author Alex Sexton - @SlexAxton
 *  @version 0.3.0-1
 *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors
 *  @license To use or fork, MIT. To contribute back, Dojo CLA  */


/** Utility function for quoting an Object's key value iff required
 *  @private  */
function propname(key, obj) {
  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {
    return obj ? obj + '.' + key : key;
  } else {
    var jkey = JSON.stringify(key);
    return obj ? obj + '[' + jkey + ']' : jkey;
  }
};


/** Create a new message formatter
 *
 *  @class
 *  @global
 *  @param {string|string[]} [locale="en"] - The locale to use, with fallbacks
 *  @param {function} [pluralFunc] - Optional custom pluralization function
 *  @param {function[]} [formatters] - Optional custom formatting functions  */
function MessageFormat(locale, pluralFunc, formatters) {
  this.lc = [locale];  
  this.runtime.pluralFuncs = {};
  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;
  this.runtime.fmt = {};
  if (formatters) for (var f in formatters) {
    this.runtime.fmt[f] = formatters[f];
  }
}




/** Parse an input string to its AST
 *
 *  Precompiled from `lib/messageformat-parser.pegjs` by
 *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object
 *  to enable testing.
 *
 *  @private  */



/** Pluralization functions from
 *  {@link http://github.com/eemeli/make-plural.js make-plural}
 *
 *  @memberof MessageFormat
 *  @type Object.<string,function>  */
MessageFormat.plurals = {};


/** Default number formatting functions in the style of ICU's
 *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}
 *  implemented using the
 *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}
 *  object defined by ECMA-402.
 *
 *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so
 *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.
 *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these
 *  functions to be available for inclusion in the output.
 *
 *  @see MessageFormat#setIntlSupport
 *
 *  @namespace
 *  @memberof MessageFormat
 *  @property {function} number - Represent a number as an integer, percent or currency value
 *  @property {function} date - Represent a date as a full/long/default/short string
 *  @property {function} time - Represent a time as a full/long/default/short string
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is 5.50."
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is 5.50."  */
MessageFormat.formatters = {};

/** Enable or disable support for the default formatters, which require the
 *  `Intl` object. Note that this can't be autodetected, as the environment
 *  in which the formatted text is compiled into Javascript functions is not
 *  necessarily the same environment in which they will get executed.
 *
 *  @see MessageFormat.formatters
 *
 *  @memberof MessageFormat
 *  @param {boolean} [enable=true]
 *  @returns {Object} The MessageFormat instance, to allow for chaining
 *  @example
 *  > var Intl = require('intl');
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > mf.compile("The total is {V,number,currency}.")({V:5.5});
 *  "The total is 5.50."  */



/** A set of utility functions that are called by the compiled Javascript
 *  functions, these are included locally in the output of {@link
 *  MessageFormat#compile compile()}.
 *
 *  @namespace
 *  @memberof MessageFormat  */
MessageFormat.prototype.runtime = {

  /** Utility function for `#` in plural rules
   *
   *  @param {number} value - The value to operate on
   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */
  number: function(value, offset) {
    if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
    return value - (offset || 0);
  },

  /** Utility function for `{N, plural|selectordinal, ...}`
   *
   *  @param {number} value - The key to use to find a pluralization rule
   *  @param {number} offset - An offset to apply to `value`
   *  @param {function} lcfunc - A locale function from `pluralFuncs`
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules
   *  @returns {string} The result of the pluralization  */
  plural: function(value, offset, lcfunc, data, isOrdinal) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    if (offset) value -= offset;
    var key = lcfunc(value, isOrdinal);
    if (key in data) return data[key]();
    return data.other();
  },

  /** Utility function for `{N, select, ...}`
   *
   *  @param {number} value - The key to use to find a selection
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @returns {string} The result of the select statement  */
  select: function(value, data) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    return data.other()
  },

  /** Pluralization functions included in compiled output
   *  @instance
   *  @type Object.<string,function>  */
  pluralFuncs: {},

  /** Custom formatting functions called by `{var, fn[, args]*}` syntax
   *
   *  For examples, see {@link MessageFormat.formatters}
   *
   *  @instance
   *  @see MessageFormat.formatters
   *  @type Object.<string,function>  */
  fmt: {},

  /** Custom stringifier to clean up browser inconsistencies
   *  @instance  */
  toString: function () {
    var _stringify = function(o, level) {
      if (typeof o != 'object') {
        var funcStr = o.toString().replace(/^(function )\w*/, '$1');
        var indent = /([ \t]*)\S.*$/.exec(funcStr);
        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;
      }
      var s = [];
      for (var i in o) if (i != 'toString') {
        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\n');
        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));
      }
      if (level == 0) return s.join('');
      if (s.length == 0) return '{}';
      var indent = '  '; while (--level) indent += '  ';
      return '{\n' + s.join(',\n').replace(/^/gm, indent) + '\n}';
    };
    return _stringify(this, 0);
  }
};


/** Recursively map an AST to its resulting string
 *
 *  @memberof MessageFormat
 *
 *  @param ast - the Ast node for which the JS code should be generated
 *
 *  @private  */
MessageFormat.prototype._precompile = function(ast, data) {
  data = data || { keys: {}, offset: {} };
  var r = [], i, tmp, args = [];

  switch ( ast.type ) {
    case 'messageFormatPattern':
      for ( i = 0; i < ast.statements.length; ++i ) {
        r.push(this._precompile( ast.statements[i], data ));
      }
      tmp = r.join(' + ') || '""';
      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';

    case 'messageFormatElement':
      data.pf_count = data.pf_count || 0;
      if ( ast.output ) {
        return propname(ast.argumentIndex, 'd');
      }
      else {
        data.keys[data.pf_count] = ast.argumentIndex;
        return this._precompile( ast.elementFormat, data );
      }
      return '';

    case 'elementFormat':
      args = [ propname(data.keys[data.pf_count], 'd') ];
      switch (ast.key) {
        case 'select':
          args.push(this._precompile(ast.val, data));
          return 'select(' + args.join(', ') + ')';
        case 'selectordinal':
          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);
          return 'plural(' + args.join(', ') + ')';
        case 'plural':
          data.offset[data.pf_count || 0] = ast.val.offset || 0;
          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);
          return 'plural(' + args.join(', ') + ')';
        default:
          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {
            tmp = MessageFormat.formatters[ast.key];
            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;
          }
          args.push(JSON.stringify(this.lc));
          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));
          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';
      }

    case 'pluralFormatPattern':
    case 'selectFormatPattern':
      data.pf_count = data.pf_count || 0;
      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;
      var needOther = true;
      for (i = 0; i < ast.pluralForms.length; ++i) {
        var key = ast.pluralForms[i].key;
        if (key === 'other') needOther = false;
        var data_copy = JSON.parse(JSON.stringify(data));
        data_copy.pf_count++;
        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');
      }
      if (needOther) throw new Error("No 'other' form found in " + ast.type + " " + data.pf_count);
      return '{ ' + r.join(', ') + ' }';

    case 'string':
      return JSON.stringify(ast.val || "");

    case 'octothorpe':
      if (!data.pf_count) return '"#"';
      args = [ propname(data.keys[data.pf_count-1], 'd') ];
      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);
      return 'number(' + args.join(', ') + ')';

    default:
      throw new Error( 'Bad AST type: ' + ast.type );
  }
};

/** Compile messages into an executable function with clean string
 *  representation.
 *
 *  If `messages` is a single string including ICU MessageFormat declarations,
 *  `opt` is ignored and the returned function takes a single Object parameter
 *  `d` representing each of the input's defined variables. The returned
 *  function will be defined in a local scope that includes all the required
 *  runtime variables.
 *
 *  If `messages` is a map of keys to strings, or a map of namespace keys to
 *  such key/string maps, the returned function will fill the specified global
 *  with javascript functions matching the structure of the input. In such use,
 *  the output of `compile()` is expected to be serialized using `.toString()`,
 *  and will include definitions of the runtime functions. If `opt.global` is
 *  null, calling the output function will return the object itself.
 *
 *  Together, the input parameters should match the following patterns:
 *  ```js
 *  messages = "string" || { key0: "string0", key1: "string1", ... } || {
 *    ns0: { key0: "string0", key1: "string1", ...  },
 *    ns1: { key0: "string0", key1: "string1", ...  },
 *    ...
 *  }
 *
 *  opt = null || {
 *    locale: null || {
 *      ns0: "lc0" || [ "lc0", ... ],
 *      ns1: "lc1" || [ "lc1", ... ],
 *      ...
 *    },
 *    global: null || "module.exports" || "exports" || "i18n" || ...
 *  }
 *  ```
 *
 *  @memberof MessageFormat
 *  @param {string|Object}
 *      messages - The input message(s) to be compiled, in ICU MessageFormat
 *  @param {Object} [opt={}] - Options controlling output for non-simple intput
 *  @param {Object} [opt.locale] - The locales to use for the messages, with a
 *      structure matching that of `messages`
 *  @param {string} [opt.global=""] - The global variable that the output
 *      function should use, or a null string for none. "exports" and
 *      "module.exports" are recognised as special cases.
 *  @returns {function} The first match found for the given locale(s)
 *
 *  @example
 * > var MessageFormat = require('messageformat'),
 * ...   mf = new MessageFormat('en'),
 * ...   mfunc0 = mf.compile('A {TYPE} example.');
 * > mfunc0({TYPE:'simple'})
 * 'A simple example.'
 * > mfunc0.toString()
 * 'function (d) { return "A " + d.TYPE + " example."; }'
 *
 *  @example
 * > var msgSet = { a: 'A {TYPE} example.',
 * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },
 * ...   mfuncSet = mf.compile(msgSet);
 * > mfuncSet().a({TYPE:'more complex'})
 * 'A more complex example.'
 * > mfuncSet().b({COUNT:2})
 * 'This has 2 members.'
 *
 * > console.log(mfuncSet.toString())
 * function anonymous() {
 * var number = function (value, offset) {
 *   if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
 *   return value - (offset || 0);
 * };
 * var plural = function (value, offset, lcfunc, data, isOrdinal) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   if (offset) value -= offset;
 *   var key = lcfunc(value, isOrdinal);
 *   if (key in data) return data[key]();
 *   return data.other();
 * };
 * var select = function (value, data) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   return data.other()
 * };
 * var pluralFuncs = {
 *   en: function (n, ord) {
 *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
 *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
 *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'
 *         : (n10 == 2 && n100 != 12) ? 'two'
 *         : (n10 == 3 && n100 != 13) ? 'few'
 *         : 'other';
 *     return (n == 1 && v0) ? 'one' : 'other';
 *   }
 * };
 * var fmt = {};
 *
 * return {
 *   a: function(d) { return "A " + d.TYPE + " example."; },
 *   b: function(d) { return "This has " + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return "one member";}, other: function() { return number(d.COUNT)+" members";} }) + "."; }
 * }
 * }
 *
 *  @example
 * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;
 * > var multiSet = { en: { a: 'A {TYPE} example.',
 * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },
 * ...                fi: { a: '{TYPE} esimerkki.',
 * ...                      b: 'Tm on {COUNT, selectordinal, other{#.}} esimerkki.' } },
 * ...   multiSetLocales = { en: 'en', fi: 'fi' },
 * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });
 * > mfuncSet(this);
 * > i18n.en.b({COUNT:3})
 * 'This is the 3rd example.'
 * > i18n.fi.b({COUNT:3})
 * 'Tm on 3. esimerkki.'  */
MessageFormat.prototype.compile = function ( messages, opt ) {
  var r = {}, lc0 = this.lc,
      compileMsg = function(self, msg) {
        try {
          var ast = MessageFormat._parse(msg);
          return self._precompile(ast);
        } catch (e) {
          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());
        }
      },
      stringify = function(r, level) {
        if (!level) level = 0;
        if (typeof r != 'object') return r;
        var o = [], indent = '';
        for (var i = 0; i < level; ++i) indent += '  ';
        for (var k in r) o.push('\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));
        return '{' + o.join(',') + '\n' + indent + '}';
      };

  if (typeof messages == 'string') {
    var f = new Function(
        'number, plural, select, pluralFuncs, fmt',
        'return ' + compileMsg(this, messages));
    return f(this.runtime.number, this.runtime.plural, this.runtime.select,
        this.runtime.pluralFuncs, this.runtime.fmt);
  }

  opt = opt || {};

  for (var ns in messages) {
    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;
    if (typeof messages[ns] == 'string') {
      try { r[ns] = compileMsg(this, messages[ns]); }
      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }
    } else {
      r[ns] = {};
      for (var key in messages[ns]) {
        try { r[ns][key] = compileMsg(this, messages[ns][key]); }
        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }
      }
    }
  }

  this.lc = lc0;
  var s = this.runtime.toString() + '\n';
  switch (opt.global || '') {
    case 'exports':
      var o = [];
      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));
      return new Function(s + o.join(';\n'));
    case 'module.exports':
      return new Function(s + 'module.exports = ' + stringify(r));
    case '':
      return new Function(s + 'return ' + stringify(r));
    default:
      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));
  }
};


return MessageFormat;
}());
/* jshint ignore:end */


var createErrorPluralModulePresence = function() {
	return createError( "E_MISSING_PLURAL_MODULE", "Plural module not loaded." );
};




var validateMessageBundle = function( cldr ) {
	validate(
		"E_MISSING_MESSAGE_BUNDLE",
		"Missing message bundle for locale `{locale}`.",
		cldr.attributes.bundle && cldr.get( "globalize-messages/{bundle}" ) !== undefined,
		{
			locale: cldr.locale
		}
	);
};




var validateMessagePresence = function( path, value ) {
	path = path.join( "/" );
	validate( "E_MISSING_MESSAGE", "Missing required message content `{path}`.",
		value !== undefined, { path: path } );
};




var validateMessageType = function( path, value ) {
	path = path.join( "/" );
	validate(
		"E_INVALID_MESSAGE",
		"Invalid message content `{path}`. {expected} expected.",
		typeof value === "string",
		{
			expected: "a string",
			path: path
		}
	);
};




var validateParameterTypeMessageVariables = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ) || Array.isArray( value ),
		"Array or Plain Object"
	);
};




var messageFormatterFn = function( formatter ) {
	return function messageFormatter( variables ) {
		if ( typeof variables === "number" || typeof variables === "string" ) {
			variables = [].slice.call( arguments, 0 );
		}
		validateParameterTypeMessageVariables( variables, "variables" );
		return formatter( variables );
	};
};




var messageFormatterRuntimeBind = function( cldr, messageformatter ) {
	var locale = cldr.locale,
		origToString = messageformatter.toString;

	messageformatter.toString = function() {
		var argNames, argValues, output,
			args = {};

		// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:
		output = origToString.call( messageformatter );

		if ( /number\(/.test( output ) ) {
			args.number = "messageFormat.number";
		}

		if ( /plural\(/.test( output ) ) {
			args.plural = "messageFormat.plural";
		}

		if ( /select\(/.test( output ) ) {
			args.select = "messageFormat.select";
		}

		output.replace( /pluralFuncs(\[([^\]]+)\]|\.([a-zA-Z]+))/, function( match ) {
			args.pluralFuncs = "{" +
				"\"" + locale + "\": Globalize(\"" + locale + "\").pluralGenerator()" +
				"}";
			return match;
		});

		argNames = Object.keys( args ).join( ", " );
		argValues = Object.keys( args ).map(function( key ) {
			return args[ key ];
		}).join( ", " );

		return "(function( " + argNames + " ) {\n" +
			"  return " + output + "\n" +
			"})(" + argValues + ")";
	};

	return messageformatter;
};




var slice = [].slice;

/**
 * .loadMessages( json )
 *
 * @json [JSON]
 *
 * Load translation data.
 */
Globalize.loadMessages = function( json ) {
	var locale,
		customData = {
			"globalize-messages": json,
			"main": {}
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	// Set available bundles by populating customData main dataset.
	for ( locale in json ) {
		if ( json.hasOwnProperty( locale ) ) {
			customData.main[ locale ] = {};
		}
	}

	Cldr.load( customData );
};

/**
 * .messageFormatter( path )
 *
 * @path [String or Array]
 *
 * Format a message given its path.
 */
Globalize.messageFormatter =
Globalize.prototype.messageFormatter = function( path ) {
	var cldr, formatter, message, pluralGenerator, returnFn,
		args = slice.call( arguments, 0 );

	validateParameterPresence( path, "path" );
	validateParameterType( path, "path", typeof path === "string" || Array.isArray( path ),
		"a String nor an Array" );

	path = alwaysArray( path );
	cldr = this.cldr;

	validateDefaultLocale( cldr );
	validateMessageBundle( cldr );

	message = cldr.get( [ "globalize-messages/{bundle}" ].concat( path ) );
	validateMessagePresence( path, message );

	// If message is an Array, concatenate it.
	if ( Array.isArray( message ) ) {
		message = message.join( " " );
	}
	validateMessageType( path, message );

	// Is plural module present? Yes, use its generator. Nope, use an error generator.
	pluralGenerator = this.plural !== undefined ?
		this.pluralGenerator() :
		createErrorPluralModulePresence;

	formatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );

	returnFn = messageFormatterFn( formatter );

	runtimeBind( args, cldr, returnFn,
		[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );

	return returnFn;
};

/**
 * .formatMessage( path [, variables] )
 *
 * @path [String or Array]
 *
 * @variables [Number, String, Array or Object]
 *
 * Format a message given its path.
 */
Globalize.formatMessage =
Globalize.prototype.formatMessage = function( path /* , variables */ ) {
	return this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/number.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	regexpEscape = Globalize._regexpEscape,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterRange = Globalize._validateParameterRange,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var createErrorUnsupportedFeature = function( feature ) {
	return createError( "E_UNSUPPORTED", "Unsupported {feature}.", {
		feature: feature
	});
};




var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypeString = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string",
		"a string"
	);
};




/**
 * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )
 *
 * @number [Number].
 *
 * @primaryGroupingSize [Number]
 *
 * @secondaryGroupingSize [Number]
 *
 * Return the formatted number with group separator.
 */
var numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {
	var index,
		currentGroupingSize = primaryGroupingSize,
		ret = "",
		sep = ",",
		switchToSecondary = secondaryGroupingSize ? true : false;

	number = String( number ).split( "." );
	index = number[ 0 ].length;

	while ( index > currentGroupingSize ) {
		ret = number[ 0 ].slice( index - currentGroupingSize, index ) +
			( ret.length ? sep : "" ) + ret;
		index -= currentGroupingSize;
		if ( switchToSecondary ) {
			currentGroupingSize = secondaryGroupingSize;
			switchToSecondary = false;
		}
	}

	number[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : "" ) + ret;
	return number.join( "." );
};




/**
 * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,
 * maximumFractionDigits, round, roundIncrement )
 *
 * @number [Number]
 *
 * @minimumIntegerDigits [Number]
 *
 * @minimumFractionDigits [Number]
 *
 * @maximumFractionDigits [Number]
 *
 * @round [Function]
 *
 * @roundIncrement [Function]
 *
 * Return the formatted integer and fraction digits.
 */
var numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,
	roundIncrement ) {

	// Fraction
	if ( maximumFractionDigits ) {

		// Rounding
		if ( roundIncrement ) {
			number = round( number, roundIncrement );

		// Maximum fraction digits
		} else {
			number = round( number, { exponent: -maximumFractionDigits } );
		}

	} else {
		number = round( number );
	}

	number = String( number );

	// Maximum integer digits (post string phase)
	if ( maximumFractionDigits && /e-/.test( number ) ) {

		// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are
		// displayed using plain digits instead of scientific notation.
		// 1: Remove leading decimal zeros.
		// 2: Remove leading decimal separator.
		// Note: String() is still preferred so it doesn't mess up with a number precision
		// unnecessarily, e.g., (123456789.123).toFixed(10) === "123456789.1229999959",
		// String(123456789.123) === "123456789.123".
		number = ( +number ).toFixed( maximumFractionDigits )
			.replace( /0+$/, "" ) /* 1 */
			.replace( /\.$/, "" ) /* 2 */;
	}

	// Minimum fraction digits (post string phase)
	if ( minimumFractionDigits ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumFractionDigits, true );
		number = number.join( "." );
	}

	// Minimum integer digits
	if ( minimumIntegerDigits ) {
		number = number.split( "." );
		number[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );
		number = number.join( "." );
	}

	return number;
};




/**
 * toPrecision( number, precision, round )
 *
 * @number (Number)
 *
 * @precision (Number) significant figures precision (not decimal precision).
 *
 * @round (Function)
 *
 * Return number.toPrecision( precision ) using the given round function.
 */
var numberToPrecision = function( number, precision, round ) {
	var roundOrder;

	// Get number at two extra significant figure precision.
	number = number.toPrecision( precision + 2 );

	// Then, round it to the required significant figure precision.
	roundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );
	roundOrder -= precision;

	return round( number, { exponent: roundOrder } );
};




/**
 * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )
 *
 * @number [Number]
 *
 * @minimumSignificantDigits [Number]
 *
 * @maximumSignificantDigits [Number]
 *
 * @round [Function]
 *
 * Return the formatted significant digits number.
 */
var numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {
	var atMinimum, atMaximum;

	// Sanity check.
	if ( minimumSignificantDigits > maximumSignificantDigits ) {
		maximumSignificantDigits = minimumSignificantDigits;
	}

	atMinimum = numberToPrecision( number, minimumSignificantDigits, round );
	atMaximum = numberToPrecision( number, maximumSignificantDigits, round );

	// Use atMaximum only if it has more significant digits than atMinimum.
	number = +atMinimum === +atMaximum ? atMinimum : atMaximum;

	// Expand integer numbers, eg. 123e5 to 12300.
	number = ( +number ).toString( 10 );

	if ( ( /e/ ).test( number ) ) {
		throw createErrorUnsupportedFeature({
			feature: "integers out of (1e21, 1e-7)"
		});
	}

	// Add trailing zeros if necessary.
	if ( minimumSignificantDigits - number.replace( /^0+|\./g, "" ).length > 0 ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumSignificantDigits - number[ 0 ].replace( /^0+/, "" ).length, true );
		number = number.join( "." );
	}

	return number;
};




/**
 * removeLiteralQuotes( string )
 *
 * Return:
 * - `` if input string is `''`.
 * - `o'clock` if input string is `'o''clock'`.
 * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted
 *   string.
 */
var removeLiteralQuotes = function( string ) {
	if ( string[ 0 ] + string[ string.length - 1 ] !== "''" ) {
		return string;
	}
	if ( string === "''" ) {
		return "";
	}
	return string.replace( /''/g, "'" ).slice( 1, -1 );
};




/**
 * format( number, properties )
 *
 * @number [Number].
 *
 * @properties [Object] Output of number/format-properties.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormat = function( number, properties ) {
	var infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
	minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix,
	primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix,
	symbolMap;

	padding = properties[ 1 ];
	minimumIntegerDigits = properties[ 2 ];
	minimumFractionDigits = properties[ 3 ];
	maximumFractionDigits = properties[ 4 ];
	minimumSignificantDigits = properties[ 5 ];
	maximumSignificantDigits = properties[ 6 ];
	roundIncrement = properties[ 7 ];
	primaryGroupingSize = properties[ 8 ];
	secondaryGroupingSize = properties[ 9 ];
	round = properties[ 15 ];
	infinitySymbol = properties[ 16 ];
	nanSymbol = properties[ 17 ];
	symbolMap = properties[ 18 ];
	nuDigitsMap = properties[ 19 ];

	// NaN
	if ( isNaN( number ) ) {
		return nanSymbol;
	}

	if ( number < 0 ) {
		pattern = properties[ 12 ];
		prefix = properties[ 13 ];
		suffix = properties[ 14 ];
	} else {
		pattern = properties[ 11 ];
		prefix = properties[ 0 ];
		suffix = properties[ 10 ];
	}

	// Infinity
	if ( !isFinite( number ) ) {
		return prefix + infinitySymbol + suffix;
	}

	ret = prefix;

	// Percent
	if ( pattern.indexOf( "%" ) !== -1 ) {
		number *= 100;

	// Per mille
	} else if ( pattern.indexOf( "\u2030" ) !== -1 ) {
		number *= 1000;
	}

	// Significant digit format
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		number = numberFormatSignificantDigits( number, minimumSignificantDigits,
			maximumSignificantDigits, round );

	// Integer and fractional format
	} else {
		number = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,
			minimumFractionDigits, maximumFractionDigits, round, roundIncrement );
	}

	// Remove the possible number minus sign
	number = number.replace( /^-/, "" );

	// Grouping separators
	if ( primaryGroupingSize ) {
		number = numberFormatGroupingSeparator( number, primaryGroupingSize,
			secondaryGroupingSize );
	}

	ret += number;

	// Scientific notation
	// TODO implement here

	// Padding/'([^']|'')+'|''|[.,\-+E%\u2030]/g
	// TODO implement here

	ret += suffix;

	return ret.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

		// Literals
		if ( literal ) {
			return removeLiteralQuotes( literal );
		}

		// Symbols
		character = character.replace( /[.,\-+E%\u2030]/, function( symbol ) {
			return symbolMap[ symbol ];
		});

		// Numbering system
		if ( nuDigitsMap ) {
			character = character.replace( /[0-9]/, function( digit ) {
				return nuDigitsMap[ +digit ];
			});
		}

		return character;
	});
};




var numberFormatterFn = function( properties ) {
	return function numberFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return numberFormat( value, properties );
	};
};




/**
 * NumberingSystem( cldr )
 *
 * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems
 * - http://cldr.unicode.org/index/bcp47-extension
 * - http://www.unicode.org/reports/tr35/#u_Extension
 */
var numberNumberingSystem = function( cldr ) {
	var nu = cldr.attributes[ "u-nu" ];

	if ( nu ) {
		if ( nu === "traditio" ) {
			nu = "traditional";
		}
		if ( [ "native", "traditional", "finance" ].indexOf( nu ) !== -1 ) {

			// Unicode locale extension `u-nu` is set using either (native, traditional or
			// finance). So, lookup the respective locale's numberingSystem and return it.
			return cldr.main([ "numbers/otherNumberingSystems", nu ]);
		}

		// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.
		return nu;
	}

	// Return the default numberingSystem.
	return cldr.main( "numbers/defaultNumberingSystem" );
};




/**
 * nuMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return digits map if numbering system is different than `latn`.
 */
var numberNumberingSystemDigitsMap = function( cldr ) {
	var aux,
		nu = numberNumberingSystem( cldr );

	if ( nu === "latn" ) {
		return;
	}

	aux = cldr.supplemental([ "numberingSystems", nu ]);

	if ( aux._type !== "numeric" ) {
		throw createErrorUnsupportedFeature( "`" + aux._type + "` numbering system" );
	}

	return aux._digits;
};




/**
 * EBNF representation:
 *
 * number_pattern_re =        prefix?
 *                            padding?
 *                            (integer_fraction_pattern | significant_pattern)
 *                            scientific_notation?
 *                            suffix?
 *
 * prefix =                   non_number_stuff
 *
 * padding =                  "*" regexp(.)
 *
 * integer_fraction_pattern = integer_pattern
 *                            fraction_pattern?
 *
 * integer_pattern =          regexp([#,]*[0,]*0+)
 *
 * fraction_pattern =         "." regexp(0*[0-9]*#*)
 *
 * significant_pattern =      regexp([#,]*@+#*)
 *
 * scientific_notation =      regexp(E\+?0+)
 *
 * suffix =                   non_number_stuff
 *
 * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)
 *
 *
 * Regexp groups:
 *
 *  0: number_pattern_re
 *  1: prefix
 *  2: -
 *  3: -
 *  4: padding
 *  5: (integer_fraction_pattern | significant_pattern)
 *  6: integer_fraction_pattern
 *  7: integer_pattern
 *  8: fraction_pattern
 *  9: significant_pattern
 * 10: scientific_notation
 * 11: suffix
 * 12: -
 */
var numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );




/**
 * format( number, pattern )
 *
 * @number [Number].
 *
 * @pattern [String] raw pattern for numbers.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberPatternProperties = function( pattern ) {
	var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,
		maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
		minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,
		roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;

	pattern = pattern.match( numberPatternRe );
	if ( !pattern ) {
		throw new Error( "Invalid pattern: " + pattern );
	}

	prefix = pattern[ 1 ];
	padding = pattern[ 4 ];
	integerFractionOrSignificantPattern = pattern[ 5 ];
	significantPattern = pattern[ 9 ];
	scientificNotation = pattern[ 10 ];
	suffix = pattern[ 11 ];

	// Significant digit format
	if ( significantPattern ) {
		significantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {
			minimumSignificantDigits = minimumSignificantDigitsMatch.length;
			maximumSignificantDigits = minimumSignificantDigits +
				maximumSignificantDigitsMatch.length;
		});

	// Integer and fractional format
	} else {
		fractionPattern = pattern[ 8 ];
		integerPattern = pattern[ 7 ];

		if ( fractionPattern ) {

			// Minimum fraction digits, and rounding.
			fractionPattern.replace( /[0-9]+/, function( match ) {
				minimumFractionDigits = match;
			});
			if ( minimumFractionDigits ) {
				roundIncrement = +( "0." + minimumFractionDigits );
				minimumFractionDigits = minimumFractionDigits.length;
			} else {
				minimumFractionDigits = 0;
			}

			// Maximum fraction digits
			// 1: ignore decimal character
			maximumFractionDigits = fractionPattern.length - 1 /* 1 */;
		}

		// Minimum integer digits
		integerPattern.replace( /0+$/, function( match ) {
			minimumIntegerDigits = match.length;
		});
	}

	// Scientific notation
	if ( scientificNotation ) {
		throw createErrorUnsupportedFeature({
			feature: "scientific notation (not implemented)"
		});
	}

	// Padding
	if ( padding ) {
		throw createErrorUnsupportedFeature({
			feature: "padding (not implemented)"
		});
	}

	// Grouping
	if ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( "," ) ) !== -1 ) {

		// Primary grouping size is the interval between the last group separator and the end of
		// the integer (or the end of the significant pattern).
		aux2 = integerFractionOrSignificantPattern.split( "." )[ 0 ];
		primaryGroupingSize = aux2.length - aux1 - 1;

		// Secondary grouping size is the interval between the last two group separators.
		if ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( ",", aux1 - 1 ) ) !== -1 ) {
			secondaryGroupingSize = aux1 - 1 - aux2;
		}
	}

	// Return:
	//  0: @prefix String
	//  1: @padding Array [ <character>, <count> ] TODO
	//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer
	//        digits to be used. Numbers will be padded with leading zeroes if necessary.
	//  3: @minimumFractionDigits and
	//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and
	//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing
	//        zeroes if necessary.
	//  5: @minimumSignificantDigits and
	//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and
	//        maximum fraction digits to be shown. Either none or both of these properties are
	//        present; if they are, they override minimum and maximum integer and fraction digits
	//         the formatter uses however many integer and fraction digits are required to display
	//        the specified number of significant digits.
	//  7: @roundIncrement Decimal round increment or null
	//  8: @primaryGroupingSize
	//  9: @secondaryGroupingSize
	// 10: @suffix String
	return [
		prefix,
		padding,
		minimumIntegerDigits,
		minimumFractionDigits,
		maximumFractionDigits,
		minimumSignificantDigits,
		maximumSignificantDigits,
		roundIncrement,
		primaryGroupingSize,
		secondaryGroupingSize,
		suffix
	];
};




/**
 * Symbol( name, cldr )
 *
 * @name [String] Symbol name.
 *
 * @cldr [Cldr instance].
 *
 * Return the localized symbol given its name.
 */
var numberSymbol = function( name, cldr ) {
	return cldr.main([
		"numbers/symbols-numberSystem-" + numberNumberingSystem( cldr ),
		name
	]);
};




var numberSymbolName = {
	".": "decimal",
	",": "group",
	"%": "percentSign",
	"+": "plusSign",
	"-": "minusSign",
	"E": "exponential",
	"\u2030": "perMille"
};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   ".": "",
 *   ",": "",
 *   "%": "",
 *   ...
 * };
 */
var numberSymbolMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );
	}

	return symbolMap;
};




var numberTruncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};




/**
 * round( method )
 *
 * @method [String] with either "round", "ceil", "floor", or "truncate".
 *
 * Return function( value, incrementOrExp ):
 *
 *   @value [Number] eg. 123.45.
 *
 *   @incrementOrExp [Number] optional, eg. 0.1; or
 *     [Object] Either { increment: <value> } or { exponent: <value> }
 *
 *   Return the rounded number, eg:
 *   - round( "round" )( 123.45 ): 123;
 *   - round( "ceil" )( 123.45 ): 124;
 *   - round( "floor" )( 123.45 ): 123;
 *   - round( "truncate" )( 123.45 ): 123;
 *   - round( "round" )( 123.45, 0.1 ): 123.5;
 *   - round( "round" )( 123.45, 10 ): 120;
 *
 *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
 *   Ref: #376
 */
var numberRound = function( method ) {
	method = method || "round";
	method = method === "truncate" ? numberTruncate : Math[ method ];

	return function( value, incrementOrExp ) {
		var exp, increment;

		value = +value;

		// If the value is not a number, return NaN.
		if ( isNaN( value ) ) {
			return NaN;
		}

		// Exponent given.
		if ( typeof incrementOrExp === "object" && incrementOrExp.exponent ) {
			exp = +incrementOrExp.exponent;
			increment = 1;

			if ( exp === 0 ) {
				return method( value );
			}

			// If the exp is not an integer, return NaN.
			if ( !( typeof exp === "number" && exp % 1 === 0 ) ) {
				return NaN;
			}

		// Increment given.
		} else {
			increment = +incrementOrExp || 1;

			if ( increment === 1 ) {
				return method( value );
			}

			// If the increment is not a number, return NaN.
			if ( isNaN( increment ) ) {
				return NaN;
			}

			increment = increment.toExponential().split( "e" );
			exp = +increment[ 1 ];
			increment = +increment[ 0 ];
		}

		// Shift & Round
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] / increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;
		value = method( +( value[ 0 ] + "e" + value[ 1 ] ) );

		// Shift back
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] * increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;
		return +( value[ 0 ] + "e" + value[ 1 ] );
	};
};




/**
 * formatProperties( pattern, cldr [, options] )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]:
 * - minimumIntegerDigits [Number]
 * - minimumFractionDigits, maximumFractionDigits [Number]
 * - minimumSignificantDigits, maximumSignificantDigits [Number]
 * - round [String] "ceil", "floor", "round" (default), or "truncate".
 * - useGrouping [Boolean] default true.
 *
 * Return the processed properties that will be used in number/format.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormatProperties = function( pattern, cldr, options ) {
	var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,
		roundFn, properties;

	function getOptions( attribute, propertyIndex ) {
		if ( attribute in options ) {
			properties[ propertyIndex ] = options[ attribute ];
		}
	}

	options = options || {};
	pattern = pattern.split( ";" );

	positivePattern = pattern[ 0 ];

	negativePattern = pattern[ 1 ] || "-" + positivePattern;
	negativeProperties = numberPatternProperties( negativePattern );
	negativePrefix = negativeProperties[ 0 ];
	negativeSuffix = negativeProperties[ 10 ];

	// Have runtime code to refer to numberRound() instead of including it explicitly.
	roundFn = numberRound( options.round );
	roundFn.generatorString = function() {
		return "numberRound(" + ( options.round ? "\"" + options.round + "\"" : "" ) + ")";
	};

	properties = numberPatternProperties( positivePattern ).concat([
		positivePattern,
		negativePrefix + positivePattern + negativeSuffix,
		negativePrefix,
		negativeSuffix,
		roundFn,
		numberSymbol( "infinity", cldr ),
		numberSymbol( "nan", cldr ),
		numberSymbolMap( cldr ),
		numberNumberingSystemDigitsMap( cldr )
	]);

	getOptions( "minimumIntegerDigits", 2 );
	getOptions( "minimumFractionDigits", 3 );
	getOptions( "maximumFractionDigits", 4 );
	getOptions( "minimumSignificantDigits", 5 );
	getOptions( "maximumSignificantDigits", 6 );

	// Grouping separators
	if ( options.useGrouping === false ) {
		properties[ 8 ] = null;
	}

	// Normalize number of digits if only one of either minimumFractionDigits or
	// maximumFractionDigits is passed in as an option
	if ( "minimumFractionDigits" in options && !( "maximumFractionDigits" in options ) ) {

		// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );
		properties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );
	} else if ( !( "minimumFractionDigits" in options ) &&
			"maximumFractionDigits" in options ) {

		// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );
		properties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );
	}

	// Return:
	// 0-10: see number/pattern-properties.
	// 11: @positivePattern [String] Positive pattern.
	// 12: @negativePattern [String] Negative pattern.
	// 13: @negativePrefix [String] Negative prefix.
	// 14: @negativeSuffix [String] Negative suffix.
	// 15: @round [Function] Round function.
	// 16: @infinitySymbol [String] Infinity symbol.
	// 17: @nanSymbol [String] NaN symbol.
	// 18: @symbolMap [Object] A bunch of other symbols.
	// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.
	return properties;
};




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var formatSymbols = require( * "unicode-8.0.0/General_Category/Format/symbols" );
 * regenerate().add( formatSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 */
var regexpCfG = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/g;




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var dashSymbols = require( * "unicode-8.0.0/General_Category/Dash_Punctuation/symbols" );
 * regenerate().add( dashSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 *
 * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.
 */
var regexpDashG = /[\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u2212]/g;




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var spaceSeparatorSymbols = require( "unicode-8.0.0/General_Category/Space_Separator/symbols" );
 * regenerate().add( spaceSeparatorSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 */
var regexpZsG = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/g;




/**
 * Loose Matching:
 * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI
 *   formatting.
 * - Map all characters in [:Zs:] to U+0020 SPACE;
 * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;
 */
var looseMatching = function( value ) {
	return value
		.replace( regexpCfG, "" )
		.replace( regexpDashG, "-" )
		.replace( regexpZsG, " " );
};




/**
 * parse( value, properties )
 *
 * @value [String].
 *
 * @properties [Object] Parser properties is a reduced pre-processed cldr
 * data set returned by numberParserProperties().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberParse = function( value, properties ) {
	var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,
		suffix, tokenizer, valid;

	// Grammar:
	// - Value <=           NaN | PositiveNumber | NegativeNumber
	// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix
	// - NegativeNumber <=  NegativePrefix NumberOrInf
	// - NumberOrInf <=     Number | Inf
	grammar = [
		[ "nan" ],
		[ "prefix", "infinity", "suffix" ],
		[ "prefix", "number", "suffix" ],
		[ "negativePrefix", "infinity", "negativeSuffix" ],
		[ "negativePrefix", "number", "negativeSuffix" ]
	];

	invertedSymbolMap = properties[ 0 ];
	invertedNuDigitsMap = properties[ 1 ] || {};
	tokenizer = properties[ 2 ];

	value = looseMatching( value );

	function parse( type ) {
		return function( lexeme ) {

			// Reverse localized symbols and numbering system.
			lexeme = lexeme.split( "" ).map(function( character ) {
				return invertedSymbolMap[ character ] ||
					invertedNuDigitsMap[ character ] ||
					character;
			}).join( "" );

			switch ( type ) {
				case "infinity":
					number = Infinity;
					break;

				case "nan":
					number = NaN;
					break;

				case "number":

					// Remove grouping separators.
					lexeme = lexeme.replace( /,/g, "" );

					number = +lexeme;
					break;

				case "prefix":
				case "negativePrefix":
					prefix = lexeme;
					break;

				case "suffix":
					suffix = lexeme;
					break;

				case "negativeSuffix":
					suffix = lexeme;
					negative = true;
					break;

				// This should never be reached.
				default:
					throw new Error( "Internal error" );
			}
			return "";
		};
	}

	function tokenizeNParse( _value, grammar ) {
		return grammar.some(function( statement ) {
			var value = _value;

			// The whole grammar statement should be used (i.e., .every() return true) and value be
			// entirely consumed (i.e., !value.length).
			return statement.every(function( type ) {
				if ( value.match( tokenizer[ type ] ) === null ) {
					return false;
				}

				// Consume and parse it.
				value = value.replace( tokenizer[ type ], parse( type ) );
				return true;
			}) && !value.length;
		});
	}

	valid = tokenizeNParse( value, grammar );

	// NaN
	if ( !valid || isNaN( number ) ) {
		return NaN;
	}

	prefixNSuffix = "" + prefix + suffix;

	// Percent
	if ( prefixNSuffix.indexOf( "%" ) !== -1 ) {
		number /= 100;

	// Per mille
	} else if ( prefixNSuffix.indexOf( "\u2030" ) !== -1 ) {
		number /= 1000;
	}

	// Negative number
	if ( negative ) {
		number *= -1;
	}

	return number;
};




var numberParserFn = function( properties ) {
	return function numberParser( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		return numberParse( value, properties );
	};

};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   "": ".",
 *   "": ",",
 *   "": "%",
 *   ...
 * };
 */
var numberSymbolInvertedMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;
	}

	return symbolMap;
};




/**
 * objectMap( object, fn)
 *
 * - object
 *
 * - fn( pair ) => pair
 */
var objectMap = function( object, fn ) {
	return Object.keys( object ).map(function( key ) {
		return fn([ key, object[ key ] ]);
	}).reduce(function( object, pair ) {
		object[ pair[ 0 ] ] = pair[ 1 ];
		return object;
	}, {});
};




/**
 * parseProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * Return parser properties, used to feed parser function.
 *
 * TODO:
 * - Scientific_notation;
 * - Padding;
 */
var numberParseProperties = function( pattern, cldr, options ) {
	var aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,
		invertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,
		minimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,
		numberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,
		formatProperties = numberFormatProperties( pattern, cldr, options );

	prefix = looseMatching( formatProperties[ 0 ] );
	maximumFractionDigits = formatProperties[ 4 ];
	minimumSignificantDigits = formatProperties[ 5 ];
	maximumSignificantDigits = formatProperties[ 6 ];
	primaryGroupingSize = formatProperties[ 8 ];
	secondaryGroupingSize = formatProperties[ 9 ];
	suffix = looseMatching( formatProperties[ 10 ] );
	negativePrefix = looseMatching( formatProperties[ 13 ] );
	negativeSuffix = looseMatching( formatProperties[ 14 ] );
	infinitySymbol = looseMatching( formatProperties[ 16 ] );
	nanSymbol = looseMatching( formatProperties[ 17 ] );
	symbolMap = objectMap( formatProperties[ 18 ], function( pair ) {
		return [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];
	});
	nuDigitsMap = formatProperties[ 19 ];

	invertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {
		return [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];
	});

	digitsRe = nuDigitsMap ? "[" + nuDigitsMap + "]" : "\\d";
	groupingSeparatorRe = regexpEscape( symbolMap[ "," ] );
	decimalSymbolRe = regexpEscape( symbolMap[ "." ] );

	if ( nuDigitsMap ) {
		invertedNuDigitsMap = nuDigitsMap.split( "" ).reduce(function( object, localizedDigit, i ) {
			object[ localizedDigit ] = String( i );
			return object;
		}, {} );
	}

	aux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {
		return value.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

			// Literals
			if ( literal ) {
				return removeLiteralQuotes( literal );
			}

			// Symbols
			character = character.replace( /[\-+E%\u2030]/, function( symbol ) {
				return symbolMap[ symbol ];
			});

			return character;
		});
	});

	prefix = aux[ 0 ];
	suffix = aux[ 1 ];
	negativePrefix = aux[ 2 ];
	negativeSuffix = aux[ 3 ];

	// Number
	//
	// number_re =                       integer fraction?
	//
	// integer =                         digits | digits_using_grouping_separators
	//
	// fraction =                        regexp((.\d+)?)
	//
	// digits =                          regexp(\d+)
	//
	// digits_w_grouping_separators =    digits_w_1_grouping_separators |
	//                                   digits_w_2_grouping_separators
	//
	// digits_w_1_grouping_separators =  regexp(\d{1,3}(,\d{3})+)
	//
	// digits_w_2_grouping_separators =  regexp(\d{1,2}((,\d{2})*(,\d{3})))

	// Integer part
	numberTokenizer = digitsRe + "+";

	// Grouping separators
	if ( primaryGroupingSize ) {
		if ( secondaryGroupingSize ) {
			aux = digitsRe + "{1," + secondaryGroupingSize + "}((" + groupingSeparatorRe +
				digitsRe + "{" + secondaryGroupingSize + "})*(" + groupingSeparatorRe +
				digitsRe + "{" + primaryGroupingSize + "}))";
		} else {
			aux = digitsRe + "{1," + primaryGroupingSize + "}(" + groupingSeparatorRe +
				digitsRe + "{" + primaryGroupingSize + "})+";
		}
		numberTokenizer = "(" + aux + "|" + numberTokenizer + ")";
	}

	// Fraction part? Only included if 1 or 2.
	// 1: Using significant digit format.
	// 2: Using integer and fractional format && it has a maximumFractionDigits.
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */
				maximumFractionDigits /* 2 */ ) {

		// 1: Handle trailing decimal separator, e.g., `"1." => `1``.
		aux = decimalSymbolRe + digitsRe + "+";
		numberTokenizer = numberTokenizer + "(" + aux + "|" + decimalSymbolRe /* 1 */ + ")?" +

			// Handle non-padded decimals, e.g., `".12"` => `0.12` by making the integer part
			// optional.
			"|(" + numberTokenizer + ")?" + aux;

		numberTokenizer = "(" + numberTokenizer + ")";
	}

	// 0: @invertedSymbolMap [Object] Inverted symbol map.
	// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than
	//    `latn`.
	// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.
	return [
		invertedSymbolMap,
		invertedNuDigitsMap,
		{
			infinity: new RegExp( "^" + regexpEscape( infinitySymbol ) ),
			nan:  new RegExp( "^" + regexpEscape( nanSymbol ) ),
			negativePrefix: new RegExp( "^" + regexpEscape( negativePrefix ) ),
			negativeSuffix: new RegExp( "^" + regexpEscape( negativeSuffix ) ),
			number: new RegExp( "^" + numberTokenizer ),
			prefix: new RegExp( "^" + regexpEscape( prefix ) ),
			suffix: new RegExp( "^" + regexpEscape( suffix ) )
		}
	];

};




/**
 * Pattern( style )
 *
 * @style [String] "decimal" (default) or "percent".
 *
 * @cldr [Cldr instance].
 */
var numberPattern = function( style, cldr ) {
	if ( style !== "decimal" && style !== "percent" ) {
		throw new Error( "Invalid style" );
	}

	return cldr.main([
		"numbers",
		style + "Formats-numberSystem-" + numberNumberingSystem( cldr ),
		"standard"
	]);
};




function validateDigits( properties ) {
	var minimumIntegerDigits = properties[ 2 ],
		minimumFractionDigits = properties[ 3 ],
		maximumFractionDigits = properties[ 4 ],
		minimumSignificantDigits = properties[ 5 ],
		maximumSignificantDigits = properties[ 6 ];

	// Validate significant digit format properties
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		validateParameterRange( minimumSignificantDigits, "minimumSignificantDigits", 1, 21 );
		validateParameterRange( maximumSignificantDigits, "maximumSignificantDigits",
			minimumSignificantDigits, 21 );

	} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {
		throw new Error( "Neither or both the minimum and maximum significant digits must be " +
			"present" );

	// Validate integer and fractional format
	} else {
		validateParameterRange( minimumIntegerDigits, "minimumIntegerDigits", 1, 21 );
		validateParameterRange( minimumFractionDigits, "minimumFractionDigits", 0, 20 );
		validateParameterRange( maximumFractionDigits, "maximumFractionDigits",
			minimumFractionDigits, 20 );
	}
}

/**
 * .numberFormatter( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 * - see also number/format options.
 *
 * Return a function that formats a number according to the given options and default/instance
 * locale.
 */
Globalize.numberFormatter =
Globalize.prototype.numberFormatter = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberFormatProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	validateDigits( properties );

	returnFn = numberFormatterFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .numberParser( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 *
 * Return the number parser according to the default/instance locale.
 */
Globalize.numberParser =
Globalize.prototype.numberParser = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberParseProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	returnFn = numberParserFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .formatNumber( value [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @options [Object]: see number/format-properties.
 *
 * Format a number according to the given options and default/instance locale.
 */
Globalize.formatNumber =
Globalize.prototype.formatNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.numberFormatter( options )( value );
};

/**
 * .parseNumber( value [, options] )
 *
 * @value [String]
 *
 * @options [Object]: See numberParser().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 */
Globalize.parseNumber =
Globalize.prototype.parseNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.numberParser( options )( value );
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;
Globalize._numberNumberingSystem = numberNumberingSystem;
Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;
Globalize._numberPattern = numberPattern;
Globalize._numberSymbol = numberSymbol;
Globalize._looseMatching = looseMatching;
Globalize._removeLiteralQuotes = removeLiteralQuotes;
Globalize._stringPad = stringPad;
Globalize._validateParameterTypeNumber = validateParameterTypeNumber;
Globalize._validateParameterTypeString = validateParameterTypeString;

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/plural.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var runtimeBind = Globalize._runtimeBind,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MakePlural;
/* jshint ignore:start */
MakePlural = (function() {
'use strict';

var _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();


/**
 * make-plural.js -- https://github.com/eemeli/make-plural.js/
 * Copyright (c) 2014-2015 by Eemeli Aro <eemeli@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * The software is provided "as is" and the author disclaims all warranties
 * with regard to this software including all implied warranties of
 * merchantability and fitness. In no event shall the author be liable for
 * any special, direct, indirect, or consequential damages or any damages
 * whatsoever resulting from loss of use, data or profits, whether in an
 * action of contract, negligence or other tortious action, arising out of
 * or in connection with the use or performance of this software.
 */

var Parser = (function () {
    function Parser() {
        _classCallCheck(this, Parser);
    }

    _createClass(Parser, [{
        key: 'parse',
        value: function parse(cond) {
            var _this = this;

            if (cond === 'i = 0 or n = 1') {
                return 'n >= 0 && n <= 1';
            }if (cond === 'i = 0,1') {
                return 'n >= 0 && n < 2';
            }if (cond === 'i = 1 and v = 0') {
                this.v0 = 1;
                return 'n == 1 && v0';
            }
            return cond.replace(/([tv]) (!?)= 0/g, function (m, sym, noteq) {
                var sn = sym + '0';
                _this[sn] = 1;
                return noteq ? '!' + sn : sn;
            }).replace(/\b[fintv]\b/g, function (m) {
                _this[m] = 1;
                return m;
            }).replace(/([fin]) % (10+)/g, function (m, sym, num) {
                var sn = sym + num;
                _this[sn] = 1;
                return sn;
            }).replace(/n10+ = 0/g, 't0 && $&').replace(/(\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (m, se, noteq, x) {
                if (m === 'n = 0,1') return '(n == 0 || n == 1)';
                if (noteq) return se + x.split(',').join(' && ' + se);
                return '(' + se + x.split(',').join(' || ' + se) + ')';
            }).replace(/(\w+) (!?)= ([0-9]+)\.\.([0-9]+)/g, function (m, sym, noteq, x0, x1) {
                if (Number(x0) + 1 === Number(x1)) {
                    if (noteq) return '' + sym + ' != ' + x0 + ' && ' + sym + ' != ' + x1;
                    return '(' + sym + ' == ' + x0 + ' || ' + sym + ' == ' + x1 + ')';
                }
                if (noteq) return '(' + sym + ' < ' + x0 + ' || ' + sym + ' > ' + x1 + ')';
                if (sym === 'n') {
                    _this.t0 = 1;return '(t0 && n >= ' + x0 + ' && n <= ' + x1 + ')';
                }
                return '(' + sym + ' >= ' + x0 + ' && ' + sym + ' <= ' + x1 + ')';
            }).replace(/ and /g, ' && ').replace(/ or /g, ' || ').replace(/ = /g, ' == ');
        }
    }, {
        key: 'vars',
        value: (function (_vars) {
            function vars() {
                return _vars.apply(this, arguments);
            }

            vars.toString = function () {
                return _vars.toString();
            };

            return vars;
        })(function () {
            var vars = [];
            if (this.i) vars.push('i = s[0]');
            if (this.f || this.v) vars.push('f = s[1] || \'\'');
            if (this.t) vars.push('t = (s[1] || \'\').replace(/0+$/, \'\')');
            if (this.v) vars.push('v = f.length');
            if (this.v0) vars.push('v0 = !s[1]');
            if (this.t0 || this.n10 || this.n100) vars.push('t0 = Number(s[0]) == n');
            for (var k in this) {
                if (/^.10+$/.test(k)) {
                    var k0 = k[0] === 'n' ? 't0 && s[0]' : k[0];
                    vars.push('' + k + ' = ' + k0 + '.slice(-' + k.substr(2).length + ')');
                }
            }if (!vars.length) return '';
            return 'var ' + ['s = String(n).split(\'.\')'].concat(vars).join(', ');
        })
    }]);

    return Parser;
})();



var MakePlural = (function () {
    function MakePlural(lc) {
        var _ref = arguments[1] === undefined ? MakePlural : arguments[1];

        var cardinals = _ref.cardinals;
        var ordinals = _ref.ordinals;

        _classCallCheck(this, MakePlural);

        if (!cardinals && !ordinals) throw new Error('At least one type of plural is required');
        this.lc = lc;
        this.categories = { cardinal: [], ordinal: [] };
        this.parser = new Parser();
        
        this.fn = this.buildFunction(cardinals, ordinals);
        this.fn._obj = this;
        this.fn.categories = this.categories;
        
        this.fn.toString = this.fnToString.bind(this);
        return this.fn;
    }

    _createClass(MakePlural, [{
        key: 'compile',
        value: function compile(type, req) {
            var cases = [];
            var rules = MakePlural.rules[type][this.lc];
            if (!rules) {
                if (req) throw new Error('Locale "' + this.lc + '" ' + type + ' rules not found');
                this.categories[type] = ['other'];
                return '\'other\'';
            }
            for (var r in rules) {
                var _rules$r$trim$split = rules[r].trim().split(/\s*@\w*/);

                var _rules$r$trim$split2 = _toArray(_rules$r$trim$split);

                var cond = _rules$r$trim$split2[0];
                var examples = _rules$r$trim$split2.slice(1);
                var cat = r.replace('pluralRule-count-', '');
                if (cond) cases.push([this.parser.parse(cond), cat]);
                
            }
            this.categories[type] = cases.map(function (c) {
                return c[1];
            }).concat('other');
            if (cases.length === 1) {
                return '(' + cases[0][0] + ') ? \'' + cases[0][1] + '\' : \'other\'';
            } else {
                return [].concat(_toConsumableArray(cases.map(function (c) {
                    return '(' + c[0] + ') ? \'' + c[1] + '\'';
                })), ['\'other\'']).join('\n      : ');
            }
        }
    }, {
        key: 'buildFunction',
        value: function buildFunction(cardinals, ordinals) {
            var _this3 = this;

            var compile = function compile(c) {
                return c ? (c[1] ? 'return ' : 'if (ord) return ') + _this3.compile.apply(_this3, _toConsumableArray(c)) : '';
            },
                fold = { vars: function vars(str) {
                    return ('  ' + str + ';').replace(/(.{1,78})(,|$) ?/g, '$1$2\n      ');
                },
                cond: function cond(str) {
                    return ('  ' + str + ';').replace(/(.{1,78}) (\|\| |$) ?/gm, '$1\n          $2');
                } },
                cond = [ordinals && ['ordinal', !cardinals], cardinals && ['cardinal', true]].map(compile).map(fold.cond),
                body = [fold.vars(this.parser.vars())].concat(_toConsumableArray(cond)).join('\n').replace(/\s+$/gm, '').replace(/^[\s;]*[\r\n]+/gm, ''),
                args = ordinals && cardinals ? 'n, ord' : 'n';
            return new Function(args, body);
        }
    }, {
        key: 'fnToString',
        value: function fnToString(name) {
            return Function.prototype.toString.call(this.fn).replace(/^function( \w+)?/, name ? 'function ' + name : 'function').replace('\n/**/', '');
        }
    }], [{
        key: 'load',
        value: function load() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            args.forEach(function (cldr) {
                var data = cldr && cldr.supplemental || null;
                if (!data) throw new Error('Data does not appear to be CLDR data');
                MakePlural.rules = {
                    cardinal: data['plurals-type-cardinal'] || MakePlural.rules.cardinal,
                    ordinal: data['plurals-type-ordinal'] || MakePlural.rules.ordinal
                };
            });
            return MakePlural;
        }
    }]);

    return MakePlural;
})();



MakePlural.cardinals = true;
MakePlural.ordinals = false;
MakePlural.rules = { cardinal: {}, ordinal: {} };


return MakePlural;
}());
/* jshint ignore:end */


var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypePluralType = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || value === "cardinal" || value === "ordinal",
		"String \"cardinal\" or \"ordinal\""
	);
};




var pluralGeneratorFn = function( plural ) {
	return function pluralGenerator( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return plural( value );
	};
};




/**
 * .plural( value )
 *
 * @value [Number]
 *
 * Return the corresponding form (zero | one | two | few | many | other) of a
 * value given locale.
 */
Globalize.plural =
Globalize.prototype.plural = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );
	return this.pluralGenerator( options )( value );
};

/**
 * .pluralGenerator( [options] )
 *
 * Return a plural function (of the form below).
 *
 * fn( value )
 *
 * @value [Number]
 *
 * Return the corresponding form (zero | one | two | few | many | other) of a value given the
 * default/instance locale.
 */
Globalize.pluralGenerator =
Globalize.prototype.pluralGenerator = function( options ) {
	var args, cldr, isOrdinal, plural, returnFn, type;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];
	type = options.type || "cardinal";

	validateParameterTypePluralType( options.type, "options.type" );

	validateDefaultLocale( cldr );

	isOrdinal = type === "ordinal";

	cldr.on( "get", validateCldr );
	cldr.supplemental([ "plurals-type-" + type, "{language}" ]);
	cldr.off( "get", validateCldr );

	MakePlural.rules = {};
	MakePlural.rules[ type ] = cldr.supplemental( "plurals-type-" + type );

	plural = new MakePlural( cldr.attributes.language, {
		"ordinals": isOrdinal,
		"cardinals": !isOrdinal
	});

	returnFn = pluralGeneratorFn( plural );

	runtimeBind( args, cldr, returnFn, [ plural ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/relative-time.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"./plural",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var formatMessage = Globalize._formatMessage,
	runtimeBind = Globalize._runtimeBind,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterTypeString = Globalize._validateParameterTypeString,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber;


/**
 * format( value, numberFormatter, pluralGenerator, properties )
 *
 * @value [Number] The number to format
 *
 * @numberFormatter [String] A numberFormatter from Globalize.numberFormatter
 *
 * @pluralGenerator [String] A pluralGenerator from Globalize.pluralGenerator
 *
 * @properties [Object] containing relative time plural message.
 *
 * Format relative time.
 */
var relativeTimeFormat = function( value, numberFormatter, pluralGenerator, properties ) {

	var relativeTime,
		message = properties[ "relative-type-" + value ];

	if ( message ) {
		return message;
	}

	relativeTime = value <= 0 ? properties[ "relativeTime-type-past" ]
		: properties[ "relativeTime-type-future" ];

	value = Math.abs( value );

	message = relativeTime[ "relativeTimePattern-count-" + pluralGenerator( value ) ];
	return formatMessage( message, [ numberFormatter( value ) ] );
};




var relativeTimeFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	return function relativeTimeFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return relativeTimeFormat( value, numberFormatter, pluralGenerator, properties );
	};

};




/**
 * properties( unit, cldr, options )
 *
 * @unit [String] eg. "day", "week", "month", etc.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]
 * - form: [String] eg. "short" or "narrow". Or falsy for default long form.
 *
 * Return relative time properties.
 */
var relativeTimeProperties = function( unit, cldr, options ) {

	var form = options.form,
		raw, properties, key, match;

	if ( form ) {
		unit = unit + "-" + form;
	}

	raw = cldr.main( [ "dates", "fields", unit ] );
	properties = {
		"relativeTime-type-future": raw[ "relativeTime-type-future" ],
		"relativeTime-type-past": raw[ "relativeTime-type-past" ]
	};
	for ( key in raw ) {
		if ( raw.hasOwnProperty( key ) ) {
			match = /relative-type-(-?[0-9]+)/.exec( key );
			if ( match ) {
				properties[ key ] = raw[ key ];
			}
		}
	}

	return properties;
};




/**
 * .formatRelativeTime( value, unit [, options] )
 *
 * @value [Number] The number of unit to format.
 *
 * @unit [String] see .relativeTimeFormatter() for details.
 *
 * @options [Object] see .relativeTimeFormatter() for details.
 *
 * Formats a relative time according to the given unit, options, and the default/instance locale.
 */
Globalize.formatRelativeTime =
Globalize.prototype.formatRelativeTime = function( value, unit, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.relativeTimeFormatter( unit, options )( value );
};

/**
 * .relativeTimeFormatter( unit [, options ])
 *
 * @unit [String] String value indicating the unit to be formatted. eg. "day", "week", "month", etc.
 *
 * @options [Object]
 * - form: [String] eg. "short" or "narrow". Or falsy for default long form.
 *
 * Returns a function that formats a relative time according to the given unit, options, and the
 * default/instance locale.
 */
Globalize.relativeTimeFormatter =
Globalize.prototype.relativeTimeFormatter = function( unit, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn;

	validateParameterPresence( unit, "unit" );
	validateParameterTypeString( unit, "unit" );

	cldr = this.cldr;
	options = options || {};

	args = [ unit, options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );
	properties = relativeTimeProperties( unit, cldr, options );
	cldr.off( "get", validateCldr );

	numberFormatter = this.numberFormatter( options );
	pluralGenerator = this.pluralGenerator();

	returnFn = relativeTimeFormatterFn( numberFormatter, pluralGenerator, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/unit.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"./plural"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var formatMessage = Globalize._formatMessage,
	runtimeBind = Globalize._runtimeBind,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypeString = Globalize._validateParameterTypeString;


/**
 * format( value, numberFormatter, pluralGenerator, unitProperies )
 *
 * @value [Number]
 *
 * @numberFormatter [Object]: A numberFormatter from Globalize.numberFormatter.
 *
 * @pluralGenerator [Object]: A pluralGenerator from Globalize.pluralGenerator.
 *
 * @unitProperies [Object]: localized unit data from cldr.
 *
 * Format units such as seconds, minutes, days, weeks, etc.
 *
 * OBS:
 *
 * Unit Sequences are not implemented.
 * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#Unit_Sequences
 *
 * Duration Unit (for composed time unit durations) is not implemented.
 * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#durationUnit
 */
var unitFormat = function( value, numberFormatter, pluralGenerator, unitProperties ) {
	var compoundUnitPattern = unitProperties.compoundUnitPattern, dividend, dividendProperties,
		formattedValue, divisor, divisorProperties, message, pluralValue;

	unitProperties = unitProperties.unitProperties;
	formattedValue = numberFormatter( value );
	pluralValue = pluralGenerator( value );

	// computed compound unit, eg. "megabyte-per-second".
	if ( unitProperties instanceof Array ) {
		dividendProperties = unitProperties[ 0 ];
		divisorProperties = unitProperties[ 1 ];

		dividend = formatMessage( dividendProperties[ pluralValue ], [ value ] );
		divisor = formatMessage( divisorProperties.one, [ "" ] ).trim();

		return formatMessage( compoundUnitPattern, [ dividend, divisor ] );
	}

	message = unitProperties[ pluralValue ];

	return formatMessage( message, [ formattedValue ] );
};




var unitFormatterFn = function( numberFormatter, pluralGenerator, unitProperties ) {
	return function unitFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return unitFormat( value, numberFormatter, pluralGenerator, unitProperties );
	};

};




/**
 * categories()
 *
 * Return all unit categories.
 */
var unitCategories = [ "acceleration", "angle", "area", "digital", "duration", "length", "mass", "power",
"pressure", "speed", "temperature", "volume" ];




function stripPluralGarbage( data ) {
	var aux, pluralCount;

	if ( data ) {
		aux = {};
		for ( pluralCount in data ) {
			aux[ pluralCount.replace( /unitPattern-count-/, "" ) ] = data[ pluralCount ];
		}
	}

	return aux;
}

/**
 * get( unit, form, cldr )
 *
 * @unit [String] The full type-unit name (eg. duration-second), or the short unit name
 * (eg. second).
 *
 * @form [String] A string describing the form of the unit representation (eg. long,
 * short, narrow).
 *
 * @cldr [Cldr instance].
 *
 * Return the plural map of a unit, eg: "second"
 * { "one": "{0} second",
 *   "other": "{0} seconds" }
 * }
 *
 * Or the Array of plural maps of a compound-unit, eg: "foot-per-second"
 * [ { "one": "{0} foot",
 *     "other": "{0} feet" },
 *   { "one": "{0} second",
 *     "other": "{0} seconds" } ]
 *
 * Uses the precomputed form of a compound-unit if available, eg: "mile-per-hour"
 * { "displayName": "miles per hour",
 *    "unitPattern-count-one": "{0} mile per hour",
 *    "unitPattern-count-other": "{0} miles per hour"
 * },
 *
 * Also supports "/" instead of "-per-", eg. "foot/second", using the precomputed form if
 * available.
 *
 * Or the Array of plural maps of a compound-unit, eg: "foot-per-second"
 * [ { "one": "{0} foot",
 *     "other": "{0} feet" },
 *   { "one": "{0} second",
 *     "other": "{0} seconds" } ]
 *
 * Or undefined in case the unit (or a unit of the compound-unit) doesn't exist.
 */
var get = function( unit, form, cldr ) {
	var ret;

	// Ensure that we get the 'precomputed' form, if present.
	unit = unit.replace( /\//, "-per-" );

	// Get unit or <category>-unit (eg. "duration-second").
	[ "" ].concat( unitCategories ).some(function( category ) {
		return ret = cldr.main([
			"units",
			form,
			category.length ? category + "-" + unit : unit
		]);
	});

	// Rename keys s/unitPattern-count-//g.
	ret = stripPluralGarbage( ret );

	// Compound Unit, eg. "foot-per-second" or "foot/second".
	if ( !ret && ( /-per-/ ).test( unit ) ) {

		// "Some units already have 'precomputed' forms, such as kilometer-per-hour;
		// where such units exist, they should be used in preference" UTS#35.
		// Note that precomputed form has already been handled above (!ret).

		// Get both recursively.
		unit = unit.split( "-per-" );
		ret = unit.map(function( unit ) {
			return get( unit, form, cldr );
		});
		if ( !ret[ 0 ] || !ret[ 1 ] ) {
			return;
		}
	}

	return ret;
};

var unitGet = get;




/**
 * properties( unit, form, cldr )
 *
 * @unit [String] The full type-unit name (eg. duration-second), or the short unit name
 * (eg. second).
 *
 * @form [String] A string describing the form of the unit representation (eg. long,
 * short, narrow).
 *
 * @cldr [Cldr instance].
 */
var unitProperties = function( unit, form, cldr ) {
	var compoundUnitPattern, unitProperties;

	compoundUnitPattern = cldr.main( [ "units", form, "per/compoundUnitPattern" ] );
	unitProperties = unitGet( unit, form, cldr );

	return {
		compoundUnitPattern: compoundUnitPattern,
		unitProperties: unitProperties
	};
};




/**
 * Globalize.formatUnit( value, unit, options )
 *
 * @value [Number]
 *
 * @unit [String]: The unit (e.g "second", "day", "year")
 *
 * @options [Object]
 * - form: [String] "long", "short" (default), or "narrow".
 *
 * Format units such as seconds, minutes, days, weeks, etc.
 */
Globalize.formatUnit =
Globalize.prototype.formatUnit = function( value, unit, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.unitFormatter( unit, options )( value );
};

/**
 * Globalize.unitFormatter( unit, options )
 *
 * @unit [String]: The unit (e.g "second", "day", "year")
 *
 * @options [Object]
 * - form: [String] "long", "short" (default), or "narrow".
 *
 * - numberFormatter: [Function] a number formatter function. Defaults to Globalize
 *   `.numberFormatter()` for the current locale using the default options.
 */
Globalize.unitFormatter =
Globalize.prototype.unitFormatter = function( unit, options ) {
	var args, form, numberFormatter, pluralGenerator, returnFn, properties;

	validateParameterPresence( unit, "unit" );
	validateParameterTypeString( unit, "unit" );

	validateParameterTypePlainObject( options, "options" );

	options = options || {};

	args = [ unit, options ];
	form = options.form || "long";
	properties = unitProperties( unit, form, this.cldr );

	numberFormatter = options.numberFormatter || this.numberFormatter();
	pluralGenerator = this.pluralGenerator();
	returnFn = unitFormatterFn( numberFormatter, pluralGenerator, properties );

	runtimeBind( args, this.cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/node-main.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/*!
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */

// Core
module.exports = __webpack_require__( "./node_modules/globalize/dist/globalize.js" );

// Extent core with the following modules
__webpack_require__( "./node_modules/globalize/dist/globalize/message.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/number.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/plural.js" );

// Load after globalize/number
__webpack_require__( "./node_modules/globalize/dist/globalize/currency.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/date.js" );

// Load after globalize/number and globalize/plural
__webpack_require__( "./node_modules/globalize/dist/globalize/relative-time.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/unit.js" );



/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmeidate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/App.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __syncRequire = typeof module === "object" && typeof module.exports === "object";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var css = __webpack_require__("./src/app.m.css");
var App = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Foo;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,src/Foo!./src/Foo.ts")(); }) : false];
                case 1:
                    Foo = _a.sent();
                    return [2 /*return*/, Foo.default];
            }
        });
    });
};
var Bar = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Bar;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Bar.ts")(); }) : false];
                case 1:
                    Bar = _a.sent();
                    return [2 /*return*/, Bar.default];
            }
        });
    });
};
var Baz = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Baz;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Baz.ts")(); }) : false];
                case 1:
                    Baz = _a.sent();
                    return [2 /*return*/, Baz.default];
            }
        });
    });
};
function default_1() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var bar, baz;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log(css);
                    return [4 /*yield*/, Bar()];
                case 1:
                    bar = _a.sent();
                    return [4 /*yield*/, Baz()];
                case 2:
                    baz = _a.sent();
                    bar();
                    baz();
                    return [2 /*return*/, App()];
            }
        });
    });
}
exports.default = default_1;


/***/ }),

/***/ "./src/app.m.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {" _key":"app","root":"app-m__root__YxttP theme-m__root__3x1SG"};

/***/ }),

/***/ "./src/main.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/main.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("./node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.js");

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var App_1 = __webpack_require__("./src/App.ts");
var css = __webpack_require__("./src/app.m.css");
var has_1 = __webpack_require__("./node_modules/@dojo/has/has.js");
// !has('bar')
// elided: import './Bar'
if (true) {
    console.log('foo');
}
App_1.default().then(function (result) {
    console.log(result());
    var div = document.createElement('div');
    div.innerHTML = 'hello, world';
    (_a = div.classList).add.apply(_a, tslib_1.__spread(css.root.split(' ')));
    document.body.appendChild(div);
    var _a;
});


/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./src/main.css");
module.exports = __webpack_require__("./src/main.ts");


/***/ })

},[0]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy9EZXN0cm95YWJsZS50cyIsIndlYnBhY2s6Ly8vRXZlbnRlZC50cyIsIndlYnBhY2s6Ly8vYXNwZWN0LnRzIiwid2VicGFjazovLy9oYXMudHMiLCJ3ZWJwYWNrOi8vL2xhbmcudHMiLCJ3ZWJwYWNrOi8vL3V0aWwudHMiLCJ3ZWJwYWNrOi8vL3V1aWQudHMiLCJ3ZWJwYWNrOi8vL2xvYWQudHMiLCJ3ZWJwYWNrOi8vL2xvY2FsZXMudHMiLCJ3ZWJwYWNrOi8vL2kxOG4udHMiLCJ3ZWJwYWNrOi8vL21haW4udHMiLCJ3ZWJwYWNrOi8vL01hcC50cyIsIndlYnBhY2s6Ly8vT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vUHJvbWlzZS50cyIsIndlYnBhY2s6Ly8vU3ltYm9sLnRzIiwid2VicGFjazovLy9XZWFrTWFwLnRzIiwid2VicGFjazovLy9nbG9iYWwudHMiLCJ3ZWJwYWNrOi8vL2l0ZXJhdG9yLnRzIiwid2VicGFjazovLy9vYmplY3QudHMiLCJ3ZWJwYWNrOi8vL3N0cmluZy50cyIsIndlYnBhY2s6Ly8vcXVldWUudHMiLCJ3ZWJwYWNrOi8vL3NldExvY2FsZURhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Zvby50cz83ZGNlIiwid2VicGFjazovLy8uL3NyYy9CYXIudHM/ODg3OSIsIndlYnBhY2s6Ly8vLi9zcmMvQmF6LnRzP2JmZGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvc3VwcGxlbWVudGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L25vZGVfbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvY3VycmVuY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9kYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3BsdXJhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS91bml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9ub2RlLW1haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLm0uY3NzPzE1NmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uY3NzPzg0ODUiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUVBOzs7QUFHQTtJQUNDLE9BQU8saUJBQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO0FBQzlCO0FBRUE7OztBQUdBO0lBQ0MsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQztBQUNqRDtBQUVBO0lBTUM7OztJQUdBO1FBQ0MsSUFBSSxDQUFDLFFBQU8sRUFBRyxFQUFFO0lBQ2xCO0lBRUE7Ozs7OztJQU1BLDBCQUFHLEVBQUgsVUFBSSxPQUEwQjtRQUM3QixJQUFNLE9BQU0sRUFBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLDRCQUFxQixnQ0FBSSxPQUFPLEdBQUUsRUFBRSxPQUFPO1FBQzNFLDJCQUFpQjtRQUN6QixRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixPQUFPO1lBQ04sT0FBTztnQkFDTixRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3pDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDakI7U0FDQTtJQUNGLENBQUM7SUFFRDs7Ozs7SUFLQSw4QkFBTyxFQUFQO1FBQUE7UUFDQyxPQUFPLElBQUksaUJBQU8sQ0FBQyxVQUFDLE9BQU87WUFDMUIsS0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxNQUFNO2dCQUMzQixPQUFNLEdBQUksTUFBTSxDQUFDLFFBQU8sR0FBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQzdDLENBQUMsQ0FBQztZQUNGLEtBQUksQ0FBQyxRQUFPLEVBQUcsSUFBSTtZQUNuQixLQUFJLENBQUMsSUFBRyxFQUFHLFNB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QU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLGFBQWE7SUFDYixPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixJQUFJO0lBQ0osUUFBUTtJQUNSLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsT0FBTztJQUNQLElBQUk7SUFDSixPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxPQUFPO0lBQ1AsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLFFBQVE7SUFDUixRQUFRO0lBQ1IsS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLE9BQU87SUFDUCxJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixPQUFPO0lBQ1AsSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixRQUFRO0lBQ1IsS0FBSztJQUNMLElBQUk7SUFDSixJQUFJO0lBQ0osS0FBSztJQUNMLEtBQUs7SUFDTCxJQUFJO0lBQ0osUUFBUTtJQUNSLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLFFBQVE7SUFDUixLQUFLO0lBQ0wsT0FBTztJQUNQLElBQUk7SUFDSixPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixPQUFPO0lBQ1AsSUFBSTtJQUNKLFNBQVM7SUFDVCxTQUFTO0lBQ1QsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osT0FBTztJQUNQLElBQUk7SUFDSixLQUFLO0lBQ0wsTUFBTTtJQUNOLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osS0FBSztJQUNMLEtBQUs7SUFDTCxJQUFJO0lBQ0osVUFBVTtJQUNWLFVBQVU7SUFDVixLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osT0FBTztJQUNQLE9B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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7QUN4a0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7O0FDcEdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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LEdBQUcsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLLGNBQWMsTUFBTSxJQUFJLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDdmFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEVBQUU7QUFDckU7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVLEVBQUU7Ozs7O0FBSzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0osR0FBRyxVQUFVOztBQUViO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSwyREFBMkQsRUFBRTtBQUM3RCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBLENB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxVQUFVLElBQUksVUFBVSxTQUFTLGNBQWM7QUFDM0QsZUFBZSxXQUFXLFdBQVcsT0FBTyxjQUFjO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUssTUFBTSxHQUFHO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhLE1BQU0sR0FBRztBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUyxLQUFLLEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Ozs7Ozs7Ozs7QUM5aEVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsbUNBQW1DO0FBQy9EOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHVCQUF1QjtBQUMvQzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELHdCQUF3QixxQkFBcUIsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQSxDQUFDOzs7Ozs7Ozs7QUMzTUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxVQUFVLEVBQUU7QUFDaEIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxVQUFVLEVBQUU7QUFDbEIsa0JBQWtCLEVBQUUsUUFBUTtBQUM1QixNQUFNLFVBQVUsRUFBRTtBQUNsQixrQkFBa0IsRUFBRSxXQUFXO0FBQy9CO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUNBQWlDLEVBQUU7QUFDbkMsbUNBQW1DLEVBQUU7QUFDckMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVUsRUFBRTtBQUNsQixrQkFBa0IsRUFBRSxRQUFRO0FBQzVCLE1BQU0sVUFBVSxFQUFFO0FBQ2xCLGtCQUFrQixFQUFFLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQSxDQUFDOzs7Ozs7Ozs7QUM5U0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDN0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7O0FDdkx0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7OztBQ3pMRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUFBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUMvRSxxQkFBcUIsdURBQXVEOztBQUU1RTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLGlFQUFpRSx1QkFBdUIsRUFBRSw0QkFBNEI7QUFDcko7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLDZCQUE2QiwwQkFBMEIsYUFBYSxFQUFFLHFCQUFxQjtBQUN4RyxnQkFBZ0IscURBQXFELG9FQUFvRSxhQUFhLEVBQUU7QUFDeEosc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDLFNBQVM7QUFDM0Msa0NBQWtDLFdBQVcsVUFBVTtBQUN2RCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDZHQUE2RyxPQUFPLFVBQVU7QUFDOUgsZ0ZBQWdGLGlCQUFpQixPQUFPO0FBQ3hHLHdEQUF3RCxnQkFBZ0IsUUFBUSxPQUFPO0FBQ3ZGLDhDQUE4QyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsWUFBWSxhQUFhLE9BQU8sRUFBRSxVQUFVLFdBQVc7QUFDaEUsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzRkFBc0YsYUFBYSxFQUFFO0FBQ3RILHNCQUFzQixnQ0FBZ0MscUNBQXFDLDBDQUEwQyxFQUFFLEVBQUUsR0FBRztBQUM1SSwyQkFBMkIsTUFBTSxlQUFlLEVBQUUsWUFBWSxvQkFBb0IsRUFBRTtBQUNwRixzQkFBc0Isb0dBQW9HO0FBQzFILDZCQUE2Qix1QkFBdUI7QUFDcEQsNEJBQTRCLHdCQUF3QjtBQUNwRCwyQkFBMkIseURBQXlEO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQTRDLFNBQVMsRUFBRSxxREFBcUQsYUFBYSxFQUFFO0FBQzVJLHlCQUF5QixnQ0FBZ0Msb0JBQW9CLGdEQUFnRCxnQkFBZ0IsR0FBRztBQUNoSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHVDQUF1QyxhQUFhLEVBQUUsRUFBRSxPQUFPLGtCQUFrQjtBQUNqSDtBQUNBOzs7Ozs7OztBQ3JLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUVBLElBQU0sSUFBRyxFQUFHOzs7OzsrQkFDQyx3TEFBb0I7O29CQUExQixJQUFHLEVBQUcsU0FBcUI7b0JBQ2pDLHNCQUFPLEdBQUcsQ0FBQyxPQUFPOzs7O0NBQ2xCO0FBRUQsSUFBTSxJQUFHLEVBQUc7Ozs7OytCQUNDLHdMQUFvQjs7b0JBQTFCLElBQUcsRUFBRyxTQUFxQjtvQkFDakMsc0JBQU8sR0FBRyxDQUFDLE9BQU87Ozs7Q0FDbEI7QUFFRCxJQUFNLElBQUcsRUFBRzs7Ozs7K0JBQ0Msd0xBQW9COztvQkFBMUIsSUFBRyxFQUFHLFNBQXFCO29CQUNqQyxzQkFBTyxHQUFHLENBQUMsT0FBTzs7OztDQUNsQjtBQUVEOzs7Ozs7b0JBQ0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7b0JBQ0oscUJBQU0sR0FBRyxFQUFFOztvQkFBakIsSUFBRyxFQUFHLFNBQVc7b0JBQ1gscUJBQU0sR0FBRyxFQUFFOztvQkFBakIsSUFBRyxFQUFHLFNBQVc7b0JBQ3ZCLEdBQUcsRUFBRTtvQkFDTCxHQUFHLEVBQUU7b0JBQ0wsc0JBQU8sR0FBRyxFQUFFOzs7OztBQU5iOzs7Ozs7OztBQ2pCQTtBQUNBLGtCQUFrQixnRTs7Ozs7OztBQ0RsQix5Qzs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBOzs7VUFJZ0I7SUFDZixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztBQUNuQjtBQUVBLGFBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBTTtJQUNoQixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3JCLElBQU0sSUFBRyxFQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO0lBQ3pDLEdBQUcsQ0FBQyxVQUFTLEVBQUcsY0FBYztJQUM5QixTQUFHLENBQUMsU0FBUyxFQUFDLEdBQUcsNEJBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3hDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQzs7QUFDL0IsQ0FBQyxDQUFDIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIm1haW5cIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibWFpblwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtYWluXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsImltcG9ydCB7IEhhbmRsZSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wb3NpdGVIYW5kbGUgfSBmcm9tICcuL2xhbmcnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnQGRvam8vc2hpbS9Qcm9taXNlJztcblxuLyoqXG4gKiBObyBvcGVyYXRpb24gZnVuY3Rpb24gdG8gcmVwbGFjZSBvd24gb25jZSBpbnN0YW5jZSBpcyBkZXN0b3J5ZWRcbiAqL1xuZnVuY3Rpb24gbm9vcCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG59XG5cbi8qKlxuICogTm8gb3AgZnVuY3Rpb24gdXNlZCB0byByZXBsYWNlIG93biwgb25jZSBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0b3J5ZWRcbiAqL1xuZnVuY3Rpb24gZGVzdHJveWVkKCk6IG5ldmVyIHtcblx0dGhyb3cgbmV3IEVycm9yKCdDYWxsIG1hZGUgdG8gZGVzdHJveWVkIG1ldGhvZCcpO1xufVxuXG5leHBvcnQgY2xhc3MgRGVzdHJveWFibGUge1xuXHQvKipcblx0ICogcmVnaXN0ZXIgaGFuZGxlcyBmb3IgdGhlIGluc3RhbmNlXG5cdCAqL1xuXHRwcml2YXRlIGhhbmRsZXM6IEhhbmRsZVtdO1xuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuaGFuZGxlcyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGhhbmRsZXMgZm9yIHRoZSBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gYHRoaXMuZGVzdHJveWAgaXMgY2FsbGVkXG5cdCAqXG5cdCAqIEBwYXJhbSB7SGFuZGxlfSBoYW5kbGUgVGhlIGhhbmRsZSB0byBhZGQgZm9yIHRoZSBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7SGFuZGxlfSBhIGhhbmRsZSBmb3IgdGhlIGhhbmRsZSwgcmVtb3ZlcyB0aGUgaGFuZGxlIGZvciB0aGUgaW5zdGFuY2UgYW5kIGNhbGxzIGRlc3Ryb3lcblx0ICovXG5cdG93bihoYW5kbGVzOiBIYW5kbGUgfCBIYW5kbGVbXSk6IEhhbmRsZSB7XG5cdFx0Y29uc3QgaGFuZGxlID0gQXJyYXkuaXNBcnJheShoYW5kbGVzKSA/IGNyZWF0ZUNvbXBvc2l0ZUhhbmRsZSguLi5oYW5kbGVzKSA6IGhhbmRsZXM7XG5cdFx0Y29uc3QgeyBoYW5kbGVzOiBfaGFuZGxlcyB9ID0gdGhpcztcblx0XHRfaGFuZGxlcy5wdXNoKGhhbmRsZSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlc3Ryb3koKSB7XG5cdFx0XHRcdF9oYW5kbGVzLnNwbGljZShfaGFuZGxlcy5pbmRleE9mKGhhbmRsZSkpO1xuXHRcdFx0XHRoYW5kbGUuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJweXMgYWxsIGhhbmRlcnMgcmVnaXN0ZXJlZCBmb3IgdGhlIGluc3RhbmNlXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPGFueX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgaGFuZGxlcyBoYXZlIGJlZW4gZGVzdHJveWVkXG5cdCAqL1xuXHRkZXN0cm95KCk6IFByb21pc2U8YW55PiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHR0aGlzLmhhbmRsZXMuZm9yRWFjaCgoaGFuZGxlKSA9PiB7XG5cdFx0XHRcdGhhbmRsZSAmJiBoYW5kbGUuZGVzdHJveSAmJiBoYW5kbGUuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRlc3Ryb3kgPSBub29wO1xuXHRcdFx0dGhpcy5vd24gPSBkZXN0cm95ZWQ7XG5cdFx0XHRyZXNvbHZlKHRydWUpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlc3Ryb3lhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIERlc3Ryb3lhYmxlLnRzIiwiaW1wb3J0IE1hcCBmcm9tICdAZG9qby9zaGltL01hcCc7XG5pbXBvcnQgeyBIYW5kbGUsIEV2ZW50VHlwZSwgRXZlbnRPYmplY3QgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgb24gYXMgYXNwZWN0T24gfSBmcm9tICcuL2FzcGVjdCc7XG5pbXBvcnQgeyBEZXN0cm95YWJsZSB9IGZyb20gJy4vRGVzdHJveWFibGUnO1xuXG4vKipcbiAqIEhhbmRsZXMgYW4gYXJyYXkgb2YgaGFuZGxlc1xuICpcbiAqIEBwYXJhbSBoYW5kbGVzIGFuIGFycmF5IG9mIGhhbmRsZXNcbiAqIEByZXR1cm5zIGEgc2luZ2xlIEhhbmRsZSBmb3IgaGFuZGxlcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlc0FycmF5dG9IYW5kbGUoaGFuZGxlczogSGFuZGxlW10pOiBIYW5kbGUge1xuXHRyZXR1cm4ge1xuXHRcdGRlc3Ryb3koKSB7XG5cdFx0XHRoYW5kbGVzLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlLmRlc3Ryb3koKSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIE1hcCBvZiBjb21wdXRlZCByZWd1bGFyIGV4cHJlc3Npb25zLCBrZXllZCBieSBzdHJpbmdcbiAqL1xuY29uc3QgcmVnZXhNYXAgPSBuZXcgTWFwPHN0cmluZywgUmVnRXhwPigpO1xuXG4vKipcbiAqIERldGVybWluZXMgaXMgdGhlIGV2ZW50IHR5cGUgZ2xvYiBoYXMgYmVlbiBtYXRjaGVkXG4gKlxuICogQHJldHVybnMgYm9vbGVhbiB0aGF0IGluZGljYXRlcyBpZiB0aGUgZ2xvYiBpcyBtYXRjaGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0dsb2JNYXRjaChnbG9iU3RyaW5nOiBzdHJpbmcgfCBzeW1ib2wsIHRhcmdldFN0cmluZzogc3RyaW5nIHwgc3ltYm9sKTogYm9vbGVhbiB7XG5cdGlmICh0eXBlb2YgdGFyZ2V0U3RyaW5nID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZ2xvYlN0cmluZyA9PT0gJ3N0cmluZycgJiYgZ2xvYlN0cmluZy5pbmRleE9mKCcqJykgIT09IC0xKSB7XG5cdFx0bGV0IHJlZ2V4OiBSZWdFeHA7XG5cdFx0aWYgKHJlZ2V4TWFwLmhhcyhnbG9iU3RyaW5nKSkge1xuXHRcdFx0cmVnZXggPSByZWdleE1hcC5nZXQoZ2xvYlN0cmluZykhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoYF4ke2dsb2JTdHJpbmcucmVwbGFjZSgvXFwqL2csICcuKicpfSRgKTtcblx0XHRcdHJlZ2V4TWFwLnNldChnbG9iU3RyaW5nLCByZWdleCk7XG5cdFx0fVxuXHRcdHJldHVybiByZWdleC50ZXN0KHRhcmdldFN0cmluZyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGdsb2JTdHJpbmcgPT09IHRhcmdldFN0cmluZztcblx0fVxufVxuXG5leHBvcnQgdHlwZSBFdmVudGVkQ2FsbGJhY2s8VCA9IEV2ZW50VHlwZSwgRSBleHRlbmRzIEV2ZW50T2JqZWN0PFQ+ID0gRXZlbnRPYmplY3Q8VD4+ID0ge1xuXHQvKipcblx0ICogQSBjYWxsYmFjayB0aGF0IHRha2VzIGFuIGBldmVudGAgYXJndW1lbnRcblx0ICpcblx0ICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBvYmplY3Rcblx0ICovXG5cblx0KGV2ZW50OiBFKTogYm9vbGVhbiB8IHZvaWQ7XG59O1xuXG4vKipcbiAqIEEgdHlwZSB3aGljaCBpcyBlaXRoZXIgYSB0YXJnZXRlZCBldmVudCBsaXN0ZW5lciBvciBhbiBhcnJheSBvZiBsaXN0ZW5lcnNcbiAqIEB0ZW1wbGF0ZSBUIFRoZSB0eXBlIG9mIHRhcmdldCBmb3IgdGhlIGV2ZW50c1xuICogQHRlbXBsYXRlIEUgVGhlIGV2ZW50IHR5cGUgZm9yIHRoZSBldmVudHNcbiAqL1xuZXhwb3J0IHR5cGUgRXZlbnRlZENhbGxiYWNrT3JBcnJheTxUID0gRXZlbnRUeXBlLCBFIGV4dGVuZHMgRXZlbnRPYmplY3Q8VD4gPSBFdmVudE9iamVjdDxUPj4gPVxuXHR8IEV2ZW50ZWRDYWxsYmFjazxULCBFPlxuXHR8IEV2ZW50ZWRDYWxsYmFjazxULCBFPltdO1xuXG4vKipcbiAqIEV2ZW50IENsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudGVkPE0gZXh0ZW5kcyB7fSA9IHt9LCBUID0gRXZlbnRUeXBlLCBPIGV4dGVuZHMgRXZlbnRPYmplY3Q8VD4gPSBFdmVudE9iamVjdDxUPj4gZXh0ZW5kcyBEZXN0cm95YWJsZSB7XG5cdC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIGlzIHB1cmVseSBzbyBUeXBlU2NyaXB0IHJlbWVtYmVycyB0aGUgdHlwZSBvZiBgTWAgd2hlbiBleHRlbmRpbmcgc29cblx0Ly8gdGhhdCB0aGUgdXRpbGl0aWVzIGluIGBvbi50c2Agd2lsbCB3b3JrXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjAzNDhcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG5cdHByb3RlY3RlZCBfX3R5cGVNYXBfXz86IE07XG5cblx0LyoqXG5cdCAqIG1hcCBvZiBsaXN0ZW5lcnMga2V5ZWQgYnkgZXZlbnQgdHlwZVxuXHQgKi9cblx0cHJvdGVjdGVkIGxpc3RlbmVyc01hcDogTWFwPFQgfCBrZXlvZiBNLCBFdmVudGVkQ2FsbGJhY2s8VCwgTz4gfCBFdmVudGVkQ2FsbGJhY2s8a2V5b2YgTSwgTVtrZXlvZiBNXT4+ID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyB0aGUgZXZlbnQgb2JqZXQgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZVxuXHQgKlxuXHQgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IHRvIGVtaXRcblx0ICovXG5cdGVtaXQ8SyBleHRlbmRzIGtleW9mIE0+KGV2ZW50OiBNW0tdKTogdm9pZDtcblx0ZW1pdChldmVudDogTyk6IHZvaWQ7XG5cdGVtaXQoZXZlbnQ6IGFueSk6IHZvaWQge1xuXHRcdHRoaXMubGlzdGVuZXJzTWFwLmZvckVhY2goKG1ldGhvZCwgdHlwZSkgPT4ge1xuXHRcdFx0Ly8gU2luY2UgYHR5cGVgIGlzIGdlbmVyaWMsIHRoZSBjb21waWxlciBkb2Vzbid0IGtub3cgd2hhdCB0eXBlIGl0IGlzIGFuZCBgaXNHbG9iTWF0Y2hgIHJlcXVpcmVzIGBzdHJpbmcgfCBzeW1ib2xgXG5cdFx0XHRpZiAoaXNHbG9iTWF0Y2godHlwZSBhcyBhbnksIGV2ZW50LnR5cGUpKSB7XG5cdFx0XHRcdG1ldGhvZC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYXRjaCBhbGwgaGFuZGxlciBmb3IgdmFyaW91cyBjYWxsIHNpZ25hdHVyZXMuIFRoZSBzaWduYXR1cmVzIGFyZSBkZWZpbmVkIGluXG5cdCAqIGBCYXNlRXZlbnRlZEV2ZW50c2AuICBZb3UgY2FuIGFkZCB5b3VyIG93biBldmVudCB0eXBlIC0+IGhhbmRsZXIgdHlwZXMgYnkgZXh0ZW5kaW5nXG5cdCAqIGBCYXNlRXZlbnRlZEV2ZW50c2AuICBTZWUgZXhhbXBsZSBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogQHBhcmFtIGFyZ3Ncblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogaW50ZXJmYWNlIFdpZGdldEJhc2VFdmVudHMgZXh0ZW5kcyBCYXNlRXZlbnRlZEV2ZW50cyB7XG5cdCAqICAgICAodHlwZTogJ3Byb3BlcnRpZXM6Y2hhbmdlZCcsIGhhbmRsZXI6IFByb3BlcnRpZXNDaGFuZ2VkSGFuZGxlcik6IEhhbmRsZTtcblx0ICogfVxuXHQgKiBjbGFzcyBXaWRnZXRCYXNlIGV4dGVuZHMgRXZlbnRlZCB7XG5cdCAqICAgIG9uOiBXaWRnZXRCYXNlRXZlbnRzO1xuXHQgKiB9XG5cdCAqXG5cdCAqIEByZXR1cm4ge2FueX1cblx0ICovXG5cdG9uPEsgZXh0ZW5kcyBrZXlvZiBNPih0eXBlOiBLLCBsaXN0ZW5lcjogRXZlbnRlZENhbGxiYWNrT3JBcnJheTxLLCBNW0tdPik6IEhhbmRsZTtcblx0b24odHlwZTogVCwgbGlzdGVuZXI6IEV2ZW50ZWRDYWxsYmFja09yQXJyYXk8VCwgTz4pOiBIYW5kbGU7XG5cdG9uKHR5cGU6IGFueSwgbGlzdGVuZXI6IEV2ZW50ZWRDYWxsYmFja09yQXJyYXk8YW55LCBhbnk+KTogSGFuZGxlIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcikpIHtcblx0XHRcdGNvbnN0IGhhbmRsZXMgPSBsaXN0ZW5lci5tYXAoKGxpc3RlbmVyKSA9PiBhc3BlY3RPbih0aGlzLmxpc3RlbmVyc01hcCwgdHlwZSwgbGlzdGVuZXIpKTtcblx0XHRcdHJldHVybiBoYW5kbGVzQXJyYXl0b0hhbmRsZShoYW5kbGVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGFzcGVjdE9uKHRoaXMubGlzdGVuZXJzTWFwLCB0eXBlLCBsaXN0ZW5lcik7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50ZWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gRXZlbnRlZC50cyIsImltcG9ydCB7IEhhbmRsZSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICdAZG9qby9zaGltL1dlYWtNYXAnO1xuaW1wb3J0IHsgY3JlYXRlSGFuZGxlIH0gZnJvbSAnLi9sYW5nJztcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBwcm92aWRlcyB0aGUgbmVjZXNzYXJ5IEFQSXMgdG8gYmUgTWFwTGlrZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hcExpa2U8SywgVj4ge1xuXHRnZXQoa2V5OiBLKTogVjtcblx0c2V0KGtleTogSywgdmFsdWU/OiBWKTogdGhpcztcbn1cblxuLyoqXG4gKiBBbiBpbnRlcm5hbCB0eXBlIGd1YXJkIHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiB2YWx1ZSBpcyBNYXBMaWtlIG9yIG5vdFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZ3VhcmQgYWdhaW5zdFxuICovXG5mdW5jdGlvbiBpc01hcExpa2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIE1hcExpa2U8YW55LCBhbnk+IHtcblx0cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5nZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRleGFibGUge1xuXHRbbWV0aG9kOiBzdHJpbmddOiBhbnk7XG59XG5cbi8qKlxuICogVGhlIHR5cGVzIG9mIG9iamVjdHMgb3IgbWFwcyB3aGVyZSBhZHZpY2UgY2FuIGJlIGFwcGxpZWRcbiAqL1xuZXhwb3J0IHR5cGUgVGFyZ2V0YWJsZSA9IE1hcExpa2U8c3RyaW5nIHwgc3ltYm9sLCBhbnk+IHwgSW5kZXhhYmxlO1xuXG50eXBlIEFkdmljZVR5cGUgPSAnYmVmb3JlJyB8ICdhZnRlcicgfCAnYXJvdW5kJztcblxuLyoqXG4gKiBBIG1ldGEgZGF0YSBzdHJ1Y3R1cmUgd2hlbiBhcHBseWluZyBhZHZpY2VcbiAqL1xuaW50ZXJmYWNlIEFkdmlzZWQge1xuXHRyZWFkb25seSBpZD86IG51bWJlcjtcblx0YWR2aWNlPzogRnVuY3Rpb247XG5cdHByZXZpb3VzPzogQWR2aXNlZDtcblx0bmV4dD86IEFkdmlzZWQ7XG5cdHJlYWRvbmx5IHJlY2VpdmVBcmd1bWVudHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIGFkdmljZSB3aGljaCBpcyBkZWNvcmF0ZWQgd2l0aCBhZGRpdGlvbmFsXG4gKiBtZXRhIGRhdGEgYWJvdXQgdGhlIGFkdmljZSB0byBhcHBseVxuICovXG5pbnRlcmZhY2UgRGlzcGF0Y2hlciB7XG5cdFt0eXBlOiBzdHJpbmddOiBBZHZpc2VkIHwgdW5kZWZpbmVkO1xuXHQoKTogYW55O1xuXHR0YXJnZXQ6IGFueTtcblx0YmVmb3JlPzogQWR2aXNlZDtcblx0YXJvdW5kPzogQWR2aXNlZDtcblx0YWZ0ZXI/OiBBZHZpc2VkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5Qb2ludERpc3BhdGNoQWR2aWNlPFQ+IHtcblx0YmVmb3JlPzogSm9pblBvaW50QmVmb3JlQWR2aWNlW107XG5cdGFmdGVyPzogSm9pblBvaW50QWZ0ZXJBZHZpY2U8VD5bXTtcblx0cmVhZG9ubHkgam9pblBvaW50OiBGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2luUG9pbnRBZnRlckFkdmljZTxUPiB7XG5cdC8qKlxuXHQgKiBBZHZpY2Ugd2hpY2ggaXMgYXBwbGllZCAqYWZ0ZXIqLCByZWNlaXZpbmcgdGhlIHJlc3VsdCBhbmQgYXJndW1lbnRzIGZyb20gdGhlIGpvaW4gcG9pbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSByZXN1bHQgVGhlIHJlc3VsdCBmcm9tIHRoZSBmdW5jdGlvbiBiZWluZyBhZHZpc2VkXG5cdCAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBhZHZpc2VkIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBhZHZpY2UgaXMgdGhlbiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIG1ldGhvZFxuXHQgKi9cblx0KHJlc3VsdDogVCwgLi4uYXJnczogYW55W10pOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5Qb2ludEFyb3VuZEFkdmljZTxUPiB7XG5cdC8qKlxuXHQgKiBBZHZpY2Ugd2hpY2ggaXMgYXBwbGllZCAqYXJvdW5kKi4gIFRoZSBhZHZpc2luZyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kXG5cdCAqIG5lZWRzIHRvIHJldHVybiBhIG5ldyBmdW5jdGlvbiB3aGljaCB3aWxsIHRoZW4gaW52b2tlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIG9yaWdGbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb25cblx0ICogQHJldHVybnMgQSBuZXcgZnVuY3Rpb24gd2hpY2ggd2lsbCBpbnZva2UgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuXHQgKi9cblx0KG9yaWdGbjogR2VuZXJpY0Z1bmN0aW9uPFQ+KTogKC4uLmFyZ3M6IGFueVtdKSA9PiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5Qb2ludEJlZm9yZUFkdmljZSB7XG5cdC8qKlxuXHQgKiBBZHZpY2Ugd2hpY2ggaXMgYXBwbGllZCAqYmVmb3JlKiwgcmVjZWl2aW5nIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMsIGlmIHRoZSBhZHZpc2luZ1xuXHQgKiBmdW5jdGlvbiByZXR1cm5zIGEgdmFsdWUsIGl0IGlzIHBhc3NlZCBmdXJ0aGVyIGFsb25nIHRha2luZyB0aGUgcGxhY2Ugb2YgdGhlIG9yaWdpbmFsXG5cdCAqIGFyZ3VtZW50cy5cblx0ICpcblx0ICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0aGUgbWV0aG9kIHdhcyBjYWxsZWQgd2l0aFxuXHQgKi9cblx0KC4uLmFyZ3M6IGFueVtdKTogYW55W10gfCB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyaWNGdW5jdGlvbjxUPiB7XG5cdCguLi5hcmdzOiBhbnlbXSk6IFQ7XG59XG5cbi8qKlxuICogQSB3ZWFrIG1hcCBvZiBkaXNwYXRjaGVycyB1c2VkIHRvIGFwcGx5IHRoZSBhZHZpY2VcbiAqL1xuY29uc3QgZGlzcGF0Y2hBZHZpY2VNYXAgPSBuZXcgV2Vha01hcDxGdW5jdGlvbiwgSm9pblBvaW50RGlzcGF0Y2hBZHZpY2U8YW55Pj4oKTtcblxuLyoqXG4gKiBBIFVJRCBmb3IgdHJhY2tpbmcgYWR2aWNlIG9yZGVyaW5nXG4gKi9cbmxldCBuZXh0SWQgPSAwO1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgYWR2aXNlcyBhIGpvaW4gcG9pbnRcbiAqXG4gKiBAcGFyYW0gZGlzcGF0Y2hlciBUaGUgY3VycmVudCBhZHZpY2UgZGlzcGF0Y2hlclxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgYmVmb3JlIG9yIGFmdGVyIGFkdmljZSB0byBhcHBseVxuICogQHBhcmFtIGFkdmljZSBUaGUgYWR2aWNlIHRvIGFwcGx5XG4gKiBAcGFyYW0gcmVjZWl2ZUFyZ3VtZW50cyBJZiB0cnVlLCB0aGUgYWR2aWNlIHdpbGwgcmVjZWl2ZSB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgam9pbiBwb2ludFxuICogQHJldHVybiBUaGUgaGFuZGxlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFkdmljZVxuICovXG5mdW5jdGlvbiBhZHZpc2VPYmplY3QoXG5cdGRpc3BhdGNoZXI6IERpc3BhdGNoZXIgfCB1bmRlZmluZWQsXG5cdHR5cGU6IEFkdmljZVR5cGUsXG5cdGFkdmljZTogRnVuY3Rpb24gfCB1bmRlZmluZWQsXG5cdHJlY2VpdmVBcmd1bWVudHM/OiBib29sZWFuXG4pOiBIYW5kbGUge1xuXHRsZXQgcHJldmlvdXMgPSBkaXNwYXRjaGVyICYmIGRpc3BhdGNoZXJbdHlwZV07XG5cdGxldCBhZHZpc2VkOiBBZHZpc2VkIHwgdW5kZWZpbmVkID0ge1xuXHRcdGlkOiBuZXh0SWQrKyxcblx0XHRhZHZpY2U6IGFkdmljZSxcblx0XHRyZWNlaXZlQXJndW1lbnRzOiByZWNlaXZlQXJndW1lbnRzXG5cdH07XG5cblx0aWYgKHByZXZpb3VzKSB7XG5cdFx0aWYgKHR5cGUgPT09ICdhZnRlcicpIHtcblx0XHRcdC8vIGFkZCB0aGUgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXHRcdFx0Ly8gbm90ZSB0aGF0IHdlIGhhZCB0byBjaGFuZ2UgdGhpcyBsb29wIGEgbGl0dGxlIGJpdCB0byB3b3JrYXJvdW5kIGEgYml6YXJyZSBJRTEwIEpJVCBidWdcblx0XHRcdHdoaWxlIChwcmV2aW91cy5uZXh0ICYmIChwcmV2aW91cyA9IHByZXZpb3VzLm5leHQpKSB7fVxuXHRcdFx0cHJldmlvdXMubmV4dCA9IGFkdmlzZWQ7XG5cdFx0XHRhZHZpc2VkLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFkZCB0byB0aGUgYmVnaW5uaW5nXG5cdFx0XHRpZiAoZGlzcGF0Y2hlcikge1xuXHRcdFx0XHRkaXNwYXRjaGVyLmJlZm9yZSA9IGFkdmlzZWQ7XG5cdFx0XHR9XG5cdFx0XHRhZHZpc2VkLm5leHQgPSBwcmV2aW91cztcblx0XHRcdHByZXZpb3VzLnByZXZpb3VzID0gYWR2aXNlZDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZGlzcGF0Y2hlciAmJiAoZGlzcGF0Y2hlclt0eXBlXSA9IGFkdmlzZWQpO1xuXHR9XG5cblx0YWR2aWNlID0gcHJldmlvdXMgPSB1bmRlZmluZWQ7XG5cblx0cmV0dXJuIGNyZWF0ZUhhbmRsZShmdW5jdGlvbigpIHtcblx0XHRsZXQgeyBwcmV2aW91cyA9IHVuZGVmaW5lZCwgbmV4dCA9IHVuZGVmaW5lZCB9ID0gYWR2aXNlZCB8fCB7fTtcblxuXHRcdGlmIChkaXNwYXRjaGVyICYmICFwcmV2aW91cyAmJiAhbmV4dCkge1xuXHRcdFx0ZGlzcGF0Y2hlclt0eXBlXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHByZXZpb3VzKSB7XG5cdFx0XHRcdHByZXZpb3VzLm5leHQgPSBuZXh0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzcGF0Y2hlciAmJiAoZGlzcGF0Y2hlclt0eXBlXSA9IG5leHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChhZHZpc2VkKSB7XG5cdFx0XHRkZWxldGUgYWR2aXNlZC5hZHZpY2U7XG5cdFx0fVxuXHRcdGRpc3BhdGNoZXIgPSBhZHZpc2VkID0gdW5kZWZpbmVkO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBBZHZpc2UgYSBqb2luIHBvaW50IChmdW5jdGlvbikgd2l0aCBzdXBwbGllZCBhZHZpY2VcbiAqXG4gKiBAcGFyYW0gam9pblBvaW50IFRoZSBmdW5jdGlvbiB0byBiZSBhZHZpc2VkXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBhZHZpY2UgdG8gYmUgYXBwbGllZFxuICogQHBhcmFtIGFkdmljZSBUaGUgYWR2aWNlIHRvIGFwcGx5XG4gKi9cbmZ1bmN0aW9uIGFkdmlzZUpvaW5Qb2ludDxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihcblx0dGhpczogYW55LFxuXHRqb2luUG9pbnQ6IEYsXG5cdHR5cGU6IEFkdmljZVR5cGUsXG5cdGFkdmljZTogSm9pblBvaW50QmVmb3JlQWR2aWNlIHwgSm9pblBvaW50QWZ0ZXJBZHZpY2U8VD4gfCBKb2luUG9pbnRBcm91bmRBZHZpY2U8VD5cbik6IEYge1xuXHRsZXQgZGlzcGF0Y2hlcjogRjtcblx0aWYgKHR5cGUgPT09ICdhcm91bmQnKSB7XG5cdFx0ZGlzcGF0Y2hlciA9IGdldEpvaW5Qb2ludERpc3BhdGNoZXIoYWR2aWNlLmFwcGx5KHRoaXMsIFtqb2luUG9pbnRdKSk7XG5cdH0gZWxzZSB7XG5cdFx0ZGlzcGF0Y2hlciA9IGdldEpvaW5Qb2ludERpc3BhdGNoZXIoam9pblBvaW50KTtcblx0XHQvLyBjYW5ub3QgaGF2ZSB1bmRlZmluZWQgaW4gbWFwIGR1ZSB0byBjb2RlIGxvZ2ljLCB1c2luZyAhXG5cdFx0Y29uc3QgYWR2aWNlTWFwID0gZGlzcGF0Y2hBZHZpY2VNYXAuZ2V0KGRpc3BhdGNoZXIpITtcblx0XHRpZiAodHlwZSA9PT0gJ2JlZm9yZScpIHtcblx0XHRcdChhZHZpY2VNYXAuYmVmb3JlIHx8IChhZHZpY2VNYXAuYmVmb3JlID0gW10pKS51bnNoaWZ0KDxKb2luUG9pbnRCZWZvcmVBZHZpY2U+YWR2aWNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0KGFkdmljZU1hcC5hZnRlciB8fCAoYWR2aWNlTWFwLmFmdGVyID0gW10pKS5wdXNoKGFkdmljZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG4vKipcbiAqIEFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgb3IgY3JlYXRlcyB0aGUgZGlzcGF0Y2hlciBmb3IgYSBnaXZlbiBqb2luIHBvaW50XG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvciBtYXBcbiAqIEBwYXJhbSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB0aGUgZGlzcGF0Y2hlciBzaG91bGQgYmUgcmVzb2x2ZWQgZm9yXG4gKiBAcmV0dXJuIFRoZSBkaXNwYXRjaGVyXG4gKi9cbmZ1bmN0aW9uIGdldERpc3BhdGNoZXJPYmplY3QodGFyZ2V0OiBUYXJnZXRhYmxlLCBtZXRob2ROYW1lOiBzdHJpbmcgfCBzeW1ib2wpOiBEaXNwYXRjaGVyIHtcblx0Y29uc3QgZXhpc3RpbmcgPSBpc01hcExpa2UodGFyZ2V0KSA/IHRhcmdldC5nZXQobWV0aG9kTmFtZSkgOiB0YXJnZXQgJiYgdGFyZ2V0W21ldGhvZE5hbWVdO1xuXHRsZXQgZGlzcGF0Y2hlcjogRGlzcGF0Y2hlcjtcblxuXHRpZiAoIWV4aXN0aW5nIHx8IGV4aXN0aW5nLnRhcmdldCAhPT0gdGFyZ2V0KSB7XG5cdFx0LyogVGhlcmUgaXMgbm8gZXhpc3RpbmcgZGlzcGF0Y2hlciwgdGhlcmVmb3JlIHdlIHdpbGwgY3JlYXRlIG9uZSAqL1xuXHRcdGRpc3BhdGNoZXIgPSA8RGlzcGF0Y2hlcj5mdW5jdGlvbih0aGlzOiBEaXNwYXRjaGVyKTogYW55IHtcblx0XHRcdGxldCBleGVjdXRpb25JZCA9IG5leHRJZDtcblx0XHRcdGxldCBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0bGV0IHJlc3VsdHM6IGFueTtcblx0XHRcdGxldCBiZWZvcmUgPSBkaXNwYXRjaGVyLmJlZm9yZTtcblxuXHRcdFx0d2hpbGUgKGJlZm9yZSkge1xuXHRcdFx0XHRpZiAoYmVmb3JlLmFkdmljZSkge1xuXHRcdFx0XHRcdGFyZ3MgPSBiZWZvcmUuYWR2aWNlLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IGFyZ3M7XG5cdFx0XHRcdH1cblx0XHRcdFx0YmVmb3JlID0gYmVmb3JlLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkaXNwYXRjaGVyLmFyb3VuZCAmJiBkaXNwYXRjaGVyLmFyb3VuZC5hZHZpY2UpIHtcblx0XHRcdFx0cmVzdWx0cyA9IGRpc3BhdGNoZXIuYXJvdW5kLmFkdmljZSh0aGlzLCBhcmdzKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGFmdGVyID0gZGlzcGF0Y2hlci5hZnRlcjtcblx0XHRcdHdoaWxlIChhZnRlciAmJiBhZnRlci5pZCAhPT0gdW5kZWZpbmVkICYmIGFmdGVyLmlkIDwgZXhlY3V0aW9uSWQpIHtcblx0XHRcdFx0aWYgKGFmdGVyLmFkdmljZSkge1xuXHRcdFx0XHRcdGlmIChhZnRlci5yZWNlaXZlQXJndW1lbnRzKSB7XG5cdFx0XHRcdFx0XHRsZXQgbmV3UmVzdWx0cyA9IGFmdGVyLmFkdmljZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0XHRcdHJlc3VsdHMgPSBuZXdSZXN1bHRzID09PSB1bmRlZmluZWQgPyByZXN1bHRzIDogbmV3UmVzdWx0cztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0cyA9IGFmdGVyLmFkdmljZS5jYWxsKHRoaXMsIHJlc3VsdHMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhZnRlciA9IGFmdGVyLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHRpZiAoaXNNYXBMaWtlKHRhcmdldCkpIHtcblx0XHRcdHRhcmdldC5zZXQobWV0aG9kTmFtZSwgZGlzcGF0Y2hlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldCAmJiAodGFyZ2V0W21ldGhvZE5hbWVdID0gZGlzcGF0Y2hlcik7XG5cdFx0fVxuXG5cdFx0aWYgKGV4aXN0aW5nKSB7XG5cdFx0XHRkaXNwYXRjaGVyLmFyb3VuZCA9IHtcblx0XHRcdFx0YWR2aWNlOiBmdW5jdGlvbih0YXJnZXQ6IGFueSwgYXJnczogYW55W10pOiBhbnkge1xuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZy5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGRpc3BhdGNoZXIudGFyZ2V0ID0gdGFyZ2V0O1xuXHR9IGVsc2Uge1xuXHRcdGRpc3BhdGNoZXIgPSBleGlzdGluZztcblx0fVxuXG5cdHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3BhdGNoZXIgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gam9pblBvaW50IChtZXRob2QvZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBUaGUgZnVuY3Rpb24gdGhhdCBpcyB0byBiZSBhZHZpc2VkXG4gKi9cbmZ1bmN0aW9uIGdldEpvaW5Qb2ludERpc3BhdGNoZXI8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxUPiwgVD4oam9pblBvaW50OiBGKTogRiB7XG5cdGZ1bmN0aW9uIGRpc3BhdGNoZXIodGhpczogRnVuY3Rpb24sIC4uLmFyZ3M6IGFueVtdKTogVCB7XG5cdFx0Ly8gY2Fubm90IGhhdmUgdW5kZWZpbmVkIGluIG1hcCBkdWUgdG8gY29kZSBsb2dpYywgdXNpbmcgIVxuXHRcdGNvbnN0IHsgYmVmb3JlLCBhZnRlciwgam9pblBvaW50IH0gPSBkaXNwYXRjaEFkdmljZU1hcC5nZXQoZGlzcGF0Y2hlcikhO1xuXHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdGFyZ3MgPSBiZWZvcmUucmVkdWNlKChwcmV2aW91c0FyZ3MsIGFkdmljZSkgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50QXJncyA9IGFkdmljZS5hcHBseSh0aGlzLCBwcmV2aW91c0FyZ3MpO1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEFyZ3MgfHwgcHJldmlvdXNBcmdzO1xuXHRcdFx0fSwgYXJncyk7XG5cdFx0fVxuXHRcdGxldCByZXN1bHQgPSBqb2luUG9pbnQuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRyZXN1bHQgPSBhZnRlci5yZWR1Y2UoKHByZXZpb3VzUmVzdWx0LCBhZHZpY2UpID0+IHtcblx0XHRcdFx0cmV0dXJuIGFkdmljZS5hcHBseSh0aGlzLCBbcHJldmlvdXNSZXN1bHRdLmNvbmNhdChhcmdzKSk7XG5cdFx0XHR9LCByZXN1bHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyogV2Ugd2FudCB0byBcImNsb25lXCIgdGhlIGFkdmljZSB0aGF0IGhhcyBiZWVuIGFwcGxpZWQgYWxyZWFkeSwgaWYgdGhpc1xuXHQgKiBqb2luUG9pbnQgaXMgYWxyZWFkeSBhZHZpc2VkICovXG5cdGlmIChkaXNwYXRjaEFkdmljZU1hcC5oYXMoam9pblBvaW50KSkge1xuXHRcdC8vIGNhbm5vdCBoYXZlIHVuZGVmaW5lZCBpbiBtYXAgZHVlIHRvIGNvZGUgbG9naWMsIHVzaW5nICFcblx0XHRjb25zdCBhZHZpY2VNYXAgPSBkaXNwYXRjaEFkdmljZU1hcC5nZXQoam9pblBvaW50KSE7XG5cdFx0bGV0IHsgYmVmb3JlLCBhZnRlciB9ID0gYWR2aWNlTWFwO1xuXHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdGJlZm9yZSA9IGJlZm9yZS5zbGljZSgwKTtcblx0XHR9XG5cdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRhZnRlciA9IGFmdGVyLnNsaWNlKDApO1xuXHRcdH1cblx0XHRkaXNwYXRjaEFkdmljZU1hcC5zZXQoZGlzcGF0Y2hlciwge1xuXHRcdFx0am9pblBvaW50OiBhZHZpY2VNYXAuam9pblBvaW50LFxuXHRcdFx0YmVmb3JlLFxuXHRcdFx0YWZ0ZXJcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHQvKiBPdGhlcndpc2UsIHRoaXMgaXMgYSBuZXcgam9pblBvaW50LCBzbyB3ZSB3aWxsIGNyZWF0ZSB0aGUgYWR2aWNlIG1hcCBhZnJlc2ggKi9cblx0XHRkaXNwYXRjaEFkdmljZU1hcC5zZXQoZGlzcGF0Y2hlciwgeyBqb2luUG9pbnQgfSk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGF0Y2hlciBhcyBGO1xufVxuXG4vKipcbiAqIEFwcGx5IGFkdmljZSAqYWZ0ZXIqIHRoZSBzdXBwbGllZCBqb2luUG9pbnQgKGZ1bmN0aW9uKVxuICpcbiAqIEBwYXJhbSBqb2luUG9pbnQgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBoYXZlIGFkdmljZSBhcHBsaWVkIHRvXG4gKiBAcGFyYW0gYWR2aWNlIFRoZSBhZnRlciBhZHZpY2VcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJKb2luUG9pbnQ8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxUPiwgVD4oam9pblBvaW50OiBGLCBhZHZpY2U6IEpvaW5Qb2ludEFmdGVyQWR2aWNlPFQ+KTogRiB7XG5cdHJldHVybiBhZHZpc2VKb2luUG9pbnQoam9pblBvaW50LCAnYWZ0ZXInLCBhZHZpY2UpO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIFwiYWZ0ZXJcIiBhZHZpY2UgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqIFRoZSBhZHZpc2luZyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG9yaWdpbmFsIG1ldGhvZCdzIHJldHVybiB2YWx1ZSBhbmQgYXJndW1lbnRzIG9iamVjdC5cbiAqIFRoZSB2YWx1ZSBpdCByZXR1cm5zIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGUgbWV0aG9kIHdoZW4gaXQgaXMgY2FsbGVkIChldmVuIGlmIHRoZSByZXR1cm4gdmFsdWUgaXMgdW5kZWZpbmVkKS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB3aG9zZSBtZXRob2Qgd2lsbCBiZSBhc3BlY3RlZFxuICogQHBhcmFtIG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2QgdG8gYXNwZWN0XG4gKiBAcGFyYW0gYWR2aWNlIEFkdmlzaW5nIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgb3JpZ2luYWwgbWV0aG9kJ3MgcmV0dXJuIHZhbHVlIGFuZCBhcmd1bWVudHMgb2JqZWN0XG4gKiBAcmV0dXJuIEEgaGFuZGxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBhc3BlY3Qgd2hlbiBkZXN0cm95IGlzIGNhbGxlZFxuICovXG5mdW5jdGlvbiBhZnRlck9iamVjdChcblx0dGFyZ2V0OiBUYXJnZXRhYmxlLFxuXHRtZXRob2ROYW1lOiBzdHJpbmcgfCBzeW1ib2wsXG5cdGFkdmljZTogKG9yaWdpbmFsUmV0dXJuOiBhbnksIG9yaWdpbmFsQXJnczogSUFyZ3VtZW50cykgPT4gYW55XG4pOiBIYW5kbGUge1xuXHRyZXR1cm4gYWR2aXNlT2JqZWN0KGdldERpc3BhdGNoZXJPYmplY3QodGFyZ2V0LCBtZXRob2ROYW1lKSwgJ2FmdGVyJywgYWR2aWNlKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBcImFmdGVyXCIgYWR2aWNlIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gKiBUaGUgYWR2aXNpbmcgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBvcmlnaW5hbCBtZXRob2QncyByZXR1cm4gdmFsdWUgYW5kIGFyZ3VtZW50cyBvYmplY3QuXG4gKiBUaGUgdmFsdWUgaXQgcmV0dXJucyB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhlIG1ldGhvZCB3aGVuIGl0IGlzIGNhbGxlZCAoZXZlbiBpZiB0aGUgcmV0dXJuIHZhbHVlIGlzIHVuZGVmaW5lZCkuXG4gKlxuICogQHBhcmFtIHRhcmdldCBPYmplY3Qgd2hvc2UgbWV0aG9kIHdpbGwgYmUgYXNwZWN0ZWRcbiAqIEBwYXJhbSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kIHRvIGFzcGVjdFxuICogQHBhcmFtIGFkdmljZSBBZHZpc2luZyBmdW5jdGlvbiB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIG9yaWdpbmFsIG1ldGhvZCdzIHJldHVybiB2YWx1ZSBhbmQgYXJndW1lbnRzIG9iamVjdFxuICogQHJldHVybiBBIGhhbmRsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYXNwZWN0IHdoZW4gZGVzdHJveSBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyKFxuXHR0YXJnZXQ6IFRhcmdldGFibGUsXG5cdG1ldGhvZE5hbWU6IHN0cmluZyB8IHN5bWJvbCxcblx0YWR2aWNlOiAob3JpZ2luYWxSZXR1cm46IGFueSwgb3JpZ2luYWxBcmdzOiBJQXJndW1lbnRzKSA9PiBhbnlcbik6IEhhbmRsZTtcbi8qKlxuICogQXBwbHkgYWR2aWNlICphZnRlciogdGhlIHN1cHBsaWVkIGpvaW5Qb2ludCAoZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGhhdmUgYWR2aWNlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGFmdGVyIGFkdmljZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXI8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxUPiwgVD4oam9pblBvaW50OiBGLCBhZHZpY2U6IEpvaW5Qb2ludEFmdGVyQWR2aWNlPFQ+KTogRjtcbmV4cG9ydCBmdW5jdGlvbiBhZnRlcjxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihcblx0am9pblBvaW50T3JUYXJnZXQ6IEYgfCBUYXJnZXRhYmxlLFxuXHRtZXRob2ROYW1lT3JBZHZpY2U6IHN0cmluZyB8IHN5bWJvbCB8IEpvaW5Qb2ludEFmdGVyQWR2aWNlPFQ+LFxuXHRvYmplY3RBZHZpY2U/OiAob3JpZ2luYWxSZXR1cm46IGFueSwgb3JpZ2luYWxBcmdzOiBJQXJndW1lbnRzKSA9PiBhbnlcbik6IEhhbmRsZSB8IEYge1xuXHRpZiAodHlwZW9mIGpvaW5Qb2ludE9yVGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGFmdGVySm9pblBvaW50KGpvaW5Qb2ludE9yVGFyZ2V0LCA8Sm9pblBvaW50QWZ0ZXJBZHZpY2U8VD4+bWV0aG9kTmFtZU9yQWR2aWNlKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gYWZ0ZXJPYmplY3Qoam9pblBvaW50T3JUYXJnZXQsIDxzdHJpbmcgfCBzeW1ib2w+bWV0aG9kTmFtZU9yQWR2aWNlLCBvYmplY3RBZHZpY2UhKTtcblx0fVxufVxuXG4vKipcbiAqIEFwcGx5IGFkdmljZSAqYXJvdW5kKiB0aGUgc3VwcGxpZWQgam9pblBvaW50IChmdW5jdGlvbilcbiAqXG4gKiBAcGFyYW0gam9pblBvaW50IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgaGF2ZSBhZHZpY2UgYXBwbGllZCB0b1xuICogQHBhcmFtIGFkdmljZSBUaGUgYXJvdW5kIGFkdmljZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJvdW5kSm9pblBvaW50PEYgZXh0ZW5kcyBHZW5lcmljRnVuY3Rpb248VD4sIFQ+KGpvaW5Qb2ludDogRiwgYWR2aWNlOiBKb2luUG9pbnRBcm91bmRBZHZpY2U8VD4pOiBGIHtcblx0cmV0dXJuIGFkdmlzZUpvaW5Qb2ludDxGLCBUPihqb2luUG9pbnQsICdhcm91bmQnLCBhZHZpY2UpO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIFwiYXJvdW5kXCIgYWR2aWNlIGFyb3VuZCB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHdob3NlIG1ldGhvZCB3aWxsIGJlIGFzcGVjdGVkXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZCB0byBhc3BlY3RcbiAqIEBwYXJhbSBhZHZpY2UgQWR2aXNpbmcgZnVuY3Rpb24gd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBvcmlnaW5hbCBmdW5jdGlvblxuICogQHJldHVybiBBIGhhbmRsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYXNwZWN0IHdoZW4gZGVzdHJveSBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyb3VuZE9iamVjdChcblx0dGFyZ2V0OiBUYXJnZXRhYmxlLFxuXHRtZXRob2ROYW1lOiBzdHJpbmcgfCBzeW1ib2wsXG5cdGFkdmljZTogKChwcmV2aW91czogRnVuY3Rpb24pID0+IEZ1bmN0aW9uKVxuKTogSGFuZGxlIHtcblx0bGV0IGRpc3BhdGNoZXI6IERpc3BhdGNoZXIgfCB1bmRlZmluZWQgPSBnZXREaXNwYXRjaGVyT2JqZWN0KHRhcmdldCwgbWV0aG9kTmFtZSk7XG5cdGxldCBwcmV2aW91cyA9IGRpc3BhdGNoZXIuYXJvdW5kO1xuXHRsZXQgYWR2aXNlZDogRnVuY3Rpb24gfCB1bmRlZmluZWQ7XG5cdGlmIChhZHZpY2UpIHtcblx0XHRhZHZpc2VkID0gYWR2aWNlKGZ1bmN0aW9uKHRoaXM6IERpc3BhdGNoZXIpOiBhbnkge1xuXHRcdFx0aWYgKHByZXZpb3VzICYmIHByZXZpb3VzLmFkdmljZSkge1xuXHRcdFx0XHRyZXR1cm4gcHJldmlvdXMuYWR2aWNlKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRkaXNwYXRjaGVyLmFyb3VuZCA9IHtcblx0XHRhZHZpY2U6IGZ1bmN0aW9uKHRhcmdldDogYW55LCBhcmdzOiBhbnlbXSk6IGFueSB7XG5cdFx0XHRyZXR1cm4gYWR2aXNlZCA/IGFkdmlzZWQuYXBwbHkodGFyZ2V0LCBhcmdzKSA6IHByZXZpb3VzICYmIHByZXZpb3VzLmFkdmljZSAmJiBwcmV2aW91cy5hZHZpY2UodGFyZ2V0LCBhcmdzKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGNyZWF0ZUhhbmRsZShmdW5jdGlvbigpIHtcblx0XHRhZHZpc2VkID0gZGlzcGF0Y2hlciA9IHVuZGVmaW5lZDtcblx0fSk7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgXCJhcm91bmRcIiBhZHZpY2UgYXJvdW5kIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gKlxuICogQHBhcmFtIHRhcmdldCBPYmplY3Qgd2hvc2UgbWV0aG9kIHdpbGwgYmUgYXNwZWN0ZWRcbiAqIEBwYXJhbSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kIHRvIGFzcGVjdFxuICogQHBhcmFtIGFkdmljZSBBZHZpc2luZyBmdW5jdGlvbiB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIEEgaGFuZGxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBhc3BlY3Qgd2hlbiBkZXN0cm95IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJvdW5kKFxuXHR0YXJnZXQ6IFRhcmdldGFibGUsXG5cdG1ldGhvZE5hbWU6IHN0cmluZyB8IHN5bWJvbCxcblx0YWR2aWNlOiAoKHByZXZpb3VzOiBGdW5jdGlvbikgPT4gRnVuY3Rpb24pXG4pOiBIYW5kbGU7XG4vKipcbiAqIEFwcGx5IGFkdmljZSAqYXJvdW5kKiB0aGUgc3VwcGxpZWQgam9pblBvaW50IChmdW5jdGlvbilcbiAqXG4gKiBAcGFyYW0gam9pblBvaW50IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgaGF2ZSBhZHZpY2UgYXBwbGllZCB0b1xuICogQHBhcmFtIGFkdmljZSBUaGUgYXJvdW5kIGFkdmljZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJvdW5kPEYgZXh0ZW5kcyBHZW5lcmljRnVuY3Rpb248VD4sIFQ+KGpvaW5Qb2ludDogRiwgYWR2aWNlOiBKb2luUG9pbnRBcm91bmRBZHZpY2U8VD4pOiBGO1xuZXhwb3J0IGZ1bmN0aW9uIGFyb3VuZDxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihcblx0am9pblBvaW50T3JUYXJnZXQ6IEYgfCBUYXJnZXRhYmxlLFxuXHRtZXRob2ROYW1lT3JBZHZpY2U6IHN0cmluZyB8IHN5bWJvbCB8IEpvaW5Qb2ludEFyb3VuZEFkdmljZTxUPixcblx0b2JqZWN0QWR2aWNlPzogKChwcmV2aW91czogRnVuY3Rpb24pID0+IEZ1bmN0aW9uKVxuKTogSGFuZGxlIHwgRiB7XG5cdGlmICh0eXBlb2Ygam9pblBvaW50T3JUYXJnZXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYXJvdW5kSm9pblBvaW50KGpvaW5Qb2ludE9yVGFyZ2V0LCA8Sm9pblBvaW50QXJvdW5kQWR2aWNlPFQ+Pm1ldGhvZE5hbWVPckFkdmljZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGFyb3VuZE9iamVjdChqb2luUG9pbnRPclRhcmdldCwgPHN0cmluZyB8IHN5bWJvbD5tZXRob2ROYW1lT3JBZHZpY2UsIG9iamVjdEFkdmljZSEpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbHkgYWR2aWNlICpiZWZvcmUqIHRoZSBzdXBwbGllZCBqb2luUG9pbnQgKGZ1bmN0aW9uKVxuICpcbiAqIEBwYXJhbSBqb2luUG9pbnQgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBoYXZlIGFkdmljZSBhcHBsaWVkIHRvXG4gKiBAcGFyYW0gYWR2aWNlIFRoZSBiZWZvcmUgYWR2aWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVKb2luUG9pbnQ8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxhbnk+Pihqb2luUG9pbnQ6IEYsIGFkdmljZTogSm9pblBvaW50QmVmb3JlQWR2aWNlKTogRiB7XG5cdHJldHVybiBhZHZpc2VKb2luUG9pbnQoam9pblBvaW50LCAnYmVmb3JlJywgYWR2aWNlKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBcImJlZm9yZVwiIGFkdmljZSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB3aG9zZSBtZXRob2Qgd2lsbCBiZSBhc3BlY3RlZFxuICogQHBhcmFtIG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2QgdG8gYXNwZWN0XG4gKiBAcGFyYW0gYWR2aWNlIEFkdmlzaW5nIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG9yaWdpbmFsLCBhbmQgbWF5IHJldHVybiBuZXcgYXJndW1lbnRzXG4gKiBAcmV0dXJuIEEgaGFuZGxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBhc3BlY3Qgd2hlbiBkZXN0cm95IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlT2JqZWN0KFxuXHR0YXJnZXQ6IFRhcmdldGFibGUsXG5cdG1ldGhvZE5hbWU6IHN0cmluZyB8IHN5bWJvbCxcblx0YWR2aWNlOiAoLi4ub3JpZ2luYWxBcmdzOiBhbnlbXSkgPT4gYW55W10gfCB2b2lkXG4pOiBIYW5kbGUge1xuXHRyZXR1cm4gYWR2aXNlT2JqZWN0KGdldERpc3BhdGNoZXJPYmplY3QodGFyZ2V0LCBtZXRob2ROYW1lKSwgJ2JlZm9yZScsIGFkdmljZSk7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgXCJiZWZvcmVcIiBhZHZpY2UgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gKlxuICogQHBhcmFtIHRhcmdldCBPYmplY3Qgd2hvc2UgbWV0aG9kIHdpbGwgYmUgYXNwZWN0ZWRcbiAqIEBwYXJhbSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kIHRvIGFzcGVjdFxuICogQHBhcmFtIGFkdmljZSBBZHZpc2luZyBmdW5jdGlvbiB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoZSBvcmlnaW5hbCwgYW5kIG1heSByZXR1cm4gbmV3IGFyZ3VtZW50c1xuICogQHJldHVybiBBIGhhbmRsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYXNwZWN0IHdoZW4gZGVzdHJveSBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZShcblx0dGFyZ2V0OiBUYXJnZXRhYmxlLFxuXHRtZXRob2ROYW1lOiBzdHJpbmcgfCBzeW1ib2wsXG5cdGFkdmljZTogKC4uLm9yaWdpbmFsQXJnczogYW55W10pID0+IGFueVtdIHwgdm9pZFxuKTogSGFuZGxlO1xuLyoqXG4gKiBBcHBseSBhZHZpY2UgKmJlZm9yZSogdGhlIHN1cHBsaWVkIGpvaW5Qb2ludCAoZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGhhdmUgYWR2aWNlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGJlZm9yZSBhZHZpY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZTxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPGFueT4+KGpvaW5Qb2ludDogRiwgYWR2aWNlOiBKb2luUG9pbnRCZWZvcmVBZHZpY2UpOiBGO1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZTxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihcblx0am9pblBvaW50T3JUYXJnZXQ6IEYgfCBUYXJnZXRhYmxlLFxuXHRtZXRob2ROYW1lT3JBZHZpY2U6IHN0cmluZyB8IHN5bWJvbCB8IEpvaW5Qb2ludEJlZm9yZUFkdmljZSxcblx0b2JqZWN0QWR2aWNlPzogKCguLi5vcmlnaW5hbEFyZ3M6IGFueVtdKSA9PiBhbnlbXSB8IHZvaWQpXG4pOiBIYW5kbGUgfCBGIHtcblx0aWYgKHR5cGVvZiBqb2luUG9pbnRPclRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBiZWZvcmVKb2luUG9pbnQoam9pblBvaW50T3JUYXJnZXQsIDxKb2luUG9pbnRCZWZvcmVBZHZpY2U+bWV0aG9kTmFtZU9yQWR2aWNlKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gYmVmb3JlT2JqZWN0KGpvaW5Qb2ludE9yVGFyZ2V0LCA8c3RyaW5nIHwgc3ltYm9sPm1ldGhvZE5hbWVPckFkdmljZSwgb2JqZWN0QWR2aWNlISk7XG5cdH1cbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhZHZpY2UgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqIFRoZSBhZHZpc2luZyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gKiBUaGUgdmFsdWUgaXQgcmV0dXJucyB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhlIG1ldGhvZCB3aGVuIGl0IGlzIGNhbGxlZCAqdW5sZXNzKiBpdHMgcmV0dXJuIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB3aG9zZSBtZXRob2Qgd2lsbCBiZSBhc3BlY3RlZFxuICogQHBhcmFtIG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2QgdG8gYXNwZWN0XG4gKiBAcGFyYW0gYWR2aWNlIEFkdmlzaW5nIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG9yaWdpbmFsIG1ldGhvZFxuICogQHJldHVybiBBIGhhbmRsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYXNwZWN0IHdoZW4gZGVzdHJveSBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uKHRhcmdldDogVGFyZ2V0YWJsZSwgbWV0aG9kTmFtZTogc3RyaW5nIHwgc3ltYm9sLCBhZHZpY2U6ICguLi5vcmlnaW5hbEFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRyZXR1cm4gYWR2aXNlT2JqZWN0KGdldERpc3BhdGNoZXJPYmplY3QodGFyZ2V0LCBtZXRob2ROYW1lKSwgJ2FmdGVyJywgYWR2aWNlLCB0cnVlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhc3BlY3QudHMiLCJpbXBvcnQgaGFzLCB7IGFkZCB9IGZyb20gJ0Bkb2pvL2hhcy9oYXMnO1xuaW1wb3J0IGdsb2JhbCBmcm9tICcuLi9nbG9iYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBoYXM7XG5leHBvcnQgKiBmcm9tICdAZG9qby9oYXMvaGFzJztcblxuLyogRUNNQVNjcmlwdCA2IGFuZCA3IEZlYXR1cmVzICovXG5cbi8qIEFycmF5ICovXG5hZGQoXG5cdCdlczYtYXJyYXknLFxuXHQoKSA9PiB7XG5cdFx0cmV0dXJuIChcblx0XHRcdFsnZnJvbScsICdvZiddLmV2ZXJ5KChrZXkpID0+IGtleSBpbiBnbG9iYWwuQXJyYXkpICYmXG5cdFx0XHRbJ2ZpbmRJbmRleCcsICdmaW5kJywgJ2NvcHlXaXRoaW4nXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gZ2xvYmFsLkFycmF5LnByb3RvdHlwZSlcblx0XHQpO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG5hZGQoXG5cdCdlczYtYXJyYXktZmlsbCcsXG5cdCgpID0+IHtcblx0XHRpZiAoJ2ZpbGwnIGluIGdsb2JhbC5BcnJheS5wcm90b3R5cGUpIHtcblx0XHRcdC8qIFNvbWUgdmVyc2lvbnMgb2YgU2FmYXJpIGRvIG5vdCBwcm9wZXJseSBpbXBsZW1lbnQgdGhpcyAqL1xuXHRcdFx0cmV0dXJuICg8YW55PlsxXSkuZmlsbCg5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpWzBdID09PSAxO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdHRydWVcbik7XG5cbmFkZCgnZXM3LWFycmF5JywgKCkgPT4gJ2luY2x1ZGVzJyBpbiBnbG9iYWwuQXJyYXkucHJvdG90eXBlLCB0cnVlKTtcblxuLyogTWFwICovXG5hZGQoXG5cdCdlczYtbWFwJyxcblx0KCkgPT4ge1xuXHRcdGlmICh0eXBlb2YgZ2xvYmFsLk1hcCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Lypcblx0XHRJRTExIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgYXJlIG1pc3NpbmcgY3JpdGljYWwgRVM2IE1hcCBmdW5jdGlvbmFsaXR5XG5cdFx0V2Ugd3JhcCB0aGlzIGluIGEgdHJ5L2NhdGNoIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBNYXAgY29uc3RydWN0b3IgZXhpc3RzLCBidXQgZG9lcyBub3Rcblx0XHR0YWtlIGFyZ3VtZW50cyAoaU9TIDguNClcblx0XHQgKi9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IG1hcCA9IG5ldyBnbG9iYWwuTWFwKFtbMCwgMV1dKTtcblxuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdG1hcC5oYXMoMCkgJiZcblx0XHRcdFx0XHR0eXBlb2YgbWFwLmtleXMgPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0XHRoYXMoJ2VzNi1zeW1ib2wnKSAmJlxuXHRcdFx0XHRcdHR5cGVvZiBtYXAudmFsdWVzID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdFx0dHlwZW9mIG1hcC5lbnRyaWVzID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgdGVzdGluZyBvbiBpT1MgYXQgdGhlIG1vbWVudCAqL1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuLyogTWF0aCAqL1xuYWRkKFxuXHQnZXM2LW1hdGgnLFxuXHQoKSA9PiB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCdjbHozMicsXG5cdFx0XHQnc2lnbicsXG5cdFx0XHQnbG9nMTAnLFxuXHRcdFx0J2xvZzInLFxuXHRcdFx0J2xvZzFwJyxcblx0XHRcdCdleHBtMScsXG5cdFx0XHQnY29zaCcsXG5cdFx0XHQnc2luaCcsXG5cdFx0XHQndGFuaCcsXG5cdFx0XHQnYWNvc2gnLFxuXHRcdFx0J2FzaW5oJyxcblx0XHRcdCdhdGFuaCcsXG5cdFx0XHQndHJ1bmMnLFxuXHRcdFx0J2Zyb3VuZCcsXG5cdFx0XHQnY2JydCcsXG5cdFx0XHQnaHlwb3QnXG5cdFx0XS5ldmVyeSgobmFtZSkgPT4gdHlwZW9mIGdsb2JhbC5NYXRoW25hbWVdID09PSAnZnVuY3Rpb24nKTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuYWRkKFxuXHQnZXM2LW1hdGgtaW11bCcsXG5cdCgpID0+IHtcblx0XHRpZiAoJ2ltdWwnIGluIGdsb2JhbC5NYXRoKSB7XG5cdFx0XHQvKiBTb21lIHZlcnNpb25zIG9mIFNhZmFyaSBvbiBpb3MgZG8gbm90IHByb3Blcmx5IGltcGxlbWVudCB0aGlzICovXG5cdFx0XHRyZXR1cm4gKDxhbnk+TWF0aCkuaW11bCgweGZmZmZmZmZmLCA1KSA9PT0gLTU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuLyogT2JqZWN0ICovXG5hZGQoXG5cdCdlczYtb2JqZWN0Jyxcblx0KCkgPT4ge1xuXHRcdHJldHVybiAoXG5cdFx0XHRoYXMoJ2VzNi1zeW1ib2wnKSAmJlxuXHRcdFx0Wydhc3NpZ24nLCAnaXMnLCAnZ2V0T3duUHJvcGVydHlTeW1ib2xzJywgJ3NldFByb3RvdHlwZU9mJ10uZXZlcnkoXG5cdFx0XHRcdChuYW1lKSA9PiB0eXBlb2YgZ2xvYmFsLk9iamVjdFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cdHRydWVcbik7XG5cbmFkZChcblx0J2VzMjAxNy1vYmplY3QnLFxuXHQoKSA9PiB7XG5cdFx0cmV0dXJuIFsndmFsdWVzJywgJ2VudHJpZXMnLCAnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyddLmV2ZXJ5KFxuXHRcdFx0KG5hbWUpID0+IHR5cGVvZiBnbG9iYWwuT2JqZWN0W25hbWVdID09PSAnZnVuY3Rpb24nXG5cdFx0KTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuLyogT2JzZXJ2YWJsZSAqL1xuYWRkKCdlcy1vYnNlcnZhYmxlJywgKCkgPT4gdHlwZW9mIGdsb2JhbC5PYnNlcnZhYmxlICE9PSAndW5kZWZpbmVkJywgdHJ1ZSk7XG5cbi8qIFByb21pc2UgKi9cbmFkZCgnZXM2LXByb21pc2UnLCAoKSA9PiB0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGhhcygnZXM2LXN5bWJvbCcpLCB0cnVlKTtcblxuLyogU2V0ICovXG5hZGQoXG5cdCdlczYtc2V0Jyxcblx0KCkgPT4ge1xuXHRcdGlmICh0eXBlb2YgZ2xvYmFsLlNldCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0LyogSUUxMSBhbmQgb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIGFyZSBtaXNzaW5nIGNyaXRpY2FsIEVTNiBTZXQgZnVuY3Rpb25hbGl0eSAqL1xuXHRcdFx0Y29uc3Qgc2V0ID0gbmV3IGdsb2JhbC5TZXQoWzFdKTtcblx0XHRcdHJldHVybiBzZXQuaGFzKDEpICYmICdrZXlzJyBpbiBzZXQgJiYgdHlwZW9mIHNldC5rZXlzID09PSAnZnVuY3Rpb24nICYmIGhhcygnZXM2LXN5bWJvbCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdHRydWVcbik7XG5cbi8qIFN0cmluZyAqL1xuYWRkKFxuXHQnZXM2LXN0cmluZycsXG5cdCgpID0+IHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0W1xuXHRcdFx0XHQvKiBzdGF0aWMgbWV0aG9kcyAqL1xuXHRcdFx0XHQnZnJvbUNvZGVQb2ludCdcblx0XHRcdF0uZXZlcnkoKGtleSkgPT4gdHlwZW9mIGdsb2JhbC5TdHJpbmdba2V5XSA9PT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdFtcblx0XHRcdFx0LyogaW5zdGFuY2UgbWV0aG9kcyAqL1xuXHRcdFx0XHQnY29kZVBvaW50QXQnLFxuXHRcdFx0XHQnbm9ybWFsaXplJyxcblx0XHRcdFx0J3JlcGVhdCcsXG5cdFx0XHRcdCdzdGFydHNXaXRoJyxcblx0XHRcdFx0J2VuZHNXaXRoJyxcblx0XHRcdFx0J2luY2x1ZGVzJ1xuXHRcdFx0XS5ldmVyeSgoa2V5KSA9PiB0eXBlb2YgZ2xvYmFsLlN0cmluZy5wcm90b3R5cGVba2V5XSA9PT0gJ2Z1bmN0aW9uJylcblx0XHQpO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG5hZGQoXG5cdCdlczYtc3RyaW5nLXJhdycsXG5cdCgpID0+IHtcblx0XHRmdW5jdGlvbiBnZXRDYWxsU2l0ZShjYWxsU2l0ZTogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnN1YnN0aXR1dGlvbnM6IGFueVtdKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBbLi4uY2FsbFNpdGVdO1xuXHRcdFx0KHJlc3VsdCBhcyBhbnkpLnJhdyA9IGNhbGxTaXRlLnJhdztcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0aWYgKCdyYXcnIGluIGdsb2JhbC5TdHJpbmcpIHtcblx0XHRcdGxldCBiID0gMTtcblx0XHRcdGxldCBjYWxsU2l0ZSA9IGdldENhbGxTaXRlYGFcXG4ke2J9YDtcblxuXHRcdFx0KGNhbGxTaXRlIGFzIGFueSkucmF3ID0gWydhXFxcXG4nXTtcblx0XHRcdGNvbnN0IHN1cHBvcnRzVHJ1bmMgPSBnbG9iYWwuU3RyaW5nLnJhdyhjYWxsU2l0ZSwgNDIpID09PSAnYTpcXFxcbic7XG5cblx0XHRcdHJldHVybiBzdXBwb3J0c1RydW5jO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuYWRkKFxuXHQnZXMyMDE3LXN0cmluZycsXG5cdCgpID0+IHtcblx0XHRyZXR1cm4gWydwYWRTdGFydCcsICdwYWRFbmQnXS5ldmVyeSgoa2V5KSA9PiB0eXBlb2YgZ2xvYmFsLlN0cmluZy5wcm90b3R5cGVba2V5XSA9PT0gJ2Z1bmN0aW9uJyk7XG5cdH0sXG5cdHRydWVcbik7XG5cbi8qIFN5bWJvbCAqL1xuYWRkKCdlczYtc3ltYm9sJywgKCkgPT4gdHlwZW9mIGdsb2JhbC5TeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2woKSA9PT0gJ3N5bWJvbCcsIHRydWUpO1xuXG4vKiBXZWFrTWFwICovXG5hZGQoXG5cdCdlczYtd2Vha21hcCcsXG5cdCgpID0+IHtcblx0XHRpZiAodHlwZW9mIGdsb2JhbC5XZWFrTWFwICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0LyogSUUxMSBhbmQgb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIGFyZSBtaXNzaW5nIGNyaXRpY2FsIEVTNiBNYXAgZnVuY3Rpb25hbGl0eSAqL1xuXHRcdFx0Y29uc3Qga2V5MSA9IHt9O1xuXHRcdFx0Y29uc3Qga2V5MiA9IHt9O1xuXHRcdFx0Y29uc3QgbWFwID0gbmV3IGdsb2JhbC5XZWFrTWFwKFtba2V5MSwgMV1dKTtcblx0XHRcdE9iamVjdC5mcmVlemUoa2V5MSk7XG5cdFx0XHRyZXR1cm4gbWFwLmdldChrZXkxKSA9PT0gMSAmJiBtYXAuc2V0KGtleTIsIDIpID09PSBtYXAgJiYgaGFzKCdlczYtc3ltYm9sJyk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuLyogTWlzY2VsbGFuZW91cyBmZWF0dXJlcyAqL1xuYWRkKCdtaWNyb3Rhc2tzJywgKCkgPT4gaGFzKCdlczYtcHJvbWlzZScpIHx8IGhhcygnaG9zdC1ub2RlJykgfHwgaGFzKCdkb20tbXV0YXRpb25vYnNlcnZlcicpLCB0cnVlKTtcbmFkZChcblx0J3Bvc3RtZXNzYWdlJyxcblx0KCkgPT4ge1xuXHRcdC8vIElmIHdpbmRvdyBpcyB1bmRlZmluZWQsIGFuZCB3ZSBoYXZlIHBvc3RNZXNzYWdlLCBpdCBwcm9iYWJseSBtZWFucyB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIuIFdlYiB3b3JrZXJzIGhhdmVcblx0XHQvLyBwb3N0IG1lc3NhZ2UgYnV0IGl0IGRvZXNuJ3Qgd29yayBob3cgd2UgZXhwZWN0IGl0IHRvLCBzbyBpdCdzIGJlc3QganVzdCB0byBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG5cdFx0cmV0dXJuIHR5cGVvZiBnbG9iYWwud2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nO1xuXHR9LFxuXHR0cnVlXG4pO1xuYWRkKCdyYWYnLCAoKSA9PiB0eXBlb2YgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJywgdHJ1ZSk7XG5hZGQoJ3NldGltbWVkaWF0ZScsICgpID0+IHR5cGVvZiBnbG9iYWwuc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJywgdHJ1ZSk7XG5cbi8qIERPTSBGZWF0dXJlcyAqL1xuXG5hZGQoXG5cdCdkb20tbXV0YXRpb25vYnNlcnZlcicsXG5cdCgpID0+IHtcblx0XHRpZiAoaGFzKCdob3N0LWJyb3dzZXInKSAmJiBCb29sZWFuKGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKSkge1xuXHRcdFx0Ly8gSUUxMSBoYXMgYW4gdW5yZWxpYWJsZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIHdoZXJlIHNldFByb3BlcnR5KCkgZG9lcyBub3Rcblx0XHRcdC8vIGdlbmVyYXRlIGEgbXV0YXRpb24gZXZlbnQsIG9ic2VydmVycyBjYW4gY3Jhc2gsIGFuZCB0aGUgcXVldWUgZG9lcyBub3QgZHJhaW5cblx0XHRcdC8vIHJlbGlhYmx5LiBUaGUgZm9sbG93aW5nIGZlYXR1cmUgdGVzdCB3YXMgYWRhcHRlZCBmcm9tXG5cdFx0XHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90MTBrby80YWNlYjhjNzE2ODFmZGIyNzVlMzNlZmU1ZTU3NmIxNFxuXHRcdFx0Y29uc3QgZXhhbXBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0LyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWUgKi9cblx0XHRcdGNvbnN0IEhvc3RNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cdFx0XHRjb25zdCBvYnNlcnZlciA9IG5ldyBIb3N0TXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHt9KTtcblx0XHRcdG9ic2VydmVyLm9ic2VydmUoZXhhbXBsZSwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuXG5cdFx0XHRleGFtcGxlLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cblx0XHRcdHJldHVybiBCb29sZWFuKG9ic2VydmVyLnRha2VSZWNvcmRzKCkubGVuZ3RoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG5hZGQoXG5cdCdkb20td2ViYW5pbWF0aW9uJyxcblx0KCkgPT4gaGFzKCdob3N0LWJyb3dzZXInKSAmJiBnbG9iYWwuQW5pbWF0aW9uICE9PSB1bmRlZmluZWQgJiYgZ2xvYmFsLktleWZyYW1lRWZmZWN0ICE9PSB1bmRlZmluZWQsXG5cdHRydWVcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gaGFzLnRzIiwiaW1wb3J0IHsgSGFuZGxlIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ0Bkb2pvL3NoaW0vb2JqZWN0JztcblxuZXhwb3J0IHsgYXNzaWduIH0gZnJvbSAnQGRvam8vc2hpbS9vYmplY3QnO1xuXG5jb25zdCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRoYXQgZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgY29lcmNlZCB0byBPYmplY3RcbiAqIHRvIHdlZWQgb3V0IGhvc3Qgb2JqZWN0cyB0aGF0IGRvIG5vdCBkZXJpdmUgZnJvbSBPYmplY3QuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBkZWVwIGNvcHkgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIE5vdGU6IEluIEVTNiBpdCBpcyBwb3NzaWJsZSB0byBtb2RpZnkgYW4gb2JqZWN0J3MgU3ltYm9sLnRvU3RyaW5nVGFnIHByb3BlcnR5LCB3aGljaCB3aWxsXG4gKiBjaGFuZ2UgdGhlIHZhbHVlIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AuIFRoaXMgaXMgYSByYXJlIGVkZ2UgY2FzZSB0aGF0IGlzIGRpZmZpY3VsdCB0byBoYW5kbGUsXG4gKiBzbyBpdCBpcyBub3QgaGFuZGxlZCBoZXJlLlxuICogQHBhcmFtICB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm4gICAgICAgSWYgdGhlIHZhbHVlIGlzIGNvZXJjaWJsZSBpbnRvIGFuIE9iamVjdFxuICovXG5mdW5jdGlvbiBzaG91bGREZWVwQ29weU9iamVjdCh2YWx1ZTogYW55KTogdmFsdWUgaXMgT2JqZWN0IHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBjb3B5QXJyYXk8VD4oYXJyYXk6IFRbXSwgaW5oZXJpdGVkOiBib29sZWFuKTogVFtdIHtcblx0cmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbihpdGVtOiBUKTogVCB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcblx0XHRcdHJldHVybiA8YW55PmNvcHlBcnJheSg8YW55Pml0ZW0sIGluaGVyaXRlZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFzaG91bGREZWVwQ29weU9iamVjdChpdGVtKVxuXHRcdFx0PyBpdGVtXG5cdFx0XHQ6IF9taXhpbih7XG5cdFx0XHRcdFx0ZGVlcDogdHJ1ZSxcblx0XHRcdFx0XHRpbmhlcml0ZWQ6IGluaGVyaXRlZCxcblx0XHRcdFx0XHRzb3VyY2VzOiA8QXJyYXk8VD4+W2l0ZW1dLFxuXHRcdFx0XHRcdHRhcmdldDogPFQ+e31cblx0XHRcdFx0fSk7XG5cdH0pO1xufVxuXG5pbnRlcmZhY2UgTWl4aW5BcmdzPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9PiB7XG5cdGRlZXA6IGJvb2xlYW47XG5cdGluaGVyaXRlZDogYm9vbGVhbjtcblx0c291cmNlczogKFUgfCBudWxsIHwgdW5kZWZpbmVkKVtdO1xuXHR0YXJnZXQ6IFQ7XG5cdGNvcGllZD86IGFueVtdO1xufVxuXG5mdW5jdGlvbiBfbWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30+KGt3QXJnczogTWl4aW5BcmdzPFQsIFU+KTogVCAmIFUge1xuXHRjb25zdCBkZWVwID0ga3dBcmdzLmRlZXA7XG5cdGNvbnN0IGluaGVyaXRlZCA9IGt3QXJncy5pbmhlcml0ZWQ7XG5cdGNvbnN0IHRhcmdldDogYW55ID0ga3dBcmdzLnRhcmdldDtcblx0Y29uc3QgY29waWVkID0ga3dBcmdzLmNvcGllZCB8fCBbXTtcblx0Y29uc3QgY29waWVkQ2xvbmUgPSBbLi4uY29waWVkXTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGt3QXJncy5zb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qgc291cmNlID0ga3dBcmdzLnNvdXJjZXNbaV07XG5cblx0XHRpZiAoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Zm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRsZXQgdmFsdWU6IGFueSA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRcdGlmIChjb3BpZWRDbG9uZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkZWVwKSB7XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGNvcHlBcnJheSh2YWx1ZSwgaW5oZXJpdGVkKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNob3VsZERlZXBDb3B5T2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGFyZ2V0VmFsdWU6IGFueSA9IHRhcmdldFtrZXldIHx8IHt9O1xuXHRcdFx0XHRcdFx0Y29waWVkLnB1c2goc291cmNlKTtcblx0XHRcdFx0XHRcdHZhbHVlID0gX21peGluKHtcblx0XHRcdFx0XHRcdFx0ZGVlcDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0aW5oZXJpdGVkOiBpbmhlcml0ZWQsXG5cdFx0XHRcdFx0XHRcdHNvdXJjZXM6IFt2YWx1ZV0sXG5cdFx0XHRcdFx0XHRcdHRhcmdldDogdGFyZ2V0VmFsdWUsXG5cdFx0XHRcdFx0XHRcdGNvcGllZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIDxUICYgVT50YXJnZXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlLCBhbmQgY29waWVzIGFsbCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlXG4gKiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgbmV3bHkgY3JlYXRlZCB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcm90b3R5cGUgVGhlIHByb3RvdHlwZSB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IGZyb21cbiAqIEBwYXJhbSBtaXhpbnMgQW55IG51bWJlciBvZiBvYmplY3RzIHdob3NlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0XG4gKiBAcmV0dXJuIFRoZSBuZXcgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8XG5cdFQgZXh0ZW5kcyB7fSxcblx0VSBleHRlbmRzIHt9LFxuXHRWIGV4dGVuZHMge30sXG5cdFcgZXh0ZW5kcyB7fSxcblx0WCBleHRlbmRzIHt9LFxuXHRZIGV4dGVuZHMge30sXG5cdFogZXh0ZW5kcyB7fVxuPihwcm90b3R5cGU6IFQsIG1peGluMTogVSwgbWl4aW4yOiBWLCBtaXhpbjM6IFcsIG1peGluNDogWCwgbWl4aW41OiBZLCBtaXhpbjY6IFopOiBUICYgVSAmIFYgJiBXICYgWCAmIFkgJiBaO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZTxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fSwgWSBleHRlbmRzIHt9Pihcblx0cHJvdG90eXBlOiBULFxuXHRtaXhpbjE6IFUsXG5cdG1peGluMjogVixcblx0bWl4aW4zOiBXLFxuXHRtaXhpbjQ6IFgsXG5cdG1peGluNTogWVxuKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZTxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fT4oXG5cdHByb3RvdHlwZTogVCxcblx0bWl4aW4xOiBVLFxuXHRtaXhpbjI6IFYsXG5cdG1peGluMzogVyxcblx0bWl4aW40OiBYXG4pOiBUICYgVSAmIFYgJiBXICYgWDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9Pihcblx0cHJvdG90eXBlOiBULFxuXHRtaXhpbjE6IFUsXG5cdG1peGluMjogVixcblx0bWl4aW4zOiBXXG4pOiBUICYgVSAmIFYgJiBXO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZTxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9Pihwcm90b3R5cGU6IFQsIG1peGluMTogVSwgbWl4aW4yOiBWKTogVCAmIFUgJiBWO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZTxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fT4ocHJvdG90eXBlOiBULCBtaXhpbjogVSk6IFQgJiBVO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZTxUIGV4dGVuZHMge30+KHByb3RvdHlwZTogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZTogYW55LCAuLi5taXhpbnM6IGFueVtdKTogYW55IHtcblx0aWYgKCFtaXhpbnMubGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xhbmcuY3JlYXRlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBtaXhpbiBvYmplY3QuJyk7XG5cdH1cblxuXHRjb25zdCBhcmdzID0gbWl4aW5zLnNsaWNlKCk7XG5cdGFyZ3MudW5zaGlmdChPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpO1xuXG5cdHJldHVybiBhc3NpZ24uYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYWxsIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2Ygb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gdGhlIHRhcmdldCBvYmplY3QsXG4gKiByZWN1cnNpdmVseSBjb3B5aW5nIGFsbCBuZXN0ZWQgb2JqZWN0cyBhbmQgYXJyYXlzIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byByZWNlaXZlIHZhbHVlcyBmcm9tIHNvdXJjZSBvYmplY3RzXG4gKiBAcGFyYW0gc291cmNlcyBBbnkgbnVtYmVyIG9mIG9iamVjdHMgd2hvc2UgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZCB0byB0aGUgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBUaGUgbW9kaWZpZWQgdGFyZ2V0IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbjxcblx0VCBleHRlbmRzIHt9LFxuXHRVIGV4dGVuZHMge30sXG5cdFYgZXh0ZW5kcyB7fSxcblx0VyBleHRlbmRzIHt9LFxuXHRYIGV4dGVuZHMge30sXG5cdFkgZXh0ZW5kcyB7fSxcblx0WiBleHRlbmRzIHt9XG4+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVywgc291cmNlNDogWCwgc291cmNlNTogWSwgc291cmNlNjogWik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fSwgWSBleHRlbmRzIHt9Pihcblx0dGFyZ2V0OiBULFxuXHRzb3VyY2UxOiBVLFxuXHRzb3VyY2UyOiBWLFxuXHRzb3VyY2UzOiBXLFxuXHRzb3VyY2U0OiBYLFxuXHRzb3VyY2U1OiBZXG4pOiBUICYgVSAmIFYgJiBXICYgWCAmIFk7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fT4oXG5cdHRhcmdldDogVCxcblx0c291cmNlMTogVSxcblx0c291cmNlMjogVixcblx0c291cmNlMzogVyxcblx0c291cmNlNDogWFxuKTogVCAmIFUgJiBWICYgVyAmIFg7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30+KFxuXHR0YXJnZXQ6IFQsXG5cdHNvdXJjZTE6IFUsXG5cdHNvdXJjZTI6IFYsXG5cdHNvdXJjZTM6IFdcbik6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9Pih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUsIHNvdXJjZTI6IFYpOiBUICYgVSAmIFY7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2U6IFUpOiBUICYgVTtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldDogYW55LCAuLi5zb3VyY2VzOiBhbnlbXSk6IGFueSB7XG5cdHJldHVybiBfbWl4aW4oe1xuXHRcdGRlZXA6IHRydWUsXG5cdFx0aW5oZXJpdGVkOiBmYWxzZSxcblx0XHRzb3VyY2VzOiBzb3VyY2VzLFxuXHRcdHRhcmdldDogdGFyZ2V0XG5cdH0pO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGFsbCBlbnVtZXJhYmxlIChvd24gb3IgaW5oZXJpdGVkKSBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogdGFyZ2V0IG9iamVjdCwgcmVjdXJzaXZlbHkgY29weWluZyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGFycmF5cyBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gcmVjZWl2ZSB2YWx1ZXMgZnJvbSBzb3VyY2Ugb2JqZWN0c1xuICogQHBhcmFtIHNvdXJjZXMgQW55IG51bWJlciBvZiBvYmplY3RzIHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZCB0byB0aGUgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBUaGUgbW9kaWZpZWQgdGFyZ2V0IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcE1peGluPFxuXHRUIGV4dGVuZHMge30sXG5cdFUgZXh0ZW5kcyB7fSxcblx0ViBleHRlbmRzIHt9LFxuXHRXIGV4dGVuZHMge30sXG5cdFggZXh0ZW5kcyB7fSxcblx0WSBleHRlbmRzIHt9LFxuXHRaIGV4dGVuZHMge31cbj4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWLCBzb3VyY2UzOiBXLCBzb3VyY2U0OiBYLCBzb3VyY2U1OiBZLCBzb3VyY2U2OiBaKTogVCAmIFUgJiBWICYgVyAmIFggJiBZICYgWjtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30sIFkgZXh0ZW5kcyB7fT4oXG5cdHRhcmdldDogVCxcblx0c291cmNlMTogVSxcblx0c291cmNlMjogVixcblx0c291cmNlMzogVyxcblx0c291cmNlNDogWCxcblx0c291cmNlNTogWVxuKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fT4oXG5cdHRhcmdldDogVCxcblx0c291cmNlMTogVSxcblx0c291cmNlMjogVixcblx0c291cmNlMzogVyxcblx0c291cmNlNDogWFxuKTogVCAmIFUgJiBWICYgVyAmIFg7XG5leHBvcnQgZnVuY3Rpb24gZGVlcE1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30sIFcgZXh0ZW5kcyB7fT4oXG5cdHRhcmdldDogVCxcblx0c291cmNlMTogVSxcblx0c291cmNlMjogVixcblx0c291cmNlMzogV1xuKTogVCAmIFUgJiBWICYgVztcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWKTogVCAmIFUgJiBWO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2U6IFUpOiBUICYgVTtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWl4aW4odGFyZ2V0OiBhbnksIC4uLnNvdXJjZXM6IGFueVtdKTogYW55IHtcblx0cmV0dXJuIF9taXhpbih7XG5cdFx0ZGVlcDogdHJ1ZSxcblx0XHRpbmhlcml0ZWQ6IHRydWUsXG5cdFx0c291cmNlczogc291cmNlcyxcblx0XHR0YXJnZXQ6IHRhcmdldFxuXHR9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB1c2luZyB0aGUgcHJvdmlkZWQgc291cmNlJ3MgcHJvdG90eXBlIGFzIHRoZSBwcm90b3R5cGUgZm9yIHRoZSBuZXcgb2JqZWN0LCBhbmQgdGhlblxuICogZGVlcCBjb3BpZXMgdGhlIHByb3ZpZGVkIHNvdXJjZSdzIHZhbHVlcyBpbnRvIHRoZSBuZXcgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgVGhlIG9iamVjdCB0byBkdXBsaWNhdGVcbiAqIEByZXR1cm4gVGhlIG5ldyBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGR1cGxpY2F0ZTxUIGV4dGVuZHMge30+KHNvdXJjZTogVCk6IFQge1xuXHRjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcblxuXHRyZXR1cm4gZGVlcE1peGluKHRhcmdldCwgc291cmNlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGEgRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICogQHBhcmFtIGIgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSB0aGUgc2FtZTsgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lkZW50aWNhbChhOiBhbnksIGI6IGFueSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gKFxuXHRcdGEgPT09IGIgfHxcblx0XHQvKiBib3RoIHZhbHVlcyBhcmUgTmFOICovXG5cdFx0KGEgIT09IGEgJiYgYiAhPT0gYilcblx0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBiaW5kcyBhIG1ldGhvZCB0byB0aGUgc3BlY2lmaWVkIG9iamVjdCBhdCBydW50aW1lLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAqIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAsIGJ1dCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gaXQgdGFrZXMgdGhlIG5hbWUgb2YgYSBtZXRob2Qgb24gYW4gb2JqZWN0LlxuICogQXMgYSByZXN1bHQsIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBgbGF0ZUJpbmRgIHdpbGwgYWx3YXlzIGNhbGwgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBhc3NpZ25lZCB0b1xuICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0IGFzIG9mIHRoZSBtb21lbnQgdGhlIGZ1bmN0aW9uIGl0IHJldHVybnMgaXMgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvbiB0aGUgY29udGV4dCBvYmplY3QgdG8gYmluZCB0byBpdHNlbGZcbiAqIEBwYXJhbSBzdXBwbGllZEFyZ3MgQW4gb3B0aW9uYWwgYXJyYXkgb2YgdmFsdWVzIHRvIHByZXBlbmQgdG8gdGhlIGBpbnN0YW5jZVttZXRob2RdYCBhcmd1bWVudHMgbGlzdFxuICogQHJldHVybiBUaGUgYm91bmQgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhdGVCaW5kKGluc3RhbmNlOiB7fSwgbWV0aG9kOiBzdHJpbmcsIC4uLnN1cHBsaWVkQXJnczogYW55W10pOiAoLi4uYXJnczogYW55W10pID0+IGFueSB7XG5cdHJldHVybiBzdXBwbGllZEFyZ3MubGVuZ3RoXG5cdFx0PyBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgYXJnczogYW55W10gPSBhcmd1bWVudHMubGVuZ3RoID8gc3VwcGxpZWRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogc3VwcGxpZWRBcmdzO1xuXG5cdFx0XHRcdC8vIFRTNzAxN1xuXHRcdFx0XHRyZXR1cm4gKDxhbnk+aW5zdGFuY2UpW21ldGhvZF0uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRTNzAxN1xuXHRcdFx0XHRyZXR1cm4gKDxhbnk+aW5zdGFuY2UpW21ldGhvZF0uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGFsbCBlbnVtZXJhYmxlIChvd24gb3IgaW5oZXJpdGVkKSBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIFRoZSBtb2RpZmllZCB0YXJnZXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fSwgWSBleHRlbmRzIHt9LCBaIGV4dGVuZHMge30+KFxuXHR0YXJnZXQ6IFQsXG5cdHNvdXJjZTE6IFUsXG5cdHNvdXJjZTI6IFYsXG5cdHNvdXJjZTM6IFcsXG5cdHNvdXJjZTQ6IFgsXG5cdHNvdXJjZTU6IFksXG5cdHNvdXJjZTY6IFpcbik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gbWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30sIFkgZXh0ZW5kcyB7fT4oXG5cdHRhcmdldDogVCxcblx0c291cmNlMTogVSxcblx0c291cmNlMjogVixcblx0c291cmNlMzogVyxcblx0c291cmNlNDogWCxcblx0c291cmNlNTogWVxuKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30sIFcgZXh0ZW5kcyB7fSwgWCBleHRlbmRzIHt9Pihcblx0dGFyZ2V0OiBULFxuXHRzb3VyY2UxOiBVLFxuXHRzb3VyY2UyOiBWLFxuXHRzb3VyY2UzOiBXLFxuXHRzb3VyY2U0OiBYXG4pOiBUICYgVSAmIFYgJiBXICYgWDtcbmV4cG9ydCBmdW5jdGlvbiBtaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30+KFxuXHR0YXJnZXQ6IFQsXG5cdHNvdXJjZTE6IFUsXG5cdHNvdXJjZTI6IFYsXG5cdHNvdXJjZTM6IFdcbik6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gbWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWKTogVCAmIFUgJiBWO1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9Pih0YXJnZXQ6IFQsIHNvdXJjZTogVSk6IFQgJiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluKHRhcmdldDogYW55LCAuLi5zb3VyY2VzOiBhbnlbXSk6IGFueSB7XG5cdHJldHVybiBfbWl4aW4oe1xuXHRcdGRlZXA6IGZhbHNlLFxuXHRcdGluaGVyaXRlZDogdHJ1ZSxcblx0XHRzb3VyY2VzOiBzb3VyY2VzLFxuXHRcdHRhcmdldDogdGFyZ2V0XG5cdH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMgcHJlcGVuZGVkIHRvIGl0cyBhcmd1bWVudCBsaXN0LlxuICogTGlrZSBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgLCBidXQgZG9lcyBub3QgYWx0ZXIgZXhlY3V0aW9uIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHRhcmdldEZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGJvdW5kXG4gKiBAcGFyYW0gc3VwcGxpZWRBcmdzIEFuIG9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRoZSBgdGFyZ2V0RnVuY3Rpb25gIGFyZ3VtZW50cyBsaXN0XG4gKiBAcmV0dXJuIFRoZSBib3VuZCBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbCh0YXJnZXRGdW5jdGlvbjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIC4uLnN1cHBsaWVkQXJnczogYW55W10pOiAoLi4uYXJnczogYW55W10pID0+IGFueSB7XG5cdHJldHVybiBmdW5jdGlvbih0aGlzOiBhbnkpIHtcblx0XHRjb25zdCBhcmdzOiBhbnlbXSA9IGFyZ3VtZW50cy5sZW5ndGggPyBzdXBwbGllZEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBzdXBwbGllZEFyZ3M7XG5cblx0XHRyZXR1cm4gdGFyZ2V0RnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIGRlc3Ryb3kgbWV0aG9kIHRoYXQsIHdoZW4gY2FsbGVkLCBjYWxscyB0aGUgcGFzc2VkLWluIGRlc3RydWN0b3IuXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIHByb3ZpZGUgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgY3JlYXRpbmcgXCJyZW1vdmVcIiAvIFwiZGVzdHJveVwiIGhhbmRsZXJzIGZvclxuICogZXZlbnQgbGlzdGVuZXJzLCB0aW1lcnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gZGVzdHJ1Y3RvciBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgaGFuZGxlJ3MgYGRlc3Ryb3lgIG1ldGhvZCBpcyBpbnZva2VkXG4gKiBAcmV0dXJuIFRoZSBoYW5kbGUgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYW5kbGUoZGVzdHJ1Y3RvcjogKCkgPT4gdm9pZCk6IEhhbmRsZSB7XG5cdHJldHVybiB7XG5cdFx0ZGVzdHJveTogZnVuY3Rpb24odGhpczogSGFuZGxlKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0ZGVzdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlc3Ryb3kgbXVsdGlwbGUgaGFuZGxlcyBzaW11bHRhbmVvdXNseS5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlcyBBbiBhcnJheSBvZiBoYW5kbGVzIHdpdGggYGRlc3Ryb3lgIG1ldGhvZHNcbiAqIEByZXR1cm4gVGhlIGhhbmRsZSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBvc2l0ZUhhbmRsZSguLi5oYW5kbGVzOiBIYW5kbGVbXSk6IEhhbmRsZSB7XG5cdHJldHVybiBjcmVhdGVIYW5kbGUoZnVuY3Rpb24oKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBoYW5kbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYW5kbGVzW2ldLmRlc3Ryb3koKTtcblx0XHR9XG5cdH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxhbmcudHMiLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHZhbHVlIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICAgIFRoZSB2YWx1ZSB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBzaG91bGQgYmUgc2V0IHRvXG4gKiBAcGFyYW0gZW51bWVyYWJsZSAgIElmIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgZW51bWJlcmFibGUsIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcGFyYW0gd3JpdGFibGUgICAgIElmIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgd3JpdGFibGUsIGRlZmF1bHRzIHRvIHRydWVcbiAqIEBwYXJhbSBjb25maWd1cmFibGUgSWYgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25maWd1cmFibGUsIGRlZmF1bHRzIHRvIHRydWVcbiAqIEByZXR1cm4gICAgICAgICAgICAgVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZURlc2NyaXB0b3I8VD4oXG5cdHZhbHVlOiBULFxuXHRlbnVtZXJhYmxlOiBib29sZWFuID0gZmFsc2UsXG5cdHdyaXRhYmxlOiBib29sZWFuID0gdHJ1ZSxcblx0Y29uZmlndXJhYmxlOiBib29sZWFuID0gdHJ1ZVxuKTogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8VD4ge1xuXHRyZXR1cm4ge1xuXHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRlbnVtZXJhYmxlOiBlbnVtZXJhYmxlLFxuXHRcdHdyaXRhYmxlOiB3cml0YWJsZSxcblx0XHRjb25maWd1cmFibGU6IGNvbmZpZ3VyYWJsZVxuXHR9O1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHdoaWNoIHdyYXBzIGEgZnVuY3Rpb24gd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IGJlY29tZXMgdGhlIHNjb3BlXG4gKiBvZiB0aGUgY2FsbFxuICpcbiAqIEBwYXJhbSBuYXRpdmVGdW5jdGlvbiBUaGUgc291cmNlIGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOYXRpdmU8VCwgVSwgUj4obmF0aXZlRnVuY3Rpb246IChhcmcxOiBVKSA9PiBSKTogKHRhcmdldDogVCwgYXJnMTogVSkgPT4gUjtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTmF0aXZlPFQsIFUsIFYsIFI+KG5hdGl2ZUZ1bmN0aW9uOiAoYXJnMTogVSwgYXJnMjogVikgPT4gUik6ICh0YXJnZXQ6IFQsIGFyZzE6IFUsIGFyZzI6IFYpID0+IFI7XG5leHBvcnQgZnVuY3Rpb24gd3JhcE5hdGl2ZTxULCBVLCBWLCBXLCBSPihcblx0bmF0aXZlRnVuY3Rpb246IChhcmcxOiBVLCBhcmcyOiBWLCBhcmczOiBXKSA9PiBSXG4pOiAodGFyZ2V0OiBULCBhcmcxOiBVLCBhcmcyOiBWLCBhcmczOiBXKSA9PiBSO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOYXRpdmU8VCwgVSwgViwgVywgWCwgUj4oXG5cdG5hdGl2ZUZ1bmN0aW9uOiAoYXJnMTogVSwgYXJnMjogViwgYXJnMzogVykgPT4gUlxuKTogKHRhcmdldDogVCwgYXJnMTogVSwgYXJnMjogViwgYXJnMzogVykgPT4gUjtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTmF0aXZlPFQsIFUsIFYsIFcsIFgsIFksIFI+KFxuXHRuYXRpdmVGdW5jdGlvbjogKGFyZzE6IFUsIGFyZzI6IFYsIGFyZzM6IFcsIGFyZzQ6IFkpID0+IFJcbik6ICh0YXJnZXQ6IFQsIGFyZzE6IFUsIGFyZzI6IFYsIGFyZzM6IFcsIGFyZzQ6IFkpID0+IFI7XG5leHBvcnQgZnVuY3Rpb24gd3JhcE5hdGl2ZShuYXRpdmVGdW5jdGlvbjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiAodGFyZ2V0OiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkge1xuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0OiBhbnksIC4uLmFyZ3M6IGFueVtdKTogYW55IHtcblx0XHRyZXR1cm4gbmF0aXZlRnVuY3Rpb24uYXBwbHkodGFyZ2V0LCBhcmdzKTtcblx0fTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB1dGlsLnRzIiwiLyoqXG4gKiBSZXR1cm5zIGEgdjQgY29tcGxpYW50IFVVSUQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXVpZCgpOiBzdHJpbmcge1xuXHRyZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG5cdFx0Y29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcblx0XHRcdHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuXHRcdHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0fSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdXVpZC50cyIsIi8vIHJlcXVpcmVkIGZvciBHbG9iYWxpemUvQ2xkciB0byBwcm9wZXJseSByZXNvbHZlIGxvY2FsZXMgaW4gdGhlIGJyb3dzZXIuXG5pbXBvcnQgJ2NsZHJqcy9kaXN0L2NsZHIvdW5yZXNvbHZlZCc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdAZG9qby9zaGltL1Byb21pc2UnO1xuaW1wb3J0ICogYXMgR2xvYmFsaXplIGZyb20gJ2dsb2JhbGl6ZSc7XG5pbXBvcnQgc3VwcG9ydGVkTG9jYWxlcyBmcm9tICcuL2xvY2FsZXMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVMb2NhbGVzLCB2YWxpZGF0ZUxvY2FsZSB9IGZyb20gJy4uL3V0aWwvbWFpbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xkckRhdGEge1xuXHRtYWluPzogTG9jYWxlRGF0YTtcblx0c3VwcGxlbWVudGFsPzogYW55O1xufVxuXG5leHBvcnQgdHlwZSBDbGRyR3JvdXAgPSAnbWFpbicgfCAnc3VwcGxlbWVudGFsJztcblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbGVEYXRhIHtcblx0W2xvY2FsZTogc3RyaW5nXTogYW55O1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgcmVxdWlyZWQgQ0xEUiBwYWNrYWdlcyBmb3IgYW4gaW5kaXZpZHVhbCBsb2NhbGUuXG4gKi9cbmV4cG9ydCBjb25zdCBtYWluUGFja2FnZXMgPSBPYmplY3QuZnJlZXplKFtcblx0J2RhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4nLFxuXHQnZGF0ZXMvZmllbGRzJyxcblx0J2RhdGVzL3RpbWVab25lTmFtZXMnLFxuXHQnbnVtYmVycycsXG5cdCdudW1iZXJzL2N1cnJlbmNpZXMnLFxuXHQndW5pdHMnXG5dKTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIHJlcXVpcmVkIENMRFIgc3VwcGxlbWVudCBwYWNrYWdlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBsZW1lbnRhbFBhY2thZ2VzID0gT2JqZWN0LmZyZWV6ZShbXG5cdCdjdXJyZW5jeURhdGEnLFxuXHQnbGlrZWx5U3VidGFncycsXG5cdCdudW1iZXJpbmdTeXN0ZW1zJyxcblx0J3BsdXJhbHMtdHlwZS1jYXJkaW5hbCcsXG5cdCdwbHVyYWxzLXR5cGUtb3JkaW5hbCcsXG5cdCd0aW1lRGF0YScsXG5cdCd3ZWVrRGF0YSdcbl0pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIHNpbXBsZSBtYXAgY29udGFpbmluZyBib29sZWFuIGZsYWdzIGluZGljYXRpbmcgd2hldGhlciBhIHBhcnRpY3VsYXIgQ0xEUiBwYWNrYWdlIGhhcyBiZWVuIGxvYWRlZC5cbiAqL1xuY29uc3QgbG9hZENhY2hlID0ge1xuXHRtYWluOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXHRzdXBwbGVtZW50YWw6IGdlbmVyYXRlU3VwcGxlbWVudGFsQ2FjaGUoKVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogR2VuZXJhdGUgdGhlIGxvY2FsZS1zcGVjaWZpYyBkYXRhIGNhY2hlIGZyb20gYSBsaXN0IG9mIGtleXMuIE5lc3RlZCBvYmplY3RzIHdpbGwgYmUgZ2VuZXJhdGVkIGZyb21cbiAqIHNsYXNoLXNlcGFyYXRlZCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSBjYWNoZVxuICogQW4gZW1wdHkgbG9jYWxlIGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ga2V5c1xuICogVGhlIGxpc3Qgb2Yga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVMb2NhbGVDYWNoZShjYWNoZTogYW55LCBrZXlzOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcblx0cmV0dXJuIGtleXMucmVkdWNlKCh0cmVlOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG5cdFx0Y29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy8nKTtcblxuXHRcdGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRyZWVba2V5XSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRyZWU7XG5cdFx0fVxuXG5cdFx0cGFydHMucmVkdWNlKCh0cmVlOiBhbnksIGtleTogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgdHJlZVtrZXldICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0cmVlW2tleV0gPSBpID09PSBwYXJ0cy5sZW5ndGggLSAxID8gZmFsc2UgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRyZWVba2V5XTtcblx0XHR9LCB0cmVlKTtcblxuXHRcdHJldHVybiB0cmVlO1xuXHR9LCBjYWNoZSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEdlbmVyYXRlIHRoZSBzdXBwbGVtZW50YWwgZGF0YSBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTdXBwbGVtZW50YWxDYWNoZSgpIHtcblx0cmV0dXJuIHN1cHBsZW1lbnRhbFBhY2thZ2VzLnJlZHVjZSgobWFwOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG5cdFx0bWFwW2tleV0gPSBmYWxzZTtcblx0XHRyZXR1cm4gbWFwO1xuXHR9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjdXJzaXZlbHkgZGV0ZXJtaW5lIHdoZXRoZXIgYSBsaXN0IG9mIHBhY2thZ2VzIGhhdmUgYmVlbiBsb2FkZWQgZm9yIHRoZSBzcGVjaWZpZWQgQ0xEUiBncm91cC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXBcbiAqIFRoZSBDTERSIGdyb3VwIG9iamVjdCAoZS5nLiwgdGhlIHN1cHBsZW1lbnRhbCBkYXRhLCBvciBhIHNwZWNpZmljIGxvY2FsZSBncm91cClcbiAqXG4gKiBAcGFyYW0gYXJnc1xuICogQSBsaXN0IG9mIGtleXMgdG8gcmVjdXJzaXZlbHkgY2hlY2sgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBGb3IgZXhhbXBsZSwgaWYgWyBcImVuXCIsIFwibnVtYmVyc1wiIF0sXG4gKiB0aGVuIGBncm91cC5lbi5udW1iZXJzYCBtdXN0IGV4aXN0IGZvciB0aGUgdGVzdCB0byBwYXNzLlxuICpcbiAqIEByZXR1cm5cbiAqIGB0cnVlYCBpZiB0aGUgZGVlcGVzdCB2YWx1ZSBleGlzdHM7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0xvYWRlZEZvckdyb3VwKGdyb3VwOiBhbnksIGFyZ3M6IHN0cmluZ1tdKSB7XG5cdHJldHVybiBhcmdzLmV2ZXJ5KChhcmc6IHN0cmluZykgPT4ge1xuXHRcdGNvbnN0IG5leHQgPSBncm91cFthcmddO1xuXHRcdGdyb3VwID0gbmV4dDtcblx0XHRyZXR1cm4gQm9vbGVhbihuZXh0KTtcblx0fSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY3Vyc2l2ZWx5IGZsYWcgYXMgbG9hZGVkIGFsbCByZWNvZ25pemVkIGtleXMgb24gdGhlIHByb3ZpZGVkIENMRFIgZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNhY2hlXG4gKiBUaGUgbG9hZCBjYWNoZSAoZWl0aGVyIHRoZSBlbnRpcmUgb2JqZWN0LCBvciBhIG5lc3RlZCBzZWdtZW50IG9mIGl0KS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlRGF0YVxuICogVGhlIENMRFIgZGF0YSBvYmplY3QgYmVpbmcgbG9hZGVkIChlaXRoZXIgdGhlIGVudGlyZSBvYmplY3QsIG9yIGEgbmVzdGVkIHNlZ21lbnQgb2YgaXQpLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckxvY2FsZURhdGEoY2FjaGU6IGFueSwgbG9jYWxlRGF0YTogYW55KSB7XG5cdE9iamVjdC5rZXlzKGxvY2FsZURhdGEpLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0aWYgKGtleSBpbiBjYWNoZSkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBjYWNoZVtrZXldO1xuXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0Y2FjaGVba2V5XSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWdpc3RlckxvY2FsZURhdGEodmFsdWUsIGxvY2FsZURhdGFba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRmxhZyBhbGwgc3VwcGxpZWQgQ0xEUiBwYWNrYWdlcyBmb3IgYSBzcGVjaWZpYyBsb2NhbGUgYXMgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBUaGUgYG1haW5gIGxvY2FsZSBkYXRhLlxuICovXG5mdW5jdGlvbiByZWdpc3Rlck1haW4oZGF0YT86IExvY2FsZURhdGEpIHtcblx0aWYgKCFkYXRhKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgobG9jYWxlOiBzdHJpbmcpID0+IHtcblx0XHRpZiAoc3VwcG9ydGVkTG9jYWxlcy5pbmRleE9mKGxvY2FsZSkgPCAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IGxvYWRlZERhdGEgPSBsb2FkQ2FjaGUubWFpbltsb2NhbGVdO1xuXHRcdGlmICghbG9hZGVkRGF0YSkge1xuXHRcdFx0bG9hZGVkRGF0YSA9IGxvYWRDYWNoZS5tYWluW2xvY2FsZV0gPSBnZW5lcmF0ZUxvY2FsZUNhY2hlKE9iamVjdC5jcmVhdGUobnVsbCksIG1haW5QYWNrYWdlcyk7XG5cdFx0fVxuXG5cdFx0cmVnaXN0ZXJMb2NhbGVEYXRhKGxvYWRlZERhdGEsIGRhdGFbbG9jYWxlXSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBGbGFnIGFsbCBzdXBwbGllZCBDTERSIHN1cHBsZW1lbnRhbCBwYWNrYWdlcyBhcyBsb2FkZWQuXG4gKlxuICogQHBhcmFtIGRhdGFcbiAqIFRoZSBzdXBwbGVtZW50YWwgZGF0YS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJTdXBwbGVtZW50YWwoZGF0YT86IGFueSkge1xuXHRpZiAoIWRhdGEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBzdXBwbGVtZW50YWwgPSBsb2FkQ2FjaGUuc3VwcGxlbWVudGFsO1xuXHRPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xuXHRcdGlmIChrZXkgaW4gc3VwcGxlbWVudGFsKSB7XG5cdFx0XHRzdXBwbGVtZW50YWxba2V5XSA9IHRydWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIHBhcnRpY3VsYXIgQ0xEUiBwYWNrYWdlIGhhcyBiZWVuIGxvYWRlZC5cbiAqXG4gKiBFeGFtcGxlOiB0byBjaGVjayB0aGF0IGBzdXBwbGVtZW50YWwubGlrZWx5U3VidGFnc2AgaGFzIGJlZW4gbG9hZGVkLCBgaXNMb2FkZWRgIHdvdWxkIGJlIGNhbGxlZCBhc1xuICogYGlzTG9hZGVkKCdzdXBwbGVtZW50YWwnLCAnbGlrZWx5U3VidGFncycpYC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXBOYW1lXG4gKiBUaGUgZ3JvdXAgdG8gY2hlY2s7IGVpdGhlciBcIm1haW5cIiBvciBcInN1cHBsZW1lbnRhbFwiLlxuICpcbiAqIEBwYXJhbSAuLi5hcmdzXG4gKiBBbnkgcmVtYWluaW5nIGtleXMgaW4gdGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgcGFja2FnZS5cbiAqXG4gKiBAcmV0dXJuXG4gKiBgdHJ1ZWAgaWYgdGhlIGRlZXBlc3QgdmFsdWUgZXhpc3RzOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9hZGVkKGdyb3VwTmFtZTogQ2xkckdyb3VwLCAuLi5hcmdzOiBzdHJpbmdbXSkge1xuXHRsZXQgZ3JvdXA6IGFueSA9IGxvYWRDYWNoZVtncm91cE5hbWVdO1xuXG5cdGlmIChncm91cE5hbWUgPT09ICdtYWluJyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zdCBsb2NhbGUgPSBhcmdzWzBdO1xuXG5cdFx0aWYgKCF2YWxpZGF0ZUxvY2FsZShsb2NhbGUpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0YXJncyA9IGFyZ3Muc2xpY2UoMSk7XG5cdFx0cmV0dXJuIGdlbmVyYXRlTG9jYWxlcyhsb2NhbGUpLnNvbWUoKGxvY2FsZTogc3RyaW5nKSA9PiB7XG5cdFx0XHRjb25zdCBuZXh0ID0gZ3JvdXBbbG9jYWxlXTtcblx0XHRcdHJldHVybiBuZXh0ID8gaXNMb2FkZWRGb3JHcm91cChuZXh0LCBhcmdzKSA6IGZhbHNlO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIGlzTG9hZGVkRm9yR3JvdXAoZ3JvdXAsIGFyZ3MpO1xufVxuXG4vKipcbiAqIExvYWQgdGhlIHNwZWNpZmllZCBDTERSIGRhdGEgd2l0aCB0aGUgaTE4biBlY29zeXN0ZW0uXG4gKlxuICogQHBhcmFtIGRhdGFcbiAqIEEgZGF0YSBvYmplY3QgY29udGFpbmluZyBgbWFpbmAgYW5kL29yIGBzdXBwbGVtZW50YWxgIG9iamVjdHMgd2l0aCBDTERSIGRhdGEuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvYWRDbGRyRGF0YShkYXRhOiBDbGRyRGF0YSk6IFByb21pc2U8dm9pZD4ge1xuXHRyZWdpc3Rlck1haW4oZGF0YS5tYWluKTtcblx0cmVnaXN0ZXJTdXBwbGVtZW50YWwoZGF0YS5zdXBwbGVtZW50YWwpO1xuXHRHbG9iYWxpemUubG9hZChkYXRhKTtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSBsb2FkIGNhY2hlLCBlaXRoZXIgdGhlIGVudGlyZSBjYWNoZSBmb3IgdGhlIHNwZWNpZmllZCBncm91cC4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAqIGBpc0xvYWRlZGAgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGtleXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZ3JvdXAocykuXG4gKlxuICogQHBhcmFtIGdyb3VwXG4gKiBBbiBvcHRpb25hbCBncm91cCBuYW1lLiBJZiBub3QgcHJvdmlkZWQsIHRoZW4gYm90aCB0aGUgXCJtYWluXCIgYW5kIFwic3VwcGxlbWVudGFsXCIgY2FjaGVzIHdpbGwgYmUgY2xlYXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KGdyb3VwPzogQ2xkckdyb3VwKSB7XG5cdGlmIChncm91cCAhPT0gJ3N1cHBsZW1lbnRhbCcpIHtcblx0XHRsb2FkQ2FjaGUubWFpbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdH1cblxuXHRpZiAoZ3JvdXAgIT09ICdtYWluJykge1xuXHRcdGxvYWRDYWNoZS5zdXBwbGVtZW50YWwgPSBnZW5lcmF0ZVN1cHBsZW1lbnRhbENhY2hlKCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsb2FkLnRzIiwiLyoqXG4gKiBBIGxpc3Qgb2YgYGNsZHItZGF0YS9tYWluYCBkaXJlY3RvcmllcyB1c2VkIHRvIGxvYWQgdGhlIGNvcnJlY3QgQ0xEUiBkYXRhIGZvciBhIGdpdmVuIGxvY2FsZS5cbiAqL1xuY29uc3QgbG9jYWxlc0xpc3QgPSBbXG5cdCdhZi1OQScsXG5cdCdhZicsXG5cdCdhZ3EnLFxuXHQnYWsnLFxuXHQnYW0nLFxuXHQnYXItQUUnLFxuXHQnYXItQkgnLFxuXHQnYXItREonLFxuXHQnYXItRFonLFxuXHQnYXItRUcnLFxuXHQnYXItRUgnLFxuXHQnYXItRVInLFxuXHQnYXItSUwnLFxuXHQnYXItSVEnLFxuXHQnYXItSk8nLFxuXHQnYXItS00nLFxuXHQnYXItS1cnLFxuXHQnYXItTEInLFxuXHQnYXItTFknLFxuXHQnYXItTUEnLFxuXHQnYXItTVInLFxuXHQnYXItT00nLFxuXHQnYXItUFMnLFxuXHQnYXItUUEnLFxuXHQnYXItU0EnLFxuXHQnYXItU0QnLFxuXHQnYXItU08nLFxuXHQnYXItU1MnLFxuXHQnYXItU1knLFxuXHQnYXItVEQnLFxuXHQnYXItVE4nLFxuXHQnYXItWUUnLFxuXHQnYXInLFxuXHQnYXMnLFxuXHQnYXNhJyxcblx0J2FzdCcsXG5cdCdhei1DeXJsJyxcblx0J2F6LUxhdG4nLFxuXHQnYXonLFxuXHQnYmFzJyxcblx0J2JlJyxcblx0J2JlbScsXG5cdCdiZXonLFxuXHQnYmcnLFxuXHQnYm0nLFxuXHQnYm4tSU4nLFxuXHQnYm4nLFxuXHQnYm8tSU4nLFxuXHQnYm8nLFxuXHQnYnInLFxuXHQnYnJ4Jyxcblx0J2JzLUN5cmwnLFxuXHQnYnMtTGF0bicsXG5cdCdicycsXG5cdCdjYS1BRCcsXG5cdCdjYS1FUy1WQUxFTkNJQScsXG5cdCdjYS1GUicsXG5cdCdjYS1JVCcsXG5cdCdjYScsXG5cdCdjZScsXG5cdCdjZ2cnLFxuXHQnY2hyJyxcblx0J2NrYi1JUicsXG5cdCdja2InLFxuXHQnY3MnLFxuXHQnY3UnLFxuXHQnY3knLFxuXHQnZGEtR0wnLFxuXHQnZGEnLFxuXHQnZGF2Jyxcblx0J2RlLUFUJyxcblx0J2RlLUJFJyxcblx0J2RlLUNIJyxcblx0J2RlLUlUJyxcblx0J2RlLUxJJyxcblx0J2RlLUxVJyxcblx0J2RlJyxcblx0J2RqZScsXG5cdCdkc2InLFxuXHQnZHVhJyxcblx0J2R5bycsXG5cdCdkeicsXG5cdCdlYnUnLFxuXHQnZWUtVEcnLFxuXHQnZWUnLFxuXHQnZWwtQ1knLFxuXHQnZWwnLFxuXHQnZW4tMDAxJyxcblx0J2VuLTE1MCcsXG5cdCdlbi1BRycsXG5cdCdlbi1BSScsXG5cdCdlbi1BUycsXG5cdCdlbi1BVCcsXG5cdCdlbi1BVScsXG5cdCdlbi1CQicsXG5cdCdlbi1CRScsXG5cdCdlbi1CSScsXG5cdCdlbi1CTScsXG5cdCdlbi1CUycsXG5cdCdlbi1CVycsXG5cdCdlbi1CWicsXG5cdCdlbi1DQScsXG5cdCdlbi1DQycsXG5cdCdlbi1DSCcsXG5cdCdlbi1DSycsXG5cdCdlbi1DTScsXG5cdCdlbi1DWCcsXG5cdCdlbi1DWScsXG5cdCdlbi1ERScsXG5cdCdlbi1ERycsXG5cdCdlbi1ESycsXG5cdCdlbi1ETScsXG5cdCdlbi1FUicsXG5cdCdlbi1GSScsXG5cdCdlbi1GSicsXG5cdCdlbi1GSycsXG5cdCdlbi1GTScsXG5cdCdlbi1HQicsXG5cdCdlbi1HRCcsXG5cdCdlbi1HRycsXG5cdCdlbi1HSCcsXG5cdCdlbi1HSScsXG5cdCdlbi1HTScsXG5cdCdlbi1HVScsXG5cdCdlbi1HWScsXG5cdCdlbi1ISycsXG5cdCdlbi1JRScsXG5cdCdlbi1JTCcsXG5cdCdlbi1JTScsXG5cdCdlbi1JTicsXG5cdCdlbi1JTycsXG5cdCdlbi1KRScsXG5cdCdlbi1KTScsXG5cdCdlbi1LRScsXG5cdCdlbi1LSScsXG5cdCdlbi1LTicsXG5cdCdlbi1LWScsXG5cdCdlbi1MQycsXG5cdCdlbi1MUicsXG5cdCdlbi1MUycsXG5cdCdlbi1NRycsXG5cdCdlbi1NSCcsXG5cdCdlbi1NTycsXG5cdCdlbi1NUCcsXG5cdCdlbi1NUycsXG5cdCdlbi1NVCcsXG5cdCdlbi1NVScsXG5cdCdlbi1NVycsXG5cdCdlbi1NWScsXG5cdCdlbi1OQScsXG5cdCdlbi1ORicsXG5cdCdlbi1ORycsXG5cdCdlbi1OTCcsXG5cdCdlbi1OUicsXG5cdCdlbi1OVScsXG5cdCdlbi1OWicsXG5cdCdlbi1QRycsXG5cdCdlbi1QSCcsXG5cdCdlbi1QSycsXG5cdCdlbi1QTicsXG5cdCdlbi1QUicsXG5cdCdlbi1QVycsXG5cdCdlbi1SVycsXG5cdCdlbi1TQicsXG5cdCdlbi1TQycsXG5cdCdlbi1TRCcsXG5cdCdlbi1TRScsXG5cdCdlbi1TRycsXG5cdCdlbi1TSCcsXG5cdCdlbi1TSScsXG5cdCdlbi1TTCcsXG5cdCdlbi1TUycsXG5cdCdlbi1TWCcsXG5cdCdlbi1TWicsXG5cdCdlbi1UQycsXG5cdCdlbi1USycsXG5cdCdlbi1UTycsXG5cdCdlbi1UVCcsXG5cdCdlbi1UVicsXG5cdCdlbi1UWicsXG5cdCdlbi1VRycsXG5cdCdlbi1VTScsXG5cdCdlbi1VUy1QT1NJWCcsXG5cdCdlbi1WQycsXG5cdCdlbi1WRycsXG5cdCdlbi1WSScsXG5cdCdlbi1WVScsXG5cdCdlbi1XUycsXG5cdCdlbi1aQScsXG5cdCdlbi1aTScsXG5cdCdlbi1aVycsXG5cdCdlbicsXG5cdCdlbycsXG5cdCdlcy00MTknLFxuXHQnZXMtQVInLFxuXHQnZXMtQk8nLFxuXHQnZXMtQlInLFxuXHQnZXMtQ0wnLFxuXHQnZXMtQ08nLFxuXHQnZXMtQ1InLFxuXHQnZXMtQ1UnLFxuXHQnZXMtRE8nLFxuXHQnZXMtRUEnLFxuXHQnZXMtRUMnLFxuXHQnZXMtR1EnLFxuXHQnZXMtR1QnLFxuXHQnZXMtSE4nLFxuXHQnZXMtSUMnLFxuXHQnZXMtTVgnLFxuXHQnZXMtTkknLFxuXHQnZXMtUEEnLFxuXHQnZXMtUEUnLFxuXHQnZXMtUEgnLFxuXHQnZXMtUFInLFxuXHQnZXMtUFknLFxuXHQnZXMtU1YnLFxuXHQnZXMtVVMnLFxuXHQnZXMtVVknLFxuXHQnZXMtVkUnLFxuXHQnZXMnLFxuXHQnZXQnLFxuXHQnZXUnLFxuXHQnZXdvJyxcblx0J2ZhLUFGJyxcblx0J2ZhJyxcblx0J2ZmLUNNJyxcblx0J2ZmLUdOJyxcblx0J2ZmLU1SJyxcblx0J2ZmJyxcblx0J2ZpJyxcblx0J2ZpbCcsXG5cdCdmby1ESycsXG5cdCdmbycsXG5cdCdmci1CRScsXG5cdCdmci1CRicsXG5cdCdmci1CSScsXG5cdCdmci1CSicsXG5cdCdmci1CTCcsXG5cdCdmci1DQScsXG5cdCdmci1DRCcsXG5cdCdmci1DRicsXG5cdCdmci1DRycsXG5cdCdmci1DSCcsXG5cdCdmci1DSScsXG5cdCdmci1DTScsXG5cdCdmci1ESicsXG5cdCdmci1EWicsXG5cdCdmci1HQScsXG5cdCdmci1HRicsXG5cdCdmci1HTicsXG5cdCdmci1HUCcsXG5cdCdmci1HUScsXG5cdCdmci1IVCcsXG5cdCdmci1LTScsXG5cdCdmci1MVScsXG5cdCdmci1NQScsXG5cdCdmci1NQycsXG5cdCdmci1NRicsXG5cdCdmci1NRycsXG5cdCdmci1NTCcsXG5cdCdmci1NUScsXG5cdCdmci1NUicsXG5cdCdmci1NVScsXG5cdCdmci1OQycsXG5cdCdmci1ORScsXG5cdCdmci1QRicsXG5cdCdmci1QTScsXG5cdCdmci1SRScsXG5cdCdmci1SVycsXG5cdCdmci1TQycsXG5cdCdmci1TTicsXG5cdCdmci1TWScsXG5cdCdmci1URCcsXG5cdCdmci1URycsXG5cdCdmci1UTicsXG5cdCdmci1WVScsXG5cdCdmci1XRicsXG5cdCdmci1ZVCcsXG5cdCdmcicsXG5cdCdmdXInLFxuXHQnZnknLFxuXHQnZ2EnLFxuXHQnZ2QnLFxuXHQnZ2wnLFxuXHQnZ3N3LUZSJyxcblx0J2dzdy1MSScsXG5cdCdnc3cnLFxuXHQnZ3UnLFxuXHQnZ3V6Jyxcblx0J2d2Jyxcblx0J2hhLUdIJyxcblx0J2hhLU5FJyxcblx0J2hhJyxcblx0J2hhdycsXG5cdCdoZScsXG5cdCdoaScsXG5cdCdoci1CQScsXG5cdCdocicsXG5cdCdoc2InLFxuXHQnaHUnLFxuXHQnaHknLFxuXHQnaWQnLFxuXHQnaWcnLFxuXHQnaWknLFxuXHQnaXMnLFxuXHQnaXQtQ0gnLFxuXHQnaXQtU00nLFxuXHQnaXQnLFxuXHQnamEnLFxuXHQnamdvJyxcblx0J2ptYycsXG5cdCdrYScsXG5cdCdrYWInLFxuXHQna2FtJyxcblx0J2tkZScsXG5cdCdrZWEnLFxuXHQna2hxJyxcblx0J2tpJyxcblx0J2trJyxcblx0J2traicsXG5cdCdrbCcsXG5cdCdrbG4nLFxuXHQna20nLFxuXHQna24nLFxuXHQna28tS1AnLFxuXHQna28nLFxuXHQna29rJyxcblx0J2tzJyxcblx0J2tzYicsXG5cdCdrc2YnLFxuXHQna3NoJyxcblx0J2t3Jyxcblx0J2t5Jyxcblx0J2xhZycsXG5cdCdsYicsXG5cdCdsZycsXG5cdCdsa3QnLFxuXHQnbG4tQU8nLFxuXHQnbG4tQ0YnLFxuXHQnbG4tQ0cnLFxuXHQnbG4nLFxuXHQnbG8nLFxuXHQnbHJjLUlRJyxcblx0J2xyYycsXG5cdCdsdCcsXG5cdCdsdScsXG5cdCdsdW8nLFxuXHQnbHV5Jyxcblx0J2x2Jyxcblx0J21hcy1UWicsXG5cdCdtYXMnLFxuXHQnbWVyJyxcblx0J21mZScsXG5cdCdtZycsXG5cdCdtZ2gnLFxuXHQnbWdvJyxcblx0J21rJyxcblx0J21sJyxcblx0J21uJyxcblx0J21yJyxcblx0J21zLUJOJyxcblx0J21zLVNHJyxcblx0J21zJyxcblx0J210Jyxcblx0J211YScsXG5cdCdteScsXG5cdCdtem4nLFxuXHQnbmFxJyxcblx0J25iLVNKJyxcblx0J25iJyxcblx0J25kJyxcblx0J25kcy1OTCcsXG5cdCduZHMnLFxuXHQnbmUtSU4nLFxuXHQnbmUnLFxuXHQnbmwtQVcnLFxuXHQnbmwtQkUnLFxuXHQnbmwtQlEnLFxuXHQnbmwtQ1cnLFxuXHQnbmwtU1InLFxuXHQnbmwtU1gnLFxuXHQnbmwnLFxuXHQnbm1nJyxcblx0J25uJyxcblx0J25uaCcsXG5cdCdudXMnLFxuXHQnbnluJyxcblx0J29tLUtFJyxcblx0J29tJyxcblx0J29yJyxcblx0J29zLVJVJyxcblx0J29zJyxcblx0J3BhLUFyYWInLFxuXHQncGEtR3VydScsXG5cdCdwYScsXG5cdCdwbCcsXG5cdCdwcmcnLFxuXHQncHMnLFxuXHQncHQtQU8nLFxuXHQncHQtQ0gnLFxuXHQncHQtQ1YnLFxuXHQncHQtR1EnLFxuXHQncHQtR1cnLFxuXHQncHQtTFUnLFxuXHQncHQtTU8nLFxuXHQncHQtTVonLFxuXHQncHQtUFQnLFxuXHQncHQtU1QnLFxuXHQncHQtVEwnLFxuXHQncHQnLFxuXHQncXUtQk8nLFxuXHQncXUtRUMnLFxuXHQncXUnLFxuXHQncm0nLFxuXHQncm4nLFxuXHQncm8tTUQnLFxuXHQncm8nLFxuXHQncm9mJyxcblx0J3Jvb3QnLFxuXHQncnUtQlknLFxuXHQncnUtS0cnLFxuXHQncnUtS1onLFxuXHQncnUtTUQnLFxuXHQncnUtVUEnLFxuXHQncnUnLFxuXHQncncnLFxuXHQncndrJyxcblx0J3NhaCcsXG5cdCdzYXEnLFxuXHQnc2JwJyxcblx0J3NlLUZJJyxcblx0J3NlLVNFJyxcblx0J3NlJyxcblx0J3NlaCcsXG5cdCdzZXMnLFxuXHQnc2cnLFxuXHQnc2hpLUxhdG4nLFxuXHQnc2hpLVRmbmcnLFxuXHQnc2hpJyxcblx0J3NpJyxcblx0J3NrJyxcblx0J3NsJyxcblx0J3NtbicsXG5cdCdzbicsXG5cdCdzby1ESicsXG5cdCdzby1FVCcsXG5cdCdzby1LRScsXG5cdCdzbycsXG5cdCdzcS1NSycsXG5cdCdzcS1YSycsXG5cdCdzcScsXG5cdCdzci1DeXJsLUJBJyxcblx0J3NyLUN5cmwtTUUnLFxuXHQnc3ItQ3lybC1YSycsXG5cdCdzci1DeXJsJyxcblx0J3NyLUxhdG4tQkEnLFxuXHQnc3ItTGF0bi1NRScsXG5cdCdzci1MYXRuLVhLJyxcblx0J3NyLUxhdG4nLFxuXHQnc3InLFxuXHQnc3YtQVgnLFxuXHQnc3YtRkknLFxuXHQnc3YnLFxuXHQnc3ctQ0QnLFxuXHQnc3ctS0UnLFxuXHQnc3ctVUcnLFxuXHQnc3cnLFxuXHQndGEtTEsnLFxuXHQndGEtTVknLFxuXHQndGEtU0cnLFxuXHQndGEnLFxuXHQndGUnLFxuXHQndGVvLUtFJyxcblx0J3RlbycsXG5cdCd0aCcsXG5cdCd0aS1FUicsXG5cdCd0aScsXG5cdCd0aycsXG5cdCd0bycsXG5cdCd0ci1DWScsXG5cdCd0cicsXG5cdCd0d3EnLFxuXHQndHptJyxcblx0J3VnJyxcblx0J3VrJyxcblx0J3VyLUlOJyxcblx0J3VyJyxcblx0J3V6LUFyYWInLFxuXHQndXotQ3lybCcsXG5cdCd1ei1MYXRuJyxcblx0J3V6Jyxcblx0J3ZhaS1MYXRuJyxcblx0J3ZhaS1WYWlpJyxcblx0J3ZhaScsXG5cdCd2aScsXG5cdCd2bycsXG5cdCd2dW4nLFxuXHQnd2FlJyxcblx0J3hvZycsXG5cdCd5YXYnLFxuXHQneWknLFxuXHQneW8tQkonLFxuXHQneW8nLFxuXHQneXVlJyxcblx0J3pnaCcsXG5cdCd6aC1IYW5zLUhLJyxcblx0J3poLUhhbnMtTU8nLFxuXHQnemgtSGFucy1TRycsXG5cdCd6aC1IYW5zJyxcblx0J3poLUhhbnQtSEsnLFxuXHQnemgtSGFudC1NTycsXG5cdCd6aC1IYW50Jyxcblx0J3poJyxcblx0J3p1J1xuXTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsZXNMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxvY2FsZXMudHMiLCIvKiB0c2xpbnQ6ZGlzYWJsZTppbnRlcmZhY2UtbmFtZSAqL1xuaW1wb3J0ICdAZG9qby9zaGltL1Byb21pc2UnOyAvLyBlbnN1cmUgUHJvbWlzZS5hbGwgZXhpc3RzXG5pbXBvcnQgRXZlbnRlZCBmcm9tICdAZG9qby9jb3JlL0V2ZW50ZWQnO1xuaW1wb3J0IGhhcyBmcm9tICdAZG9qby9jb3JlL2hhcyc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdAZG9qby9jb3JlL2xhbmcnO1xuaW1wb3J0IHsgdXNlRGVmYXVsdCB9IGZyb20gJ0Bkb2pvL2NvcmUvbG9hZC91dGlsJztcbmltcG9ydCB1dWlkIGZyb20gJ0Bkb2pvL2NvcmUvdXVpZCc7XG5pbXBvcnQgeyBIYW5kbGUgfSBmcm9tICdAZG9qby9jb3JlL2ludGVyZmFjZXMnO1xuaW1wb3J0IGdsb2JhbCBmcm9tICdAZG9qby9zaGltL2dsb2JhbCc7XG5pbXBvcnQgTWFwIGZyb20gJ0Bkb2pvL3NoaW0vTWFwJztcbmltcG9ydCBPYnNlcnZhYmxlLCB7IE9ic2VydmVyLCBTdWJzY3JpcHRpb24sIFN1YnNjcmlwdGlvbk9ic2VydmVyIH0gZnJvbSAnQGRvam8vc2hpbS9PYnNlcnZhYmxlJztcbmltcG9ydCAqIGFzIEdsb2JhbGl6ZSBmcm9tICdnbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbWVzc2FnZSc7XG5pbXBvcnQgeyBpc0xvYWRlZCB9IGZyb20gJy4vY2xkci9sb2FkJztcbmltcG9ydCB7IGdlbmVyYXRlTG9jYWxlcywgbm9ybWFsaXplTG9jYWxlIH0gZnJvbSAnLi91dGlsL21haW4nO1xuXG4vKipcbiAqIEEgZGVmYXVsdCBidW5kbGUgdXNlZCBhcyBiYXNpcyBmb3IgbG9hZGluZyBsb2NhbGUtc3BlY2lmaWMgYnVuZGxlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCdW5kbGU8VCBleHRlbmRzIE1lc3NhZ2VzPiB7XG5cdC8qKlxuXHQgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVuZGxlIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGl0IGlzIHJlZ2lzdGVyZWQuXG5cdCAqL1xuXHRyZWFkb25seSBpZD86IHN0cmluZztcblxuXHQvKipcblx0ICogQSBsaXN0IG9mIHN1cHBvcnRlZCBsb2NhbGVzLiBBbnkgaW5jbHVkZWQgbG9jYWxlIE1VU1QgaGF2ZSBhbiBhc3NvY2lhdGVkIGJ1bmRsZS5cblx0ICovXG5cdHJlYWRvbmx5IGxvY2FsZXM/OiBMb2NhbGVMb2FkZXJzPFQ+O1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFwIG9mIGRlZmF1bHQgbWVzc2FnZXMgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBsb2NhbGUtc3BlY2lmaWMgbWVzc2FnZXMgYXJlIHVuYXZhaWxhYmxlLlxuXHQgKiBOb3RlIHRoYXQgYW55IG1lc3NhZ2Uga2V5IHVzZWQgaW4gdGhlIGkxOG4gc3lzdGVtIE1VU1QgaGF2ZSBhIGRlZmF1bHQgc3BlY2lmaWVkIGhlcmUuXG5cdCAqL1xuXHRyZWFkb25seSBtZXNzYWdlczogVDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gbWVzc2FnZSBmb3JtYXR0ZXJzIGFuZCB1c2VkIGZvciB0b2tlbiByZXBsYWNlbWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRPcHRpb25zIHtcblx0W2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEkxOG48VCBleHRlbmRzIE1lc3NhZ2VzPiB7XG5cdChidW5kbGU6IEJ1bmRsZTxUPiwgbG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxUPjtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgbmFtZXNwYWNlIGFzIHNldCB2aWEgYHN3aXRjaExvY2FsZWAuIERlZmF1bHRzIHRvIGBzeXN0ZW1Mb2NhbGVgLlxuXHQgKi9cblx0cmVhZG9ubHkgbG9jYWxlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBtYXAgb2YgbG9jYWxlcyB0byBmdW5jdGlvbnMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgdGhlaXIgcmVzcGVjdGl2ZSB0cmFuc2xhdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxlTG9hZGVyczxUIGV4dGVuZHMgTWVzc2FnZXM+IHtcblx0W2xvY2FsZTogc3RyaW5nXTogKCkgPT4gTG9jYWxlVHJhbnNsYXRpb25zPFQ+IHwgUHJvbWlzZTxMb2NhbGVUcmFuc2xhdGlvbnM8VD4+O1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCBvZiBsb2NhbGUtc3BlY2lmaWMgdHJhbnNsYXRpb25zLlxuICovXG5leHBvcnQgdHlwZSBMb2NhbGVUcmFuc2xhdGlvbnM8VCBleHRlbmRzIE1lc3NhZ2VzPiA9IFBhcnRpYWw8VD4gfCB7IGRlZmF1bHQ/OiBQYXJ0aWFsPFQ+IH07XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgY29tcGlsZWQgSUNVIG1lc3NhZ2UgZm9ybWF0dGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VGb3JtYXR0ZXIge1xuXHQob3B0aW9ucz86IEZvcm1hdE9wdGlvbnMpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IG9mIGtleXMgdG8gbG9jYWxlIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VzIHtcblx0W2tleTogc3RyaW5nXTogc3RyaW5nO1xufVxuXG5jb25zdCBUT0tFTl9QQVRURVJOID0gL1xceyhbYS16MC05X10rKVxcfS9naTtcbmNvbnN0IGJ1bmRsZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBNZXNzYWdlcz4+KCk7XG5jb25zdCBmb3JtYXR0ZXJNYXAgPSBuZXcgTWFwPHN0cmluZywgTWVzc2FnZUZvcm1hdHRlcj4oKTtcbmNvbnN0IGxvY2FsZVByb2R1Y2VyID0gbmV3IEV2ZW50ZWQoKTtcbmxldCByb290TG9jYWxlOiBzdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBidW5kbGUncyB1bmlxdWUgaWRlbnRpZmllciwgY3JlYXRpbmcgb25lIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gKlxuICogQHBhcmFtIGJ1bmRsZSBBIG1lc3NhZ2UgYnVuZGxlXG4gKiBAcmV0dXJuIFRoZSBidW5kbGUncyB1bmlxdWUgaWRlbnRpZmllclxuICovXG5mdW5jdGlvbiBnZXRCdW5kbGVJZDxUIGV4dGVuZHMgTWVzc2FnZXM+KGJ1bmRsZTogQnVuZGxlPFQ+KTogc3RyaW5nIHtcblx0aWYgKGJ1bmRsZS5pZCkge1xuXHRcdHJldHVybiBidW5kbGUuaWQ7XG5cdH1cblxuXHRjb25zdCBpZCA9IHV1aWQoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1bmRsZSwgJ2lkJywge1xuXHRcdHZhbHVlOiBpZFxuXHR9KTtcblx0cmV0dXJuIGlkO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYW4gSUNVLXN0eWxlIG1lc3NhZ2UsIGFuZCB0YWtlcyBhbiBvcHRpb25hbCB2YWx1ZSBmb3IgdG9rZW4gcmVwbGFjZW1lbnQuXG4gKlxuICogVXNhZ2U6XG4gKiBjb25zdCBmb3JtYXR0ZXIgPSBnZXRNZXNzYWdlRm9ybWF0dGVyKGJ1bmRsZSwgJ2d1ZXN0SW5mbycsICdmcicpO1xuICogY29uc3QgbWVzc2FnZSA9IGZvcm1hdHRlcih7XG4gKiAgIGhvc3Q6ICdNaWxlcycsXG4gKiAgIGdlbmRlcjogJ21hbGUnLFxuICogICBndWVzdDogJ09zY2FyJyxcbiAqICAgZ3Vlc3RDb3VudDogJzE1J1xuICogfSk7XG4gKlxuICogQHBhcmFtIGlkXG4gKiBUaGUgbWVzc2FnZSdzIGJ1bmRsZSBpZC5cbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBUaGUgbWVzc2FnZSdzIGtleS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUgZm9yIHRoZSBmb3JtYXR0ZXIuIElmIG5vIGxvY2FsZSBpcyBzdXBwbGllZCwgb3IgaWYgdGhlIGxvY2FsZSBpcyBub3Qgc3VwcG9ydGVkLCB0aGVcbiAqIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuXG4gKlxuICogQHJldHVyblxuICogVGhlIG1lc3NhZ2UgZm9ybWF0dGVyLlxuICovXG5mdW5jdGlvbiBnZXRJY3VNZXNzYWdlRm9ybWF0dGVyKGlkOiBzdHJpbmcsIGtleTogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpOiBNZXNzYWdlRm9ybWF0dGVyIHtcblx0bG9jYWxlID0gbm9ybWFsaXplTG9jYWxlKGxvY2FsZSB8fCBnZXRSb290TG9jYWxlKCkpO1xuXHRjb25zdCBmb3JtYXR0ZXJLZXkgPSBgJHtsb2NhbGV9OiR7aWR9OiR7a2V5fWA7XG5cdGxldCBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJNYXAuZ2V0KGZvcm1hdHRlcktleSk7XG5cblx0aWYgKGZvcm1hdHRlcikge1xuXHRcdHJldHVybiBmb3JtYXR0ZXI7XG5cdH1cblxuXHRjb25zdCBnbG9iYWxpemUgPSBsb2NhbGUgIT09IGdldFJvb3RMb2NhbGUoKSA/IG5ldyBHbG9iYWxpemUobm9ybWFsaXplTG9jYWxlKGxvY2FsZSkpIDogR2xvYmFsaXplO1xuXHRmb3JtYXR0ZXIgPSBnbG9iYWxpemUubWVzc2FnZUZvcm1hdHRlcihgJHtpZH0vJHtrZXl9YCk7XG5cblx0Y29uc3QgY2FjaGVkID0gYnVuZGxlTWFwLmdldChpZCk7XG5cdGlmIChjYWNoZWQgJiYgY2FjaGVkLmdldChsb2NhbGUpKSB7XG5cdFx0Zm9ybWF0dGVyTWFwLnNldChmb3JtYXR0ZXJLZXksIGZvcm1hdHRlcik7XG5cdH1cblxuXHRyZXR1cm4gZm9ybWF0dGVyO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBMb2FkIHRoZSBzcGVjaWZpZWQgbG9jYWxlLXNwZWNpZmljIGJ1bmRsZXMsIG1hcHBpbmcgdGhlIGRlZmF1bHQgZXhwb3J0cyB0byBzaW1wbGUgYE1lc3NhZ2VzYCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBsb2FkTG9jYWxlQnVuZGxlczxUIGV4dGVuZHMgTWVzc2FnZXM+KGxvY2FsZXM6IExvY2FsZUxvYWRlcnM8VD4sIHN1cHBvcnRlZDogc3RyaW5nW10pOiBQcm9taXNlPFRbXT4ge1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoc3VwcG9ydGVkLm1hcCgobG9jYWxlKSA9PiBsb2NhbGVzW2xvY2FsZV0oKSkpLnRoZW4oKGJ1bmRsZXMpID0+IHtcblx0XHRyZXR1cm4gYnVuZGxlcy5tYXAoKGJ1bmRsZSkgPT4gdXNlRGVmYXVsdChidW5kbGUpKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybiB0aGUgcm9vdCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0gbG9jYWxlLlxuICovXG5mdW5jdGlvbiBnZXRSb290TG9jYWxlKCk6IHN0cmluZyB7XG5cdHJldHVybiByb290TG9jYWxlIHx8IHN5c3RlbUxvY2FsZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0cmlldmUgYSBsaXN0IG9mIHN1cHBvcnRlZCBsb2NhbGVzIHRoYXQgY2FuIHByb3ZpZGUgbWVzc2FnZXMgZm9yIHRoZSBzcGVjaWZpZWQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIFRoZSB0YXJnZXQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBzdXBwb3J0ZWRcbiAqIFRoZSBsb2NhbGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSB0aGUgYnVuZGxlLlxuICpcbiAqIEByZXR1cm5cbiAqIEEgbGlzdCBvZiBzdXBwb3J0ZWQgbG9jYWxlcyB0aGF0IG1hdGNoIHRoZSB0YXJnZXQgbG9jYWxlLlxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRMb2NhbGVzKGxvY2FsZTogc3RyaW5nLCBzdXBwb3J0ZWQ6IHN0cmluZ1tdID0gW10pOiBzdHJpbmdbXSB7XG5cdHJldHVybiBnZW5lcmF0ZUxvY2FsZXMobG9jYWxlKS5maWx0ZXIoKGxvY2FsZTogc3RyaW5nKSA9PiBzdXBwb3J0ZWQuaW5kZXhPZihsb2NhbGUpID4gLTEpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbmplY3QgbWVzc2FnZXMgZm9yIHRoZSBzcGVjaWZpZWQgbG9jYWxlIGludG8gdGhlIGkxOG4gc3lzdGVtLlxuICpcbiAqIEBwYXJhbSBpZFxuICogVGhlIGJ1bmRsZSdzIHVuaXF1ZSBpZGVudGlmaWVyXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VzXG4gKiBUaGUgbWVzc2FnZXMgdG8gaW5qZWN0XG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogQW4gb3B0aW9uYWwgbG9jYWxlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbWVzc2FnZXMgYXJlIHRoZSBkZWZhdWx0cyBmb3IgdGhlIGdpdmVuXG4gKiBidW5kbGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gbG9hZE1lc3NhZ2VzPFQgZXh0ZW5kcyBNZXNzYWdlcz4oaWQ6IHN0cmluZywgbWVzc2FnZXM6IFQsIGxvY2FsZTogc3RyaW5nID0gJ3Jvb3QnKSB7XG5cdGxldCBjYWNoZWQgPSBidW5kbGVNYXAuZ2V0KGlkKTtcblxuXHRpZiAoIWNhY2hlZCkge1xuXHRcdGNhY2hlZCA9IG5ldyBNYXA8c3RyaW5nLCBNZXNzYWdlcz4oKTtcblx0XHRidW5kbGVNYXAuc2V0KGlkLCBjYWNoZWQpO1xuXHR9XG5cblx0Y2FjaGVkLnNldChsb2NhbGUsIG1lc3NhZ2VzKTtcblx0R2xvYmFsaXplLmxvYWRNZXNzYWdlcyh7XG5cdFx0W2xvY2FsZV06IHtcblx0XHRcdFtpZF06IG1lc3NhZ2VzXG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAqXG4gKiBJZiBib3RoIHRoZSBcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzXCIgYW5kIFwic3VwcGxlbWVudGFsL3BsdXJhbHMtdHlwZS1jYXJkaW5hbFwiIENMRFIgZGF0YSBoYXZlIGJlZW4gbG9hZGVkLCB0aGVuXG4gKiB0aGUgSUNVIG1lc3NhZ2UgZm9ybWF0IGlzIHN1cHBvcnRlZC4gT3RoZXJ3aXNlLCBhIHNpbXBsZSB0b2tlbi1yZXBsYWNlbWVudCBtZWNoYW5pc20gaXMgdXNlZC5cbiAqXG4gKiBVc2FnZTpcbiAqIGZvcm1hdE1lc3NhZ2UoYnVuZGxlLCAnZ3Vlc3RJbmZvJywge1xuICogICBob3N0OiAnQmlsbCcsXG4gKiAgIGd1ZXN0OiAnSm9obidcbiAqIH0sICdmcicpO1xuICpcbiAqIEBwYXJhbSBidW5kbGVcbiAqIFRoZSBidW5kbGUgY29udGFpbmluZyB0aGUgdGFyZ2V0IG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGtleVxuICogVGhlIG1lc3NhZ2UncyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEFuIG9wdGlvbmFsIHZhbHVlIHVzZWQgYnkgdGhlIGZvcm1hdHRlciB0byByZXBsYWNlIHRva2VucyB3aXRoIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUgZm9yIHRoZSBmb3JtYXR0ZXIuIElmIG5vIGxvY2FsZSBpcyBzdXBwbGllZCwgb3IgaWYgdGhlIGxvY2FsZSBpcyBub3Qgc3VwcG9ydGVkLCB0aGVcbiAqIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuXG4gKlxuICogQHJldHVyblxuICogVGhlIGZvcm1hdHRlZCBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZTxUIGV4dGVuZHMgTWVzc2FnZXM+KFxuXHRidW5kbGU6IEJ1bmRsZTxUPixcblx0a2V5OiBzdHJpbmcsXG5cdG9wdGlvbnM/OiBGb3JtYXRPcHRpb25zLFxuXHRsb2NhbGU/OiBzdHJpbmdcbik6IHN0cmluZyB7XG5cdHJldHVybiBnZXRNZXNzYWdlRm9ybWF0dGVyKGJ1bmRsZSwga2V5LCBsb2NhbGUpKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY2FjaGVkIG1lc3NhZ2VzIGZvciB0aGUgc3BlY2lmaWVkIGJ1bmRsZSBhbmQgbG9jYWxlLiBJZiBtZXNzYWdlcyBoYXZlIG5vdCBiZWVuIHByZXZpb3VzbHkgbG9hZGVkIGZvciB0aGVcbiAqIHNwZWNpZmllZCBsb2NhbGUsIG5vIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGJ1bmRsZVxuICogVGhlIGRlZmF1bHQgYnVuZGxlIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIGxvY2FsZS1zcGVjaWZpYyBidW5kbGVzIGFyZSBsb2NhdGVkLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIFRoZSBsb2NhbGUgb2YgdGhlIGRlc2lyZWQgbWVzc2FnZXMuXG4gKlxuICogQHJldHVybiBUaGUgY2FjaGVkIG1lc3NhZ2VzIG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkTWVzc2FnZXM8VCBleHRlbmRzIE1lc3NhZ2VzPihidW5kbGU6IEJ1bmRsZTxUPiwgbG9jYWxlOiBzdHJpbmcpOiBUIHwgdm9pZCB7XG5cdGNvbnN0IHsgaWQgPSBnZXRCdW5kbGVJZChidW5kbGUpLCBsb2NhbGVzLCBtZXNzYWdlcyB9ID0gYnVuZGxlO1xuXHRjb25zdCBjYWNoZWQgPSBidW5kbGVNYXAuZ2V0KGlkKTtcblxuXHRpZiAoIWNhY2hlZCkge1xuXHRcdGxvYWRNZXNzYWdlcyhpZCwgbWVzc2FnZXMpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGxvY2FsZU1lc3NhZ2VzID0gY2FjaGVkLmdldChsb2NhbGUpO1xuXHRcdGlmIChsb2NhbGVNZXNzYWdlcykge1xuXHRcdFx0cmV0dXJuIGxvY2FsZU1lc3NhZ2VzIGFzIFQ7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc3VwcG9ydGVkTG9jYWxlcyA9IGdldFN1cHBvcnRlZExvY2FsZXMobG9jYWxlLCBsb2NhbGVzICYmIE9iamVjdC5rZXlzKGxvY2FsZXMpKTtcblx0aWYgKCFzdXBwb3J0ZWRMb2NhbGVzLmxlbmd0aCkge1xuXHRcdHJldHVybiBtZXNzYWdlcztcblx0fVxuXG5cdGlmIChjYWNoZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkLmdldChzdXBwb3J0ZWRMb2NhbGVzW3N1cHBvcnRlZExvY2FsZXMubGVuZ3RoIC0gMV0pIGFzIFQ7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBzcGVjaWZpYyBtZXNzYWdlLCBhbmQgdGFrZXMgYW4gb3B0aW9uYWwgdmFsdWUgZm9yIHRva2VuIHJlcGxhY2VtZW50LlxuICpcbiAqIElmIGJvdGggdGhlIFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3NcIiBhbmQgXCJzdXBwbGVtZW50YWwvcGx1cmFscy10eXBlLWNhcmRpbmFsXCIgQ0xEUiBkYXRhIGhhdmUgYmVlbiBsb2FkZWQsIHRoZW5cbiAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGhhdmUgSUNVIG1lc3NhZ2UgZm9ybWF0IHN1cHBvcnQuIE90aGVyd2lzZSwgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSBhIHNpbXBsZVxuICogdG9rZW4gcmVwbGFjZW1lbnQgb24gdGhlIG1lc3NhZ2Ugc3RyaW5nLlxuICpcbiAqIFVzYWdlOlxuICogY29uc3QgZm9ybWF0dGVyID0gZ2V0TWVzc2FnZUZvcm1hdHRlcihidW5kbGUsICdndWVzdEluZm8nLCAnZnInKTtcbiAqIGNvbnN0IG1lc3NhZ2UgPSBmb3JtYXR0ZXIoe1xuICogICBob3N0OiAnTWlsZXMnLFxuICogICBnZW5kZXI6ICdtYWxlJyxcbiAqICAgZ3Vlc3Q6ICdPc2NhcicsXG4gKiAgIGd1ZXN0Q291bnQ6ICcxNSdcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSBidW5kbGVcbiAqIFRoZSBidW5kbGUgY29udGFpbmluZyB0aGUgdGFyZ2V0IG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGtleVxuICogVGhlIG1lc3NhZ2UncyBrZXkuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogQW4gb3B0aW9uYWwgbG9jYWxlIGZvciB0aGUgZm9ybWF0dGVyLiBJZiBubyBsb2NhbGUgaXMgc3VwcGxpZWQsIG9yIGlmIHRoZSBsb2NhbGUgaXMgbm90IHN1cHBvcnRlZCwgdGhlXG4gKiBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLlxuICpcbiAqIEByZXR1cm5cbiAqIFRoZSBtZXNzYWdlIGZvcm1hdHRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VGb3JtYXR0ZXI8VCBleHRlbmRzIE1lc3NhZ2VzPihcblx0YnVuZGxlOiBCdW5kbGU8VD4sXG5cdGtleTogc3RyaW5nLFxuXHRsb2NhbGU/OiBzdHJpbmdcbik6IE1lc3NhZ2VGb3JtYXR0ZXIge1xuXHRjb25zdCB7IGlkID0gZ2V0QnVuZGxlSWQoYnVuZGxlKSB9ID0gYnVuZGxlO1xuXG5cdGlmIChpc0xvYWRlZCgnc3VwcGxlbWVudGFsJywgJ2xpa2VseVN1YnRhZ3MnKSAmJiBpc0xvYWRlZCgnc3VwcGxlbWVudGFsJywgJ3BsdXJhbHMtdHlwZS1jYXJkaW5hbCcpKSB7XG5cdFx0cmV0dXJuIGdldEljdU1lc3NhZ2VGb3JtYXR0ZXIoaWQsIGtleSwgbG9jYWxlKTtcblx0fVxuXG5cdGNvbnN0IGNhY2hlZCA9IGJ1bmRsZU1hcC5nZXQoaWQpO1xuXHRjb25zdCBtZXNzYWdlcyA9IGNhY2hlZCA/IGNhY2hlZC5nZXQobG9jYWxlIHx8IGdldFJvb3RMb2NhbGUoKSkgfHwgY2FjaGVkLmdldCgncm9vdCcpIDogbnVsbDtcblxuXHRpZiAoIW1lc3NhZ2VzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBUaGUgYnVuZGxlIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLmApO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnM6IEZvcm1hdE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2VzW2tleV0ucmVwbGFjZShUT0tFTl9QQVRURVJOLCAodG9rZW46IHN0cmluZywgcHJvcGVydHk6IHN0cmluZykgPT4ge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBvcHRpb25zW3Byb3BlcnR5XTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHByb3BlcnR5ICR7cHJvcGVydHl9YCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9KTtcblx0fTtcbn1cblxuLyoqXG4gKiBMb2FkIGxvY2FsZS1zcGVjaWZpYyBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBidW5kbGUgYW5kIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gYnVuZGxlXG4gKiBUaGUgZGVmYXVsdCBidW5kbGUgdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVyZSB0aGUgbG9jYWxlLXNwZWNpZmljIGJ1bmRsZXMgYXJlIGxvY2F0ZWQuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogQW4gb3B0aW9uYWwgbG9jYWxlLiBJZiBubyBsb2NhbGUgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGN1cnJlbnQgbG9jYWxlIGlzIGFzc3VtZWQuXG4gKlxuICogQHJldHVybiBBIHByb21pc2UgdG8gdGhlIGxvY2FsZS1zcGVjaWZpYyBtZXNzYWdlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaTE4bjxUIGV4dGVuZHMgTWVzc2FnZXM+KGJ1bmRsZTogQnVuZGxlPFQ+LCBsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPFQ+IHtcblx0Y29uc3QgY3VycmVudExvY2FsZSA9IGxvY2FsZSA/IG5vcm1hbGl6ZUxvY2FsZShsb2NhbGUpIDogZ2V0Um9vdExvY2FsZSgpO1xuXHRjb25zdCBjYWNoZWRNZXNzYWdlcyA9IGdldENhY2hlZE1lc3NhZ2VzKGJ1bmRsZSwgY3VycmVudExvY2FsZSk7XG5cblx0aWYgKGNhY2hlZE1lc3NhZ2VzKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1lc3NhZ2VzO1xuXHR9XG5cblx0Y29uc3QgbG9jYWxlcyA9IGJ1bmRsZS5sb2NhbGVzIGFzIExvY2FsZUxvYWRlcnM8VD47XG5cdGNvbnN0IHN1cHBvcnRlZExvY2FsZXMgPSBnZXRTdXBwb3J0ZWRMb2NhbGVzKGN1cnJlbnRMb2NhbGUsIE9iamVjdC5rZXlzKGxvY2FsZXMpKTtcblx0Y29uc3QgYnVuZGxlcyA9IGF3YWl0IGxvYWRMb2NhbGVCdW5kbGVzPFQ+KGxvY2FsZXMsIHN1cHBvcnRlZExvY2FsZXMpO1xuXHRyZXR1cm4gYnVuZGxlcy5yZWR1Y2UoKHByZXZpb3VzOiBULCBwYXJ0aWFsOiBUKTogVCA9PiB7XG5cdFx0Y29uc3QgbG9jYWxlTWVzc2FnZXM6IFQgPSBhc3NpZ24oe30sIHByZXZpb3VzLCBwYXJ0aWFsKTtcblx0XHRsb2FkTWVzc2FnZXMoZ2V0QnVuZGxlSWQoYnVuZGxlKSwgPFQ+T2JqZWN0LmZyZWV6ZShsb2NhbGVNZXNzYWdlcyksIGN1cnJlbnRMb2NhbGUpO1xuXHRcdHJldHVybiBsb2NhbGVNZXNzYWdlcztcblx0fSwgYnVuZGxlLm1lc3NhZ2VzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGkxOG4sICdsb2NhbGUnLCB7XG5cdGdldDogZ2V0Um9vdExvY2FsZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGkxOG4gYXMgSTE4bjxNZXNzYWdlcz47XG5cbi8qKlxuICogSW52YWxpZGF0ZSB0aGUgY2FjaGUgZm9yIGEgcGFydGljdWxhciBidW5kbGUsIG9yIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS4gTm90ZSB0aGF0IGNhY2hlZCBtZXNzYWdlcyBmb3IgYWxsXG4gKiBsb2NhbGVzIGZvciBhIGdpdmVuIGJ1bmRsZSB3aWxsIGJlIGNsZWFyZWQuXG4gKlxuICogQHBhcmFtIGJ1bmRsZVxuICogQW4gb3B0aW9uYWwgYnVuZGxlIHRvIGludmFsaWRhdGUuIElmIG5vIGJ1bmRsZSBpcyBwcm92aWRlZCwgdGhlbiB0aGUgY2FjaGUgaXMgY2xlYXJlZCBmb3IgYWxsIGJ1bmRsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlPFQgZXh0ZW5kcyBNZXNzYWdlcz4oYnVuZGxlPzogQnVuZGxlPFQ+KSB7XG5cdGlmIChidW5kbGUpIHtcblx0XHRidW5kbGUuaWQgJiYgYnVuZGxlTWFwLmRlbGV0ZShidW5kbGUuaWQpO1xuXHR9IGVsc2Uge1xuXHRcdGJ1bmRsZU1hcC5jbGVhcigpO1xuXHR9XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgcm9vdCBsb2NhbGUgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2ZXJcbiAqIFRoZSBvYnNlcnZlciB3aG9zZSBgbmV4dGAgbWV0aG9kIHdpbGwgcmVjZWl2ZSB0aGUgbG9jYWxlIHN0cmluZyBvbiB1cGRhdGVzLCBhbmQgd2hvc2UgYGVycm9yYCBtZXRob2Qgd2lsbCByZWNlaXZlXG4gKiBhbiBFcnJvciBvYmplY3QgaWYgdGhlIGxvY2FsZSBzd2l0Y2ggZmFpbHMuXG4gKlxuICogQHJldHVyblxuICogQSBzdWJzY3JpcHRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgZnJvbSB1cGRhdGVzLlxuICovXG5leHBvcnQgY29uc3Qgb2JzZXJ2ZUxvY2FsZSA9IChmdW5jdGlvbigpIHtcblx0Y29uc3QgbG9jYWxlU291cmNlID0gbmV3IE9ic2VydmFibGU8c3RyaW5nPigob2JzZXJ2ZXI6IFN1YnNjcmlwdGlvbk9ic2VydmVyPHN0cmluZz4pID0+IHtcblx0XHRjb25zdCBoYW5kbGVzOiBIYW5kbGVbXSA9IFtcblx0XHRcdGxvY2FsZVByb2R1Y2VyLm9uKCdjaGFuZ2UnLCAoZXZlbnQ6IGFueSkgPT4ge1xuXHRcdFx0XHRvYnNlcnZlci5uZXh0KGV2ZW50LnRhcmdldCk7XG5cdFx0XHR9KVxuXHRcdF07XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRoYW5kbGVzLmZvckVhY2goKGhhbmRsZTogSGFuZGxlKSA9PiB7XG5cdFx0XHRcdGhhbmRsZS5kZXN0cm95KCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24ob2JzZXJ2ZXI6IE9ic2VydmVyPHN0cmluZz4pOiBTdWJzY3JpcHRpb24ge1xuXHRcdHJldHVybiBsb2NhbGVTb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyKTtcblx0fTtcbn0pKCk7XG5cbi8qKlxuICogUHJlLWxvYWQgbG9jYWxlLXNwZWNpZmljIG1lc3NhZ2VzIGludG8gdGhlIGkxOG4gc3lzdGVtLlxuICpcbiAqIEBwYXJhbSBidW5kbGVcbiAqIFRoZSBkZWZhdWx0IGJ1bmRsZSB0aGF0IGlzIHVzZWQgdG8gbWVyZ2UgbG9jYWxlLXNwZWNpZmljIG1lc3NhZ2VzIHdpdGggdGhlIGRlZmF1bHQgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VzXG4gKiBUaGUgbWVzc2FnZXMgdG8gY2FjaGUuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIGxvY2FsZSBmb3IgdGhlIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2NhbGVNZXNzYWdlczxUIGV4dGVuZHMgTWVzc2FnZXM+KFxuXHRidW5kbGU6IEJ1bmRsZTxUPixcblx0bG9jYWxlTWVzc2FnZXM6IFBhcnRpYWw8VD4sXG5cdGxvY2FsZTogc3RyaW5nXG4pOiB2b2lkIHtcblx0Y29uc3QgbWVzc2FnZXM6IFQgPSBhc3NpZ24oe30sIGJ1bmRsZS5tZXNzYWdlcywgbG9jYWxlTWVzc2FnZXMpO1xuXHRsb2FkTWVzc2FnZXMoZ2V0QnVuZGxlSWQoYnVuZGxlKSwgPFQ+T2JqZWN0LmZyZWV6ZShtZXNzYWdlcyksIGxvY2FsZSk7XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSByb290IGxvY2FsZSwgYW5kIG5vdGlmeSBhbnkgcmVnaXN0ZXJlZCBvYnNlcnZlcnMuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIG5ldyBsb2NhbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2l0Y2hMb2NhbGUobG9jYWxlOiBzdHJpbmcpOiB2b2lkIHtcblx0Y29uc3QgcHJldmlvdXMgPSByb290TG9jYWxlO1xuXHRyb290TG9jYWxlID0gbG9jYWxlID8gbm9ybWFsaXplTG9jYWxlKGxvY2FsZSkgOiAnJztcblxuXHRpZiAocHJldmlvdXMgIT09IHJvb3RMb2NhbGUpIHtcblx0XHRpZiAoaXNMb2FkZWQoJ3N1cHBsZW1lbnRhbCcsICdsaWtlbHlTdWJ0YWdzJykpIHtcblx0XHRcdEdsb2JhbGl6ZS5sb2FkKHtcblx0XHRcdFx0bWFpbjoge1xuXHRcdFx0XHRcdFtyb290TG9jYWxlXToge31cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRHbG9iYWxpemUubG9jYWxlKHJvb3RMb2NhbGUpO1xuXHRcdH1cblxuXHRcdGxvY2FsZVByb2R1Y2VyLmVtaXQoeyB0eXBlOiAnY2hhbmdlJywgdGFyZ2V0OiByb290TG9jYWxlIH0pO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZW52aXJvbm1lbnQgbG9jYWxlLlxuICpcbiAqIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHdoaWxlIHRoZSBzeXN0ZW0gbG9jYWxlIHdpbGwgYmUgbm9ybWFsaXplZCB0byBhIHNpbmdsZVxuICogZm9ybWF0IHdoZW4gbG9hZGluZyBtZXNzYWdlIGJ1bmRsZXMsIHRoaXMgdmFsdWUgcmVwcmVzZW50cyB0aGUgdW5hbHRlcmVkXG4gKiBsb2NhbGUgcmV0dXJuZWQgZGlyZWN0bHkgYnkgdGhlIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgY29uc3Qgc3lzdGVtTG9jYWxlOiBzdHJpbmcgPSAoZnVuY3Rpb24oKSB7XG5cdGxldCBzeXN0ZW1Mb2NhbGUgPSAnZW4nO1xuXHRpZiAoaGFzKCdob3N0LWJyb3dzZXInKSkge1xuXHRcdGNvbnN0IG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cdFx0c3lzdGVtTG9jYWxlID0gbmF2aWdhdG9yLmxhbmd1YWdlIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2U7XG5cdH0gZWxzZSBpZiAoaGFzKCdob3N0LW5vZGUnKSkge1xuXHRcdHN5c3RlbUxvY2FsZSA9IHByb2Nlc3MuZW52LkxBTkcgfHwgc3lzdGVtTG9jYWxlO1xuXHR9XG5cdHJldHVybiBub3JtYWxpemVMb2NhbGUoc3lzdGVtTG9jYWxlKTtcbn0pKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gaTE4bi50cyIsIi8vIE1hdGNoZXMgYW4gSVNPIDYzOS4xLzYzOS4yIGNvbXBhdGlibGUgbGFuZ3VhZ2UsIGZvbGxvd2VkIGJ5IG9wdGlvbmFsIHN1YnRhZ3MuXG5jb25zdCBWQUxJRF9MT0NBTEVfUEFUVEVSTiA9IC9eW2Etel17MiwzfSgtW2EtejAtOVxcLVxcX10rKT8kL2k7XG5cbi8qKlxuICogUmV0cmlldmUgYSBsaXN0IG9mIGxvY2FsZXMgdGhhdCBjYW4gcHJvdmlkZSBzdWJzdGl0dXRlIGZvciB0aGUgc3BlY2lmaWVkIGxvY2FsZVxuICogKGluY2x1ZGluZyBpdHNlbGYpLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiAnZnItQ0EnIGlzIHNwZWNpZmllZCwgdGhlbiBgWyAnZnInLCAnZnItQ0EnIF1gIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIFRoZSB0YXJnZXQgbG9jYWxlLlxuICpcbiAqIEByZXR1cm5cbiAqIEEgbGlzdCBvZiBsb2NhbGVzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldCBsb2NhbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUxvY2FsZXMobG9jYWxlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG5cdGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVMb2NhbGUobG9jYWxlKTtcblx0Y29uc3QgcGFydHMgPSBub3JtYWxpemVkLnNwbGl0KCctJyk7XG5cdGxldCBjdXJyZW50ID0gcGFydHNbMF07XG5cdGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbY3VycmVudF07XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcblx0XHRjdXJyZW50ICs9ICctJyArIHBhcnRzW2kgKyAxXTtcblx0XHRyZXN1bHQucHVzaChjdXJyZW50KTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgbG9jYWxlIHNvIHRoYXQgaXQgY2FuIGJlIGNvbnZlcnRlZCB0byBhIGJ1bmRsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIFRoZSB0YXJnZXQgbG9jYWxlLlxuICpcbiAqIEByZXR1cm4gVGhlIG5vcm1hbGl6ZWQgbG9jYWxlLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplTG9jYWxlID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcih2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSgvKFxcLXxfKSQvLCAnJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBub3JtYWxpemUobG9jYWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmIChsb2NhbGUuaW5kZXhPZignLicpID09PSAtMSkge1xuXHRcdFx0cmV0dXJuIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKGxvY2FsZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxvY2FsZVxuXHRcdFx0LnNwbGl0KCcuJylcblx0XHRcdC5zbGljZSgwLCAtMSlcblx0XHRcdC5tYXAoKHBhcnQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcihwYXJ0KS5yZXBsYWNlKC9fL2csICctJyk7XG5cdFx0XHR9KVxuXHRcdFx0LmpvaW4oJy0nKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihsb2NhbGU6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShsb2NhbGUpO1xuXG5cdFx0aWYgKCF2YWxpZGF0ZUxvY2FsZShub3JtYWxpemVkKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke25vcm1hbGl6ZWR9IGlzIG5vdCBhIHZhbGlkIGxvY2FsZS5gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbm9ybWFsaXplZDtcblx0fTtcbn0pKCk7XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIHByb3ZpZGVkIGxvY2FsZSBhdCBsZWFzdCBiZWdpbnMgd2l0aCBhIElTTyA2MzkuMS82MzkuMiBjb21wdGFiaWxlIGxhbmd1YWdlIHN1YnRhZyxcbiAqIGFuZCB0aGF0IGFueSBhZGRpdGlvbmFsIHN1YnRhZ3MgY29udGFpbiBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gKlxuICogV2hpbGUgbG9jYWxlcyBzaG91bGQgYWRoZXJlIHRvIHRoZSBndWlkZWxpbmVzIHNldCBmb3J0aCBieSBSRkMgNTY0NiAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU2NDYpLFxuICogb25seSB0aGUgbGFuZ3VhZ2Ugc3VidGFnIGlzIHN0cmljdGx5IGVuZm9yY2VkLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIFRoZSBsb2NhbGUgdG8gdmFsaWRhdGUuXG4gKlxuICogQHJldHVyblxuICogYHRydWVgIGlmIHRoZSBsb2NhbGUgaXMgdmFsaWQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMb2NhbGUobG9jYWxlOiBzdHJpbmcpOiBib29sZWFuIHtcblx0cmV0dXJuIFZBTElEX0xPQ0FMRV9QQVRURVJOLnRlc3QobG9jYWxlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBtYWluLnRzIiwiaW1wb3J0IHsgaXNBcnJheUxpa2UsIEl0ZXJhYmxlLCBJdGVyYWJsZUl0ZXJhdG9yLCBTaGltSXRlcmF0b3IgfSBmcm9tICcuL2l0ZXJhdG9yJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHsgaXMgYXMgb2JqZWN0SXMgfSBmcm9tICcuL29iamVjdCc7XG5pbXBvcnQgaGFzIGZyb20gJy4vc3VwcG9ydC9oYXMnO1xuaW1wb3J0ICcuL1N5bWJvbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwPEssIFY+IHtcblx0LyoqXG5cdCAqIERlbGV0ZXMgYWxsIGtleXMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzLlxuXHQgKi9cblx0Y2xlYXIoKTogdm9pZDtcblxuXHQvKipcblx0ICogRGVsZXRlcyBhIGdpdmVuIGtleSBhbmQgaXRzIGFzc29jaWF0ZWQgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBkZWxldGVcblx0ICogQHJldHVybiB0cnVlIGlmIHRoZSBrZXkgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2VzIG5vdFxuXHQgKi9cblx0ZGVsZXRlKGtleTogSyk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCBrZXkvdmFsdWUgcGFpciBhcyBhbiBhcnJheS5cblx0ICpcblx0ICogQHJldHVybiBBbiBpdGVyYXRvciBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRlbnRyaWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W0ssIFZdPjtcblxuXHQvKipcblx0ICogRXhlY3V0ZXMgYSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBtYXAgZW50cnkuIFRoZSBmdW5jdGlvblxuXHQgKiBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiB0aGUgZWxlbWVudCB2YWx1ZSwgdGhlXG5cdCAqIGVsZW1lbnQga2V5LCBhbmQgdGhlIGFzc29jaWF0ZWQgTWFwIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gY2FsbGJhY2tmbiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBtYXAgZW50cnksXG5cdCAqIEBwYXJhbSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgZm9yIGB0aGlzYCBmb3IgZWFjaCBleGVjdXRpb24gb2YgdGhlIGNhbGJhY2tcblx0ICovXG5cdGZvckVhY2goY2FsbGJhY2tmbjogKHZhbHVlOiBWLCBrZXk6IEssIG1hcDogTWFwPEssIFY+KSA9PiB2b2lkLCB0aGlzQXJnPzogYW55KTogdm9pZDtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5LlxuXHQgKlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gbG9vayB1cFxuXHQgKiBAcmV0dXJuIFRoZSB2YWx1ZSBpZiBvbmUgZXhpc3RzIG9yIHVuZGVmaW5lZFxuXHQgKi9cblx0Z2V0KGtleTogSyk6IFYgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCBrZXkgaW4gdGhlIG1hcC5cblx0ICpcblx0ICogQHJldHVybiBBbiBpdGVyYXRvciBjb250YWluaW5nIHRoZSBpbnN0YW5jZSdzIGtleXMuXG5cdCAqL1xuXHRrZXlzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Sz47XG5cblx0LyoqXG5cdCAqIENoZWNrcyBmb3IgdGhlIHByZXNlbmNlIG9mIGEgZ2l2ZW4ga2V5LlxuXHQgKlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gY2hlY2sgZm9yXG5cdCAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5IGV4aXN0cywgZmFsc2UgaWYgaXQgZG9lcyBub3Rcblx0ICovXG5cdGhhcyhrZXk6IEspOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXkuXG5cdCAqXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBkZWZpbmUgYSB2YWx1ZSB0b1xuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnblxuXHQgKiBAcmV0dXJuIFRoZSBNYXAgaW5zdGFuY2Vcblx0ICovXG5cdHNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcztcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleSAvIHZhbHVlIHBhaXJzIGluIHRoZSBNYXAuXG5cdCAqL1xuXHRyZWFkb25seSBzaXplOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCB2YWx1ZSBpbiB0aGUgbWFwLlxuXHQgKlxuXHQgKiBAcmV0dXJuIEFuIGl0ZXJhdG9yIGNvbnRhaW5pbmcgdGhlIGluc3RhbmNlJ3MgdmFsdWVzLlxuXHQgKi9cblx0dmFsdWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Vj47XG5cblx0LyoqIFJldHVybnMgYW4gaXRlcmFibGUgb2YgZW50cmllcyBpbiB0aGUgbWFwLiAqL1xuXHRbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFtLLCBWXT47XG5cblx0cmVhZG9ubHkgW1N5bWJvbC50b1N0cmluZ1RhZ106IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXBDb25zdHJ1Y3RvciB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IE1hcFxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdG5ldyAoKTogTWFwPGFueSwgYW55PjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBNYXBcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVyYXRvclxuXHQgKiBBcnJheSBvciBpdGVyYXRvciBjb250YWluaW5nIHR3by1pdGVtIHR1cGxlcyB1c2VkIHRvIGluaXRpYWxseSBwb3B1bGF0ZSB0aGUgbWFwLlxuXHQgKiBUaGUgZmlyc3QgaXRlbSBpbiBlYWNoIHR1cGxlIGNvcnJlc3BvbmRzIHRvIHRoZSBrZXkgb2YgdGhlIG1hcCBlbnRyeS5cblx0ICogVGhlIHNlY29uZCBpdGVtIGNvcnJlc3BvbmRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbWFwIGVudHJ5LlxuXHQgKi9cblx0bmV3IDxLLCBWPihpdGVyYXRvcj86IFtLLCBWXVtdKTogTWFwPEssIFY+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IE1hcFxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIGl0ZXJhdG9yXG5cdCAqIEFycmF5IG9yIGl0ZXJhdG9yIGNvbnRhaW5pbmcgdHdvLWl0ZW0gdHVwbGVzIHVzZWQgdG8gaW5pdGlhbGx5IHBvcHVsYXRlIHRoZSBtYXAuXG5cdCAqIFRoZSBmaXJzdCBpdGVtIGluIGVhY2ggdHVwbGUgY29ycmVzcG9uZHMgdG8gdGhlIGtleSBvZiB0aGUgbWFwIGVudHJ5LlxuXHQgKiBUaGUgc2Vjb25kIGl0ZW0gY29ycmVzcG9uZHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBtYXAgZW50cnkuXG5cdCAqL1xuXHRuZXcgPEssIFY+KGl0ZXJhdG9yOiBJdGVyYWJsZTxbSywgVl0+KTogTWFwPEssIFY+O1xuXG5cdHJlYWRvbmx5IHByb3RvdHlwZTogTWFwPGFueSwgYW55PjtcblxuXHRyZWFkb25seSBbU3ltYm9sLnNwZWNpZXNdOiBNYXBDb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGxldCBNYXA6IE1hcENvbnN0cnVjdG9yID0gZ2xvYmFsLk1hcDtcblxuaWYgKCFoYXMoJ2VzNi1tYXAnKSkge1xuXHRNYXAgPSBjbGFzcyBNYXA8SywgVj4ge1xuXHRcdHByb3RlY3RlZCByZWFkb25seSBfa2V5czogS1tdID0gW107XG5cdFx0cHJvdGVjdGVkIHJlYWRvbmx5IF92YWx1ZXM6IFZbXSA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYWx0ZXJuYXRpdmUgdG8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgdXNpbmcgT2JqZWN0LmlzXG5cdFx0ICogdG8gY2hlY2sgZm9yIGVxdWFsaXR5LiBTZWUgaHR0cDovL216bC5sYS8xenVLTzJWXG5cdFx0ICovXG5cdFx0cHJvdGVjdGVkIF9pbmRleE9mS2V5KGtleXM6IEtbXSwga2V5OiBLKTogbnVtYmVyIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmplY3RJcyhrZXlzW2ldLCBrZXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cblx0XHRzdGF0aWMgW1N5bWJvbC5zcGVjaWVzXSA9IE1hcDtcblxuXHRcdGNvbnN0cnVjdG9yKGl0ZXJhYmxlPzogQXJyYXlMaWtlPFtLLCBWXT4gfCBJdGVyYWJsZTxbSywgVl0+KSB7XG5cdFx0XHRpZiAoaXRlcmFibGUpIHtcblx0XHRcdFx0aWYgKGlzQXJyYXlMaWtlKGl0ZXJhYmxlKSkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gaXRlcmFibGVbaV07XG5cdFx0XHRcdFx0XHR0aGlzLnNldCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdldCBzaXplKCk6IG51bWJlciB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0Y2xlYXIoKTogdm9pZCB7XG5cdFx0XHR0aGlzLl9rZXlzLmxlbmd0aCA9IHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGRlbGV0ZShrZXk6IEspOiBib29sZWFuIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXhPZktleSh0aGlzLl9rZXlzLCBrZXkpO1xuXHRcdFx0aWYgKGluZGV4IDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9rZXlzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR0aGlzLl92YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGVudHJpZXMoKTogSXRlcmFibGVJdGVyYXRvcjxbSywgVl0+IHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuX2tleXMubWFwKChrZXk6IEssIGk6IG51bWJlcik6IFtLLCBWXSA9PiB7XG5cdFx0XHRcdHJldHVybiBba2V5LCB0aGlzLl92YWx1ZXNbaV1dO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBuZXcgU2hpbUl0ZXJhdG9yKHZhbHVlcyk7XG5cdFx0fVxuXG5cdFx0Zm9yRWFjaChjYWxsYmFjazogKHZhbHVlOiBWLCBrZXk6IEssIG1hcEluc3RhbmNlOiBNYXA8SywgVj4pID0+IGFueSwgY29udGV4dD86IHt9KSB7XG5cdFx0XHRjb25zdCBrZXlzID0gdGhpcy5fa2V5cztcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdmFsdWVzW2ldLCBrZXlzW2ldLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnZXQoa2V5OiBLKTogViB8IHVuZGVmaW5lZCB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4T2ZLZXkodGhpcy5fa2V5cywga2V5KTtcblx0XHRcdHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiB0aGlzLl92YWx1ZXNbaW5kZXhdO1xuXHRcdH1cblxuXHRcdGhhcyhrZXk6IEspOiBib29sZWFuIHtcblx0XHRcdHJldHVybiB0aGlzLl9pbmRleE9mS2V5KHRoaXMuX2tleXMsIGtleSkgPiAtMTtcblx0XHR9XG5cblx0XHRrZXlzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Sz4ge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGltSXRlcmF0b3IodGhpcy5fa2V5cyk7XG5cdFx0fVxuXG5cdFx0c2V0KGtleTogSywgdmFsdWU6IFYpOiBNYXA8SywgVj4ge1xuXHRcdFx0bGV0IGluZGV4ID0gdGhpcy5faW5kZXhPZktleSh0aGlzLl9rZXlzLCBrZXkpO1xuXHRcdFx0aW5kZXggPSBpbmRleCA8IDAgPyB0aGlzLl9rZXlzLmxlbmd0aCA6IGluZGV4O1xuXHRcdFx0dGhpcy5fa2V5c1tpbmRleF0gPSBrZXk7XG5cdFx0XHR0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR2YWx1ZXMoKTogSXRlcmFibGVJdGVyYXRvcjxWPiB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoaW1JdGVyYXRvcih0aGlzLl92YWx1ZXMpO1xuXHRcdH1cblxuXHRcdFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W0ssIFZdPiB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG5cdFx0fVxuXG5cdFx0W1N5bWJvbC50b1N0cmluZ1RhZ106ICdNYXAnID0gJ01hcCc7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBNYXAudHMiLCJpbXBvcnQgZ2xvYmFsIGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IGlzQXJyYXlMaWtlLCBpc0l0ZXJhYmxlLCBJdGVyYWJsZSB9IGZyb20gJy4vaXRlcmF0b3InO1xuaW1wb3J0IGhhcyBmcm9tICcuL3N1cHBvcnQvaGFzJztcbmltcG9ydCAnLi9TeW1ib2wnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlT2JqZWN0IHtcblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgaGFuZGxpbmcgZW1pdHRlZCB2YWx1ZXMsIGVycm9yIGFuZCBjb21wbGV0aW9ucyBmcm9tIHRoZSBvYnNlcnZhYmxlLCBhbmRcblx0ICogZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbS5cblx0ICpcblx0ICogQHBhcmFtIG9ic2VydmVyICAgIFRoZSBvYnNlcnZlciBvYmplY3QgdGhhdCB3aWxsIGhhbmRsZSBldmVudHNcblx0ICpcblx0ICogQHJldHVybiBBIFN1YnNjcmlwdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgdGhlIHN1YnNjcmlwdGlvbi5cblx0ICovXG5cdHN1YnNjcmliZShvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pOiBTdWJzY3JpcHRpb247XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgaGFuZGxpbmcgZW1pdHRlZCB2YWx1ZXMsIGVycm9yIGFuZCBjb21wbGV0aW9ucyBmcm9tIHRoZSBvYnNlcnZhYmxlLCBhbmRcblx0ICogZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbS5cblx0ICpcblx0ICogQHBhcmFtIG9uTmV4dCBBIGZ1bmN0aW9uIHRvIGhhbmRsZSBhbiBlbWl0dGVkIHZhbHVlLiBWYWx1ZSBpcyBwYXNzZWQgaW4gYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byB0aGUgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSBvbkVycm9yIEEgZnVuY3Rpb24gdG8gaGFuZGxlIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBvbk5leHQsIG9yIGR1cmluZyBzdWJzY3JpcHRpb24uXG5cdCAqIEBwYXJhbSBvbkNvbXBsZXRlIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gaXMgY29tcGxldGUsIGFuZCB3aWxsIG5vdCBzZW5kIGFueSBtb3JlIHZhbHVlcy4gVGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gZ2V0IGNhbGxlZCBpZiBhbiBlcnJvciBvY2N1cnMgYW5kIG9uRXJyb3IgaXMgbm90IGRlZmluZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gQSBTdWJzY3JpcHRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFuYWdlIHRoZSBzdWJzY3JpcHRpb24uXG5cdCAqL1xuXHRzdWJzY3JpYmUoXG5cdFx0b25OZXh0OiAodmFsdWU6IFQpID0+IGFueSxcblx0XHRvbkVycm9yPzogKGVycm9yOiBhbnkpID0+IGFueSxcblx0XHRvbkNvbXBsZXRlPzogKGNvbXBsZXRlVmFsdWU/OiBhbnkpID0+IHZvaWRcblx0KTogU3Vic2NyaXB0aW9uO1xuXG5cdFtTeW1ib2wub2JzZXJ2YWJsZV0oKTogdGhpcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZhYmxlQ29uc3RydWN0b3Ige1xuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IG9ic2VydmVyYWJsZSB3aXRoIGEgc3Vic2NyaWJlciBmdW5jdGlvbi4gVGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gd2lsbCBnZXQgY2FsbGVkIHdpdGggYVxuXHQgKiBTdWJzY3JpcHRpb25PYnNlcnZlciBwYXJhbWV0ZXIgZm9yIGNvbnRyb2xsaW5nIHRoZSBzdWJzY3JpcHRpb24uICBJIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmVcblx0ICogcnVuIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiBpcyBjb21wbGV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHN1YnNjcmliZXIgVGhlIHN1YnNjcmlwdGlvbiBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBvYnNlcnZlcnMgYXJlIHN1YnNjcmliZWRcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgdHNcblx0ICogY29uc3Qgc291cmNlID0gbmV3IE9ic2VydmVyPG51bWJlcj4oKG9ic2VydmVyKSA9PiB7XG5cdCAqICAgICBvYnNlcnZlci5uZXh0KDEpO1xuXHQgKiAgICAgb2JzZXJ2ZXIubmV4dCgyKTtcblx0ICogICAgIG9ic2VydmVyLm5leHQoMyk7XG5cdCAqIH0pO1xuXHQgKiBgYGB0c1xuXHQgKi9cblx0bmV3IDxUPihzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KTogT2JzZXJ2YWJsZTxUPjtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuIE9ic2VydmFibGUgZnJvbSBhbm90aGVyIG9iamVjdC4gSWYgdGhlIG9iamVjdCBpcyBpbiBpdHNlbGYgT2JzZXJ2YWJsZSwgdGhlIG9iamVjdCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBPdGhlcndpc2UsIHRoZSB2YWx1ZSB3aWxsIGJlIHdyYXBwZWQgaW4gYW4gT2JzZXJ2YWJsZS4gSWYgdGhlIG9iamVjdCBpcyBpdGVyYWJsZSwgYW4gT2JzZXJ2YWJsZSB3aWxsIGJlIGNyZWF0ZWRcblx0ICogdGhhdCBlbWl0cyBlYWNoIGl0ZW0gb2YgdGhlIGl0ZXJhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBiZSB0dXJuZWQgaW50byBhbiBPYnNlcnZhYmxlXG5cdCAqIEByZXR1cm4gQW4gb2JzZXJ2YWJsZSBmb3IgdGhlIGl0ZW0geW91IHBhc3NlZCBpblxuXHQgKi9cblx0ZnJvbTxUPihpdGVtOiBJdGVyYWJsZTxUPiB8IEFycmF5TGlrZTxUPiB8IE9ic2VydmFibGVPYmplY3QpOiBPYnNlcnZhYmxlPFQ+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gT2JzZXJ2YWJsZSBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVtcyBUaGUgdmFsdWVzIHRvIGJlIGVtaXR0ZWRcblx0ICogQHJldHVybiBBbiBPYnNlcnZhYmxlIHRoYXQgd2lsbCBlbWl0IHRoZSBzcGVjaWZpZWQgdmFsdWVzXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYHRzXG5cdCAqIGxldCBzb3VyY2UgPSBPYnNlcnZhYmxlLm9mKDEsIDIsIDMpO1xuXHQgKiAvLyB3aWxsIGVtaXQgdGhyZWUgc2VwYXJhdGUgdmFsdWVzLCAxLCAyLCBhbmQgMy5cblx0ICogYGBgXG5cdCAqL1xuXHRvZjxUPiguLi5pdGVtczogVFtdKTogT2JzZXJ2YWJsZTxUPjtcbn1cblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIGEgU3ltYm9sLm9ic2VydmVyYWJsZSBtZXRob2QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2YWJsZU9iamVjdCB7XG5cdFtTeW1ib2wub2JzZXJ2YWJsZV06ICgpID0+IGFueTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGV2ZW50cyBlbWl0dGVkIGZyb20gdGhlIHN1YnNjcmlwdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmVyPFQ+IHtcblx0LyoqXG5cdCAqIENhbGxlZCB0byBoYW5kbGUgYSBzaW5nbGUgZW1pdHRlZCBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHdhcyBlbWl0dGVkLlxuXHQgKi9cblx0bmV4dD8odmFsdWU6IFQpOiBhbnk7XG5cblx0LyoqXG5cdCAqIEFuIG9wdGlvbmFsIG1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHN0YXJ0cyAoYmVmb3JlIGFueSBldmVudHMgYXJlIGVtaXR0ZWQpLlxuXHQgKiBAcGFyYW0gb2JzZXJ2ZXJcblx0ICovXG5cdHN0YXJ0PyhvYnNlcnZlcjogU3Vic2NyaXB0aW9uKTogdm9pZDtcblxuXHQvKipcblx0ICogQW4gb3B0aW9uYWwgbWV0aG9kIHRvIGJlIGNhbGxlZCBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHN1YnNjcmlwdGlvbiBvciBoYW5kbGluZy5cblx0ICpcblx0ICogQHBhcmFtIGVycm9yVmFsdWUgVGhlIGVycm9yXG5cdCAqL1xuXHRlcnJvcj8oZXJyb3JWYWx1ZTogYW55KTogYW55O1xuXG5cdC8qKlxuXHQgKiBBbiBvcHRpb25hbCBtZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiBpcyBjb21wbGV0ZWQgKHVubGVzcyBhbiBlcnJvciBvY2N1cnJlZCBhbmQgdGhlIGVycm9yIG1ldGhvZCB3YXMgc3BlY2lmaWVkKVxuXHQgKlxuXHQgKiBAcGFyYW0gY29tcGxldGVWYWx1ZSBUaGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBjb21wbGV0aW9uIG1ldGhvZC5cblx0ICovXG5cdGNvbXBsZXRlPyhjb21wbGV0ZVZhbHVlPzogYW55KTogdm9pZDtcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG9cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpYmFibGU8VD4ge1xuXHRzdWJzY3JpYmUob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KTogU3Vic2NyaXB0aW9uO1xuXHRzdWJzY3JpYmUoXG5cdFx0b25OZXh0OiAodmFsdWU6IFQpID0+IGFueSxcblx0XHRvbkVycm9yPzogKGVycm9yOiBhbnkpID0+IGFueSxcblx0XHRvbkNvbXBsZXRlPzogKGNvbXBsZXRlVmFsdWU/OiBhbnkpID0+IHZvaWRcblx0KTogU3Vic2NyaXB0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmliZXI8VD4ge1xuXHQob2JzZXJ2ZXI6IFN1YnNjcmlwdGlvbk9ic2VydmVyPFQ+KTogKCgpID0+IHZvaWQpIHwgdm9pZCB8IHsgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGluZGl2aWR1YWwgc3Vic2NyaXB0aW9uIHRvIGFuIE9ic2VydmFibGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcblx0LyoqXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBzdWJzY3JpcHRpb24gaXMgY2xvc2VkLiBDbG9zZWQgc3Vic2NyaXB0aW9ucyB3aWxsIG5vdCBlbWl0IHZhbHVlcy5cblx0ICovXG5cdGNsb3NlZDogYm9vbGVhbjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiB0byBjYWxsIHRvIGNsb3NlIHRoZSBzdWJzY3JpcHRpb24uIENhbGxpbmcgdGhpcyB3aWxsIGNhbGwgYW55IGFzc29jaWF0ZWQgdGVhciBkb3duIG1ldGhvZHMuXG5cdCAqL1xuXHR1bnN1YnNjcmliZTogKCgpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB1c2VkIHRvIGNvbnRyb2wgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIGFuZCBhbiBvYnNlcnZlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb25PYnNlcnZlcjxUPiB7XG5cdC8qKlxuXHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc3Vic2NyaXB0aW9uIGlzIGNsb3NlZC5cblx0ICovXG5cdHJlYWRvbmx5IGNsb3NlZDogYm9vbGVhbjtcblxuXHQvKipcblx0ICogRW1pdCBhbiBldmVudCB0byB0aGUgb2JzZXJ2ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgZW1pdHRlZC5cblx0ICovXG5cdG5leHQodmFsdWU6IFQpOiBhbnk7XG5cblx0LyoqXG5cdCAqIFJlcG9ydCBhbiBlcnJvci4gVGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGNsb3NlZCBhZnRlciBhbiBlcnJvciBoYXMgb2NjdXJyZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBlcnJvclZhbHVlIFRoZSBlcnJvciB0byBiZSByZXBvcnRlZC5cblx0ICovXG5cdGVycm9yKGVycm9yVmFsdWU6IGFueSk6IGFueTtcblxuXHQvKipcblx0ICogUmVwb3J0IGNvbXBsZXRpb24gb2YgdGhlIHN1YnNjcmlwdGlvbi4gVGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGNsb3NlZCwgYW5kIG5vIG5ldyB2YWx1ZXMgd2lsbCBiZSBlbWl0dGVkLFxuXHQgKiBhZnRlciBjb21wbGV0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0gY29tcGxldGVWYWx1ZSBBIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGNvbXBsZXRpb24gaGFuZGxlci5cblx0ICovXG5cdGNvbXBsZXRlKGNvbXBsZXRlVmFsdWU/OiBhbnkpOiB2b2lkO1xufVxuXG5leHBvcnQgbGV0IE9ic2VydmFibGU6IE9ic2VydmFibGVDb25zdHJ1Y3RvciA9IGdsb2JhbC5PYnNlcnZhYmxlO1xuXG5pZiAoIWhhcygnZXMtb2JzZXJ2YWJsZScpKSB7XG5cdC8qXG5cdCAqIENyZWF0ZSBhIHN1YnNjcmlwdGlvbiBvYnNlcnZlciBmb3IgYSBnaXZlbiBvYnNlcnZlciwgYW5kIHJldHVybiB0aGUgc3Vic2NyaXB0aW9uLiAgVGhlIFwibG9naWNcIiBmb3IgT2JzZXJ2ZXJhYmxlc1xuXHQgKiBpcyBpbiBoZXJlIVxuXHQgKi9cblx0Y29uc3Qgc3RhcnRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBzdGFydFN1YnNjcmlwdGlvbjxUPihcblx0XHRleGVjdXRvcjogU3Vic2NyaWJlcjxUPixcblx0XHRvYnNlcnZlcjogT2JzZXJ2ZXI8VD5cblx0KTogU3Vic2NyaXB0aW9uIHtcblx0XHRsZXQgY2xvc2VkID0gZmFsc2U7XG5cdFx0bGV0IGNsZWFuVXA6ICgpID0+IHZvaWQgfCB1bmRlZmluZWQ7XG5cblx0XHRmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcblx0XHRcdGlmICghY2xvc2VkKSB7XG5cdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGNsZWFuVXApIHtcblx0XHRcdFx0XHRjbGVhblVwKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdGFydChzdWJzY3JpcHRpb25PYnNlcnZlcjogU3Vic2NyaXB0aW9uT2JzZXJ2ZXI8VD4pIHtcblx0XHRcdGlmIChvYnNlcnZlci5zdGFydCkge1xuXHRcdFx0XHRvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgcmVzdWx0OiBhbnkgPSBleGVjdXRvcihzdWJzY3JpcHRpb25PYnNlcnZlcik7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjbGVhblVwID0gcmVzdWx0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCAmJiAndW5zdWJzY3JpYmUnIGluIHJlc3VsdCkge1xuXHRcdFx0XHRcdGNsZWFuVXAgPSByZXN1bHQudW5zdWJzY3JpYmU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU3Vic2NyaWJlciBtdXN0IHJldHVybiBhIGNhbGxhYmxlIG9yIHN1YnNjcmlwdGlvbicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRcdGlmIChjbGVhblVwKSB7XG5cdFx0XHRcdFx0XHRjbGVhblVwKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9yKGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5leHQodmFsdWU6IFQpOiBhbnkge1xuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5leHQgPSBvYnNlcnZlci5uZXh0O1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG5leHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV4dCh2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIG5leHQgIT09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZlci5uZXh0IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXJyb3IoZXJyb3JWYWx1ZT86IGFueSk6IGFueSB7XG5cdFx0XHRpZiAoIWNsb3NlZCkge1xuXHRcdFx0XHRsZXQgY2xlYW5VcEVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjbGVhblVwRXJyb3IgPSBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgb2JzZXJ2ZXJFcnJvciA9IG9ic2VydmVyLmVycm9yO1xuXG5cdFx0XHRcdGlmIChvYnNlcnZlckVycm9yICE9PSB1bmRlZmluZWQgJiYgb2JzZXJ2ZXJFcnJvciAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JzZXJ2ZXJFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3JSZXN1bHQgPSBvYnNlcnZlckVycm9yKGVycm9yVmFsdWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoY2xlYW5VcEVycm9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgY2xlYW5VcEVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3JSZXN1bHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmVyLmVycm9yIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG9ic2VydmVyLmNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlKGVycm9yVmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGVycm9yVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGVycm9yVmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoY29tcGxldGVWYWx1ZT86IGFueSk6IGFueSB7XG5cdFx0XHRpZiAoIWNsb3NlZCkge1xuXHRcdFx0XHRsZXQgY2xlYW5VcEVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjbGVhblVwRXJyb3IgPSBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgb2JzZXJ2ZXJDb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlO1xuXG5cdFx0XHRcdGlmIChvYnNlcnZlckNvbXBsZXRlICE9PSB1bmRlZmluZWQgJiYgb2JzZXJ2ZXJDb21wbGV0ZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JzZXJ2ZXJDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgY29tcGxldGVSZXN1bHQgPSBvYnNlcnZlckNvbXBsZXRlKGNvbXBsZXRlVmFsdWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoY2xlYW5VcEVycm9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgY2xlYW5VcEVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVSZXN1bHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmVyLmNvbXBsZXRlIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNsZWFuVXBFcnJvcikge1xuXHRcdFx0XHRcdHRocm93IGNsZWFuVXBFcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHN1YnNjcmlwdGlvbiA9IE9iamVjdC5jcmVhdGUoXG5cdFx0XHRPYmplY3QuY3JlYXRlKFxuXHRcdFx0XHR7fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNsb3NlZDoge1xuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjbG9zZWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR1bnN1YnNjcmliZToge1xuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHZhbHVlOiB1bnN1YnNjcmliZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdCk7XG5cblx0XHRjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxuXHRcdFx0e30sXG5cdFx0XHR7XG5cdFx0XHRcdG5leHQ6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogbmV4dCxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogZXJyb3IsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IGNvbXBsZXRlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbG9zZWQ6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNsb3NlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBTdWJzY3JpcHRpb25PYnNlcnZlciBhbmQga2ljayB0aGluZ3Mgb2ZmXG5cdFx0c3RhcnQoT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpKTtcblxuXHRcdC8vIHRoZSBPTkxZIHdheSB0byBjb250cm9sIHRoZSBTdWJzY3JpcHRpb25PYnNlcnZlciBpcyB3aXRoIHRoZSBzdWJzY3JpcHRpb24gb3IgZnJvbSBhIHN1YnNjcmliZXJcblx0XHRyZXR1cm4gc3Vic2NyaXB0aW9uO1xuXHR9O1xuXG5cdE9ic2VydmFibGUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24gbm9uRW51bWVyYWJsZSh0YXJnZXQ6IGFueSwga2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikge1xuXHRcdFx0ZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y2xhc3MgT2JzZXJ2YWJsZTxUPiB7XG5cdFx0XHRwcml2YXRlIF9leGVjdXRvcjogU3Vic2NyaWJlcjxUPjtcblxuXHRcdFx0QG5vbkVudW1lcmFibGVcblx0XHRcdFtTeW1ib2wub2JzZXJ2YWJsZV0oKTogdGhpcyB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdHJ1Y3RvcihzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc3Vic2NyaWJlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3N1YnNjcmliZXIgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2V4ZWN1dG9yID0gc3Vic2NyaWJlcjtcblx0XHRcdH1cblxuXHRcdFx0QG5vbkVudW1lcmFibGVcblx0XHRcdHN1YnNjcmliZShvYnNlcnZlck9yTmV4dDogYW55LCAuLi5saXN0ZW5lcnM6IGFueVtdKSB7XG5cdFx0XHRcdGNvbnN0IFtvbkVycm9yLCBvbkNvbXBsZXRlXSA9IFsuLi5saXN0ZW5lcnNdO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhb2JzZXJ2ZXJPck5leHQgfHxcblx0XHRcdFx0XHR0eXBlb2Ygb2JzZXJ2ZXJPck5leHQgPT09ICdudW1iZXInIHx8XG5cdFx0XHRcdFx0dHlwZW9mIG9ic2VydmVyT3JOZXh0ID09PSAnc3RyaW5nJyB8fFxuXHRcdFx0XHRcdHR5cGVvZiBvYnNlcnZlck9yTmV4dCA9PT0gJ2Jvb2xlYW4nXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JzZXJ2ZXInKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBvYnNlcnZlcjogT2JzZXJ2ZXI8VD47XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBvYnNlcnZlck9yTmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdG9ic2VydmVyID0ge1xuXHRcdFx0XHRcdFx0bmV4dDogb2JzZXJ2ZXJPck5leHRcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlci5lcnJvciA9IG9uRXJyb3I7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlci5jb21wbGV0ZSA9IG9uQ29tcGxldGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9ic2VydmVyID0gb2JzZXJ2ZXJPck5leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3RhcnRTdWJzY3JpcHRpb24odGhpcy5fZXhlY3V0b3IsIG9ic2VydmVyKTtcblx0XHRcdH1cblxuXHRcdFx0QG5vbkVudW1lcmFibGVcblx0XHRcdHN0YXRpYyBvZjxVPiguLi5pdGVtczogVVtdKTogT2JzZXJ2YWJsZTxVPiB7XG5cdFx0XHRcdGxldCBjb25zdHJ1Y3RvcjogdHlwZW9mIE9ic2VydmFibGU7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3RydWN0b3IgPSBPYnNlcnZhYmxlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0cnVjdG9yID0gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoKG9ic2VydmVyOiBTdWJzY3JpcHRpb25PYnNlcnZlcjxVPikgPT4ge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbyBvZiBpdGVtcykge1xuXHRcdFx0XHRcdFx0b2JzZXJ2ZXIubmV4dChvKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2JzZXJ2ZXIuY29tcGxldGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdEBub25FbnVtZXJhYmxlXG5cdFx0XHRzdGF0aWMgZnJvbTxVPihpdGVtOiBJdGVyYWJsZTxVPiB8IEFycmF5TGlrZTxVPiB8IE9ic2VydmFibGU8VT4pOiBPYnNlcnZhYmxlPFU+IHtcblx0XHRcdFx0aWYgKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaXRlbSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBjb25zdHJ1Y3RvcjogdHlwZW9mIE9ic2VydmFibGU7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3RydWN0b3IgPSBPYnNlcnZhYmxlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0cnVjdG9yID0gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IG9ic2VydmFibGVTeW1ib2wgPSAoaXRlbSBhcyBPYnNlcnZhYmxlPFU+KVtTeW1ib2wub2JzZXJ2YWJsZV07XG5cblx0XHRcdFx0aWYgKG9ic2VydmFibGVTeW1ib2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JzZXJ2YWJsZVN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sLm9ic2VydmFibGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0OiBhbnkgPSBvYnNlcnZhYmxlU3ltYm9sLmNhbGwoaXRlbSk7XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRyZXN1bHQgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdFx0cmVzdWx0ID09PSBudWxsIHx8XG5cdFx0XHRcdFx0XHR0eXBlb2YgcmVzdWx0ID09PSAnbnVtYmVyJyB8fFxuXHRcdFx0XHRcdFx0dHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nIHx8XG5cdFx0XHRcdFx0XHR0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUmV0dXJuIHZhbHVlIG9mIFN5bWJvbC5vYnNlcnZhYmxlIG11c3QgYmUgb2JqZWN0Jyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKChyZXN1bHQuY29uc3RydWN0b3IgJiYgcmVzdWx0LmNvbnN0cnVjdG9yID09PSB0aGlzKSB8fCByZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmVzdWx0LnN1YnNjcmliZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3RvcihyZXN1bHQuc3Vic2NyaWJlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGNvbnN0cnVjdG9yLm9mKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb25zdHJ1Y3Rvci5vZihyZXN1bHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIE9ic2VydmFibGUub2YocmVzdWx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNJdGVyYWJsZShpdGVtKSB8fCBpc0FycmF5TGlrZShpdGVtKSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoKG9ic2VydmVyOiBTdWJzY3JpcHRpb25PYnNlcnZlcjxVPikgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGlzQXJyYXlMaWtlKGl0ZW0pKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdG9ic2VydmVyLm5leHQoaXRlbVtpXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgbyBvZiBpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdFx0b2JzZXJ2ZXIubmV4dChvKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b2JzZXJ2ZXIuY29tcGxldGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgaXMgbmVpdGhlciBPYnNlcnZhYmxlIG5vciBJdGVyYWJsZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBPYnNlcnZhYmxlO1xuXHR9KSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBPYnNlcnZhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIE9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBUaGVuYWJsZSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9zdXBwb3J0L3F1ZXVlJztcbmltcG9ydCB7IEl0ZXJhYmxlIH0gZnJvbSAnLi9pdGVyYXRvcic7XG5pbXBvcnQgJy4vU3ltYm9sJztcbmltcG9ydCBoYXMgZnJvbSAnLi9zdXBwb3J0L2hhcyc7XG5cbi8qKlxuICogRXhlY3V0b3IgaXMgdGhlIGludGVyZmFjZSBmb3IgZnVuY3Rpb25zIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIFByb21pc2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0b3I8VD4ge1xuXHQvKipcblx0ICogVGhlIGV4ZWN1dG9yIGZvciB0aGUgcHJvbWlzZVxuXHQgKlxuXHQgKiBAcGFyYW0gcmVzb2x2ZSBUaGUgcmVzb2x2ZXIgY2FsbGJhY2sgb2YgdGhlIHByb21pc2Vcblx0ICogQHBhcmFtIHJlamVjdCBUaGUgcmVqZWN0b3IgY2FsbGJhY2sgb2YgdGhlIHByb21pc2Vcblx0ICovXG5cdChyZXNvbHZlOiAodmFsdWU/OiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBsZXQgU2hpbVByb21pc2U6IHR5cGVvZiBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG5cbmV4cG9ydCBjb25zdCBpc1RoZW5hYmxlID0gZnVuY3Rpb24gaXNUaGVuYWJsZTxUPih2YWx1ZTogYW55KTogdmFsdWUgaXMgUHJvbWlzZUxpa2U8VD4ge1xuXHRyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59O1xuXG5pZiAoIWhhcygnZXM2LXByb21pc2UnKSkge1xuXHRjb25zdCBlbnVtIFN0YXRlIHtcblx0XHRGdWxmaWxsZWQsXG5cdFx0UGVuZGluZyxcblx0XHRSZWplY3RlZFxuXHR9XG5cblx0Z2xvYmFsLlByb21pc2UgPSBTaGltUHJvbWlzZSA9IGNsYXNzIFByb21pc2U8VD4gaW1wbGVtZW50cyBUaGVuYWJsZTxUPiB7XG5cdFx0c3RhdGljIGFsbChpdGVyYWJsZTogSXRlcmFibGU8YW55IHwgUHJvbWlzZUxpa2U8YW55Pj4gfCAoYW55IHwgUHJvbWlzZUxpa2U8YW55PilbXSk6IFByb21pc2U8YW55PiB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlczogYW55W10gPSBbXTtcblx0XHRcdFx0bGV0IGNvbXBsZXRlID0gMDtcblx0XHRcdFx0bGV0IHRvdGFsID0gMDtcblx0XHRcdFx0bGV0IHBvcHVsYXRpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGZ1bGZpbGwoaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSk6IHZvaWQge1xuXHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblx0XHRcdFx0XHQrK2NvbXBsZXRlO1xuXHRcdFx0XHRcdGZpbmlzaCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gZmluaXNoKCk6IHZvaWQge1xuXHRcdFx0XHRcdGlmIChwb3B1bGF0aW5nIHx8IGNvbXBsZXRlIDwgdG90YWwpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzb2x2ZSh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gcHJvY2Vzc0l0ZW0oaW5kZXg6IG51bWJlciwgaXRlbTogYW55KTogdm9pZCB7XG5cdFx0XHRcdFx0Kyt0b3RhbDtcblx0XHRcdFx0XHRpZiAoaXNUaGVuYWJsZShpdGVtKSkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgYW4gaXRlbSBQcm9taXNlIHJlamVjdHMsIHRoaXMgUHJvbWlzZSBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZSBpdGVtXG5cdFx0XHRcdFx0XHQvLyBQcm9taXNlJ3MgcmVqZWN0aW9uIGVycm9yLlxuXHRcdFx0XHRcdFx0aXRlbS50aGVuKGZ1bGZpbGwuYmluZChudWxsLCBpbmRleCksIHJlamVjdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShpdGVtKS50aGVuKGZ1bGZpbGwuYmluZChudWxsLCBpbmRleCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBpID0gMDtcblx0XHRcdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuXHRcdFx0XHRcdHByb2Nlc3NJdGVtKGksIHZhbHVlKTtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9wdWxhdGluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdGZpbmlzaCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHJhY2U8VD4oaXRlcmFibGU6IEl0ZXJhYmxlPFQgfCBQcm9taXNlTGlrZTxUPj4gfCAoVCB8IFByb21pc2VMaWtlPFQ+KVtdKTogUHJvbWlzZTxUW10+IHtcblx0XHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbihyZXNvbHZlOiAodmFsdWU/OiBhbnkpID0+IHZvaWQsIHJlamVjdCkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcblx0XHRcdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdFx0XHRcdC8vIElmIGEgUHJvbWlzZSBpdGVtIHJlamVjdHMsIHRoaXMgUHJvbWlzZSBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZSBpdGVtXG5cdFx0XHRcdFx0XHQvLyBQcm9taXNlJ3MgcmVqZWN0aW9uIGVycm9yLlxuXHRcdFx0XHRcdFx0aXRlbS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShpdGVtKS50aGVuKHJlc29sdmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHJlamVjdChyZWFzb24/OiBhbnkpOiBQcm9taXNlPG5ldmVyPiB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdHJlamVjdChyZWFzb24pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHJlc29sdmUoKTogUHJvbWlzZTx2b2lkPjtcblx0XHRzdGF0aWMgcmVzb2x2ZTxUPih2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KTogUHJvbWlzZTxUPjtcblx0XHRzdGF0aWMgcmVzb2x2ZTxUPih2YWx1ZT86IGFueSk6IFByb21pc2U8VD4ge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdFx0cmVzb2x2ZSg8VD52YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRzdGF0aWMgW1N5bWJvbC5zcGVjaWVzXTogUHJvbWlzZUNvbnN0cnVjdG9yID0gU2hpbVByb21pc2UgYXMgUHJvbWlzZUNvbnN0cnVjdG9yO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIG5ldyBQcm9taXNlLlxuXHRcdCAqXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gZXhlY3V0b3Jcblx0XHQgKiBUaGUgZXhlY3V0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIFByb21pc2UgaXMgaW5zdGFudGlhdGVkLiBJdCBpcyByZXNwb25zaWJsZSBmb3Jcblx0XHQgKiBzdGFydGluZyB0aGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGVuIGl0IGlzIGludm9rZWQuXG5cdFx0ICpcblx0XHQgKiBUaGUgZXhlY3V0b3IgbXVzdCBjYWxsIGVpdGhlciB0aGUgcGFzc2VkIGByZXNvbHZlYCBmdW5jdGlvbiB3aGVuIHRoZSBhc3luY2hyb25vdXMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcblx0XHQgKiBzdWNjZXNzZnVsbHksIG9yIHRoZSBgcmVqZWN0YCBmdW5jdGlvbiB3aGVuIHRoZSBvcGVyYXRpb24gZmFpbHMuXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoZXhlY3V0b3I6IEV4ZWN1dG9yPFQ+KSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIElmIHRydWUsIHRoZSByZXNvbHV0aW9uIG9mIHRoaXMgcHJvbWlzZSBpcyBjaGFpbmVkIChcImxvY2tlZCBpblwiKSB0byBhbm90aGVyIHByb21pc2UuXG5cdFx0XHQgKi9cblx0XHRcdGxldCBpc0NoYWluZWQgPSBmYWxzZTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHByb21pc2UgaXMgaW4gYSByZXNvbHZlZCBzdGF0ZS5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgaXNSZXNvbHZlZCA9ICgpOiBib29sZWFuID0+IHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RhdGUgIT09IFN0YXRlLlBlbmRpbmcgfHwgaXNDaGFpbmVkO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgaW52b2tlZCBvbmNlIHRoZSBhc3luY2hyb25vdXMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG5cdFx0XHQgKi9cblx0XHRcdGxldCBjYWxsYmFja3M6IG51bGwgfCAoQXJyYXk8KCkgPT4gdm9pZD4pID0gW107XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSW5pdGlhbGx5IHB1c2hlcyBjYWxsYmFja3Mgb250byBhIHF1ZXVlIGZvciBleGVjdXRpb24gb25jZSB0aGlzIHByb21pc2Ugc2V0dGxlcy4gQWZ0ZXIgdGhlIHByb21pc2Ugc2V0dGxlcyxcblx0XHRcdCAqIGVucXVldWVzIGNhbGxiYWNrcyBmb3IgZXhlY3V0aW9uIG9uIHRoZSBuZXh0IGV2ZW50IGxvb3AgdHVybi5cblx0XHRcdCAqL1xuXHRcdFx0bGV0IHdoZW5GaW5pc2hlZCA9IGZ1bmN0aW9uKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0XHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0dGxlcyB0aGlzIHByb21pc2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIG5ld1N0YXRlIFRoZSByZXNvbHZlZCBzdGF0ZSBmb3IgdGhpcyBwcm9taXNlLlxuXHRcdFx0ICogQHBhcmFtIHtUfGFueX0gdmFsdWUgVGhlIHJlc29sdmVkIHZhbHVlIGZvciB0aGlzIHByb21pc2UuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IHNldHRsZSA9IChuZXdTdGF0ZTogU3RhdGUsIHZhbHVlOiBhbnkpOiB2b2lkID0+IHtcblx0XHRcdFx0Ly8gQSBwcm9taXNlIGNhbiBvbmx5IGJlIHNldHRsZWQgb25jZS5cblx0XHRcdFx0aWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBlbmRpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR3aGVuRmluaXNoZWQgPSBxdWV1ZU1pY3JvVGFzaztcblxuXHRcdFx0XHQvLyBPbmx5IGVucXVldWUgYSBjYWxsYmFjayBydW5uZXIgaWYgdGhlcmUgYXJlIGNhbGxiYWNrcyBzbyB0aGF0IGluaXRpYWxseSBmdWxmaWxsZWQgUHJvbWlzZXMgZG9uJ3QgaGF2ZSB0b1xuXHRcdFx0XHQvLyB3YWl0IGFuIGV4dHJhIHR1cm4uXG5cdFx0XHRcdGlmIChjYWxsYmFja3MgJiYgY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRxdWV1ZU1pY3JvVGFzayhmdW5jdGlvbigpOiB2b2lkIHtcblx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdFx0XHRcdFx0bGV0IGNvdW50ID0gY2FsbGJhY2tzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzW2ldLmNhbGwobnVsbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXNvbHZlcyB0aGlzIHByb21pc2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIG5ld1N0YXRlIFRoZSByZXNvbHZlZCBzdGF0ZSBmb3IgdGhpcyBwcm9taXNlLlxuXHRcdFx0ICogQHBhcmFtIHtUfGFueX0gdmFsdWUgVGhlIHJlc29sdmVkIHZhbHVlIGZvciB0aGlzIHByb21pc2UuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IHJlc29sdmUgPSAobmV3U3RhdGU6IFN0YXRlLCB2YWx1ZTogYW55KTogdm9pZCA9PiB7XG5cdFx0XHRcdGlmIChpc1Jlc29sdmVkKCkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNUaGVuYWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHR2YWx1ZS50aGVuKHNldHRsZS5iaW5kKG51bGwsIFN0YXRlLkZ1bGZpbGxlZCksIHNldHRsZS5iaW5kKG51bGwsIFN0YXRlLlJlamVjdGVkKSk7XG5cdFx0XHRcdFx0aXNDaGFpbmVkID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXR0bGUobmV3U3RhdGUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy50aGVuID0gPFRSZXN1bHQxID0gVCwgVFJlc3VsdDIgPSBuZXZlcj4oXG5cdFx0XHRcdG9uRnVsZmlsbGVkPzogKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcblx0XHRcdFx0b25SZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KSB8IHVuZGVmaW5lZCB8IG51bGxcblx0XHRcdCk6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4gPT4ge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0XHRcdC8vIHdoZW5GaW5pc2hlZCBpbml0aWFsbHkgcXVldWVzIHVwIGNhbGxiYWNrcyBmb3IgZXhlY3V0aW9uIGFmdGVyIHRoZSBwcm9taXNlIGhhcyBzZXR0bGVkLiBPbmNlIHRoZVxuXHRcdFx0XHRcdC8vIHByb21pc2UgaGFzIHNldHRsZWQsIHdoZW5GaW5pc2hlZCB3aWxsIHNjaGVkdWxlIGNhbGxiYWNrcyBmb3IgZXhlY3V0aW9uIG9uIHRoZSBuZXh0IHR1cm4gdGhyb3VnaCB0aGVcblx0XHRcdFx0XHQvLyBldmVudCBsb29wLlxuXHRcdFx0XHRcdHdoZW5GaW5pc2hlZCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBjYWxsYmFjazogKCh2YWx1ZT86IGFueSkgPT4gYW55KSB8IHVuZGVmaW5lZCB8IG51bGwgPVxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlID09PSBTdGF0ZS5SZWplY3RlZCA/IG9uUmVqZWN0ZWQgOiBvbkZ1bGZpbGxlZDtcblxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FsbGJhY2sodGhpcy5yZXNvbHZlZFZhbHVlKSk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5SZWplY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QodGhpcy5yZXNvbHZlZFZhbHVlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUodGhpcy5yZXNvbHZlZFZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRleGVjdXRvcihyZXNvbHZlLmJpbmQobnVsbCwgU3RhdGUuRnVsZmlsbGVkKSwgcmVzb2x2ZS5iaW5kKG51bGwsIFN0YXRlLlJlamVjdGVkKSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRzZXR0bGUoU3RhdGUuUmVqZWN0ZWQsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjYXRjaDxUUmVzdWx0ID0gbmV2ZXI+KFxuXHRcdFx0b25SZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PikgfCB1bmRlZmluZWQgfCBudWxsXG5cdFx0KTogUHJvbWlzZTxUIHwgVFJlc3VsdD4ge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgcHJvbWlzZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHN0YXRlID0gU3RhdGUuUGVuZGluZztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhpcyBwcm9taXNlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1R8YW55fVxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVzb2x2ZWRWYWx1ZTogYW55O1xuXG5cdFx0dGhlbjogPFRSZXN1bHQxID0gVCwgVFJlc3VsdDIgPSBuZXZlcj4oXG5cdFx0XHRvbmZ1bGZpbGxlZD86ICgodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG5cdFx0XHRvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbFxuXHRcdCkgPT4gUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPjtcblxuXHRcdFtTeW1ib2wudG9TdHJpbmdUYWddOiAnUHJvbWlzZScgPSAnUHJvbWlzZSc7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNoaW1Qcm9taXNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFByb21pc2UudHMiLCJpbXBvcnQgaGFzIGZyb20gJy4vc3VwcG9ydC9oYXMnO1xuaW1wb3J0IGdsb2JhbCBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgeyBnZXRWYWx1ZURlc2NyaXB0b3IgfSBmcm9tICcuL3N1cHBvcnQvdXRpbCc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcblx0aW50ZXJmYWNlIFN5bWJvbENvbnN0cnVjdG9yIHtcblx0XHRvYnNlcnZhYmxlOiBzeW1ib2w7XG5cdH1cbn1cblxuZXhwb3J0IGxldCBTeW1ib2w6IFN5bWJvbENvbnN0cnVjdG9yID0gZ2xvYmFsLlN5bWJvbDtcblxuaWYgKCFoYXMoJ2VzNi1zeW1ib2wnKSkge1xuXHQvKipcblx0ICogVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgYSBzeW1ib2wsIHVzZWQgaW50ZXJuYWxseSB3aXRoaW4gdGhlIFNoaW1cblx0ICogQHBhcmFtICB7YW55fSAgICB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcblx0ICogQHJldHVybiB7c3ltYm9sfSAgICAgICBSZXR1cm5zIHRoZSBzeW1ib2wgb3IgdGhyb3dzXG5cdCAqL1xuXHRjb25zdCB2YWxpZGF0ZVN5bWJvbCA9IGZ1bmN0aW9uIHZhbGlkYXRlU3ltYm9sKHZhbHVlOiBhbnkpOiBzeW1ib2wge1xuXHRcdGlmICghaXNTeW1ib2wodmFsdWUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgJyBpcyBub3QgYSBzeW1ib2wnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdGNvbnN0IGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0Y29uc3QgZGVmaW5lUHJvcGVydHk6IChcblx0XHRvOiBhbnksXG5cdFx0cDogc3RyaW5nIHwgc3ltYm9sLFxuXHRcdGF0dHJpYnV0ZXM6IFByb3BlcnR5RGVzY3JpcHRvciAmIFRoaXNUeXBlPGFueT5cblx0KSA9PiBhbnkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgYXMgYW55O1xuXHRjb25zdCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG5cdGNvbnN0IG9ialByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0Y29uc3QgZ2xvYmFsU3ltYm9sczogeyBba2V5OiBzdHJpbmddOiBzeW1ib2wgfSA9IHt9O1xuXG5cdGNvbnN0IGdldFN5bWJvbE5hbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3QgY3JlYXRlZCA9IGNyZWF0ZShudWxsKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZGVzYzogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcblx0XHRcdGxldCBwb3N0Zml4ID0gMDtcblx0XHRcdGxldCBuYW1lOiBzdHJpbmc7XG5cdFx0XHR3aGlsZSAoY3JlYXRlZFtTdHJpbmcoZGVzYykgKyAocG9zdGZpeCB8fCAnJyldKSB7XG5cdFx0XHRcdCsrcG9zdGZpeDtcblx0XHRcdH1cblx0XHRcdGRlc2MgKz0gU3RyaW5nKHBvc3RmaXggfHwgJycpO1xuXHRcdFx0Y3JlYXRlZFtkZXNjXSA9IHRydWU7XG5cdFx0XHRuYW1lID0gJ0BAJyArIGRlc2M7XG5cblx0XHRcdC8vIEZJWE1FOiBUZW1wb3JhcnkgZ3VhcmQgdW50aWwgdGhlIGR1cGxpY2F0ZSBleGVjdXRpb24gd2hlbiB0ZXN0aW5nIGNhbiBiZVxuXHRcdFx0Ly8gcGlubmVkIGRvd24uXG5cdFx0XHRpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqUHJvdG90eXBlLCBuYW1lKSkge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShvYmpQcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHRoaXM6IFN5bWJvbCwgdmFsdWU6IGFueSkge1xuXHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZ2V0VmFsdWVEZXNjcmlwdG9yKHZhbHVlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fTtcblx0fSkoKTtcblxuXHRjb25zdCBJbnRlcm5hbFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCh0aGlzOiBhbnksIGRlc2NyaXB0aW9uPzogc3RyaW5nIHwgbnVtYmVyKTogc3ltYm9sIHtcblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIEludGVybmFsU3ltYm9sKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlRXJyb3I6IFN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gU3ltYm9sKGRlc2NyaXB0aW9uKTtcblx0fTtcblxuXHRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKHRoaXM6IFN5bWJvbCwgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCBudW1iZXIpOiBzeW1ib2wge1xuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlRXJyb3I6IFN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHRcdH1cblx0XHRjb25zdCBzeW0gPSBPYmplY3QuY3JlYXRlKEludGVybmFsU3ltYm9sLnByb3RvdHlwZSk7XG5cdFx0ZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcoZGVzY3JpcHRpb24pO1xuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKHN5bSwge1xuXHRcdFx0X19kZXNjcmlwdGlvbl9fOiBnZXRWYWx1ZURlc2NyaXB0b3IoZGVzY3JpcHRpb24pLFxuXHRcdFx0X19uYW1lX186IGdldFZhbHVlRGVzY3JpcHRvcihnZXRTeW1ib2xOYW1lKGRlc2NyaXB0aW9uKSlcblx0XHR9KTtcblx0fSBhcyBTeW1ib2xDb25zdHJ1Y3RvcjtcblxuXHQvKiBEZWNvcmF0ZSB0aGUgU3ltYm9sIGZ1bmN0aW9uIHdpdGggdGhlIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMgKi9cblx0ZGVmaW5lUHJvcGVydHkoXG5cdFx0U3ltYm9sLFxuXHRcdCdmb3InLFxuXHRcdGdldFZhbHVlRGVzY3JpcHRvcihmdW5jdGlvbihrZXk6IHN0cmluZyk6IHN5bWJvbCB7XG5cdFx0XHRpZiAoZ2xvYmFsU3ltYm9sc1trZXldKSB7XG5cdFx0XHRcdHJldHVybiBnbG9iYWxTeW1ib2xzW2tleV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKGdsb2JhbFN5bWJvbHNba2V5XSA9IFN5bWJvbChTdHJpbmcoa2V5KSkpO1xuXHRcdH0pXG5cdCk7XG5cdGRlZmluZVByb3BlcnRpZXMoU3ltYm9sLCB7XG5cdFx0a2V5Rm9yOiBnZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24oc3ltOiBzeW1ib2wpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXHRcdFx0bGV0IGtleTogc3RyaW5nO1xuXHRcdFx0dmFsaWRhdGVTeW1ib2woc3ltKTtcblx0XHRcdGZvciAoa2V5IGluIGdsb2JhbFN5bWJvbHMpIHtcblx0XHRcdFx0aWYgKGdsb2JhbFN5bWJvbHNba2V5XSA9PT0gc3ltKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGtleTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdGhhc0luc3RhbmNlOiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcignaGFzSW5zdGFuY2UnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHRpc0NvbmNhdFNwcmVhZGFibGU6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdpc0NvbmNhdFNwcmVhZGFibGUnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHRpdGVyYXRvcjogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ2l0ZXJhdG9yJyksIGZhbHNlLCBmYWxzZSksXG5cdFx0bWF0Y2g6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdtYXRjaCcpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdG9ic2VydmFibGU6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdvYnNlcnZhYmxlJyksIGZhbHNlLCBmYWxzZSksXG5cdFx0cmVwbGFjZTogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ3JlcGxhY2UnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHRzZWFyY2g6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdzZWFyY2gnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHRzcGVjaWVzOiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcignc3BlY2llcycpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdHNwbGl0OiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcignc3BsaXQnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHR0b1ByaW1pdGl2ZTogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ3RvUHJpbWl0aXZlJyksIGZhbHNlLCBmYWxzZSksXG5cdFx0dG9TdHJpbmdUYWc6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCd0b1N0cmluZ1RhZycpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdHVuc2NvcGFibGVzOiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcigndW5zY29wYWJsZXMnKSwgZmFsc2UsIGZhbHNlKVxuXHR9KTtcblxuXHQvKiBEZWNvcmF0ZSB0aGUgSW50ZXJuYWxTeW1ib2wgb2JqZWN0ICovXG5cdGRlZmluZVByb3BlcnRpZXMoSW50ZXJuYWxTeW1ib2wucHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wpLFxuXHRcdHRvU3RyaW5nOiBnZXRWYWx1ZURlc2NyaXB0b3IoXG5cdFx0XHRmdW5jdGlvbih0aGlzOiB7IF9fbmFtZV9fOiBzdHJpbmcgfSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX25hbWVfXztcblx0XHRcdH0sXG5cdFx0XHRmYWxzZSxcblx0XHRcdGZhbHNlXG5cdFx0KVxuXHR9KTtcblxuXHQvKiBEZWNvcmF0ZSB0aGUgU3ltYm9sLnByb3RvdHlwZSAqL1xuXHRkZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbC5wcm90b3R5cGUsIHtcblx0XHR0b1N0cmluZzogZ2V0VmFsdWVEZXNjcmlwdG9yKGZ1bmN0aW9uKHRoaXM6IFN5bWJvbCkge1xuXHRcdFx0cmV0dXJuICdTeW1ib2wgKCcgKyAoPGFueT52YWxpZGF0ZVN5bWJvbCh0aGlzKSkuX19kZXNjcmlwdGlvbl9fICsgJyknO1xuXHRcdH0pLFxuXHRcdHZhbHVlT2Y6IGdldFZhbHVlRGVzY3JpcHRvcihmdW5jdGlvbih0aGlzOiBTeW1ib2wpIHtcblx0XHRcdHJldHVybiB2YWxpZGF0ZVN5bWJvbCh0aGlzKTtcblx0XHR9KVxuXHR9KTtcblxuXHRkZWZpbmVQcm9wZXJ0eShcblx0XHRTeW1ib2wucHJvdG90eXBlLFxuXHRcdFN5bWJvbC50b1ByaW1pdGl2ZSxcblx0XHRnZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24odGhpczogU3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gdmFsaWRhdGVTeW1ib2wodGhpcyk7XG5cdFx0fSlcblx0KTtcblx0ZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBnZXRWYWx1ZURlc2NyaXB0b3IoJ1N5bWJvbCcsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpO1xuXG5cdGRlZmluZVByb3BlcnR5KFxuXHRcdEludGVybmFsU3ltYm9sLnByb3RvdHlwZSxcblx0XHRTeW1ib2wudG9QcmltaXRpdmUsXG5cdFx0Z2V0VmFsdWVEZXNjcmlwdG9yKCg8YW55PlN5bWJvbCkucHJvdG90eXBlW1N5bWJvbC50b1ByaW1pdGl2ZV0sIGZhbHNlLCBmYWxzZSwgdHJ1ZSlcblx0KTtcblx0ZGVmaW5lUHJvcGVydHkoXG5cdFx0SW50ZXJuYWxTeW1ib2wucHJvdG90eXBlLFxuXHRcdFN5bWJvbC50b1N0cmluZ1RhZyxcblx0XHRnZXRWYWx1ZURlc2NyaXB0b3IoKDxhbnk+U3ltYm9sKS5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuXHQpO1xufVxuXG4vKipcbiAqIEEgY3VzdG9tIGd1YXJkIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiBvYmplY3QgaXMgYSBzeW1ib2wgb3Igbm90XG4gKiBAcGFyYW0gIHthbnl9ICAgICAgIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjayB0byBzZWUgaWYgaXQgaXMgYSBzeW1ib2wgb3Igbm90XG4gKiBAcmV0dXJuIHtpcyBzeW1ib2x9ICAgICAgIFJldHVybnMgdHJ1ZSBpZiBhIHN5bWJvbCBvciBub3QgKGFuZCBuYXJyb3dzIHRoZSB0eXBlIGd1YXJkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWU6IGFueSk6IHZhbHVlIGlzIHN5bWJvbCB7XG5cdHJldHVybiAodmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpKSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBGaWxsIGFueSBtaXNzaW5nIHdlbGwga25vd24gc3ltYm9scyBpZiB0aGUgbmF0aXZlIFN5bWJvbCBpcyBtaXNzaW5nIHRoZW1cbiAqL1xuW1xuXHQnaGFzSW5zdGFuY2UnLFxuXHQnaXNDb25jYXRTcHJlYWRhYmxlJyxcblx0J2l0ZXJhdG9yJyxcblx0J3NwZWNpZXMnLFxuXHQncmVwbGFjZScsXG5cdCdzZWFyY2gnLFxuXHQnc3BsaXQnLFxuXHQnbWF0Y2gnLFxuXHQndG9QcmltaXRpdmUnLFxuXHQndG9TdHJpbmdUYWcnLFxuXHQndW5zY29wYWJsZXMnLFxuXHQnb2JzZXJ2YWJsZSdcbl0uZm9yRWFjaCgod2VsbEtub3duKSA9PiB7XG5cdGlmICghKFN5bWJvbCBhcyBhbnkpW3dlbGxLbm93bl0pIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLCB3ZWxsS25vd24sIGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKHdlbGxLbm93biksIGZhbHNlLCBmYWxzZSkpO1xuXHR9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFN5bWJvbC50cyIsImltcG9ydCBnbG9iYWwgZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHsgaXNBcnJheUxpa2UsIEl0ZXJhYmxlIH0gZnJvbSAnLi9pdGVyYXRvcic7XG5pbXBvcnQgaGFzIGZyb20gJy4vc3VwcG9ydC9oYXMnO1xuaW1wb3J0ICcuL1N5bWJvbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vha01hcDxLIGV4dGVuZHMgb2JqZWN0LCBWPiB7XG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBga2V5YCBmcm9tIHRoZSBtYXBcblx0ICpcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlbW92ZVxuXHQgKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgdmFsdWUgd2FzIHJlbW92ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG5cdCAqL1xuXHRkZWxldGUoa2V5OiBLKTogYm9vbGVhbjtcblxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIHZhbHVlLCBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgYGtleWBcblx0ICpcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJldHJpZXZlIHRoZSBgdmFsdWVgIGZvclxuXHQgKiBAcmV0dXJuIHRoZSBgdmFsdWVgIGJhc2VkIG9uIHRoZSBga2V5YCBpZiBmb3VuZCwgb3RoZXJ3aXNlIGBmYWxzZWBcblx0ICovXG5cdGdldChrZXk6IEspOiBWIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgYGtleWAgaXMgcHJlc2VudCBpbiB0aGUgbWFwXG5cdCAqXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGBrZXlgIHRvIGNoZWNrXG5cdCAqIEByZXR1cm4gYHRydWVgIGlmIHRoZSBrZXkgaXMgcGFydCBvZiB0aGUgbWFwLCBvdGhlcndpc2UgYGZhbHNlYC5cblx0ICovXG5cdGhhcyhrZXk6IEspOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBTZXQgYSBgdmFsdWVgIGZvciBhIHBhcnRpY3VsYXIgYGtleWAuXG5cdCAqXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGBrZXlgIHRvIHNldCB0aGUgYHZhbHVlYCBmb3Jcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBgdmFsdWVgIHRvIHNldFxuXHQgKiBAcmV0dXJuIHRoZSBpbnN0YW5jZXNcblx0ICovXG5cdHNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcztcblxuXHRyZWFkb25seSBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1dlYWtNYXAnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYWtNYXBDb25zdHJ1Y3RvciB7XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBgV2Vha01hcGBcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRuZXcgKCk6IFdlYWtNYXA8b2JqZWN0LCBhbnk+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBgV2Vha01hcGBcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVyYWJsZSBBbiBpdGVyYWJsZSB0aGF0IGNvbnRhaW5zIHlpZWxkcyB1cCBrZXkvdmFsdWUgcGFpciBlbnRyaWVzXG5cdCAqL1xuXHRuZXcgPEsgZXh0ZW5kcyBvYmplY3QsIFY+KGl0ZXJhYmxlPzogW0ssIFZdW10pOiBXZWFrTWFwPEssIFY+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBgV2Vha01hcGBcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVyYWJsZSBBbiBpdGVyYWJsZSB0aGF0IGNvbnRhaW5zIHlpZWxkcyB1cCBrZXkvdmFsdWUgcGFpciBlbnRyaWVzXG5cdCAqL1xuXHRuZXcgPEsgZXh0ZW5kcyBvYmplY3QsIFY+KGl0ZXJhYmxlOiBJdGVyYWJsZTxbSywgVl0+KTogV2Vha01hcDxLLCBWPjtcblxuXHRyZWFkb25seSBwcm90b3R5cGU6IFdlYWtNYXA8b2JqZWN0LCBhbnk+O1xufVxuXG5leHBvcnQgbGV0IFdlYWtNYXA6IFdlYWtNYXBDb25zdHJ1Y3RvciA9IGdsb2JhbC5XZWFrTWFwO1xuXG5pbnRlcmZhY2UgRW50cnk8SywgVj4ge1xuXHRrZXk6IEs7XG5cdHZhbHVlOiBWO1xufVxuXG5pZiAoIWhhcygnZXM2LXdlYWttYXAnKSkge1xuXHRjb25zdCBERUxFVEVEOiBhbnkgPSB7fTtcblxuXHRjb25zdCBnZXRVSUQgPSBmdW5jdGlvbiBnZXRVSUQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcblx0fTtcblxuXHRjb25zdCBnZW5lcmF0ZU5hbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0bGV0IHN0YXJ0SWQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgJSAxMDAwMDAwMDApO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlTmFtZSgpOiBzdHJpbmcge1xuXHRcdFx0cmV0dXJuICdfX3dtJyArIGdldFVJRCgpICsgKHN0YXJ0SWQrKyArICdfXycpO1xuXHRcdH07XG5cdH0pKCk7XG5cblx0V2Vha01hcCA9IGNsYXNzIFdlYWtNYXA8SywgVj4ge1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgX25hbWU6IHN0cmluZztcblx0XHRwcml2YXRlIHJlYWRvbmx5IF9mcm96ZW5FbnRyaWVzOiBFbnRyeTxLLCBWPltdO1xuXG5cdFx0Y29uc3RydWN0b3IoaXRlcmFibGU/OiBBcnJheUxpa2U8W0ssIFZdPiB8IEl0ZXJhYmxlPFtLLCBWXT4pIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX25hbWUnLCB7XG5cdFx0XHRcdHZhbHVlOiBnZW5lcmF0ZU5hbWUoKVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2Zyb3plbkVudHJpZXMgPSBbXTtcblxuXHRcdFx0aWYgKGl0ZXJhYmxlKSB7XG5cdFx0XHRcdGlmIChpc0FycmF5TGlrZShpdGVyYWJsZSkpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpdGVtID0gaXRlcmFibGVbaV07XG5cdFx0XHRcdFx0XHR0aGlzLnNldChpdGVtWzBdLCBpdGVtWzFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlcmFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHByaXZhdGUgX2dldEZyb3plbkVudHJ5SW5kZXgoa2V5OiBhbnkpOiBudW1iZXIge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mcm96ZW5FbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9mcm96ZW5FbnRyaWVzW2ldLmtleSA9PT0ga2V5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblxuXHRcdGRlbGV0ZShrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGVudHJ5OiBFbnRyeTxLLCBWPiA9IGtleVt0aGlzLl9uYW1lXTtcblx0XHRcdGlmIChlbnRyeSAmJiBlbnRyeS5rZXkgPT09IGtleSAmJiBlbnRyeS52YWx1ZSAhPT0gREVMRVRFRCkge1xuXHRcdFx0XHRlbnRyeS52YWx1ZSA9IERFTEVURUQ7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmcm96ZW5JbmRleCA9IHRoaXMuX2dldEZyb3plbkVudHJ5SW5kZXgoa2V5KTtcblx0XHRcdGlmIChmcm96ZW5JbmRleCA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2Zyb3plbkVudHJpZXMuc3BsaWNlKGZyb3plbkluZGV4LCAxKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRnZXQoa2V5OiBhbnkpOiBWIHwgdW5kZWZpbmVkIHtcblx0XHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW50cnk6IEVudHJ5PEssIFY+ID0ga2V5W3RoaXMuX25hbWVdO1xuXHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5LmtleSA9PT0ga2V5ICYmIGVudHJ5LnZhbHVlICE9PSBERUxFVEVEKSB7XG5cdFx0XHRcdHJldHVybiBlbnRyeS52YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZnJvemVuSW5kZXggPSB0aGlzLl9nZXRGcm96ZW5FbnRyeUluZGV4KGtleSk7XG5cdFx0XHRpZiAoZnJvemVuSW5kZXggPj0gMCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZnJvemVuRW50cmllc1tmcm96ZW5JbmRleF0udmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFzKGtleTogYW55KTogYm9vbGVhbiB7XG5cdFx0XHRpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW50cnk6IEVudHJ5PEssIFY+ID0ga2V5W3RoaXMuX25hbWVdO1xuXHRcdFx0aWYgKEJvb2xlYW4oZW50cnkgJiYgZW50cnkua2V5ID09PSBrZXkgJiYgZW50cnkudmFsdWUgIT09IERFTEVURUQpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmcm96ZW5JbmRleCA9IHRoaXMuX2dldEZyb3plbkVudHJ5SW5kZXgoa2V5KTtcblx0XHRcdGlmIChmcm96ZW5JbmRleCA+PSAwKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0c2V0KGtleTogYW55LCB2YWx1ZT86IGFueSk6IHRoaXMge1xuXHRcdFx0aWYgKCFrZXkgfHwgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmFsdWUgdXNlZCBhcyB3ZWFrIG1hcCBrZXknKTtcblx0XHRcdH1cblx0XHRcdGxldCBlbnRyeTogRW50cnk8SywgVj4gPSBrZXlbdGhpcy5fbmFtZV07XG5cdFx0XHRpZiAoIWVudHJ5IHx8IGVudHJ5LmtleSAhPT0ga2V5KSB7XG5cdFx0XHRcdGVudHJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG5cdFx0XHRcdFx0a2V5OiB7IHZhbHVlOiBrZXkgfVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoT2JqZWN0LmlzRnJvemVuKGtleSkpIHtcblx0XHRcdFx0XHR0aGlzLl9mcm96ZW5FbnRyaWVzLnB1c2goZW50cnkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMuX25hbWUsIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBlbnRyeVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbnRyeS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0W1N5bWJvbC50b1N0cmluZ1RhZ106ICdXZWFrTWFwJyA9ICdXZWFrTWFwJztcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2Vha01hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBXZWFrTWFwLnRzIiwiY29uc3QgZ2xvYmFsT2JqZWN0OiBhbnkgPSAoZnVuY3Rpb24oKTogYW55IHtcblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0Ly8gZ2xvYmFsIHNwZWMgZGVmaW5lcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBjYWxsZWQgJ2dsb2JhbCdcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcblx0XHQvLyBgZ2xvYmFsYCBpcyBhbHNvIGRlZmluZWQgaW4gTm9kZUpTXG5cdFx0cmV0dXJuIGdsb2JhbDtcblx0fSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdC8vIHdpbmRvdyBpcyBkZWZpbmVkIGluIGJyb3dzZXJzXG5cdFx0cmV0dXJuIHdpbmRvdztcblx0fSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQvLyBzZWxmIGlzIGRlZmluZWQgaW4gV2ViV29ya2Vyc1xuXHRcdHJldHVybiBzZWxmO1xuXHR9XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2xvYmFsLnRzIiwiaW1wb3J0ICcuL1N5bWJvbCc7XG5pbXBvcnQgeyBISUdIX1NVUlJPR0FURV9NQVgsIEhJR0hfU1VSUk9HQVRFX01JTiB9IGZyb20gJy4vc3RyaW5nJztcblxuZXhwb3J0IGludGVyZmFjZSBJdGVyYXRvclJlc3VsdDxUPiB7XG5cdHJlYWRvbmx5IGRvbmU6IGJvb2xlYW47XG5cdHJlYWRvbmx5IHZhbHVlOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZXJhdG9yPFQ+IHtcblx0bmV4dCh2YWx1ZT86IGFueSk6IEl0ZXJhdG9yUmVzdWx0PFQ+O1xuXG5cdHJldHVybj8odmFsdWU/OiBhbnkpOiBJdGVyYXRvclJlc3VsdDxUPjtcblxuXHR0aHJvdz8oZT86IGFueSk6IEl0ZXJhdG9yUmVzdWx0PFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZXJhYmxlPFQ+IHtcblx0W1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmF0b3I8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRlcmFibGVJdGVyYXRvcjxUPiBleHRlbmRzIEl0ZXJhdG9yPFQ+IHtcblx0W1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxUPjtcbn1cblxuY29uc3Qgc3RhdGljRG9uZTogSXRlcmF0b3JSZXN1bHQ8YW55PiA9IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBfc2hpbXNfIGFuIGl0ZXJhdG9yIGludGVyZmFjZSBvbiBhcnJheSBsaWtlIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGltSXRlcmF0b3I8VD4ge1xuXHRwcml2YXRlIF9saXN0OiBBcnJheUxpa2U8VD47XG5cdHByaXZhdGUgX25leHRJbmRleCA9IC0xO1xuXHRwcml2YXRlIF9uYXRpdmVJdGVyYXRvcjogSXRlcmF0b3I8VD47XG5cblx0Y29uc3RydWN0b3IobGlzdDogQXJyYXlMaWtlPFQ+IHwgSXRlcmFibGU8VD4pIHtcblx0XHRpZiAoaXNJdGVyYWJsZShsaXN0KSkge1xuXHRcdFx0dGhpcy5fbmF0aXZlSXRlcmF0b3IgPSBsaXN0W1N5bWJvbC5pdGVyYXRvcl0oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbGlzdCA9IGxpc3Q7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgbmV4dCBpdGVyYXRpb24gcmVzdWx0IGZvciB0aGUgSXRlcmF0b3Jcblx0ICovXG5cdG5leHQoKTogSXRlcmF0b3JSZXN1bHQ8VD4ge1xuXHRcdGlmICh0aGlzLl9uYXRpdmVJdGVyYXRvcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX25hdGl2ZUl0ZXJhdG9yLm5leHQoKTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9saXN0KSB7XG5cdFx0XHRyZXR1cm4gc3RhdGljRG9uZTtcblx0XHR9XG5cdFx0aWYgKCsrdGhpcy5fbmV4dEluZGV4IDwgdGhpcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRvbmU6IGZhbHNlLFxuXHRcdFx0XHR2YWx1ZTogdGhpcy5fbGlzdFt0aGlzLl9uZXh0SW5kZXhdXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gc3RhdGljRG9uZTtcblx0fVxuXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8VD4ge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiBzb21ldGhpbmcgaGFzIGFuIEl0ZXJhYmxlIGludGVyZmFjZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdHlwZSBndWFyZCBhZ2FpbnN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBJdGVyYWJsZTxhbnk+IHtcblx0cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgY2hlY2tpbmcgaWYgc29tZXRoaW5nIGlzIEFycmF5TGlrZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdHlwZSBndWFyZCBhZ2FpbnN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgQXJyYXlMaWtlPGFueT4ge1xuXHRyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgZm9yIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSBpdGVyYWJsZSBUaGUgaXRlcmFibGUgb2JqZWN0IHRvIHJldHVybiB0aGUgaXRlcmF0b3IgZm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQ8VD4oaXRlcmFibGU6IEl0ZXJhYmxlPFQ+IHwgQXJyYXlMaWtlPFQ+KTogSXRlcmF0b3I8VD4gfCB1bmRlZmluZWQge1xuXHRpZiAoaXNJdGVyYWJsZShpdGVyYWJsZSkpIHtcblx0XHRyZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXHR9IGVsc2UgaWYgKGlzQXJyYXlMaWtlKGl0ZXJhYmxlKSkge1xuXHRcdHJldHVybiBuZXcgU2hpbUl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvck9mQ2FsbGJhY2s8VD4ge1xuXHQvKipcblx0ICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYSBmb3JPZigpIGl0ZXJhdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXJcblx0ICogQHBhcmFtIGRvQnJlYWsgQSBmdW5jdGlvbiwgaWYgY2FsbGVkLCB3aWxsIHN0b3AgdGhlIGl0ZXJhdGlvblxuXHQgKi9cblx0KHZhbHVlOiBULCBvYmplY3Q6IEl0ZXJhYmxlPFQ+IHwgQXJyYXlMaWtlPFQ+IHwgc3RyaW5nLCBkb0JyZWFrOiAoKSA9PiB2b2lkKTogdm9pZDtcbn1cblxuLyoqXG4gKiBTaGltcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBgZm9yIC4uLiBvZmAgYmxvY2tzXG4gKlxuICogQHBhcmFtIGl0ZXJhYmxlIFRoZSBvYmplY3QgdGhlIHByb3ZpZGVzIGFuIGludGVyYXRvciBpbnRlcmZhY2VcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlbSBvZiB0aGUgaXRlcmFibGVcbiAqIEBwYXJhbSB0aGlzQXJnIE9wdGlvbmFsIHNjb3BlIHRvIHBhc3MgdGhlIGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JPZjxUPihcblx0aXRlcmFibGU6IEl0ZXJhYmxlPFQ+IHwgQXJyYXlMaWtlPFQ+IHwgc3RyaW5nLFxuXHRjYWxsYmFjazogRm9yT2ZDYWxsYmFjazxUPixcblx0dGhpc0FyZz86IGFueVxuKTogdm9pZCB7XG5cdGxldCBicm9rZW4gPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBkb0JyZWFrKCkge1xuXHRcdGJyb2tlbiA9IHRydWU7XG5cdH1cblxuXHQvKiBXZSBuZWVkIHRvIGhhbmRsZSBpdGVyYXRpb24gb2YgZG91YmxlIGJ5dGUgc3RyaW5ncyBwcm9wZXJseSAqL1xuXHRpZiAoaXNBcnJheUxpa2UoaXRlcmFibGUpICYmIHR5cGVvZiBpdGVyYWJsZSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCBsID0gaXRlcmFibGUubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRsZXQgY2hhciA9IGl0ZXJhYmxlW2ldO1xuXHRcdFx0aWYgKGkgKyAxIDwgbCkge1xuXHRcdFx0XHRjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRpZiAoY29kZSA+PSBISUdIX1NVUlJPR0FURV9NSU4gJiYgY29kZSA8PSBISUdIX1NVUlJPR0FURV9NQVgpIHtcblx0XHRcdFx0XHRjaGFyICs9IGl0ZXJhYmxlWysraV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrLmNhbGwodGhpc0FyZywgY2hhciwgaXRlcmFibGUsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gZ2V0KGl0ZXJhYmxlKTtcblx0XHRpZiAoaXRlcmF0b3IpIHtcblx0XHRcdGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cblx0XHRcdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIGl0ZXJhYmxlLCBkb0JyZWFrKTtcblx0XHRcdFx0aWYgKGJyb2tlbikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gaXRlcmF0b3IudHMiLCJpbXBvcnQgZ2xvYmFsIGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCBoYXMgZnJvbSAnLi9zdXBwb3J0L2hhcyc7XG5pbXBvcnQgeyBpc1N5bWJvbCB9IGZyb20gJy4vU3ltYm9sJztcblxuZXhwb3J0IGludGVyZmFjZSBPYmplY3RBc3NpZ24ge1xuXHQvKipcblx0ICogQ29weSB0aGUgdmFsdWVzIG9mIGFsbCBvZiB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGFcblx0ICogdGFyZ2V0IG9iamVjdC4gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBjb3B5IHRvLlxuXHQgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gY29weSBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0PFQsIFU+KHRhcmdldDogVCwgc291cmNlOiBVKTogVCAmIFU7XG5cblx0LyoqXG5cdCAqIENvcHkgdGhlIHZhbHVlcyBvZiBhbGwgb2YgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byBhXG5cdCAqIHRhcmdldCBvYmplY3QuIFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QuXG5cdCAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gY29weSB0by5cblx0ICogQHBhcmFtIHNvdXJjZTEgVGhlIGZpcnN0IHNvdXJjZSBvYmplY3QgZnJvbSB3aGljaCB0byBjb3B5IHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSBzb3VyY2UyIFRoZSBzZWNvbmQgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cblx0ICovXG5cdDxULCBVLCBWPih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUsIHNvdXJjZTI6IFYpOiBUICYgVSAmIFY7XG5cblx0LyoqXG5cdCAqIENvcHkgdGhlIHZhbHVlcyBvZiBhbGwgb2YgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byBhXG5cdCAqIHRhcmdldCBvYmplY3QuIFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QuXG5cdCAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gY29weSB0by5cblx0ICogQHBhcmFtIHNvdXJjZTEgVGhlIGZpcnN0IHNvdXJjZSBvYmplY3QgZnJvbSB3aGljaCB0byBjb3B5IHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSBzb3VyY2UyIFRoZSBzZWNvbmQgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHNvdXJjZTMgVGhlIHRoaXJkIHNvdXJjZSBvYmplY3QgZnJvbSB3aGljaCB0byBjb3B5IHByb3BlcnRpZXMuXG5cdCAqL1xuXHQ8VCwgVSwgViwgVz4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWLCBzb3VyY2UzOiBXKTogVCAmIFUgJiBWICYgVztcblxuXHQvKipcblx0ICogQ29weSB0aGUgdmFsdWVzIG9mIGFsbCBvZiB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGFcblx0ICogdGFyZ2V0IG9iamVjdC4gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBjb3B5IHRvLlxuXHQgKiBAcGFyYW0gc291cmNlcyBPbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllc1xuXHQgKi9cblx0KHRhcmdldDogb2JqZWN0LCAuLi5zb3VyY2VzOiBhbnlbXSk6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPYmplY3RFbnRlcmllcyB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGtleS92YWx1ZXMgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3Rcblx0ICogQHBhcmFtIG8gT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuIFRoaXMgY2FuIGJlIGFuIG9iamVjdCB0aGF0IHlvdSBjcmVhdGVkIG9yIGFuIGV4aXN0aW5nIERvY3VtZW50IE9iamVjdCBNb2RlbCAoRE9NKSBvYmplY3QuXG5cdCAqL1xuXHQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0sIEsgZXh0ZW5kcyBrZXlvZiBUPihvOiBUKTogW2tleW9mIFQsIFRbS11dW107XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yga2V5L3ZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuXHQgKiBAcGFyYW0gbyBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy4gVGhpcyBjYW4gYmUgYW4gb2JqZWN0IHRoYXQgeW91IGNyZWF0ZWQgb3IgYW4gZXhpc3RpbmcgRG9jdW1lbnQgT2JqZWN0IE1vZGVsIChET00pIG9iamVjdC5cblx0ICovXG5cdChvOiBvYmplY3QpOiBbc3RyaW5nLCBhbnldW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB7XG5cdDxUPihvOiBUKTogeyBbSyBpbiBrZXlvZiBUXTogUHJvcGVydHlEZXNjcmlwdG9yIH07XG5cdChvOiBhbnkpOiB7IFtrZXk6IHN0cmluZ106IFByb3BlcnR5RGVzY3JpcHRvciB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdFZhbHVlcyB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuXHQgKiBAcGFyYW0gbyBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy4gVGhpcyBjYW4gYmUgYW4gb2JqZWN0IHRoYXQgeW91IGNyZWF0ZWQgb3IgYW4gZXhpc3RpbmcgRG9jdW1lbnQgT2JqZWN0IE1vZGVsIChET00pIG9iamVjdC5cblx0ICovXG5cdDxUPihvOiB7IFtzOiBzdHJpbmddOiBUIH0pOiBUW107XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG5cdCAqIEBwYXJhbSBvIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLiBUaGlzIGNhbiBiZSBhbiBvYmplY3QgdGhhdCB5b3UgY3JlYXRlZCBvciBhbiBleGlzdGluZyBEb2N1bWVudCBPYmplY3QgTW9kZWwgKERPTSkgb2JqZWN0LlxuXHQgKi9cblx0KG86IG9iamVjdCk6IGFueVtdO1xufVxuXG5leHBvcnQgbGV0IGFzc2lnbjogT2JqZWN0QXNzaWduO1xuXG4vKipcbiAqIEdldHMgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICogQW4gb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgaXMgb25lIHRoYXQgaXMgZGVmaW5lZCBkaXJlY3RseSBvbiB0aGUgb2JqZWN0IGFuZCBpcyBub3RcbiAqIGluaGVyaXRlZCBmcm9tIHRoZSBvYmplY3QncyBwcm90b3R5cGUuXG4gKiBAcGFyYW0gbyBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gcCBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGxldCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IDxULCBLIGV4dGVuZHMga2V5b2YgVD4obzogVCwgcHJvcGVydHlLZXk6IEspID0+IFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgb3duIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LiBUaGUgb3duIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFyZSB0aG9zZSB0aGF0IGFyZSBkZWZpbmVkIGRpcmVjdGx5XG4gKiBvbiB0aGF0IG9iamVjdCwgYW5kIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gdGhlIG9iamVjdCdzIHByb3RvdHlwZS4gVGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGluY2x1ZGUgYm90aCBmaWVsZHMgKG9iamVjdHMpIGFuZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gbyBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgb3duIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBsZXQgZ2V0T3duUHJvcGVydHlOYW1lczogKG86IGFueSkgPT4gc3RyaW5nW107XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgc3ltYm9sIHByb3BlcnRpZXMgZm91bmQgZGlyZWN0bHkgb24gb2JqZWN0IG8uXG4gKiBAcGFyYW0gbyBPYmplY3QgdG8gcmV0cmlldmUgdGhlIHN5bWJvbHMgZnJvbS5cbiAqL1xuZXhwb3J0IGxldCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IChvOiBhbnkpID0+IHN5bWJvbFtdO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlMSBUaGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUyIFRoZSBzZWNvbmQgdmFsdWUuXG4gKi9cbmV4cG9ydCBsZXQgaXM6ICh2YWx1ZTE6IGFueSwgdmFsdWUyOiBhbnkpID0+IGJvb2xlYW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiBhbiBvYmplY3QuXG4gKiBAcGFyYW0gbyBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy4gVGhpcyBjYW4gYmUgYW4gb2JqZWN0IHRoYXQgeW91IGNyZWF0ZWQgb3IgYW4gZXhpc3RpbmcgRG9jdW1lbnQgT2JqZWN0IE1vZGVsIChET00pIG9iamVjdC5cbiAqL1xuZXhwb3J0IGxldCBrZXlzOiAobzogb2JqZWN0KSA9PiBzdHJpbmdbXTtcblxuLyogRVM3IE9iamVjdCBzdGF0aWMgbWV0aG9kcyAqL1xuXG5leHBvcnQgbGV0IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cbmV4cG9ydCBsZXQgZW50cmllczogT2JqZWN0RW50ZXJpZXM7XG5cbmV4cG9ydCBsZXQgdmFsdWVzOiBPYmplY3RWYWx1ZXM7XG5cbmlmIChoYXMoJ2VzNi1vYmplY3QnKSkge1xuXHRjb25zdCBnbG9iYWxPYmplY3QgPSBnbG9iYWwuT2JqZWN0O1xuXHRhc3NpZ24gPSBnbG9iYWxPYmplY3QuYXNzaWduO1xuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnbG9iYWxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXHRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2xvYmFsT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5cdGdldE93blByb3BlcnR5U3ltYm9scyA9IGdsb2JhbE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdGlzID0gZ2xvYmFsT2JqZWN0LmlzO1xuXHRrZXlzID0gZ2xvYmFsT2JqZWN0LmtleXM7XG59IGVsc2Uge1xuXHRrZXlzID0gZnVuY3Rpb24gc3ltYm9sQXdhcmVLZXlzKG86IG9iamVjdCk6IHN0cmluZ1tdIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMobykuZmlsdGVyKChrZXkpID0+ICFCb29sZWFuKGtleS5tYXRjaCgvXkBALisvKSkpO1xuXHR9O1xuXG5cdGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQ6IGFueSwgLi4uc291cmNlczogYW55W10pIHtcblx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblx0XHRzb3VyY2VzLmZvckVhY2goKG5leHRTb3VyY2UpID0+IHtcblx0XHRcdGlmIChuZXh0U291cmNlKSB7XG5cdFx0XHRcdC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0XHRrZXlzKG5leHRTb3VyY2UpLmZvckVhY2goKG5leHRLZXkpID0+IHtcblx0XHRcdFx0XHR0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRvO1xuXHR9O1xuXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihcblx0XHRvOiBhbnksXG5cdFx0cHJvcDogc3RyaW5nIHwgc3ltYm9sXG5cdCk6IFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKGlzU3ltYm9sKHByb3ApKSB7XG5cdFx0XHRyZXR1cm4gKDxhbnk+T2JqZWN0KS5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgcHJvcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHByb3ApO1xuXHRcdH1cblx0fTtcblxuXHRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvOiBhbnkpOiBzdHJpbmdbXSB7XG5cdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8pLmZpbHRlcigoa2V5KSA9PiAhQm9vbGVhbihrZXkubWF0Y2goL15AQC4rLykpKTtcblx0fTtcblxuXHRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMobzogYW55KTogc3ltYm9sW10ge1xuXHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKVxuXHRcdFx0LmZpbHRlcigoa2V5KSA9PiBCb29sZWFuKGtleS5tYXRjaCgvXkBALisvKSkpXG5cdFx0XHQubWFwKChrZXkpID0+IFN5bWJvbC5mb3Ioa2V5LnN1YnN0cmluZygyKSkpO1xuXHR9O1xuXG5cdGlzID0gZnVuY3Rpb24gaXModmFsdWUxOiBhbnksIHZhbHVlMjogYW55KTogYm9vbGVhbiB7XG5cdFx0aWYgKHZhbHVlMSA9PT0gdmFsdWUyKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUxICE9PSAwIHx8IDEgLyB2YWx1ZTEgPT09IDEgLyB2YWx1ZTI7IC8vIC0wXG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMSAmJiB2YWx1ZTIgIT09IHZhbHVlMjsgLy8gTmFOXG5cdH07XG59XG5cbmlmIChoYXMoJ2VzMjAxNy1vYmplY3QnKSkge1xuXHRjb25zdCBnbG9iYWxPYmplY3QgPSBnbG9iYWwuT2JqZWN0O1xuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gZ2xvYmFsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cdGVudHJpZXMgPSBnbG9iYWxPYmplY3QuZW50cmllcztcblx0dmFsdWVzID0gZ2xvYmFsT2JqZWN0LnZhbHVlcztcbn0gZWxzZSB7XG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG86IGFueSkge1xuXHRcdHJldHVybiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG8pLnJlZHVjZShcblx0XHRcdChwcmV2aW91cywga2V5KSA9PiB7XG5cdFx0XHRcdHByZXZpb3VzW2tleV0gPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobywga2V5KSE7XG5cdFx0XHRcdHJldHVybiBwcmV2aW91cztcblx0XHRcdH0sXG5cdFx0XHR7fSBhcyB7IFtrZXk6IHN0cmluZ106IFByb3BlcnR5RGVzY3JpcHRvciB9XG5cdFx0KTtcblx0fTtcblxuXHRlbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcyhvOiBhbnkpOiBbc3RyaW5nLCBhbnldW10ge1xuXHRcdHJldHVybiBrZXlzKG8pLm1hcCgoa2V5KSA9PiBba2V5LCBvW2tleV1dIGFzIFtzdHJpbmcsIGFueV0pO1xuXHR9O1xuXG5cdHZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyhvOiBhbnkpOiBhbnlbXSB7XG5cdFx0cmV0dXJuIGtleXMobykubWFwKChrZXkpID0+IG9ba2V5XSk7XG5cdH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb2JqZWN0LnRzIiwiaW1wb3J0IGdsb2JhbCBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgaGFzIGZyb20gJy4vc3VwcG9ydC9oYXMnO1xuaW1wb3J0IHsgd3JhcE5hdGl2ZSB9IGZyb20gJy4vc3VwcG9ydC91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJpbmdOb3JtYWxpemUge1xuXHQvKipcblx0ICogUmV0dXJucyB0aGUgU3RyaW5nIHZhbHVlIHJlc3VsdCBvZiBub3JtYWxpemluZyB0aGUgc3RyaW5nIGludG8gdGhlIG5vcm1hbGl6YXRpb24gZm9ybVxuXHQgKiBuYW1lZCBieSBmb3JtIGFzIHNwZWNpZmllZCBpbiBVbmljb2RlIFN0YW5kYXJkIEFubmV4ICMxNSwgVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm1zLlxuXHQgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nXG5cdCAqIEBwYXJhbSBmb3JtIEFwcGxpY2FibGUgdmFsdWVzOiBcIk5GQ1wiLCBcIk5GRFwiLCBcIk5GS0NcIiwgb3IgXCJORktEXCIsIElmIG5vdCBzcGVjaWZpZWQgZGVmYXVsdFxuXHQgKiBpcyBcIk5GQ1wiXG5cdCAqL1xuXHQodGFyZ2V0OiBzdHJpbmcsIGZvcm06ICdORkMnIHwgJ05GRCcgfCAnTkZLQycgfCAnTkZLRCcpOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIFN0cmluZyB2YWx1ZSByZXN1bHQgb2Ygbm9ybWFsaXppbmcgdGhlIHN0cmluZyBpbnRvIHRoZSBub3JtYWxpemF0aW9uIGZvcm1cblx0ICogbmFtZWQgYnkgZm9ybSBhcyBzcGVjaWZpZWQgaW4gVW5pY29kZSBTdGFuZGFyZCBBbm5leCAjMTUsIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3Jtcy5cblx0ICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZ1xuXHQgKiBAcGFyYW0gZm9ybSBBcHBsaWNhYmxlIHZhbHVlczogXCJORkNcIiwgXCJORkRcIiwgXCJORktDXCIsIG9yIFwiTkZLRFwiLCBJZiBub3Qgc3BlY2lmaWVkIGRlZmF1bHRcblx0ICogaXMgXCJORkNcIlxuXHQgKi9cblx0KHRhcmdldDogc3RyaW5nLCBmb3JtPzogc3RyaW5nKTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSBtaW5pbXVtIGxvY2F0aW9uIG9mIGhpZ2ggc3Vycm9nYXRlc1xuICovXG5leHBvcnQgY29uc3QgSElHSF9TVVJST0dBVEVfTUlOID0gMHhkODAwO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGxvY2F0aW9uIG9mIGhpZ2ggc3Vycm9nYXRlc1xuICovXG5leHBvcnQgY29uc3QgSElHSF9TVVJST0dBVEVfTUFYID0gMHhkYmZmO1xuXG4vKipcbiAqIFRoZSBtaW5pbXVtIGxvY2F0aW9uIG9mIGxvdyBzdXJyb2dhdGVzXG4gKi9cbmV4cG9ydCBjb25zdCBMT1dfU1VSUk9HQVRFX01JTiA9IDB4ZGMwMDtcblxuLyoqXG4gKiBUaGUgbWF4aW11bSBsb2NhdGlvbiBvZiBsb3cgc3Vycm9nYXRlc1xuICovXG5leHBvcnQgY29uc3QgTE9XX1NVUlJPR0FURV9NQVggPSAweGRmZmY7XG5cbi8qIEVTNiBzdGF0aWMgbWV0aG9kcyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgU3RyaW5nIHZhbHVlIHdob3NlIGVsZW1lbnRzIGFyZSwgaW4gb3JkZXIsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGlzdCBlbGVtZW50cy5cbiAqIElmIGxlbmd0aCBpcyAwLCB0aGUgZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuICogQHBhcmFtIGNvZGVQb2ludHMgVGhlIGNvZGUgcG9pbnRzIHRvIGdlbmVyYXRlIHRoZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGxldCBmcm9tQ29kZVBvaW50OiAoLi4uY29kZVBvaW50czogbnVtYmVyW10pID0+IHN0cmluZztcblxuLyoqXG4gKiBgcmF3YCBpcyBpbnRlbmRlZCBmb3IgdXNlIGFzIGEgdGFnIGZ1bmN0aW9uIG9mIGEgVGFnZ2VkIFRlbXBsYXRlIFN0cmluZy4gV2hlbiBjYWxsZWRcbiAqIGFzIHN1Y2ggdGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgYmUgYSB3ZWxsIGZvcm1lZCB0ZW1wbGF0ZSBjYWxsIHNpdGUgb2JqZWN0IGFuZCB0aGUgcmVzdFxuICogcGFyYW1ldGVyIHdpbGwgY29udGFpbiB0aGUgc3Vic3RpdHV0aW9uIHZhbHVlcy5cbiAqIEBwYXJhbSB0ZW1wbGF0ZSBBIHdlbGwtZm9ybWVkIHRlbXBsYXRlIHN0cmluZyBjYWxsIHNpdGUgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0gc3Vic3RpdHV0aW9ucyBBIHNldCBvZiBzdWJzdGl0dXRpb24gdmFsdWVzLlxuICovXG5leHBvcnQgbGV0IHJhdzogKHRlbXBsYXRlOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uc3Vic3RpdHV0aW9uczogYW55W10pID0+IHN0cmluZztcblxuLyogRVM2IGluc3RhbmNlIG1ldGhvZHMgKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgbm9ubmVnYXRpdmUgaW50ZWdlciBOdW1iZXIgbGVzcyB0aGFuIDExMTQxMTIgKDB4MTEwMDAwKSB0aGF0IGlzIHRoZSBjb2RlIHBvaW50XG4gKiB2YWx1ZSBvZiB0aGUgVVRGLTE2IGVuY29kZWQgY29kZSBwb2ludCBzdGFydGluZyBhdCB0aGUgc3RyaW5nIGVsZW1lbnQgYXQgcG9zaXRpb24gcG9zIGluXG4gKiB0aGUgU3RyaW5nIHJlc3VsdGluZyBmcm9tIGNvbnZlcnRpbmcgdGhpcyBvYmplY3QgdG8gYSBTdHJpbmcuXG4gKiBJZiB0aGVyZSBpcyBubyBlbGVtZW50IGF0IHRoYXQgcG9zaXRpb24sIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkLlxuICogSWYgYSB2YWxpZCBVVEYtMTYgc3Vycm9nYXRlIHBhaXIgZG9lcyBub3QgYmVnaW4gYXQgcG9zLCB0aGUgcmVzdWx0IGlzIHRoZSBjb2RlIHVuaXQgYXQgcG9zLlxuICovXG5leHBvcnQgbGV0IGNvZGVQb2ludEF0OiAodGFyZ2V0OiBzdHJpbmcsIHBvcz86IG51bWJlcikgPT4gbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VxdWVuY2Ugb2YgZWxlbWVudHMgb2Ygc2VhcmNoU3RyaW5nIGNvbnZlcnRlZCB0byBhIFN0cmluZyBpcyB0aGVcbiAqIHNhbWUgYXMgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgb2YgdGhpcyBvYmplY3QgKGNvbnZlcnRlZCB0byBhIFN0cmluZykgc3RhcnRpbmcgYXRcbiAqIGVuZFBvc2l0aW9uIOKAkyBsZW5ndGgodGhpcykuIE90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICovXG5leHBvcnQgbGV0IGVuZHNXaXRoOiAodGFyZ2V0OiBzdHJpbmcsIHNlYXJjaFN0cmluZzogc3RyaW5nLCBlbmRQb3NpdGlvbj86IG51bWJlcikgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgc2VhcmNoU3RyaW5nIGFwcGVhcnMgYXMgYSBzdWJzdHJpbmcgb2YgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIHRoaXNcbiAqIG9iamVjdCB0byBhIFN0cmluZywgYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIHRoYXQgYXJlXG4gKiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gcG9zaXRpb247IG90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBzdHJpbmdcbiAqIEBwYXJhbSBzZWFyY2hTdHJpbmcgc2VhcmNoIHN0cmluZ1xuICogQHBhcmFtIHBvc2l0aW9uIElmIHBvc2l0aW9uIGlzIHVuZGVmaW5lZCwgMCBpcyBhc3N1bWVkLCBzbyBhcyB0byBzZWFyY2ggYWxsIG9mIHRoZSBTdHJpbmcuXG4gKi9cbmV4cG9ydCBsZXQgaW5jbHVkZXM6ICh0YXJnZXQ6IHN0cmluZywgc2VhcmNoU3RyaW5nOiBzdHJpbmcsIHBvc2l0aW9uPzogbnVtYmVyKSA9PiBib29sZWFuO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFN0cmluZyB2YWx1ZSByZXN1bHQgb2Ygbm9ybWFsaXppbmcgdGhlIHN0cmluZyBpbnRvIHRoZSBub3JtYWxpemF0aW9uIGZvcm1cbiAqIG5hbWVkIGJ5IGZvcm0gYXMgc3BlY2lmaWVkIGluIFVuaWNvZGUgU3RhbmRhcmQgQW5uZXggIzE1LCBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybXMuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nXG4gKiBAcGFyYW0gZm9ybSBBcHBsaWNhYmxlIHZhbHVlczogXCJORkNcIiwgXCJORkRcIiwgXCJORktDXCIsIG9yIFwiTkZLRFwiLCBJZiBub3Qgc3BlY2lmaWVkIGRlZmF1bHRcbiAqIGlzIFwiTkZDXCJcbiAqL1xuZXhwb3J0IGxldCBub3JtYWxpemU6IFN0cmluZ05vcm1hbGl6ZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgU3RyaW5nIHZhbHVlIHRoYXQgaXMgbWFkZSBmcm9tIGNvdW50IGNvcGllcyBhcHBlbmRlZCB0b2dldGhlci4gSWYgY291bnQgaXMgMCxcbiAqIFQgaXMgdGhlIGVtcHR5IFN0cmluZyBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSBjb3VudCBudW1iZXIgb2YgY29waWVzIHRvIGFwcGVuZFxuICovXG5leHBvcnQgbGV0IHJlcGVhdDogKHRhcmdldDogc3RyaW5nLCBjb3VudD86IG51bWJlcikgPT4gc3RyaW5nO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VxdWVuY2Ugb2YgZWxlbWVudHMgb2Ygc2VhcmNoU3RyaW5nIGNvbnZlcnRlZCB0byBhIFN0cmluZyBpcyB0aGVcbiAqIHNhbWUgYXMgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgb2YgdGhpcyBvYmplY3QgKGNvbnZlcnRlZCB0byBhIFN0cmluZykgc3RhcnRpbmcgYXRcbiAqIHBvc2l0aW9uLiBPdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAqL1xuZXhwb3J0IGxldCBzdGFydHNXaXRoOiAodGFyZ2V0OiBzdHJpbmcsIHNlYXJjaFN0cmluZzogc3RyaW5nLCBwb3NpdGlvbj86IG51bWJlcikgPT4gYm9vbGVhbjtcblxuLyogRVM3IGluc3RhbmNlIG1ldGhvZHMgKi9cblxuLyoqXG4gKiBQYWRzIHRoZSBjdXJyZW50IHN0cmluZyB3aXRoIGEgZ2l2ZW4gc3RyaW5nIChwb3NzaWJseSByZXBlYXRlZCkgc28gdGhhdCB0aGUgcmVzdWx0aW5nIHN0cmluZyByZWFjaGVzIGEgZ2l2ZW4gbGVuZ3RoLlxuICogVGhlIHBhZGRpbmcgaXMgYXBwbGllZCBmcm9tIHRoZSBlbmQgKHJpZ2h0KSBvZiB0aGUgY3VycmVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZ1xuICogQHBhcmFtIG1heExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgc3RyaW5nIG9uY2UgdGhlIGN1cnJlbnQgc3RyaW5nIGhhcyBiZWVuIHBhZGRlZC5cbiAqICAgICAgICBJZiB0aGlzIHBhcmFtZXRlciBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgc3RyaW5nJ3MgbGVuZ3RoLCB0aGUgY3VycmVudCBzdHJpbmcgd2lsbCBiZSByZXR1cm5lZCBhcyBpdCBpcy5cbiAqXG4gKiBAcGFyYW0gZmlsbFN0cmluZyBUaGUgc3RyaW5nIHRvIHBhZCB0aGUgY3VycmVudCBzdHJpbmcgd2l0aC5cbiAqICAgICAgICBJZiB0aGlzIHN0cmluZyBpcyB0b28gbG9uZywgaXQgd2lsbCBiZSB0cnVuY2F0ZWQgYW5kIHRoZSBsZWZ0LW1vc3QgcGFydCB3aWxsIGJlIGFwcGxpZWQuXG4gKiAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgcGFyYW1ldGVyIGlzIFwiIFwiIChVKzAwMjApLlxuICovXG5leHBvcnQgbGV0IHBhZEVuZDogKHRhcmdldDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciwgZmlsbFN0cmluZz86IHN0cmluZykgPT4gc3RyaW5nO1xuXG4vKipcbiAqIFBhZHMgdGhlIGN1cnJlbnQgc3RyaW5nIHdpdGggYSBnaXZlbiBzdHJpbmcgKHBvc3NpYmx5IHJlcGVhdGVkKSBzbyB0aGF0IHRoZSByZXN1bHRpbmcgc3RyaW5nIHJlYWNoZXMgYSBnaXZlbiBsZW5ndGguXG4gKiBUaGUgcGFkZGluZyBpcyBhcHBsaWVkIGZyb20gdGhlIHN0YXJ0IChsZWZ0KSBvZiB0aGUgY3VycmVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZ1xuICogQHBhcmFtIG1heExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgc3RyaW5nIG9uY2UgdGhlIGN1cnJlbnQgc3RyaW5nIGhhcyBiZWVuIHBhZGRlZC5cbiAqICAgICAgICBJZiB0aGlzIHBhcmFtZXRlciBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgc3RyaW5nJ3MgbGVuZ3RoLCB0aGUgY3VycmVudCBzdHJpbmcgd2lsbCBiZSByZXR1cm5lZCBhcyBpdCBpcy5cbiAqXG4gKiBAcGFyYW0gZmlsbFN0cmluZyBUaGUgc3RyaW5nIHRvIHBhZCB0aGUgY3VycmVudCBzdHJpbmcgd2l0aC5cbiAqICAgICAgICBJZiB0aGlzIHN0cmluZyBpcyB0b28gbG9uZywgaXQgd2lsbCBiZSB0cnVuY2F0ZWQgYW5kIHRoZSBsZWZ0LW1vc3QgcGFydCB3aWxsIGJlIGFwcGxpZWQuXG4gKiAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgcGFyYW1ldGVyIGlzIFwiIFwiIChVKzAwMjApLlxuICovXG5leHBvcnQgbGV0IHBhZFN0YXJ0OiAodGFyZ2V0OiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyLCBmaWxsU3RyaW5nPzogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbmlmIChoYXMoJ2VzNi1zdHJpbmcnKSAmJiBoYXMoJ2VzNi1zdHJpbmctcmF3JykpIHtcblx0ZnJvbUNvZGVQb2ludCA9IGdsb2JhbC5TdHJpbmcuZnJvbUNvZGVQb2ludDtcblx0cmF3ID0gZ2xvYmFsLlN0cmluZy5yYXc7XG5cblx0Y29kZVBvaW50QXQgPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KTtcblx0ZW5kc1dpdGggPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKTtcblx0aW5jbHVkZXMgPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKTtcblx0bm9ybWFsaXplID0gd3JhcE5hdGl2ZShnbG9iYWwuU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUpO1xuXHRyZXBlYXQgPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLnJlcGVhdCk7XG5cdHN0YXJ0c1dpdGggPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpO1xufSBlbHNlIHtcblx0LyoqXG5cdCAqIFZhbGlkYXRlcyB0aGF0IHRleHQgaXMgZGVmaW5lZCwgYW5kIG5vcm1hbGl6ZXMgcG9zaXRpb24gKGJhc2VkIG9uIHRoZSBnaXZlbiBkZWZhdWx0IGlmIHRoZSBpbnB1dCBpcyBOYU4pLlxuXHQgKiBVc2VkIGJ5IHN0YXJ0c1dpdGgsIGluY2x1ZGVzLCBhbmQgZW5kc1dpdGguXG5cdCAqXG5cdCAqIEByZXR1cm4gTm9ybWFsaXplZCBwb3NpdGlvbi5cblx0ICovXG5cdGNvbnN0IG5vcm1hbGl6ZVN1YnN0cmluZ0FyZ3MgPSBmdW5jdGlvbihcblx0XHRuYW1lOiBzdHJpbmcsXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdHNlYXJjaDogc3RyaW5nLFxuXHRcdHBvc2l0aW9uOiBudW1iZXIsXG5cdFx0aXNFbmQ6IGJvb2xlYW4gPSBmYWxzZVxuXHQpOiBbc3RyaW5nLCBzdHJpbmcsIG51bWJlcl0ge1xuXHRcdGlmICh0ZXh0ID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZy4nICsgbmFtZSArICcgcmVxdWlyZXMgYSB2YWxpZCBzdHJpbmcgdG8gc2VhcmNoIGFnYWluc3QuJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cdFx0cG9zaXRpb24gPSBwb3NpdGlvbiAhPT0gcG9zaXRpb24gPyAoaXNFbmQgPyBsZW5ndGggOiAwKSA6IHBvc2l0aW9uO1xuXHRcdHJldHVybiBbdGV4dCwgU3RyaW5nKHNlYXJjaCksIE1hdGgubWluKE1hdGgubWF4KHBvc2l0aW9uLCAwKSwgbGVuZ3RoKV07XG5cdH07XG5cblx0ZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50czogbnVtYmVyW10pOiBzdHJpbmcge1xuXHRcdC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcuZnJvbUNvZGVQb2ludFxuXHRcdGNvbnN0IGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKCFsZW5ndGgpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRjb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXHRcdGNvbnN0IE1BWF9TSVpFID0gMHg0MDAwO1xuXHRcdGxldCBjb2RlVW5pdHM6IG51bWJlcltdID0gW107XG5cdFx0bGV0IGluZGV4ID0gLTE7XG5cdFx0bGV0IHJlc3VsdCA9ICcnO1xuXG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGxldCBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG5cblx0XHRcdC8vIENvZGUgcG9pbnRzIG11c3QgYmUgZmluaXRlIGludGVnZXJzIHdpdGhpbiB0aGUgdmFsaWQgcmFuZ2Vcblx0XHRcdGxldCBpc1ZhbGlkID1cblx0XHRcdFx0aXNGaW5pdGUoY29kZVBvaW50KSAmJiBNYXRoLmZsb29yKGNvZGVQb2ludCkgPT09IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPj0gMCAmJiBjb2RlUG9pbnQgPD0gMHgxMGZmZmY7XG5cdFx0XHRpZiAoIWlzVmFsaWQpIHtcblx0XHRcdFx0dGhyb3cgUmFuZ2VFcnJvcignc3RyaW5nLmZyb21Db2RlUG9pbnQ6IEludmFsaWQgY29kZSBwb2ludCAnICsgY29kZVBvaW50KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcblx0XHRcdFx0Ly8gQk1QIGNvZGUgcG9pbnRcblx0XHRcdFx0Y29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG5cdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0XHRcdFx0bGV0IGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIEhJR0hfU1VSUk9HQVRFX01JTjtcblx0XHRcdFx0bGV0IGxvd1N1cnJvZ2F0ZSA9IGNvZGVQb2ludCAlIDB4NDAwICsgTE9XX1NVUlJPR0FURV9NSU47XG5cdFx0XHRcdGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcblx0XHRcdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpO1xuXHRcdFx0XHRjb2RlVW5pdHMubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRyYXcgPSBmdW5jdGlvbiByYXcoY2FsbFNpdGU6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5zdWJzdGl0dXRpb25zOiBhbnlbXSk6IHN0cmluZyB7XG5cdFx0bGV0IHJhd1N0cmluZ3MgPSBjYWxsU2l0ZS5yYXc7XG5cdFx0bGV0IHJlc3VsdCA9ICcnO1xuXHRcdGxldCBudW1TdWJzdGl0dXRpb25zID0gc3Vic3RpdHV0aW9ucy5sZW5ndGg7XG5cblx0XHRpZiAoY2FsbFNpdGUgPT0gbnVsbCB8fCBjYWxsU2l0ZS5yYXcgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nLnJhdyByZXF1aXJlcyBhIHZhbGlkIGNhbGxTaXRlIG9iamVjdCB3aXRoIGEgcmF3IHZhbHVlJyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHJhd1N0cmluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlc3VsdCArPSByYXdTdHJpbmdzW2ldICsgKGkgPCBudW1TdWJzdGl0dXRpb25zICYmIGkgPCBsZW5ndGggLSAxID8gc3Vic3RpdHV0aW9uc1tpXSA6ICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGNvZGVQb2ludEF0ID0gZnVuY3Rpb24gY29kZVBvaW50QXQodGV4dDogc3RyaW5nLCBwb3NpdGlvbjogbnVtYmVyID0gMCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG5cdFx0Ly8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRcblx0XHRpZiAodGV4dCA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcuY29kZVBvaW50QXQgcmVxdXJpZXMgYSB2YWxpZCBzdHJpbmcuJyk7XG5cdFx0fVxuXHRcdGNvbnN0IGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuXG5cdFx0aWYgKHBvc2l0aW9uICE9PSBwb3NpdGlvbikge1xuXHRcdFx0cG9zaXRpb24gPSAwO1xuXHRcdH1cblx0XHRpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IGxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBHZXQgdGhlIGZpcnN0IGNvZGUgdW5pdFxuXHRcdGNvbnN0IGZpcnN0ID0gdGV4dC5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcblx0XHRpZiAoZmlyc3QgPj0gSElHSF9TVVJST0dBVEVfTUlOICYmIGZpcnN0IDw9IEhJR0hfU1VSUk9HQVRFX01BWCAmJiBsZW5ndGggPiBwb3NpdGlvbiArIDEpIHtcblx0XHRcdC8vIFN0YXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIgKGhpZ2ggc3Vycm9nYXRlIGFuZCB0aGVyZSBpcyBhIG5leHQgY29kZSB1bml0KTsgY2hlY2sgZm9yIGxvdyBzdXJyb2dhdGVcblx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0Y29uc3Qgc2Vjb25kID0gdGV4dC5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSk7XG5cdFx0XHRpZiAoc2Vjb25kID49IExPV19TVVJST0dBVEVfTUlOICYmIHNlY29uZCA8PSBMT1dfU1VSUk9HQVRFX01BWCkge1xuXHRcdFx0XHRyZXR1cm4gKGZpcnN0IC0gSElHSF9TVVJST0dBVEVfTUlOKSAqIDB4NDAwICsgc2Vjb25kIC0gTE9XX1NVUlJPR0FURV9NSU4gKyAweDEwMDAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH07XG5cblx0ZW5kc1dpdGggPSBmdW5jdGlvbiBlbmRzV2l0aCh0ZXh0OiBzdHJpbmcsIHNlYXJjaDogc3RyaW5nLCBlbmRQb3NpdGlvbj86IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdGlmIChlbmRQb3NpdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRlbmRQb3NpdGlvbiA9IHRleHQubGVuZ3RoO1xuXHRcdH1cblxuXHRcdFt0ZXh0LCBzZWFyY2gsIGVuZFBvc2l0aW9uXSA9IG5vcm1hbGl6ZVN1YnN0cmluZ0FyZ3MoJ2VuZHNXaXRoJywgdGV4dCwgc2VhcmNoLCBlbmRQb3NpdGlvbiwgdHJ1ZSk7XG5cblx0XHRjb25zdCBzdGFydCA9IGVuZFBvc2l0aW9uIC0gc2VhcmNoLmxlbmd0aDtcblx0XHRpZiAoc3RhcnQgPCAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHQuc2xpY2Uoc3RhcnQsIGVuZFBvc2l0aW9uKSA9PT0gc2VhcmNoO1xuXHR9O1xuXG5cdGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModGV4dDogc3RyaW5nLCBzZWFyY2g6IHN0cmluZywgcG9zaXRpb246IG51bWJlciA9IDApOiBib29sZWFuIHtcblx0XHRbdGV4dCwgc2VhcmNoLCBwb3NpdGlvbl0gPSBub3JtYWxpemVTdWJzdHJpbmdBcmdzKCdpbmNsdWRlcycsIHRleHQsIHNlYXJjaCwgcG9zaXRpb24pO1xuXHRcdHJldHVybiB0ZXh0LmluZGV4T2Yoc2VhcmNoLCBwb3NpdGlvbikgIT09IC0xO1xuXHR9O1xuXG5cdHJlcGVhdCA9IGZ1bmN0aW9uIHJlcGVhdCh0ZXh0OiBzdHJpbmcsIGNvdW50OiBudW1iZXIgPSAwKTogc3RyaW5nIHtcblx0XHQvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRcblx0XHRpZiAodGV4dCA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcucmVwZWF0IHJlcXVpcmVzIGEgdmFsaWQgc3RyaW5nLicpO1xuXHRcdH1cblx0XHRpZiAoY291bnQgIT09IGNvdW50KSB7XG5cdFx0XHRjb3VudCA9IDA7XG5cdFx0fVxuXHRcdGlmIChjb3VudCA8IDAgfHwgY291bnQgPT09IEluZmluaXR5KSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RyaW5nLnJlcGVhdCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgY291bnQuJyk7XG5cdFx0fVxuXG5cdFx0bGV0IHJlc3VsdCA9ICcnO1xuXHRcdHdoaWxlIChjb3VudCkge1xuXHRcdFx0aWYgKGNvdW50ICUgMikge1xuXHRcdFx0XHRyZXN1bHQgKz0gdGV4dDtcblx0XHRcdH1cblx0XHRcdGlmIChjb3VudCA+IDEpIHtcblx0XHRcdFx0dGV4dCArPSB0ZXh0O1xuXHRcdFx0fVxuXHRcdFx0Y291bnQgPj49IDE7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0c3RhcnRzV2l0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGgodGV4dDogc3RyaW5nLCBzZWFyY2g6IHN0cmluZywgcG9zaXRpb246IG51bWJlciA9IDApOiBib29sZWFuIHtcblx0XHRzZWFyY2ggPSBTdHJpbmcoc2VhcmNoKTtcblx0XHRbdGV4dCwgc2VhcmNoLCBwb3NpdGlvbl0gPSBub3JtYWxpemVTdWJzdHJpbmdBcmdzKCdzdGFydHNXaXRoJywgdGV4dCwgc2VhcmNoLCBwb3NpdGlvbik7XG5cblx0XHRjb25zdCBlbmQgPSBwb3NpdGlvbiArIHNlYXJjaC5sZW5ndGg7XG5cdFx0aWYgKGVuZCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHQuc2xpY2UocG9zaXRpb24sIGVuZCkgPT09IHNlYXJjaDtcblx0fTtcbn1cblxuaWYgKGhhcygnZXMyMDE3LXN0cmluZycpKSB7XG5cdHBhZEVuZCA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUucGFkRW5kKTtcblx0cGFkU3RhcnQgPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0KTtcbn0gZWxzZSB7XG5cdHBhZEVuZCA9IGZ1bmN0aW9uIHBhZEVuZCh0ZXh0OiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyLCBmaWxsU3RyaW5nOiBzdHJpbmcgPSAnICcpOiBzdHJpbmcge1xuXHRcdGlmICh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nLnJlcGVhdCByZXF1aXJlcyBhIHZhbGlkIHN0cmluZy4nKTtcblx0XHR9XG5cblx0XHRpZiAobWF4TGVuZ3RoID09PSBJbmZpbml0eSkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0cmluZy5wYWRFbmQgcmVxdWlyZXMgYSBub24tbmVnYXRpdmUgZmluaXRlIGNvdW50LicpO1xuXHRcdH1cblxuXHRcdGlmIChtYXhMZW5ndGggPT09IG51bGwgfHwgbWF4TGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbWF4TGVuZ3RoIDwgMCkge1xuXHRcdFx0bWF4TGVuZ3RoID0gMDtcblx0XHR9XG5cblx0XHRsZXQgc3RyVGV4dCA9IFN0cmluZyh0ZXh0KTtcblx0XHRjb25zdCBwYWRkaW5nID0gbWF4TGVuZ3RoIC0gc3RyVGV4dC5sZW5ndGg7XG5cblx0XHRpZiAocGFkZGluZyA+IDApIHtcblx0XHRcdHN0clRleHQgKz1cblx0XHRcdFx0cmVwZWF0KGZpbGxTdHJpbmcsIE1hdGguZmxvb3IocGFkZGluZyAvIGZpbGxTdHJpbmcubGVuZ3RoKSkgK1xuXHRcdFx0XHRmaWxsU3RyaW5nLnNsaWNlKDAsIHBhZGRpbmcgJSBmaWxsU3RyaW5nLmxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0clRleHQ7XG5cdH07XG5cblx0cGFkU3RhcnQgPSBmdW5jdGlvbiBwYWRTdGFydCh0ZXh0OiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyLCBmaWxsU3RyaW5nOiBzdHJpbmcgPSAnICcpOiBzdHJpbmcge1xuXHRcdGlmICh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nLnJlcGVhdCByZXF1aXJlcyBhIHZhbGlkIHN0cmluZy4nKTtcblx0XHR9XG5cblx0XHRpZiAobWF4TGVuZ3RoID09PSBJbmZpbml0eSkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0cmluZy5wYWRTdGFydCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgY291bnQuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG1heExlbmd0aCA9PT0gbnVsbCB8fCBtYXhMZW5ndGggPT09IHVuZGVmaW5lZCB8fCBtYXhMZW5ndGggPCAwKSB7XG5cdFx0XHRtYXhMZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGxldCBzdHJUZXh0ID0gU3RyaW5nKHRleHQpO1xuXHRcdGNvbnN0IHBhZGRpbmcgPSBtYXhMZW5ndGggLSBzdHJUZXh0Lmxlbmd0aDtcblxuXHRcdGlmIChwYWRkaW5nID4gMCkge1xuXHRcdFx0c3RyVGV4dCA9XG5cdFx0XHRcdHJlcGVhdChmaWxsU3RyaW5nLCBNYXRoLmZsb29yKHBhZGRpbmcgLyBmaWxsU3RyaW5nLmxlbmd0aCkpICtcblx0XHRcdFx0ZmlsbFN0cmluZy5zbGljZSgwLCBwYWRkaW5nICUgZmlsbFN0cmluZy5sZW5ndGgpICtcblx0XHRcdFx0c3RyVGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyVGV4dDtcblx0fTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzdHJpbmcudHMiLCJpbXBvcnQgZ2xvYmFsIGZyb20gJy4uL2dsb2JhbCc7XG5pbXBvcnQgaGFzIGZyb20gJy4vaGFzJztcbmltcG9ydCB7IEhhbmRsZSB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuXG5mdW5jdGlvbiBleGVjdXRlVGFzayhpdGVtOiBRdWV1ZUl0ZW0gfCB1bmRlZmluZWQpOiB2b2lkIHtcblx0aWYgKGl0ZW0gJiYgaXRlbS5pc0FjdGl2ZSAmJiBpdGVtLmNhbGxiYWNrKSB7XG5cdFx0aXRlbS5jYWxsYmFjaygpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldFF1ZXVlSGFuZGxlKGl0ZW06IFF1ZXVlSXRlbSwgZGVzdHJ1Y3Rvcj86ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KTogSGFuZGxlIHtcblx0cmV0dXJuIHtcblx0XHRkZXN0cm95OiBmdW5jdGlvbih0aGlzOiBIYW5kbGUpIHtcblx0XHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHRpdGVtLmlzQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRpdGVtLmNhbGxiYWNrID0gbnVsbDtcblxuXHRcdFx0aWYgKGRlc3RydWN0b3IpIHtcblx0XHRcdFx0ZGVzdHJ1Y3RvcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuaW50ZXJmYWNlIFBvc3RNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cdHNvdXJjZTogYW55O1xuXHRkYXRhOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVldWVJdGVtIHtcblx0aXNBY3RpdmU6IGJvb2xlYW47XG5cdGNhbGxiYWNrOiBudWxsIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KTtcbn1cblxubGV0IGNoZWNrTWljcm9UYXNrUXVldWU6ICgpID0+IHZvaWQ7XG5sZXQgbWljcm9UYXNrczogUXVldWVJdGVtW107XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gdGhlIG1hY3JvdGFzayBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGJlIHF1ZXVlZCBhbmQgbGF0ZXIgZXhlY3V0ZWQuXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhIGBkZXN0cm95YCBtZXRob2QgdGhhdCwgd2hlbiBjYWxsZWQsIHByZXZlbnRzIHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZyb20gZXhlY3V0aW5nLlxuICovXG5leHBvcnQgY29uc3QgcXVldWVUYXNrID0gKGZ1bmN0aW9uKCkge1xuXHRsZXQgZGVzdHJ1Y3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG5cdGxldCBlbnF1ZXVlOiAoaXRlbTogUXVldWVJdGVtKSA9PiB2b2lkO1xuXG5cdC8vIFNpbmNlIHRoZSBJRSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0SW1tZWRpYXRlYCBpcyBub3QgZmxhd2xlc3MsIHdlIHdpbGwgdGVzdCBmb3IgYHBvc3RNZXNzYWdlYCBmaXJzdC5cblx0aWYgKGhhcygncG9zdG1lc3NhZ2UnKSkge1xuXHRcdGNvbnN0IHF1ZXVlOiBRdWV1ZUl0ZW1bXSA9IFtdO1xuXG5cdFx0Z2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldmVudDogUG9zdE1lc3NhZ2VFdmVudCk6IHZvaWQge1xuXHRcdFx0Ly8gQ29uZmlybSB0aGF0IHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgYnkgdGhpcyBwYXJ0aWN1bGFyIGltcGxlbWVudGF0aW9uLlxuXHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmIGV2ZW50LmRhdGEgPT09ICdkb2pvLXF1ZXVlLW1lc3NhZ2UnKSB7XG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRcdGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRleGVjdXRlVGFzayhxdWV1ZS5zaGlmdCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW06IFF1ZXVlSXRlbSk6IHZvaWQge1xuXHRcdFx0cXVldWUucHVzaChpdGVtKTtcblx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSgnZG9qby1xdWV1ZS1tZXNzYWdlJywgJyonKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYgKGhhcygnc2V0aW1tZWRpYXRlJykpIHtcblx0XHRkZXN0cnVjdG9yID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xuXHRcdGVucXVldWUgPSBmdW5jdGlvbihpdGVtOiBRdWV1ZUl0ZW0pOiBhbnkge1xuXHRcdFx0cmV0dXJuIHNldEltbWVkaWF0ZShleGVjdXRlVGFzay5iaW5kKG51bGwsIGl0ZW0pKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGRlc3RydWN0b3IgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xuXHRcdGVucXVldWUgPSBmdW5jdGlvbihpdGVtOiBRdWV1ZUl0ZW0pOiBhbnkge1xuXHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZXhlY3V0ZVRhc2suYmluZChudWxsLCBpdGVtKSwgMCk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHF1ZXVlVGFzayhjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRcdGNvbnN0IGl0ZW06IFF1ZXVlSXRlbSA9IHtcblx0XHRcdGlzQWN0aXZlOiB0cnVlLFxuXHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrXG5cdFx0fTtcblx0XHRjb25zdCBpZDogYW55ID0gZW5xdWV1ZShpdGVtKTtcblxuXHRcdHJldHVybiBnZXRRdWV1ZUhhbmRsZShcblx0XHRcdGl0ZW0sXG5cdFx0XHRkZXN0cnVjdG9yICYmXG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlc3RydWN0b3IoaWQpO1xuXHRcdFx0XHR9XG5cdFx0KTtcblx0fVxuXG5cdC8vIFRPRE86IFVzZSBhc3BlY3QuYmVmb3JlIHdoZW4gaXQgaXMgYXZhaWxhYmxlLlxuXHRyZXR1cm4gaGFzKCdtaWNyb3Rhc2tzJylcblx0XHQ/IHF1ZXVlVGFza1xuXHRcdDogZnVuY3Rpb24oY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KTogSGFuZGxlIHtcblx0XHRcdFx0Y2hlY2tNaWNyb1Rhc2tRdWV1ZSgpO1xuXHRcdFx0XHRyZXR1cm4gcXVldWVUYXNrKGNhbGxiYWNrKTtcblx0XHRcdH07XG59KSgpO1xuXG4vLyBXaGVuIG5vIG1lY2hhbmlzbSBmb3IgcmVnaXN0ZXJpbmcgbWljcm90YXNrcyBpcyBleHBvc2VkIGJ5IHRoZSBlbnZpcm9ubWVudCwgbWljcm90YXNrcyB3aWxsXG4vLyBiZSBxdWV1ZWQgYW5kIHRoZW4gZXhlY3V0ZWQgaW4gYSBzaW5nbGUgbWFjcm90YXNrIGJlZm9yZSB0aGUgb3RoZXIgbWFjcm90YXNrcyBhcmUgZXhlY3V0ZWQuXG5pZiAoIWhhcygnbWljcm90YXNrcycpKSB7XG5cdGxldCBpc01pY3JvVGFza1F1ZXVlZCA9IGZhbHNlO1xuXG5cdG1pY3JvVGFza3MgPSBbXTtcblx0Y2hlY2tNaWNyb1Rhc2tRdWV1ZSA9IGZ1bmN0aW9uKCk6IHZvaWQge1xuXHRcdGlmICghaXNNaWNyb1Rhc2tRdWV1ZWQpIHtcblx0XHRcdGlzTWljcm9UYXNrUXVldWVkID0gdHJ1ZTtcblx0XHRcdHF1ZXVlVGFzayhmdW5jdGlvbigpIHtcblx0XHRcdFx0aXNNaWNyb1Rhc2tRdWV1ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAobWljcm9UYXNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRsZXQgaXRlbTogUXVldWVJdGVtIHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdHdoaWxlICgoaXRlbSA9IG1pY3JvVGFza3Muc2hpZnQoKSkpIHtcblx0XHRcdFx0XHRcdGV4ZWN1dGVUYXNrKGl0ZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhbiBhbmltYXRpb24gdGFzayB3aXRoIGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBpZiBpdCBleGlzdHMsIG9yIHdpdGggYHF1ZXVlVGFza2Agb3RoZXJ3aXNlLlxuICpcbiAqIFNpbmNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSdzIGJlaGF2aW9yIGRvZXMgbm90IG1hdGNoIHRoYXQgZXhwZWN0ZWQgZnJvbSBgcXVldWVUYXNrYCwgaXQgaXMgbm90IHVzZWQgdGhlcmUuXG4gKiBIb3dldmVyLCBhdCB0aW1lcyBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGRlbGVnYXRlIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZTsgaGVuY2UgdGhlIGZvbGxvd2luZyBtZXRob2QuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBiZSBxdWV1ZWQgYW5kIGxhdGVyIGV4ZWN1dGVkLlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYSBgZGVzdHJveWAgbWV0aG9kIHRoYXQsIHdoZW4gY2FsbGVkLCBwcmV2ZW50cyB0aGUgcmVnaXN0ZXJlZCBjYWxsYmFjayBmcm9tIGV4ZWN1dGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXVlQW5pbWF0aW9uVGFzayA9IChmdW5jdGlvbigpIHtcblx0aWYgKCFoYXMoJ3JhZicpKSB7XG5cdFx0cmV0dXJuIHF1ZXVlVGFzaztcblx0fVxuXG5cdGZ1bmN0aW9uIHF1ZXVlQW5pbWF0aW9uVGFzayhjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRcdGNvbnN0IGl0ZW06IFF1ZXVlSXRlbSA9IHtcblx0XHRcdGlzQWN0aXZlOiB0cnVlLFxuXHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrXG5cdFx0fTtcblx0XHRjb25zdCByYWZJZDogbnVtYmVyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGV4ZWN1dGVUYXNrLmJpbmQobnVsbCwgaXRlbSkpO1xuXG5cdFx0cmV0dXJuIGdldFF1ZXVlSGFuZGxlKGl0ZW0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gVE9ETzogVXNlIGFzcGVjdC5iZWZvcmUgd2hlbiBpdCBpcyBhdmFpbGFibGUuXG5cdHJldHVybiBoYXMoJ21pY3JvdGFza3MnKVxuXHRcdD8gcXVldWVBbmltYXRpb25UYXNrXG5cdFx0OiBmdW5jdGlvbihjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRcdFx0XHRjaGVja01pY3JvVGFza1F1ZXVlKCk7XG5cdFx0XHRcdHJldHVybiBxdWV1ZUFuaW1hdGlvblRhc2soY2FsbGJhY2spO1xuXHRcdFx0fTtcbn0pKCk7XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAqXG4gKiBBbnkgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgd2l0aCBgcXVldWVNaWNyb1Rhc2tgIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBuZXh0IG1hY3JvdGFzay4gSWYgbm8gbmF0aXZlXG4gKiBtZWNoYW5pc20gZm9yIHNjaGVkdWxpbmcgbWFjcm90YXNrcyBpcyBleHBvc2VkLCB0aGVuIGFueSBjYWxsYmFja3Mgd2lsbCBiZSBmaXJlZCBiZWZvcmUgYW55IG1hY3JvdGFza1xuICogcmVnaXN0ZXJlZCB3aXRoIGBxdWV1ZVRhc2tgIG9yIGBxdWV1ZUFuaW1hdGlvblRhc2tgLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gYmUgcXVldWVkIGFuZCBsYXRlciBleGVjdXRlZC5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGEgYGRlc3Ryb3lgIG1ldGhvZCB0aGF0LCB3aGVuIGNhbGxlZCwgcHJldmVudHMgdGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2sgZnJvbSBleGVjdXRpbmcuXG4gKi9cbmV4cG9ydCBsZXQgcXVldWVNaWNyb1Rhc2sgPSAoZnVuY3Rpb24oKSB7XG5cdGxldCBlbnF1ZXVlOiAoaXRlbTogUXVldWVJdGVtKSA9PiB2b2lkO1xuXG5cdGlmIChoYXMoJ2hvc3Qtbm9kZScpKSB7XG5cdFx0ZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW06IFF1ZXVlSXRlbSk6IHZvaWQge1xuXHRcdFx0Z2xvYmFsLnByb2Nlc3MubmV4dFRpY2soZXhlY3V0ZVRhc2suYmluZChudWxsLCBpdGVtKSk7XG5cdFx0fTtcblx0fSBlbHNlIGlmIChoYXMoJ2VzNi1wcm9taXNlJykpIHtcblx0XHRlbnF1ZXVlID0gZnVuY3Rpb24oaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG5cdFx0XHRnbG9iYWwuUHJvbWlzZS5yZXNvbHZlKGl0ZW0pLnRoZW4oZXhlY3V0ZVRhc2spO1xuXHRcdH07XG5cdH0gZWxzZSBpZiAoaGFzKCdkb20tbXV0YXRpb25vYnNlcnZlcicpKSB7XG5cdFx0LyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWUgKi9cblx0XHRjb25zdCBIb3N0TXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXHRcdGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRjb25zdCBxdWV1ZTogUXVldWVJdGVtW10gPSBbXTtcblx0XHRjb25zdCBvYnNlcnZlciA9IG5ldyBIb3N0TXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpOiB2b2lkIHtcblx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRpZiAoaXRlbSAmJiBpdGVtLmlzQWN0aXZlICYmIGl0ZW0uY2FsbGJhY2spIHtcblx0XHRcdFx0XHRpdGVtLmNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuXG5cdFx0ZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW06IFF1ZXVlSXRlbSk6IHZvaWQge1xuXHRcdFx0cXVldWUucHVzaChpdGVtKTtcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdxdWV1ZVN0YXR1cycsICcxJyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRlbnF1ZXVlID0gZnVuY3Rpb24oaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG5cdFx0XHRjaGVja01pY3JvVGFza1F1ZXVlKCk7XG5cdFx0XHRtaWNyb1Rhc2tzLnB1c2goaXRlbSk7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRcdGNvbnN0IGl0ZW06IFF1ZXVlSXRlbSA9IHtcblx0XHRcdGlzQWN0aXZlOiB0cnVlLFxuXHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrXG5cdFx0fTtcblxuXHRcdGVucXVldWUoaXRlbSk7XG5cblx0XHRyZXR1cm4gZ2V0UXVldWVIYW5kbGUoaXRlbSk7XG5cdH07XG59KSgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHF1ZXVlLnRzIiwiY29uc3QgaTE4biA9IHJlcXVpcmUoJ0Bkb2pvL2kxOG4vaTE4bicpO1xuY29uc3QgbG9hZENsZHJEYXRhID0gcmVxdWlyZSgnQGRvam8vaTE4bi9jbGRyL2xvYWQnKS5kZWZhdWx0O1xuY29uc3Qgc3lzdGVtTG9jYWxlID0gaTE4bi5zeXN0ZW1Mb2NhbGU7XG5cbmRlY2xhcmUgY29uc3QgX19jbGRyRGF0YV9fOiBhbnk7XG5kZWNsYXJlIGNvbnN0IF9fZGVmYXVsdExvY2FsZV9fOiBzdHJpbmc7XG5kZWNsYXJlIGNvbnN0IF9fc3VwcG9ydGVkTG9jYWxlc19fOiBzdHJpbmdbXTtcblxuY29uc3QgdXNlckxvY2FsZSA9IHN5c3RlbUxvY2FsZS5yZXBsYWNlKC9eKFthLXpdezJ9KS4qL2ksICckMScpO1xuY29uc3QgaXNVc2VyTG9jYWxlU3VwcG9ydGVkID1cblx0dXNlckxvY2FsZSA9PT0gX19kZWZhdWx0TG9jYWxlX18gfHxcblx0X19zdXBwb3J0ZWRMb2NhbGVzX18uc29tZShmdW5jdGlvbihsb2NhbGU6IHN0cmluZykge1xuXHRcdHJldHVybiBsb2NhbGUgPT09IHN5c3RlbUxvY2FsZSB8fCBsb2NhbGUgPT09IHVzZXJMb2NhbGU7XG5cdH0pO1xuXG5sb2FkQ2xkckRhdGEoX19jbGRyRGF0YV9fKTtcbmkxOG4uc3dpdGNoTG9jYWxlKGlzVXNlckxvY2FsZVN1cHBvcnRlZCA/IHN5c3RlbUxvY2FsZSA6IF9fZGVmYXVsdExvY2FsZV9fKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzZXRMb2NhbGVEYXRhLnRzIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdHJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbiAocmVxdWlyZSkge1xuXHRcdHJlc29sdmUocmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9zdGF0aWMtYnVpbGQtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMCEuLi9ub2RlX21vZHVsZXMvdW1kLWNvbXBhdC1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0xIS4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0yIS4uL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvY3NzLW1vZHVsZS1kdHMtbG9hZGVyL2luZGV4LmpzP3R5cGU9dHMmaW5zdGFuY2VOYW1lPTBfZG9qbyEuL0Zvby50c1wiKSk7XG5cdH0sIFwic3JjL0Zvb1wiKTtcblx0fSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3Byb21pc2UtbG9hZGVyP2dsb2JhbCxzcmMvRm9vIS4vc3JjL0Zvby50c1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3Byb21pc2UtbG9hZGVyL2luZGV4LmpzP2dsb2JhbCxzcmMvRm9vIS4vc3JjL0Zvby50c1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0cmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cdFx0cmVzb2x2ZShyZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3N0YXRpYy1idWlsZC1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0wIS4uL25vZGVfbW9kdWxlcy91bWQtY29tcGF0LWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTEhLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTIhLi4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9jc3MtbW9kdWxlLWR0cy1sb2FkZXIvaW5kZXguanM/dHlwZT10cyZpbnN0YW5jZU5hbWU9MF9kb2pvIS4vQmFyLnRzXCIpKTtcblx0fSwgXCJ3aWRnZXRzXCIpO1xuXHR9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvcHJvbWlzZS1sb2FkZXI/Z2xvYmFsLHdpZGdldHMhLi9zcmMvQmFyLnRzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvcHJvbWlzZS1sb2FkZXIvaW5kZXguanM/Z2xvYmFsLHdpZGdldHMhLi9zcmMvQmFyLnRzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRyZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24gKHJlcXVpcmUpIHtcblx0XHRyZXNvbHZlKHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvc3RhdGljLWJ1aWxkLWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTAhLi4vbm9kZV9tb2R1bGVzL3VtZC1jb21wYXQtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMSEuLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMiEuLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2Nzcy1tb2R1bGUtZHRzLWxvYWRlci9pbmRleC5qcz90eXBlPXRzJmluc3RhbmNlTmFtZT0wX2Rvam8hLi9CYXoudHNcIikpO1xuXHR9LCBcIndpZGdldHNcIik7XG5cdH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9wcm9taXNlLWxvYWRlcj9nbG9iYWwsd2lkZ2V0cyEuL3NyYy9CYXoudHNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9wcm9taXNlLWxvYWRlci9pbmRleC5qcz9nbG9iYWwsd2lkZ2V0cyEuL3NyYy9CYXoudHNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjhcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMTEtMjZUMTU6MDNaXG4gKi9cbi8qIVxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44IDIwMTYtMTEtMjZUMTU6MDNaIE1JVCBsaWNlbnNlIMKpIFJhZmFlbCBYYXZpZXJcbiAqIGh0dHA6Ly9naXQuaW8vaDRsbVZnXG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRC5cblx0XHRkZWZpbmUoIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gTm9kZS4gQ29tbW9uSlMuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gR2xvYmFsXG5cdFx0cm9vdC5DbGRyID0gZmFjdG9yeSgpO1xuXHR9XG5cbn0oIHRoaXMsIGZ1bmN0aW9uKCkge1xuXG5cblx0dmFyIGFycmF5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCBvYmogKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuXHR9O1xuXG5cblxuXG5cdHZhciBwYXRoTm9ybWFsaXplID0gZnVuY3Rpb24oIHBhdGgsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0aWYgKCBhcnJheUlzQXJyYXkoIHBhdGggKSApIHtcblx0XHRcdHBhdGggPSBwYXRoLmpvaW4oIFwiL1wiICk7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHBhdGggIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiaW52YWxpZCBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCJcIiApO1xuXHRcdH1cblx0XHQvLyAxOiBJZ25vcmUgbGVhZGluZyBzbGFzaCBgL2Bcblx0XHQvLyAyOiBJZ25vcmUgbGVhZGluZyBgY2xkci9gXG5cdFx0cGF0aCA9IHBhdGhcblx0XHRcdC5yZXBsYWNlKCAvXlxcLy8gLCBcIlwiICkgLyogMSAqL1xuXHRcdFx0LnJlcGxhY2UoIC9eY2xkclxcLy8gLCBcIlwiICk7IC8qIDIgKi9cblxuXHRcdC8vIFJlcGxhY2Uge2F0dHJpYnV0ZX0nc1xuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoIC97W2EtekEtWl0rfS9nLCBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoIC9eeyhbXn1dKil9JC8sIFwiJDFcIiApO1xuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBwYXRoLnNwbGl0KCBcIi9cIiApO1xuXHR9O1xuXG5cblxuXG5cdHZhciBhcnJheVNvbWUgPSBmdW5jdGlvbiggYXJyYXksIGNhbGxiYWNrICkge1xuXHRcdHZhciBpLCBsZW5ndGg7XG5cdFx0aWYgKCBhcnJheS5zb21lICkge1xuXHRcdFx0cmV0dXJuIGFycmF5LnNvbWUoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHRcdGZvciAoIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGlmICggY2FsbGJhY2soIGFycmF5WyBpIF0sIGksIGFycmF5ICkgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgbWF4aW1pemVkIGxhbmd1YWdlIGlkIGFzIGRlZmluZWQgaW5cblx0ICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI0xpa2VseV9TdWJ0YWdzXG5cdCAqIDEuIENhbm9uaWNhbGl6ZS5cblx0ICogMS4xIE1ha2Ugc3VyZSB0aGUgaW5wdXQgbG9jYWxlIGlzIGluIGNhbm9uaWNhbCBmb3JtOiB1c2VzIHRoZSByaWdodFxuXHQgKiBzZXBhcmF0b3IsIGFuZCBoYXMgdGhlIHJpZ2h0IGNhc2luZy5cblx0ICogVE9ETyBSaWdodCBjYXNpbmc/IFdoYXQgZGY/IEl0IHNlZW1zIGxhbmd1YWdlcyBhcmUgbG93ZXJjYXNlLCBzY3JpcHRzIGFyZVxuXHQgKiBDYXBpdGFsaXplZCwgdGVycml0b3J5IGlzIHVwcGVyY2FzZS4gSSBhbSBsZWF2aW5nIHRoaXMgYXMgYW4gZXhlcmNpc2UgdG9cblx0ICogdGhlIHVzZXIuXG5cdCAqXG5cdCAqIDEuMiBSZXBsYWNlIGFueSBkZXByZWNhdGVkIHN1YnRhZ3Mgd2l0aCB0aGVpciBjYW5vbmljYWwgdmFsdWVzIHVzaW5nIHRoZVxuXHQgKiA8YWxpYXM+IGRhdGEgaW4gc3VwcGxlbWVudGFsIG1ldGFkYXRhLiBVc2UgdGhlIGZpcnN0IHZhbHVlIGluIHRoZVxuXHQgKiByZXBsYWNlbWVudCBsaXN0LCBpZiBpdCBleGlzdHMuIExhbmd1YWdlIHRhZyByZXBsYWNlbWVudHMgbWF5IGhhdmUgbXVsdGlwbGVcblx0ICogcGFydHMsIHN1Y2ggYXMgXCJzaFwiIOKeniBcInNyX0xhdG5cIiBvciBtb1wiIOKeniBcInJvX01EXCIuIEluIHN1Y2ggYSBjYXNlLCB0aGVcblx0ICogb3JpZ2luYWwgc2NyaXB0IGFuZC9vciByZWdpb24gYXJlIHJldGFpbmVkIGlmIHRoZXJlIGlzIG9uZS4gVGh1c1xuXHQgKiBcInNoX0FyYWJfQVFcIiDinp4gXCJzcl9BcmFiX0FRXCIsIG5vdCBcInNyX0xhdG5fQVFcIi5cblx0ICogVE9ETyBXaGF0IDxhbGlhcz4gZGF0YT9cblx0ICpcblx0ICogMS4zIElmIHRoZSB0YWcgaXMgZ3JhbmRmYXRoZXJlZCAoc2VlIDx2YXJpYWJsZSBpZD1cIiRncmFuZGZhdGhlcmVkXCJcblx0ICogdHlwZT1cImNob2ljZVwiPiBpbiB0aGUgc3VwcGxlbWVudGFsIGRhdGEpLCB0aGVuIHJldHVybiBpdC5cblx0ICogVE9ETyBncmFuZGZhdGhlcmVkP1xuXHQgKlxuXHQgKiAxLjQgUmVtb3ZlIHRoZSBzY3JpcHQgY29kZSAnWnp6eicgYW5kIHRoZSByZWdpb24gY29kZSAnWlonIGlmIHRoZXkgb2NjdXIuXG5cdCAqIDEuNSBHZXQgdGhlIGNvbXBvbmVudHMgb2YgdGhlIGNsZWFuZWQtdXAgc291cmNlIHRhZyAobGFuZ3VhZ2VzLCBzY3JpcHRzLFxuXHQgKiBhbmQgcmVnaW9ucyksIHBsdXMgYW55IHZhcmlhbnRzIGFuZCBleHRlbnNpb25zLlxuXHQgKiAyLiBMb29rdXAuIExvb2t1cCBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgaW4gb3JkZXIsIGFuZCBzdG9wIG9uIHRoZSBmaXJzdFxuXHQgKiBtYXRjaDpcblx0ICogMi4xIGxhbmd1YWdlc19zY3JpcHRzX3JlZ2lvbnNcblx0ICogMi4yIGxhbmd1YWdlc19yZWdpb25zXG5cdCAqIDIuMyBsYW5ndWFnZXNfc2NyaXB0c1xuXHQgKiAyLjQgbGFuZ3VhZ2VzXG5cdCAqIDIuNSB1bmRfc2NyaXB0c1xuXHQgKiAzLiBSZXR1cm5cblx0ICogMy4xIElmIHRoZXJlIGlzIG5vIG1hdGNoLCBlaXRoZXIgcmV0dXJuIGFuIGVycm9yIHZhbHVlLCBvciB0aGUgbWF0Y2ggZm9yXG5cdCAqIFwidW5kXCIgKGluIEFQSXMgd2hlcmUgYSB2YWxpZCBsYW5ndWFnZSB0YWcgaXMgcmVxdWlyZWQpLlxuXHQgKiAzLjIgT3RoZXJ3aXNlIHRoZXJlIGlzIGEgbWF0Y2ggPSBsYW5ndWFnZW1fc2NyaXB0bV9yZWdpb25tXG5cdCAqIDMuMyBMZXQgeHIgPSB4cyBpZiB4cyBpcyBub3QgZW1wdHksIGFuZCB4bSBvdGhlcndpc2UuXG5cdCAqIDMuNCBSZXR1cm4gdGhlIGxhbmd1YWdlIHRhZyBjb21wb3NlZCBvZiBsYW5ndWFnZXIgXyBzY3JpcHRyIF8gcmVnaW9uciArXG5cdCAqIHZhcmlhbnRzICsgZXh0ZW5zaW9ucy5cblx0ICpcblx0ICogQHN1YnRhZ3MgW0FycmF5XSBub3JtYWxpemVkIGxhbmd1YWdlIGlkIHN1YnRhZ3MgdHVwbGUgKHNlZSBpbml0LmpzKS5cblx0ICovXG5cdHZhciBjb3JlTGlrZWx5U3VidGFncyA9IGZ1bmN0aW9uKCBDbGRyLCBjbGRyLCBzdWJ0YWdzLCBvcHRpb25zICkge1xuXHRcdHZhciBtYXRjaCwgbWF0Y2hGb3VuZCxcblx0XHRcdGxhbmd1YWdlID0gc3VidGFnc1sgMCBdLFxuXHRcdFx0c2NyaXB0ID0gc3VidGFnc1sgMSBdLFxuXHRcdFx0c2VwID0gQ2xkci5sb2NhbGVTZXAsXG5cdFx0XHR0ZXJyaXRvcnkgPSBzdWJ0YWdzWyAyIF0sXG5cdFx0XHR2YXJpYW50cyA9IHN1YnRhZ3Muc2xpY2UoIDMsIDQgKTtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIFNraXAgaWYgKGxhbmd1YWdlLCBzY3JpcHQsIHRlcnJpdG9yeSkgaXMgbm90IGVtcHR5IFszLjNdXG5cdFx0aWYgKCBsYW5ndWFnZSAhPT0gXCJ1bmRcIiAmJiBzY3JpcHQgIT09IFwiWnp6elwiICYmIHRlcnJpdG9yeSAhPT0gXCJaWlwiICkge1xuXHRcdFx0cmV0dXJuIFsgbGFuZ3VhZ2UsIHNjcmlwdCwgdGVycml0b3J5IF0uY29uY2F0KCB2YXJpYW50cyApO1xuXHRcdH1cblxuXHRcdC8vIFNraXAgaWYgbm8gc3VwcGxlbWVudGFsIGxpa2VseVN1YnRhZ3MgZGF0YSBpcyBwcmVzZW50XG5cdFx0aWYgKCB0eXBlb2YgY2xkci5nZXQoIFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3NcIiApID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFsyXVxuXHRcdG1hdGNoRm91bmQgPSBhcnJheVNvbWUoW1xuXHRcdFx0WyBsYW5ndWFnZSwgc2NyaXB0LCB0ZXJyaXRvcnkgXSxcblx0XHRcdFsgbGFuZ3VhZ2UsIHRlcnJpdG9yeSBdLFxuXHRcdFx0WyBsYW5ndWFnZSwgc2NyaXB0IF0sXG5cdFx0XHRbIGxhbmd1YWdlIF0sXG5cdFx0XHRbIFwidW5kXCIsIHNjcmlwdCBdXG5cdFx0XSwgZnVuY3Rpb24oIHRlc3QgKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2ggPSAhKC9cXGIoWnp6enxaWilcXGIvKS50ZXN0KCB0ZXN0LmpvaW4oIHNlcCApICkgLyogWzEuNF0gKi8gJiYgY2xkci5nZXQoIFsgXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFnc1wiLCB0ZXN0LmpvaW4oIHNlcCApIF0gKTtcblx0XHR9KTtcblxuXHRcdC8vIFszXVxuXHRcdGlmICggbWF0Y2hGb3VuZCApIHtcblx0XHRcdC8vIFszLjIgLi4gMy40XVxuXHRcdFx0bWF0Y2ggPSBtYXRjaC5zcGxpdCggc2VwICk7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRsYW5ndWFnZSAhPT0gXCJ1bmRcIiA/IGxhbmd1YWdlIDogbWF0Y2hbIDAgXSxcblx0XHRcdFx0c2NyaXB0ICE9PSBcIlp6enpcIiA/IHNjcmlwdCA6IG1hdGNoWyAxIF0sXG5cdFx0XHRcdHRlcnJpdG9yeSAhPT0gXCJaWlwiID8gdGVycml0b3J5IDogbWF0Y2hbIDIgXVxuXHRcdFx0XS5jb25jYXQoIHZhcmlhbnRzICk7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5mb3JjZSApIHtcblx0XHRcdC8vIFszLjEuMl1cblx0XHRcdHJldHVybiBjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFncy91bmRcIiApLnNwbGl0KCBzZXAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gWzMuMS4xXVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fTtcblxuXG5cblx0LyoqXG5cdCAqIEdpdmVuIGEgbG9jYWxlLCByZW1vdmUgYW55IGZpZWxkcyB0aGF0IEFkZCBMaWtlbHkgU3VidGFncyB3b3VsZCBhZGQuXG5cdCAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNMaWtlbHlfU3VidGFnc1xuXHQgKiAxLiBGaXJzdCBnZXQgbWF4ID0gQWRkTGlrZWx5U3VidGFncyhpbnB1dExvY2FsZSkuIElmIGFuIGVycm9yIGlzIHNpZ25hbGVkLFxuXHQgKiByZXR1cm4gaXQuXG5cdCAqIDIuIFJlbW92ZSB0aGUgdmFyaWFudHMgZnJvbSBtYXguXG5cdCAqIDMuIFRoZW4gZm9yIHRyaWFsIGluIHtsYW5ndWFnZSwgbGFuZ3VhZ2UgXyByZWdpb24sIGxhbmd1YWdlIF8gc2NyaXB0fS4gSWZcblx0ICogQWRkTGlrZWx5U3VidGFncyh0cmlhbCkgPSBtYXgsIHRoZW4gcmV0dXJuIHRyaWFsICsgdmFyaWFudHMuXG5cdCAqIDQuIElmIHlvdSBkbyBub3QgZ2V0IGEgbWF0Y2gsIHJldHVybiBtYXggKyB2YXJpYW50cy5cblx0ICogXG5cdCAqIEBtYXhMYW5ndWFnZUlkIFtBcnJheV0gbWF4TGFuZ3VhZ2VJZCB0dXBsZSAoc2VlIGluaXQuanMpLlxuXHQgKi9cblx0dmFyIGNvcmVSZW1vdmVMaWtlbHlTdWJ0YWdzID0gZnVuY3Rpb24oIENsZHIsIGNsZHIsIG1heExhbmd1YWdlSWQgKSB7XG5cdFx0dmFyIG1hdGNoLCBtYXRjaEZvdW5kLFxuXHRcdFx0bGFuZ3VhZ2UgPSBtYXhMYW5ndWFnZUlkWyAwIF0sXG5cdFx0XHRzY3JpcHQgPSBtYXhMYW5ndWFnZUlkWyAxIF0sXG5cdFx0XHR0ZXJyaXRvcnkgPSBtYXhMYW5ndWFnZUlkWyAyIF0sXG5cdFx0XHR2YXJpYW50cyA9IG1heExhbmd1YWdlSWRbIDMgXTtcblxuXHRcdC8vIFszXVxuXHRcdG1hdGNoRm91bmQgPSBhcnJheVNvbWUoW1xuXHRcdFx0WyBbIGxhbmd1YWdlLCBcIlp6enpcIiwgXCJaWlwiIF0sIFsgbGFuZ3VhZ2UgXSBdLFxuXHRcdFx0WyBbIGxhbmd1YWdlLCBcIlp6enpcIiwgdGVycml0b3J5IF0sIFsgbGFuZ3VhZ2UsIHRlcnJpdG9yeSBdIF0sXG5cdFx0XHRbIFsgbGFuZ3VhZ2UsIHNjcmlwdCwgXCJaWlwiIF0sIFsgbGFuZ3VhZ2UsIHNjcmlwdCBdIF1cblx0XHRdLCBmdW5jdGlvbiggdGVzdCApIHtcblx0XHRcdHZhciByZXN1bHQgPSBjb3JlTGlrZWx5U3VidGFncyggQ2xkciwgY2xkciwgdGVzdFsgMCBdICk7XG5cdFx0XHRtYXRjaCA9IHRlc3RbIDEgXTtcblx0XHRcdHJldHVybiByZXN1bHQgJiYgcmVzdWx0WyAwIF0gPT09IG1heExhbmd1YWdlSWRbIDAgXSAmJlxuXHRcdFx0XHRyZXN1bHRbIDEgXSA9PT0gbWF4TGFuZ3VhZ2VJZFsgMSBdICYmXG5cdFx0XHRcdHJlc3VsdFsgMiBdID09PSBtYXhMYW5ndWFnZUlkWyAyIF07XG5cdFx0fSk7XG5cblx0XHRpZiAoIG1hdGNoRm91bmQgKSB7XG5cdFx0XHRpZiAoIHZhcmlhbnRzICkge1xuXHRcdFx0XHRtYXRjaC5wdXNoKCB2YXJpYW50cyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIFs0XVxuXHRcdHJldHVybiBtYXhMYW5ndWFnZUlkO1xuXHR9O1xuXG5cblxuXG5cdC8qKlxuXHQgKiBzdWJ0YWdzKCBsb2NhbGUgKVxuXHQgKlxuXHQgKiBAbG9jYWxlIFtTdHJpbmddXG5cdCAqL1xuXHR2YXIgY29yZVN1YnRhZ3MgPSBmdW5jdGlvbiggbG9jYWxlICkge1xuXHRcdHZhciBhdXgsIHVuaWNvZGVMYW5ndWFnZUlkLFxuXHRcdFx0c3VidGFncyA9IFtdO1xuXG5cdFx0bG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoIC9fLywgXCItXCIgKTtcblxuXHRcdC8vIFVuaWNvZGUgbG9jYWxlIGV4dGVuc2lvbnMuXG5cdFx0YXV4ID0gbG9jYWxlLnNwbGl0KCBcIi11LVwiICk7XG5cdFx0aWYgKCBhdXhbIDEgXSApIHtcblx0XHRcdGF1eFsgMSBdID0gYXV4WyAxIF0uc3BsaXQoIFwiLXQtXCIgKTtcblx0XHRcdGxvY2FsZSA9IGF1eFsgMCBdICsgKCBhdXhbIDEgXVsgMSBdID8gXCItdC1cIiArIGF1eFsgMSBdWyAxIF0gOiBcIlwiKTtcblx0XHRcdHN1YnRhZ3NbIDQgLyogdW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgKi8gXSA9IGF1eFsgMSBdWyAwIF07XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETyBub3JtYWxpemUgdHJhbnNmb3JtZWQgZXh0ZW5zaW9ucy4gQ3VycmVudGx5LCBza2lwcGVkLlxuXHRcdC8vIHN1YnRhZ3NbIHggXSA9IGxvY2FsZS5zcGxpdCggXCItdC1cIiApWyAxIF07XG5cdFx0dW5pY29kZUxhbmd1YWdlSWQgPSBsb2NhbGUuc3BsaXQoIFwiLXQtXCIgKVsgMCBdO1xuXG5cdFx0Ly8gdW5pY29kZV9sYW5ndWFnZV9pZCA9IFwicm9vdFwiXG5cdFx0Ly8gICB8IHVuaWNvZGVfbGFuZ3VhZ2Vfc3VidGFnICAgICAgICAgXG5cdFx0Ly8gICAgIChzZXAgdW5pY29kZV9zY3JpcHRfc3VidGFnKT8gXG5cdFx0Ly8gICAgIChzZXAgdW5pY29kZV9yZWdpb25fc3VidGFnKT9cblx0XHQvLyAgICAgKHNlcCB1bmljb2RlX3ZhcmlhbnRfc3VidGFnKSogO1xuXHRcdC8vXG5cdFx0Ly8gQWx0aG91Z2ggdW5pY29kZV9sYW5ndWFnZV9zdWJ0YWcgPSBhbHBoYXsyLDh9LCBJJ20gdXNpbmcgYWxwaGF7MiwzfS4gQmVjYXVzZSwgdGhlcmUncyBubyBsYW5ndWFnZSBvbiBDTERSIGxlbmd0aGllciB0aGFuIDMuXG5cdFx0YXV4ID0gdW5pY29kZUxhbmd1YWdlSWQubWF0Y2goIC9eKChbYS16XXsyLDN9KSgtKFtBLVpdW2Etel17M30pKT8oLShbQS1aXXsyfXxbMC05XXszfSkpPykoKC0oW2EtekEtWjAtOV17NSw4fXxbMC05XVthLXpBLVowLTldezN9KSkqKSR8Xihyb290KSQvICk7XG5cdFx0aWYgKCBhdXggPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gWyBcInVuZFwiLCBcIlp6enpcIiwgXCJaWlwiIF07XG5cdFx0fVxuXHRcdHN1YnRhZ3NbIDAgLyogbGFuZ3VhZ2UgKi8gXSA9IGF1eFsgMTAgXSAvKiByb290ICovIHx8IGF1eFsgMiBdIHx8IFwidW5kXCI7XG5cdFx0c3VidGFnc1sgMSAvKiBzY3JpcHQgKi8gXSA9IGF1eFsgNCBdIHx8IFwiWnp6elwiO1xuXHRcdHN1YnRhZ3NbIDIgLyogdGVycml0b3J5ICovIF0gPSBhdXhbIDYgXSB8fCBcIlpaXCI7XG5cdFx0aWYgKCBhdXhbIDcgXSAmJiBhdXhbIDcgXS5sZW5ndGggKSB7XG5cdFx0XHRzdWJ0YWdzWyAzIC8qIHZhcmlhbnQgKi8gXSA9IGF1eFsgNyBdLnNsaWNlKCAxICkgLyogcmVtb3ZlIGxlYWRpbmcgXCItXCIgKi87XG5cdFx0fVxuXG5cdFx0Ly8gMDogbGFuZ3VhZ2Vcblx0XHQvLyAxOiBzY3JpcHRcblx0XHQvLyAyOiB0ZXJyaXRvcnkgKGFrYSByZWdpb24pXG5cdFx0Ly8gMzogdmFyaWFudFxuXHRcdC8vIDQ6IHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zXG5cdFx0cmV0dXJuIHN1YnRhZ3M7XG5cdH07XG5cblxuXG5cblx0dmFyIGFycmF5Rm9yRWFjaCA9IGZ1bmN0aW9uKCBhcnJheSwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGksIGxlbmd0aDtcblx0XHRpZiAoIGFycmF5LmZvckVhY2ggKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZm9yRWFjaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdFx0Zm9yICggaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2soIGFycmF5WyBpIF0sIGksIGFycmF5ICk7XG5cdFx0fVxuXHR9O1xuXG5cblxuXG5cdC8qKlxuXHQgKiBidW5kbGVMb29rdXAoIG1pbkxhbmd1YWdlSWQgKVxuXHQgKlxuXHQgKiBAQ2xkciBbQ2xkciBjbGFzc11cblx0ICpcblx0ICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdXG5cdCAqXG5cdCAqIEBtaW5MYW5ndWFnZUlkIFtTdHJpbmddIHJlcXVlc3RlZCBsYW5ndWFnZUlkIGFmdGVyIGFwcGxpZWQgcmVtb3ZlIGxpa2VseSBzdWJ0YWdzLlxuXHQgKi9cblx0dmFyIGJ1bmRsZUxvb2t1cCA9IGZ1bmN0aW9uKCBDbGRyLCBjbGRyLCBtaW5MYW5ndWFnZUlkICkge1xuXHRcdHZhciBhdmFpbGFibGVCdW5kbGVNYXAgPSBDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXAsXG5cdFx0XHRhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSA9IENsZHIuX2F2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlO1xuXG5cdFx0aWYgKCBhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZS5sZW5ndGggKSB7XG5cdFx0XHRhcnJheUZvckVhY2goIGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlLCBmdW5jdGlvbiggYnVuZGxlICkge1xuXHRcdFx0XHR2YXIgZXhpc3RpbmcsIG1heEJ1bmRsZSwgbWluQnVuZGxlLCBzdWJ0YWdzO1xuXHRcdFx0XHRzdWJ0YWdzID0gY29yZVN1YnRhZ3MoIGJ1bmRsZSApO1xuXHRcdFx0XHRtYXhCdW5kbGUgPSBjb3JlTGlrZWx5U3VidGFncyggQ2xkciwgY2xkciwgc3VidGFncyApO1xuXHRcdFx0XHRtaW5CdW5kbGUgPSBjb3JlUmVtb3ZlTGlrZWx5U3VidGFncyggQ2xkciwgY2xkciwgbWF4QnVuZGxlICk7XG5cdFx0XHRcdG1pbkJ1bmRsZSA9IG1pbkJ1bmRsZS5qb2luKCBDbGRyLmxvY2FsZVNlcCApO1xuXHRcdFx0XHRleGlzdGluZyA9IGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlWyBtaW5CdW5kbGUgXTtcblx0XHRcdFx0aWYgKCBleGlzdGluZyAmJiBleGlzdGluZy5sZW5ndGggPCBidW5kbGUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdmFpbGFibGVCdW5kbGVNYXBbIG1pbkJ1bmRsZSBdID0gYnVuZGxlO1xuXHRcdFx0fSk7XG5cdFx0XHRDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSA9IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiBhdmFpbGFibGVCdW5kbGVNYXBbIG1pbkxhbmd1YWdlSWQgXSB8fCBudWxsO1xuXHR9O1xuXG5cblxuXG5cdHZhciBvYmplY3RLZXlzID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblx0XHR2YXIgaSxcblx0XHRcdHJlc3VsdCA9IFtdO1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyApIHtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyggb2JqZWN0ICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSBpbiBvYmplY3QgKSB7XG5cdFx0XHRyZXN1bHQucHVzaCggaSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblxuXG5cblx0dmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24oIGNvZGUsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0dmFyIGVycm9yLCBtZXNzYWdlO1xuXG5cdFx0bWVzc2FnZSA9IGNvZGUgKyAoIGF0dHJpYnV0ZXMgJiYgSlNPTiA/IFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KCBhdHRyaWJ1dGVzICkgOiBcIlwiICk7XG5cdFx0ZXJyb3IgPSBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcblx0XHRlcnJvci5jb2RlID0gY29kZTtcblxuXHRcdC8vIGV4dGVuZCggZXJyb3IsIGF0dHJpYnV0ZXMgKTtcblx0XHRhcnJheUZvckVhY2goIG9iamVjdEtleXMoIGF0dHJpYnV0ZXMgKSwgZnVuY3Rpb24oIGF0dHJpYnV0ZSApIHtcblx0XHRcdGVycm9yWyBhdHRyaWJ1dGUgXSA9IGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGVycm9yO1xuXHR9O1xuXG5cblxuXG5cdHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKCBjb2RlLCBjaGVjaywgYXR0cmlidXRlcyApIHtcblx0XHRpZiAoICFjaGVjayApIHtcblx0XHRcdHRocm93IGNyZWF0ZUVycm9yKCBjb2RlLCBhdHRyaWJ1dGVzICk7XG5cdFx0fVxuXHR9O1xuXG5cblxuXG5cdHZhciB2YWxpZGF0ZVByZXNlbmNlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHRcdHZhbGlkYXRlKCBcIkVfTUlTU0lOR19QQVJBTUVURVJcIiwgdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiLCB7XG5cdFx0XHRuYW1lOiBuYW1lXG5cdFx0fSk7XG5cdH07XG5cblxuXG5cblx0dmFyIHZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSwgY2hlY2ssIGV4cGVjdGVkICkge1xuXHRcdHZhbGlkYXRlKCBcIkVfSU5WQUxJRF9QQVJfVFlQRVwiLCBjaGVjaywge1xuXHRcdFx0ZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH0pO1xuXHR9O1xuXG5cblxuXG5cdHZhciB2YWxpZGF0ZVR5cGVQYXRoID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHRcdHZhbGlkYXRlVHlwZSggdmFsdWUsIG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCBhcnJheUlzQXJyYXkoIHZhbHVlICksIFwiU3RyaW5nIG9yIEFycmF5XCIgKTtcblx0fTtcblxuXG5cblxuXHQvKipcblx0ICogRnVuY3Rpb24gaW5zcGlyZWQgYnkgalF1ZXJ5IENvcmUsIGJ1dCByZWR1Y2VkIHRvIG91ciB1c2UgY2FzZS5cblx0ICovXG5cdHZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9PSBudWxsICYmIFwiXCIgKyBvYmogPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5cdH07XG5cblxuXG5cblx0dmFyIHZhbGlkYXRlVHlwZVBsYWluT2JqZWN0ID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHRcdHZhbGlkYXRlVHlwZSggdmFsdWUsIG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc1BsYWluT2JqZWN0KCB2YWx1ZSApLCBcIlBsYWluIE9iamVjdFwiICk7XG5cdH07XG5cblxuXG5cblx0dmFyIHZhbGlkYXRlVHlwZVN0cmluZyA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIsIFwiYSBzdHJpbmdcIiApO1xuXHR9O1xuXG5cblxuXG5cdC8vIEBwYXRoOiBub3JtYWxpemVkIHBhdGhcblx0dmFyIHJlc291cmNlR2V0ID0gZnVuY3Rpb24oIGRhdGEsIHBhdGggKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRub2RlID0gZGF0YSxcblx0XHRcdGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRub2RlID0gbm9kZVsgcGF0aFsgaSBdIF07XG5cdFx0XHRpZiAoICFub2RlICkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZVsgcGF0aFsgaSBdIF07XG5cdH07XG5cblxuXG5cblx0LyoqXG5cdCAqIHNldEF2YWlsYWJsZUJ1bmRsZXMoIENsZHIsIGpzb24gKVxuXHQgKlxuXHQgKiBAQ2xkciBbQ2xkciBjbGFzc11cblx0ICpcblx0ICogQGpzb24gcmVzb2x2ZWQvdW5yZXNvbHZlZCBjbGRyIGRhdGEuXG5cdCAqXG5cdCAqIFNldCBhdmFpbGFibGUgYnVuZGxlcyBxdWV1ZSBiYXNlZCBvbiBwYXNzZWQganNvbiBDTERSIGRhdGEuIENvbnNpZGVycyBhIGJ1bmRsZSBhcyBhbnkgU3RyaW5nIGF0IC9tYWluL3tidW5kbGV9LlxuXHQgKi9cblx0dmFyIGNvcmVTZXRBdmFpbGFibGVCdW5kbGVzID0gZnVuY3Rpb24oIENsZHIsIGpzb24gKSB7XG5cdFx0dmFyIGJ1bmRsZSxcblx0XHRcdGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlID0gQ2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUsXG5cdFx0XHRtYWluID0gcmVzb3VyY2VHZXQoIGpzb24sIFsgXCJtYWluXCIgXSApO1xuXG5cdFx0aWYgKCBtYWluICkge1xuXHRcdFx0Zm9yICggYnVuZGxlIGluIG1haW4gKSB7XG5cdFx0XHRcdGlmICggbWFpbi5oYXNPd25Qcm9wZXJ0eSggYnVuZGxlICkgJiYgYnVuZGxlICE9PSBcInJvb3RcIiAmJlxuXHRcdFx0XHRcdFx0XHRhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZS5pbmRleE9mKCBidW5kbGUgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0YXZhaWxhYmxlQnVuZGxlTWFwUXVldWUucHVzaCggYnVuZGxlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuXG5cdHZhciBhbHdheXNBcnJheSA9IGZ1bmN0aW9uKCBzb21ldGhpbmdPckFycmF5ICkge1xuXHRcdHJldHVybiBhcnJheUlzQXJyYXkoIHNvbWV0aGluZ09yQXJyYXkgKSA/ICBzb21ldGhpbmdPckFycmF5IDogWyBzb21ldGhpbmdPckFycmF5IF07XG5cdH07XG5cblxuXHR2YXIganNvbk1lcmdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8vIFJldHVybnMgbmV3IGRlZXBseSBtZXJnZWQgSlNPTi5cblx0Ly9cblx0Ly8gRWcuXG5cdC8vIG1lcmdlKCB7IGE6IHsgYjogMSwgYzogMiB9IH0sIHsgYTogeyBiOiAzLCBkOiA0IH0gfSApXG5cdC8vIC0+IHsgYTogeyBiOiAzLCBjOiAyLCBkOiA0IH0gfVxuXHQvL1xuXHQvLyBAYXJndW1lbnRzIEpTT04nc1xuXHQvLyBcblx0dmFyIG1lcmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlc3RpbmF0aW9uID0ge30sXG5cdFx0XHRzb3VyY2VzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cdFx0YXJyYXlGb3JFYWNoKCBzb3VyY2VzLCBmdW5jdGlvbiggc291cmNlICkge1xuXHRcdFx0dmFyIHByb3A7XG5cdFx0XHRmb3IgKCBwcm9wIGluIHNvdXJjZSApIHtcblx0XHRcdFx0aWYgKCBwcm9wIGluIGRlc3RpbmF0aW9uICYmIHR5cGVvZiBkZXN0aW5hdGlvblsgcHJvcCBdID09PSBcIm9iamVjdFwiICYmICFhcnJheUlzQXJyYXkoIGRlc3RpbmF0aW9uWyBwcm9wIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIE1lcmdlIE9iamVjdHNcblx0XHRcdFx0XHRkZXN0aW5hdGlvblsgcHJvcCBdID0gbWVyZ2UoIGRlc3RpbmF0aW9uWyBwcm9wIF0sIHNvdXJjZVsgcHJvcCBdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFNldCBuZXcgdmFsdWVzXG5cdFx0XHRcdFx0ZGVzdGluYXRpb25bIHByb3AgXSA9IHNvdXJjZVsgcHJvcCBdO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gZGVzdGluYXRpb247XG5cdH07XG5cblx0cmV0dXJuIG1lcmdlO1xuXG59KCkpO1xuXG5cblx0LyoqXG5cdCAqIGxvYWQoIENsZHIsIHNvdXJjZSwganNvbnMgKVxuXHQgKlxuXHQgKiBAQ2xkciBbQ2xkciBjbGFzc11cblx0ICpcblx0ICogQHNvdXJjZSBbT2JqZWN0XVxuXHQgKlxuXHQgKiBAanNvbnMgW2FyZ3VtZW50c11cblx0ICovXG5cdHZhciBjb3JlTG9hZCA9IGZ1bmN0aW9uKCBDbGRyLCBzb3VyY2UsIGpzb25zICkge1xuXHRcdHZhciBpLCBqLCBqc29uO1xuXG5cdFx0dmFsaWRhdGVQcmVzZW5jZSgganNvbnNbIDAgXSwgXCJqc29uXCIgKTtcblxuXHRcdC8vIFN1cHBvcnQgYXJiaXRyYXJ5IHBhcmFtZXRlcnMsIGUuZy4sIGBDbGRyLmxvYWQoey4uLn0sIHsuLi59KWAuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBwYXJhbWV0ZXJzLCBlLmcuLCBgQ2xkci5sb2FkKFt7Li4ufSwgey4uLn1dKWAuXG5cdFx0XHRqc29uID0gYWx3YXlzQXJyYXkoIGpzb25zWyBpIF0gKTtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBqc29uLmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHR2YWxpZGF0ZVR5cGVQbGFpbk9iamVjdCgganNvblsgaiBdLCBcImpzb25cIiApO1xuXHRcdFx0XHRzb3VyY2UgPSBqc29uTWVyZ2UoIHNvdXJjZSwganNvblsgaiBdICk7XG5cdFx0XHRcdGNvcmVTZXRBdmFpbGFibGVCdW5kbGVzKCBDbGRyLCBqc29uWyBqIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9O1xuXG5cblxuXHR2YXIgaXRlbUdldFJlc29sdmVkID0gZnVuY3Rpb24oIENsZHIsIHBhdGgsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0Ly8gUmVzb2x2ZSBwYXRoXG5cdFx0dmFyIG5vcm1hbGl6ZWRQYXRoID0gcGF0aE5vcm1hbGl6ZSggcGF0aCwgYXR0cmlidXRlcyApO1xuXG5cdFx0cmV0dXJuIHJlc291cmNlR2V0KCBDbGRyLl9yZXNvbHZlZCwgbm9ybWFsaXplZFBhdGggKTtcblx0fTtcblxuXG5cblxuXHQvKipcblx0ICogbmV3IENsZHIoKVxuXHQgKi9cblx0dmFyIENsZHIgPSBmdW5jdGlvbiggbG9jYWxlICkge1xuXHRcdHRoaXMuaW5pdCggbG9jYWxlICk7XG5cdH07XG5cblx0Ly8gQnVpbGQgb3B0aW1pemF0aW9uIGhhY2sgdG8gYXZvaWQgZHVwbGljYXRpbmcgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxuXHRDbGRyLl9hbHdheXNBcnJheSA9IGFsd2F5c0FycmF5O1xuXHRDbGRyLl9jb3JlTG9hZCA9IGNvcmVMb2FkO1xuXHRDbGRyLl9jcmVhdGVFcnJvciA9IGNyZWF0ZUVycm9yO1xuXHRDbGRyLl9pdGVtR2V0UmVzb2x2ZWQgPSBpdGVtR2V0UmVzb2x2ZWQ7XG5cdENsZHIuX2pzb25NZXJnZSA9IGpzb25NZXJnZTtcblx0Q2xkci5fcGF0aE5vcm1hbGl6ZSA9IHBhdGhOb3JtYWxpemU7XG5cdENsZHIuX3Jlc291cmNlR2V0ID0gcmVzb3VyY2VHZXQ7XG5cdENsZHIuX3ZhbGlkYXRlUHJlc2VuY2UgPSB2YWxpZGF0ZVByZXNlbmNlO1xuXHRDbGRyLl92YWxpZGF0ZVR5cGUgPSB2YWxpZGF0ZVR5cGU7XG5cdENsZHIuX3ZhbGlkYXRlVHlwZVBhdGggPSB2YWxpZGF0ZVR5cGVQYXRoO1xuXHRDbGRyLl92YWxpZGF0ZVR5cGVQbGFpbk9iamVjdCA9IHZhbGlkYXRlVHlwZVBsYWluT2JqZWN0O1xuXG5cdENsZHIuX2F2YWlsYWJsZUJ1bmRsZU1hcCA9IHt9O1xuXHRDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSA9IFtdO1xuXHRDbGRyLl9yZXNvbHZlZCA9IHt9O1xuXG5cdC8vIEFsbG93IHVzZXIgdG8gb3ZlcnJpZGUgbG9jYWxlIHNlcGFyYXRvciBcIi1cIiAoZGVmYXVsdCkgfCBcIl9cIi4gQWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNVbmljb2RlX2xhbmd1YWdlX2lkZW50aWZpZXIsIGJvdGggXCItXCIgYW5kIFwiX1wiIGFyZSB2YWxpZCBsb2NhbGUgc2VwYXJhdG9ycyAoZWcuIFwiZW5fR0JcIiwgXCJlbi1HQlwiKS4gQWNjb3JkaW5nIHRvIGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzY3ODYgaXRzIHVzYWdlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IHRoZSBkYXRhIHNldC5cblx0Q2xkci5sb2NhbGVTZXAgPSBcIi1cIjtcblxuXHQvKipcblx0ICogQ2xkci5sb2FkKCBqc29uIFssIGpzb24sIC4uLl0gKVxuXHQgKlxuXHQgKiBAanNvbiBbSlNPTl0gQ0xEUiBkYXRhIG9yIFtBcnJheV0gQXJyYXkgb2YgQGpzb24ncy5cblx0ICpcblx0ICogTG9hZCByZXNvbHZlZCBjbGRyIGRhdGEuXG5cdCAqL1xuXHRDbGRyLmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRDbGRyLl9yZXNvbHZlZCA9IGNvcmVMb2FkKCBDbGRyLCBDbGRyLl9yZXNvbHZlZCwgYXJndW1lbnRzICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIC5pbml0KCkgYXV0b21hdGljYWxseSBydW4gb24gaW5zdGFudGlhdGlvbi9jb25zdHJ1Y3Rpb24uXG5cdCAqL1xuXHRDbGRyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIGxvY2FsZSApIHtcblx0XHR2YXIgYXR0cmlidXRlcywgbGFuZ3VhZ2UsIG1heExhbmd1YWdlSWQsIG1pbkxhbmd1YWdlSWQsIHNjcmlwdCwgc3VidGFncywgdGVycml0b3J5LCB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucywgdmFyaWFudCxcblx0XHRcdHNlcCA9IENsZHIubG9jYWxlU2VwLFxuXHRcdFx0dW5pY29kZUxvY2FsZUV4dGVuc2lvbnNSYXcgPSBcIlwiO1xuXG5cdFx0dmFsaWRhdGVQcmVzZW5jZSggbG9jYWxlLCBcImxvY2FsZVwiICk7XG5cdFx0dmFsaWRhdGVUeXBlU3RyaW5nKCBsb2NhbGUsIFwibG9jYWxlXCIgKTtcblxuXHRcdHN1YnRhZ3MgPSBjb3JlU3VidGFncyggbG9jYWxlICk7XG5cblx0XHRpZiAoIHN1YnRhZ3MubGVuZ3RoID09PSA1ICkge1xuXHRcdFx0dW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgPSBzdWJ0YWdzLnBvcCgpO1xuXHRcdFx0dW5pY29kZUxvY2FsZUV4dGVuc2lvbnNSYXcgPSBzZXAgKyBcInVcIiArIHNlcCArIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zO1xuXHRcdFx0Ly8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgd2hlbiB0aGVyZSBpcyB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucyBidXQgbm8gdmFyaWFudHMuXG5cdFx0XHRpZiAoICFzdWJ0YWdzWyAzIF0gKSB7XG5cdFx0XHRcdHN1YnRhZ3MucG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhcmlhbnQgPSBzdWJ0YWdzWyAzIF07XG5cblx0XHQvLyBOb3JtYWxpemUgbG9jYWxlIGNvZGUuXG5cdFx0Ly8gR2V0IChvciBkZWR1Y2UpIHRoZSBcInRyaXBsZSBzdWJ0YWdzXCI6IGxhbmd1YWdlLCB0ZXJyaXRvcnkgKGFsc28gYWxpYXNlZCBhcyByZWdpb24pLCBhbmQgc2NyaXB0IHN1YnRhZ3MuXG5cdFx0Ly8gR2V0IHRoZSB2YXJpYW50IHN1YnRhZ3MgKGNhbGVuZGFyLCBjb2xsYXRpb24sIGN1cnJlbmN5LCBldGMpLlxuXHRcdC8vIHJlZnM6XG5cdFx0Ly8gLSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jRmllbGRfRGVmaW5pdGlvbnNcblx0XHQvLyAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNMYW5ndWFnZV9hbmRfTG9jYWxlX0lEc1xuXHRcdC8vIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI1VuaWNvZGVfbG9jYWxlX2lkZW50aWZpZXJcblxuXHRcdC8vIFdoZW4gYSBsb2NhbGUgaWQgZG9lcyBub3Qgc3BlY2lmeSBhIGxhbmd1YWdlLCBvciB0ZXJyaXRvcnkgKHJlZ2lvbiksIG9yIHNjcmlwdCwgdGhleSBhcmUgb2J0YWluZWQgYnkgTGlrZWx5IFN1YnRhZ3MuXG5cdFx0bWF4TGFuZ3VhZ2VJZCA9IGNvcmVMaWtlbHlTdWJ0YWdzKCBDbGRyLCB0aGlzLCBzdWJ0YWdzLCB7IGZvcmNlOiB0cnVlIH0gKSB8fCBzdWJ0YWdzO1xuXHRcdGxhbmd1YWdlID0gbWF4TGFuZ3VhZ2VJZFsgMCBdO1xuXHRcdHNjcmlwdCA9IG1heExhbmd1YWdlSWRbIDEgXTtcblx0XHR0ZXJyaXRvcnkgPSBtYXhMYW5ndWFnZUlkWyAyIF07XG5cblx0XHRtaW5MYW5ndWFnZUlkID0gY29yZVJlbW92ZUxpa2VseVN1YnRhZ3MoIENsZHIsIHRoaXMsIG1heExhbmd1YWdlSWQgKS5qb2luKCBzZXAgKTtcblxuXHRcdC8vIFNldCBhdHRyaWJ1dGVzXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyA9IHtcblx0XHRcdGJ1bmRsZTogYnVuZGxlTG9va3VwKCBDbGRyLCB0aGlzLCBtaW5MYW5ndWFnZUlkICksXG5cblx0XHRcdC8vIFVuaWNvZGUgTGFuZ3VhZ2UgSWRcblx0XHRcdG1pbkxhbmd1YWdlSWQ6IG1pbkxhbmd1YWdlSWQgKyB1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1Jhdyxcblx0XHRcdG1heExhbmd1YWdlSWQ6IG1heExhbmd1YWdlSWQuam9pbiggc2VwICkgKyB1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1JhdyxcblxuXHRcdFx0Ly8gVW5pY29kZSBMYW5ndWFnZSBJZCBTdWJ0YWJzXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRzY3JpcHQ6IHNjcmlwdCxcblx0XHRcdHRlcnJpdG9yeTogdGVycml0b3J5LFxuXHRcdFx0cmVnaW9uOiB0ZXJyaXRvcnksIC8qIGFsaWFzICovXG5cdFx0XHR2YXJpYW50OiB2YXJpYW50XG5cdFx0fTtcblxuXHRcdC8vIFVuaWNvZGUgbG9jYWxlIGV4dGVuc2lvbnMuXG5cdFx0dW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgJiYgKCBcIi1cIiArIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zICkucmVwbGFjZSggLy1bYS16XXszLDh9fCgtW2Etel17Mn0pLShbYS16XXszLDh9KS9nLCBmdW5jdGlvbiggYXR0cmlidXRlLCBrZXksIHR5cGUgKSB7XG5cblx0XHRcdGlmICgga2V5ICkge1xuXG5cdFx0XHRcdC8vIEV4dGVuc2lvbiBpcyBpbiB0aGUgYGtleXdvcmRgIGZvcm0uXG5cdFx0XHRcdGF0dHJpYnV0ZXNbIFwidVwiICsga2V5IF0gPSB0eXBlO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRlbnNpb24gaXMgaW4gdGhlIGBhdHRyaWJ1dGVgIGZvcm0uXG5cdFx0XHRcdGF0dHJpYnV0ZXNbIFwidVwiICsgYXR0cmlidXRlIF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5sb2NhbGUgPSBsb2NhbGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIC5nZXQoKVxuXHQgKi9cblx0Q2xkci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cblx0XHR2YWxpZGF0ZVByZXNlbmNlKCBwYXRoLCBcInBhdGhcIiApO1xuXHRcdHZhbGlkYXRlVHlwZVBhdGgoIHBhdGgsIFwicGF0aFwiICk7XG5cblx0XHRyZXR1cm4gaXRlbUdldFJlc29sdmVkKCBDbGRyLCBwYXRoLCB0aGlzLmF0dHJpYnV0ZXMgKTtcblx0fTtcblxuXHQvKipcblx0ICogLm1haW4oKVxuXHQgKi9cblx0Q2xkci5wcm90b3R5cGUubWFpbiA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdHZhbGlkYXRlUHJlc2VuY2UoIHBhdGgsIFwicGF0aFwiICk7XG5cdFx0dmFsaWRhdGVUeXBlUGF0aCggcGF0aCwgXCJwYXRoXCIgKTtcblxuXHRcdHZhbGlkYXRlKCBcIkVfTUlTU0lOR19CVU5ETEVcIiwgdGhpcy5hdHRyaWJ1dGVzLmJ1bmRsZSAhPT0gbnVsbCwge1xuXHRcdFx0bG9jYWxlOiB0aGlzLmxvY2FsZVxuXHRcdH0pO1xuXG5cdFx0cGF0aCA9IGFsd2F5c0FycmF5KCBwYXRoICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KCBbIFwibWFpbi97YnVuZGxlfVwiIF0uY29uY2F0KCBwYXRoICkgKTtcblx0fTtcblxuXHRyZXR1cm4gQ2xkcjtcblxuXG5cblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKipcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgUmFmYWVsIFhhdmllciBkZSBTb3V6YVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0xMS0yNlQxNTowM1pcbiAqL1xuLyohXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjggMjAxNi0xMS0yNlQxNTowM1ogTUlUIGxpY2Vuc2UgwqkgUmFmYWVsIFhhdmllclxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1ELlxuXHRcdGRlZmluZSggWyBcIi4uL2NsZHJcIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIE5vZGUuIENvbW1vbkpTLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCIuLi9jbGRyXCIgKSApO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEdsb2JhbFxuXHRcdGZhY3RvcnkoIENsZHIgKTtcblx0fVxuXG59KGZ1bmN0aW9uKCBDbGRyICkge1xuXG5cdC8vIEJ1aWxkIG9wdGltaXphdGlvbiBoYWNrIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cblx0dmFyIHBhdGhOb3JtYWxpemUgPSBDbGRyLl9wYXRoTm9ybWFsaXplLFxuXHRcdHZhbGlkYXRlUHJlc2VuY2UgPSBDbGRyLl92YWxpZGF0ZVByZXNlbmNlLFxuXHRcdHZhbGlkYXRlVHlwZSA9IENsZHIuX3ZhbGlkYXRlVHlwZTtcblxuLyohXG4gKiBFdmVudEVtaXR0ZXIgdjQuMi43IC0gZ2l0LmlvL2VlXG4gKiBPbGl2ZXIgQ2FsZHdlbGxcbiAqIE1JVCBsaWNlbnNlXG4gKiBAcHJlc2VydmVcbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyO1xuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdC8qKlxuXHQgKiBDbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnRzLlxuXHQgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXG5cdCAqXG5cdCAqIEBjbGFzcyBFdmVudEVtaXR0ZXIgTWFuYWdlcyBldmVudCByZWdpc3RlcmluZyBhbmQgZW1pdHRpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG5cdC8vIFNob3J0Y3V0cyB0byBpbXByb3ZlIHNwZWVkIGFuZCBzaXplXG5cdHZhciBwcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG5cdHZhciBleHBvcnRzID0gdGhpcztcblx0dmFyIG9yaWdpbmFsR2xvYmFsVmFsdWUgPSBleHBvcnRzLkV2ZW50RW1pdHRlcjtcblxuXHQvKipcblx0ICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50IGluIGl0J3Mgc3RvcmFnZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBsaXN0ZW5lcnMgQXJyYXkgb2YgbGlzdGVuZXJzIHRvIHNlYXJjaCB0aHJvdWdoLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gbG9vayBmb3IuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciwgLTEgaWYgbm90IGZvdW5kXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIpIHtcblx0XHR2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsaWFzIGEgbWV0aG9kIHdoaWxlIGtlZXBpbmcgdGhlIGNvbnRleHQgY29ycmVjdCwgdG8gYWxsb3cgZm9yIG92ZXJ3cml0aW5nIG9mIHRhcmdldCBtZXRob2QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGFsaWFzZWQgbWV0aG9kXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWxpYXMobmFtZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiBhbGlhc0Nsb3N1cmUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqIFdpbGwgaW5pdGlhbGlzZSB0aGUgZXZlbnQgb2JqZWN0IGFuZCBsaXN0ZW5lciBhcnJheXMgaWYgcmVxdWlyZWQuXG5cdCAqIFdpbGwgcmV0dXJuIGFuIG9iamVjdCBpZiB5b3UgdXNlIGEgcmVnZXggc2VhcmNoLiBUaGUgb2JqZWN0IGNvbnRhaW5zIGtleXMgZm9yIGVhY2ggbWF0Y2hlZCBldmVudC4gU28gL2JhW3J6XS8gbWlnaHQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGJhciBhbmQgYmF6LiBCdXQgb25seSBpZiB5b3UgaGF2ZSBlaXRoZXIgZGVmaW5lZCB0aGVtIHdpdGggZGVmaW5lRXZlbnQgb3IgYWRkZWQgc29tZSBsaXN0ZW5lcnMgdG8gdGhlbS5cblx0ICogRWFjaCBwcm9wZXJ0eSBpbiB0aGUgb2JqZWN0IHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cblx0ICogQHJldHVybiB7RnVuY3Rpb25bXXxPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoZSBldmVudC5cblx0ICovXG5cdHByb3RvLmdldExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldExpc3RlbmVycyhldnQpIHtcblx0XHR2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG5cdFx0dmFyIHJlc3BvbnNlO1xuXHRcdHZhciBrZXk7XG5cblx0XHQvLyBSZXR1cm4gYSBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGV2ZW50cyBpZlxuXHRcdC8vIHRoZSBzZWxlY3RvciBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cblx0XHRpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHRyZXNwb25zZSA9IHt9O1xuXHRcdFx0Zm9yIChrZXkgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0cmVzcG9uc2Vba2V5XSA9IGV2ZW50c1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIGxpc3Qgb2YgbGlzdGVuZXIgb2JqZWN0cyBhbmQgZmxhdHRlbnMgaXQgaW50byBhIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdFtdfSBsaXN0ZW5lcnMgUmF3IGxpc3RlbmVyIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uW119IEp1c3QgdGhlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cblx0ICovXG5cdHByb3RvLmZsYXR0ZW5MaXN0ZW5lcnMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuZXJzKGxpc3RlbmVycykge1xuXHRcdHZhciBmbGF0TGlzdGVuZXJzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRmbGF0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzW2ldLmxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmxhdExpc3RlbmVycztcblx0fTtcblxuXHQvKipcblx0ICogRmV0Y2hlcyB0aGUgcmVxdWVzdGVkIGxpc3RlbmVycyB2aWEgZ2V0TGlzdGVuZXJzIGJ1dCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHJlc3VsdHMgaW5zaWRlIGFuIG9iamVjdC4gVGhpcyBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSBidXQgb3RoZXJzIG1heSBmaW5kIGl0IHVzZWZ1bC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBpbiBhbiBvYmplY3QuXG5cdCAqL1xuXHRwcm90by5nZXRMaXN0ZW5lcnNBc09iamVjdCA9IGZ1bmN0aW9uIGdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCkge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuXHRcdHZhciByZXNwb25zZTtcblxuXHRcdGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0cmVzcG9uc2UgPSB7fTtcblx0XHRcdHJlc3BvbnNlW2V2dF0gPSBsaXN0ZW5lcnM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3BvbnNlIHx8IGxpc3RlbmVycztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqIFRoZSBsaXN0ZW5lciB3aWxsIG5vdCBiZSBhZGRlZCBpZiBpdCBpcyBhIGR1cGxpY2F0ZS5cblx0ICogSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBjYWxsZWQuXG5cdCAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuXHRcdHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuXHRcdFx0aWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpID09PSAtMSkge1xuXHRcdFx0XHRsaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVySXNXcmFwcGVkID8gbGlzdGVuZXIgOiB7XG5cdFx0XHRcdFx0bGlzdGVuZXI6IGxpc3RlbmVyLFxuXHRcdFx0XHRcdG9uY2U6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlhcyBvZiBhZGRMaXN0ZW5lclxuXHQgKi9cblx0cHJvdG8ub24gPSBhbGlhcygnYWRkTGlzdGVuZXInKTtcblxuXHQvKipcblx0ICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcblx0ICogYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIGl0J3MgZmlyc3QgZXhlY3V0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5hZGRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRPbmNlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuXHRcdHJldHVybiB0aGlzLmFkZExpc3RlbmVyKGV2dCwge1xuXHRcdFx0bGlzdGVuZXI6IGxpc3RlbmVyLFxuXHRcdFx0b25jZTogdHJ1ZVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlhcyBvZiBhZGRPbmNlTGlzdGVuZXIuXG5cdCAqL1xuXHRwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGFuIGV2ZW50IG5hbWUuIFRoaXMgaXMgcmVxdWlyZWQgaWYgeW91IHdhbnQgdG8gdXNlIGEgcmVnZXggdG8gYWRkIGEgbGlzdGVuZXIgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIElmIHlvdSBkb24ndCBkbyB0aGlzIHRoZW4gaG93IGRvIHlvdSBleHBlY3QgaXQgdG8ga25vdyB3aGF0IGV2ZW50IHRvIGFkZCB0bz8gU2hvdWxkIGl0IGp1c3QgYWRkIHRvIGV2ZXJ5IHBvc3NpYmxlIG1hdGNoIGZvciBhIHJlZ2V4PyBOby4gVGhhdCBpcyBzY2FyeSBhbmQgYmFkLlxuXHQgKiBZb3UgbmVlZCB0byB0ZWxsIGl0IHdoYXQgZXZlbnQgbmFtZXMgc2hvdWxkIGJlIG1hdGNoZWQgYnkgYSByZWdleC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBjcmVhdGUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uZGVmaW5lRXZlbnQgPSBmdW5jdGlvbiBkZWZpbmVFdmVudChldnQpIHtcblx0XHR0aGlzLmdldExpc3RlbmVycyhldnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VzIGRlZmluZUV2ZW50IHRvIGRlZmluZSBtdWx0aXBsZSBldmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nW119IGV2dHMgQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGVmaW5lLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmRlZmluZUV2ZW50cyA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50cyhldnRzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHR0aGlzLmRlZmluZUV2ZW50KGV2dHNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICogV2hlbiBwYXNzZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUsIGl0IHdpbGwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG5cdFx0dmFyIGluZGV4O1xuXHRcdHZhciBrZXk7XG5cblx0XHRmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcblx0XHRcdGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFsaWFzIG9mIHJlbW92ZUxpc3RlbmVyXG5cdCAqL1xuXHRwcm90by5vZmYgPSBhbGlhcygncmVtb3ZlTGlzdGVuZXInKTtcblxuXHQvKipcblx0ICogQWRkcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG5cdCAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYWRkIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKiBZZWFoLCB0aGlzIGZ1bmN0aW9uIGRvZXMgcXVpdGUgYSBiaXQuIFRoYXQncyBwcm9iYWJseSBhIGJhZCB0aGluZy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuXHRcdC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXG5cdFx0cmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyhmYWxzZSwgZXZ0LCBsaXN0ZW5lcnMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cblx0ICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgcmVtb3ZlZC5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuXHRcdC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXG5cdFx0cmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyh0cnVlLCBldnQsIGxpc3RlbmVycyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVkaXRzIGxpc3RlbmVycyBpbiBidWxrLiBUaGUgYWRkTGlzdGVuZXJzIGFuZCByZW1vdmVMaXN0ZW5lcnMgbWV0aG9kcyBib3RoIHVzZSB0aGlzIHRvIGRvIHRoZWlyIGpvYi4gWW91IHNob3VsZCByZWFsbHkgdXNlIHRob3NlIGluc3RlYWQsIHRoaXMgaXMgYSBsaXR0bGUgbG93ZXIgbGV2ZWwuXG5cdCAqIFRoZSBmaXJzdCBhcmd1bWVudCB3aWxsIGRldGVybWluZSBpZiB0aGUgbGlzdGVuZXJzIGFyZSByZW1vdmVkICh0cnVlKSBvciBhZGRlZCAoZmFsc2UpLlxuXHQgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQvcmVtb3ZlZC5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWFuaXB1bGF0ZSB0aGUgbGlzdGVuZXJzIG9mIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgVHJ1ZSBpZiB5b3Ugd2FudCB0byByZW1vdmUgbGlzdGVuZXJzLCBmYWxzZSBpZiB5b3Ugd2FudCB0byBhZGQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC9yZW1vdmUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8ubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIG1hbmlwdWxhdGVMaXN0ZW5lcnMocmVtb3ZlLCBldnQsIGxpc3RlbmVycykge1xuXHRcdHZhciBpO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgc2luZ2xlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lciA6IHRoaXMuYWRkTGlzdGVuZXI7XG5cdFx0dmFyIG11bHRpcGxlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lcnMgOiB0aGlzLmFkZExpc3RlbmVycztcblxuXHRcdC8vIElmIGV2dCBpcyBhbiBvYmplY3QgdGhlbiBwYXNzIGVhY2ggb2YgaXQncyBwcm9wZXJ0aWVzIHRvIHRoaXMgbWV0aG9kXG5cdFx0aWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuXHRcdFx0Zm9yIChpIGluIGV2dCkge1xuXHRcdFx0XHRpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpICYmICh2YWx1ZSA9IGV2dFtpXSkpIHtcblx0XHRcdFx0XHQvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0c2luZ2xlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSBwYXNzIGJhY2sgdG8gdGhlIG11bHRpcGxlIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBTbyBldnQgbXVzdCBiZSBhIHN0cmluZ1xuXHRcdFx0Ly8gQW5kIGxpc3RlbmVycyBtdXN0IGJlIGFuIGFycmF5IG9mIGxpc3RlbmVyc1xuXHRcdFx0Ly8gTG9vcCBvdmVyIGl0IGFuZCBwYXNzIGVhY2ggb25lIHRvIHRoZSBtdWx0aXBsZSBtZXRob2Rcblx0XHRcdGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzaW5nbGUuY2FsbCh0aGlzLCBldnQsIGxpc3RlbmVyc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYW4gZXZlbnQgdGhlbiBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogVGhhdCBtZWFucyBldmVyeSBldmVudCB3aWxsIGJlIGVtcHRpZWQuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVnZXggdG8gcmVtb3ZlIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBbZXZ0XSBPcHRpb25hbCBuYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuIFdpbGwgcmVtb3ZlIGZyb20gZXZlcnkgZXZlbnQgaWYgbm90IHBhc3NlZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGV2dCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGV2dDtcblx0XHR2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIFJlbW92ZSBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2YgZXZ0XG5cdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHQvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuXHRcdFx0ZGVsZXRlIGV2ZW50c1tldnRdO1xuXHRcdH1cblx0XHRlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdC8vIFJlbW92ZSBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSByZWdleC5cblx0XHRcdGZvciAoa2V5IGluIGV2ZW50cykge1xuXHRcdFx0XHRpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdGRlbGV0ZSBldmVudHNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIGFsbCBldmVudHNcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFsaWFzIG9mIHJlbW92ZUV2ZW50LlxuXHQgKlxuXHQgKiBBZGRlZCB0byBtaXJyb3IgdGhlIG5vZGUgQVBJLlxuXHQgKi9cblx0cHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gYWxpYXMoJ3JlbW92ZUV2ZW50Jyk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGV2ZW50IG9mIHlvdXIgY2hvaWNlLlxuXHQgKiBXaGVuIGVtaXR0ZWQsIGV2ZXJ5IGxpc3RlbmVyIGF0dGFjaGVkIHRvIHRoYXQgZXZlbnQgd2lsbCBiZSBleGVjdXRlZC5cblx0ICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxuXHQgKiBCZWNhdXNlIGl0IHVzZXMgYGFwcGx5YCwgeW91ciBhcnJheSBvZiBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgaWYgeW91IHdyb3RlIHRoZW0gb3V0IHNlcGFyYXRlbHkuXG5cdCAqIFNvIHRoZXkgd2lsbCBub3QgYXJyaXZlIHdpdGhpbiB0aGUgYXJyYXkgb24gdGhlIG90aGVyIHNpZGUsIHRoZXkgd2lsbCBiZSBzZXBhcmF0ZS5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cblx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcblx0XHR2YXIgbGlzdGVuZXI7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIGtleTtcblx0XHR2YXIgcmVzcG9uc2U7XG5cblx0XHRmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcblx0XHRcdGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRpID0gbGlzdGVuZXJzW2tleV0ubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgc2hhbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBlaXRoZXIgd2l0aCBhIGJhc2ljIGNhbGwgb3IgYW4gYXBwbHkgaWYgdGhlcmUgaXMgYW4gYXJncyBhcnJheVxuXHRcdFx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXJzW2tleV1baV07XG5cblx0XHRcdFx0XHRpZiAobGlzdGVuZXIub25jZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNwb25zZSA9IGxpc3RlbmVyLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xuXG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWxpYXMgb2YgZW1pdEV2ZW50XG5cdCAqL1xuXHRwcm90by50cmlnZ2VyID0gYWxpYXMoJ2VtaXRFdmVudCcpO1xuXG5cdC8qKlxuXHQgKiBTdWJ0bHkgZGlmZmVyZW50IGZyb20gZW1pdEV2ZW50IGluIHRoYXQgaXQgd2lsbCBwYXNzIGl0cyBhcmd1bWVudHMgb24gdG8gdGhlIGxpc3RlbmVycywgYXMgb3Bwb3NlZCB0byB0YWtpbmcgYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3Mgb24uXG5cdCAqIEFzIHdpdGggZW1pdEV2ZW50LCB5b3UgY2FuIHBhc3MgYSByZWdleCBpbiBwbGFjZSBvZiB0aGUgZXZlbnQgbmFtZSB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdCBhbmQgZXhlY3V0ZSBsaXN0ZW5lcnMgZm9yLlxuXHQgKiBAcGFyYW0gey4uLip9IE9wdGlvbmFsIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRyZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWYgYVxuXHQgKiBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhlIG9uZSBzZXQgaGVyZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBhZnRlciBleGVjdXRpb24uIFRoaXMgdmFsdWUgZGVmYXVsdHMgdG8gdHJ1ZS5cblx0ICpcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIHRvIGNoZWNrIGZvciB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uc2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gc2V0T25jZVJldHVyblZhbHVlKHZhbHVlKSB7XG5cdFx0dGhpcy5fb25jZVJldHVyblZhbHVlID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZldGNoZXMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmXG5cdCAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxuXHQgKiBhdXRvbWF0aWNhbGx5LiBJdCB3aWxsIHJldHVybiB0cnVlIGJ5IGRlZmF1bHQuXG5cdCAqXG5cdCAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdHByb3RvLl9nZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBfZ2V0T25jZVJldHVyblZhbHVlKCkge1xuXHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KCdfb25jZVJldHVyblZhbHVlJykpIHtcblx0XHRcdHJldHVybiB0aGlzLl9vbmNlUmV0dXJuVmFsdWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGZXRjaGVzIHRoZSBldmVudHMgb2JqZWN0IGFuZCBjcmVhdGVzIG9uZSBpZiByZXF1aXJlZC5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXZlbnRzIHN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdHByb3RvLl9nZXRFdmVudHMgPSBmdW5jdGlvbiBfZ2V0RXZlbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV2ZXJ0cyB0aGUgZ2xvYmFsIHtAbGluayBFdmVudEVtaXR0ZXJ9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHZlcnNpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBOb24gY29uZmxpY3RpbmcgRXZlbnRFbWl0dGVyIGNsYXNzLlxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuXHRcdGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gb3JpZ2luYWxHbG9iYWxWYWx1ZTtcblx0XHRyZXR1cm4gRXZlbnRFbWl0dGVyO1xuXHR9O1xuXG5cdHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG5cblx0dmFyIHZhbGlkYXRlVHlwZUZ1bmN0aW9uID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHRcdHZhbGlkYXRlVHlwZSggdmFsdWUsIG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiwgXCJGdW5jdGlvblwiICk7XG5cdH07XG5cblxuXG5cblx0dmFyIHN1cGVyR2V0LCBzdXBlckluaXQsXG5cdFx0Z2xvYmFsRWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVUeXBlRXZlbnQoIHZhbHVlLCBuYW1lICkge1xuXHRcdHZhbGlkYXRlVHlwZSggdmFsdWUsIG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCwgXCJTdHJpbmcgb3IgUmVnRXhwXCIgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlVGhlbkNhbGwoIG1ldGhvZCwgc2VsZiApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGV2ZW50LCBsaXN0ZW5lciApIHtcblx0XHRcdHZhbGlkYXRlUHJlc2VuY2UoIGV2ZW50LCBcImV2ZW50XCIgKTtcblx0XHRcdHZhbGlkYXRlVHlwZUV2ZW50KCBldmVudCwgXCJldmVudFwiICk7XG5cblx0XHRcdHZhbGlkYXRlUHJlc2VuY2UoIGxpc3RlbmVyLCBcImxpc3RlbmVyXCIgKTtcblx0XHRcdHZhbGlkYXRlVHlwZUZ1bmN0aW9uKCBsaXN0ZW5lciwgXCJsaXN0ZW5lclwiICk7XG5cblx0XHRcdHJldHVybiBzZWxmWyBtZXRob2QgXS5hcHBseSggc2VsZiwgYXJndW1lbnRzICk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9mZiggc2VsZiApIHtcblx0XHRyZXR1cm4gdmFsaWRhdGVUaGVuQ2FsbCggXCJvZmZcIiwgc2VsZiApO1xuXHR9XG5cblx0ZnVuY3Rpb24gb24oIHNlbGYgKSB7XG5cdFx0cmV0dXJuIHZhbGlkYXRlVGhlbkNhbGwoIFwib25cIiwgc2VsZiApO1xuXHR9XG5cblx0ZnVuY3Rpb24gb25jZSggc2VsZiApIHtcblx0XHRyZXR1cm4gdmFsaWRhdGVUaGVuQ2FsbCggXCJvbmNlXCIsIHNlbGYgKTtcblx0fVxuXG5cdENsZHIub2ZmID0gb2ZmKCBnbG9iYWxFZSApO1xuXHRDbGRyLm9uID0gb24oIGdsb2JhbEVlICk7XG5cdENsZHIub25jZSA9IG9uY2UoIGdsb2JhbEVlICk7XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIENsZHIucHJvdG90eXBlLmluaXQoKS5cblx0ICovXG5cdHN1cGVySW5pdCA9IENsZHIucHJvdG90eXBlLmluaXQ7XG5cdENsZHIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWU7XG5cdFx0dGhpcy5lZSA9IGVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRcdHRoaXMub2ZmID0gb2ZmKCBlZSApO1xuXHRcdHRoaXMub24gPSBvbiggZWUgKTtcblx0XHR0aGlzLm9uY2UgPSBvbmNlKCBlZSApO1xuXHRcdHN1cGVySW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIGdldE92ZXJsb2FkIGlzIGVuY2Fwc3VsYXRlZCwgYmVjYXVzZSBvZiBjbGRyL3VucmVzb2x2ZWQuIElmIGl0J3MgbG9hZGVkXG5cdCAqIGFmdGVyIGNsZHIvZXZlbnQgKGFuZCBub3RlIGl0IG92ZXJ3cml0ZXMgLmdldCksIGl0IGNhbiB0cmlnZ2VyIHRoaXNcblx0ICogb3ZlcmxvYWQgYWdhaW4uXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRPdmVybG9hZCgpIHtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJsb2FkIENsZHIucHJvdG90eXBlLmdldCgpLlxuXHRcdCAqL1xuXHRcdHN1cGVyR2V0ID0gQ2xkci5wcm90b3R5cGUuZ2V0O1xuXHRcdENsZHIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdFx0dmFyIHZhbHVlID0gc3VwZXJHZXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0cGF0aCA9IHBhdGhOb3JtYWxpemUoIHBhdGgsIHRoaXMuYXR0cmlidXRlcyApLmpvaW4oIFwiL1wiICk7XG5cdFx0XHRnbG9iYWxFZS50cmlnZ2VyKCBcImdldFwiLCBbIHBhdGgsIHZhbHVlIF0gKTtcblx0XHRcdHRoaXMuZWUudHJpZ2dlciggXCJnZXRcIiwgWyBwYXRoLCB2YWx1ZSBdICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0fVxuXG5cdENsZHIuX2V2ZW50SW5pdCA9IGdldE92ZXJsb2FkO1xuXHRnZXRPdmVybG9hZCgpO1xuXG5cdHJldHVybiBDbGRyO1xuXG5cblxuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL2V2ZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKlxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBSYWZhZWwgWGF2aWVyIGRlIFNvdXphXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTExLTI2VDE1OjAzWlxuICovXG4vKiFcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOCAyMDE2LTExLTI2VDE1OjAzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXG4gKiBodHRwOi8vZ2l0LmlvL2g0bG1WZ1xuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQuXG5cdFx0ZGVmaW5lKCBbIFwiLi4vY2xkclwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gTm9kZS4gQ29tbW9uSlMuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcIi4uL2NsZHJcIiApICk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gR2xvYmFsXG5cdFx0ZmFjdG9yeSggQ2xkciApO1xuXHR9XG5cbn0oZnVuY3Rpb24oIENsZHIgKSB7XG5cblx0Ly8gQnVpbGQgb3B0aW1pemF0aW9uIGhhY2sgdG8gYXZvaWQgZHVwbGljYXRpbmcgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxuXHR2YXIgYWx3YXlzQXJyYXkgPSBDbGRyLl9hbHdheXNBcnJheTtcblxuXG5cblx0dmFyIHN1cHBsZW1lbnRhbE1haW4gPSBmdW5jdGlvbiggY2xkciApIHtcblxuXHRcdHZhciBwcmVwZW5kLCBzdXBwbGVtZW50YWw7XG5cdFx0XG5cdFx0cHJlcGVuZCA9IGZ1bmN0aW9uKCBwcmVwZW5kICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdFx0XHRwYXRoID0gYWx3YXlzQXJyYXkoIHBhdGggKTtcblx0XHRcdFx0cmV0dXJuIGNsZHIuZ2V0KCBbIHByZXBlbmQgXS5jb25jYXQoIHBhdGggKSApO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0c3VwcGxlbWVudGFsID0gcHJlcGVuZCggXCJzdXBwbGVtZW50YWxcIiApO1xuXG5cdFx0Ly8gV2VlayBEYXRhXG5cdFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI1dlZWtfRGF0YVxuXHRcdHN1cHBsZW1lbnRhbC53ZWVrRGF0YSA9IHByZXBlbmQoIFwic3VwcGxlbWVudGFsL3dlZWtEYXRhXCIgKTtcblxuXHRcdHN1cHBsZW1lbnRhbC53ZWVrRGF0YS5maXJzdERheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC93ZWVrRGF0YS9maXJzdERheS97dGVycml0b3J5fVwiICkgfHxcblx0XHRcdFx0Y2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3dlZWtEYXRhL2ZpcnN0RGF5LzAwMVwiICk7XG5cdFx0fTtcblxuXHRcdHN1cHBsZW1lbnRhbC53ZWVrRGF0YS5taW5EYXlzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWluRGF5cyA9IGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC93ZWVrRGF0YS9taW5EYXlzL3t0ZXJyaXRvcnl9XCIgKSB8fFxuXHRcdFx0XHRjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvd2Vla0RhdGEvbWluRGF5cy8wMDFcIiApO1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KCBtaW5EYXlzLCAxMCApO1xuXHRcdH07XG5cblx0XHQvLyBUaW1lIERhdGFcblx0XHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjVGltZV9EYXRhXG5cdFx0c3VwcGxlbWVudGFsLnRpbWVEYXRhID0gcHJlcGVuZCggXCJzdXBwbGVtZW50YWwvdGltZURhdGFcIiApO1xuXG5cdFx0c3VwcGxlbWVudGFsLnRpbWVEYXRhLmFsbG93ZWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvdGltZURhdGEve3RlcnJpdG9yeX0vX2FsbG93ZWRcIiApIHx8XG5cdFx0XHRcdGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC90aW1lRGF0YS8wMDEvX2FsbG93ZWRcIiApO1xuXHRcdH07XG5cblx0XHRzdXBwbGVtZW50YWwudGltZURhdGEucHJlZmVycmVkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3RpbWVEYXRhL3t0ZXJyaXRvcnl9L19wcmVmZXJyZWRcIiApIHx8XG5cdFx0XHRcdGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC90aW1lRGF0YS8wMDEvX3ByZWZlcnJlZFwiICk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBzdXBwbGVtZW50YWw7XG5cblx0fTtcblxuXG5cblxuXHR2YXIgaW5pdFN1cGVyID0gQ2xkci5wcm90b3R5cGUuaW5pdDtcblxuXHQvKipcblx0ICogLmluaXQoKSBhdXRvbWF0aWNhbGx5IHJhbiBvbiBjb25zdHJ1Y3Rpb24uXG5cdCAqXG5cdCAqIE92ZXJsb2FkIC5pbml0KCkuXG5cdCAqL1xuXHRDbGRyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aW5pdFN1cGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLnN1cHBsZW1lbnRhbCA9IHN1cHBsZW1lbnRhbE1haW4oIHRoaXMgKTtcblx0fTtcblxuXHRyZXR1cm4gQ2xkcjtcblxuXG5cblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9zdXBwbGVtZW50YWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvc3VwcGxlbWVudGFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKlxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBSYWZhZWwgWGF2aWVyIGRlIFNvdXphXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTExLTI2VDE1OjAzWlxuICovXG4vKiFcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOCAyMDE2LTExLTI2VDE1OjAzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXG4gKiBodHRwOi8vZ2l0LmlvL2g0bG1WZ1xuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQuXG5cdFx0ZGVmaW5lKCBbIFwiLi4vY2xkclwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gTm9kZS4gQ29tbW9uSlMuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcIi4uL2NsZHJcIiApICk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gR2xvYmFsXG5cdFx0ZmFjdG9yeSggQ2xkciApO1xuXHR9XG5cbn0oZnVuY3Rpb24oIENsZHIgKSB7XG5cblx0Ly8gQnVpbGQgb3B0aW1pemF0aW9uIGhhY2sgdG8gYXZvaWQgZHVwbGljYXRpbmcgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxuXHR2YXIgY29yZUxvYWQgPSBDbGRyLl9jb3JlTG9hZDtcblx0dmFyIGpzb25NZXJnZSA9IENsZHIuX2pzb25NZXJnZTtcblx0dmFyIHBhdGhOb3JtYWxpemUgPSBDbGRyLl9wYXRoTm9ybWFsaXplO1xuXHR2YXIgcmVzb3VyY2VHZXQgPSBDbGRyLl9yZXNvdXJjZUdldDtcblx0dmFyIHZhbGlkYXRlUHJlc2VuY2UgPSBDbGRyLl92YWxpZGF0ZVByZXNlbmNlO1xuXHR2YXIgdmFsaWRhdGVUeXBlUGF0aCA9IENsZHIuX3ZhbGlkYXRlVHlwZVBhdGg7XG5cblxuXG5cdHZhciBidW5kbGVQYXJlbnRMb29rdXAgPSBmdW5jdGlvbiggQ2xkciwgbG9jYWxlICkge1xuXHRcdHZhciBub3JtYWxpemVkUGF0aCwgcGFyZW50O1xuXG5cdFx0aWYgKCBsb2NhbGUgPT09IFwicm9vdFwiICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZpcnN0LCB0cnkgdG8gZmluZCBwYXJlbnQgb24gc3VwcGxlbWVudGFsIGRhdGEuXG5cdFx0bm9ybWFsaXplZFBhdGggPSBwYXRoTm9ybWFsaXplKCBbIFwic3VwcGxlbWVudGFsL3BhcmVudExvY2FsZXMvcGFyZW50TG9jYWxlXCIsIGxvY2FsZSBdICk7XG5cdFx0cGFyZW50ID0gcmVzb3VyY2VHZXQoIENsZHIuX3Jlc29sdmVkLCBub3JtYWxpemVkUGF0aCApIHx8IHJlc291cmNlR2V0KCBDbGRyLl9yYXcsIG5vcm1hbGl6ZWRQYXRoICk7XG5cdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblxuXHRcdC8vIE9yIHRydW5jYXRlIGxvY2FsZS5cblx0XHRwYXJlbnQgPSBsb2NhbGUuc3Vic3RyKCAwLCBsb2NhbGUubGFzdEluZGV4T2YoIENsZHIubG9jYWxlU2VwICkgKTtcblx0XHRpZiAoICFwYXJlbnQgKSB7XG5cdFx0XHRyZXR1cm4gXCJyb290XCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcmVudDtcblx0fTtcblxuXG5cblxuXHQvLyBAcGF0aDogbm9ybWFsaXplZCBwYXRoXG5cdHZhciByZXNvdXJjZVNldCA9IGZ1bmN0aW9uKCBkYXRhLCBwYXRoLCB2YWx1ZSApIHtcblx0XHR2YXIgaSxcblx0XHRcdG5vZGUgPSBkYXRhLFxuXHRcdFx0bGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdGlmICggIW5vZGVbIHBhdGhbIGkgXSBdICkge1xuXHRcdFx0XHRub2RlWyBwYXRoWyBpIF0gXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IG5vZGVbIHBhdGhbIGkgXSBdO1xuXHRcdH1cblx0XHRub2RlWyBwYXRoWyBpIF0gXSA9IHZhbHVlO1xuXHR9O1xuXG5cblx0dmFyIGl0ZW1Mb29rdXAgPSAoZnVuY3Rpb24oKSB7XG5cblx0dmFyIGxvb2t1cDtcblxuXHRsb29rdXAgPSBmdW5jdGlvbiggQ2xkciwgbG9jYWxlLCBwYXRoLCBhdHRyaWJ1dGVzLCBjaGlsZExvY2FsZSApIHtcblx0XHR2YXIgbm9ybWFsaXplZFBhdGgsIHBhcmVudCwgdmFsdWU7XG5cblx0XHQvLyAxOiBGaW5pc2ggcmVjdXJzaW9uXG5cdFx0Ly8gMjogQXZvaWQgaW5maW5pdGUgbG9vcFxuXHRcdGlmICggdHlwZW9mIGxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIiAvKiAxICovIHx8IGxvY2FsZSA9PT0gY2hpbGRMb2NhbGUgLyogMiAqLyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXNvbHZlIHBhdGhcblx0XHRub3JtYWxpemVkUGF0aCA9IHBhdGhOb3JtYWxpemUoIHBhdGgsIGF0dHJpYnV0ZXMgKTtcblxuXHRcdC8vIENoZWNrIHJlc29sdmVkIChjYWNoZWQpIGRhdGEgZmlyc3Rcblx0XHQvLyAxOiBEdWUgdG8gIzE2LCBuZXZlciB1c2UgdGhlIGNhY2hlZCByZXNvbHZlZCBub24tbGVhZiBub2Rlcy4gSXQgbWF5IG5vdFxuXHRcdC8vICAgIHJlcHJlc2VudCBpdHMgbGVhZnMgaW4gaXRzIGVudGlyZXR5LlxuXHRcdHZhbHVlID0gcmVzb3VyY2VHZXQoIENsZHIuX3Jlc29sdmVkLCBub3JtYWxpemVkUGF0aCApO1xuXHRcdGlmICggdmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIC8qIDEgKi8gKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgcmF3IGRhdGFcblx0XHR2YWx1ZSA9IHJlc291cmNlR2V0KCBDbGRyLl9yYXcsIG5vcm1hbGl6ZWRQYXRoICk7XG5cblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdC8vIE9yLCBsb29rdXAgYXQgcGFyZW50IGxvY2FsZVxuXHRcdFx0cGFyZW50ID0gYnVuZGxlUGFyZW50TG9va3VwKCBDbGRyLCBsb2NhbGUgKTtcblx0XHRcdHZhbHVlID0gbG9va3VwKCBDbGRyLCBwYXJlbnQsIHBhdGgsIGpzb25NZXJnZSggYXR0cmlidXRlcywgeyBidW5kbGU6IHBhcmVudCB9KSwgbG9jYWxlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdC8vIFNldCByZXNvbHZlZCAoY2FjaGVkKVxuXHRcdFx0cmVzb3VyY2VTZXQoIENsZHIuX3Jlc29sdmVkLCBub3JtYWxpemVkUGF0aCwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0cmV0dXJuIGxvb2t1cDtcblxufSgpKTtcblxuXG5cdENsZHIuX3JhdyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBDbGRyLmxvYWQoIGpzb24gWywganNvbiwgLi4uXSApXG5cdCAqXG5cdCAqIEBqc29uIFtKU09OXSBDTERSIGRhdGEgb3IgW0FycmF5XSBBcnJheSBvZiBAanNvbidzLlxuXHQgKlxuXHQgKiBMb2FkIHJlc29sdmVkIG9yIHVucmVzb2x2ZWQgY2xkciBkYXRhLlxuXHQgKiBPdmVyd3JpdGUgQ2xkci5sb2FkKCkuXG5cdCAqL1xuXHRDbGRyLmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRDbGRyLl9yYXcgPSBjb3JlTG9hZCggQ2xkciwgQ2xkci5fcmF3LCBhcmd1bWVudHMgKTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcndyaXRlIENsZHIucHJvdG90eXBlLmdldCgpLlxuXHQgKi9cblx0Q2xkci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdFx0dmFsaWRhdGVQcmVzZW5jZSggcGF0aCwgXCJwYXRoXCIgKTtcblx0XHR2YWxpZGF0ZVR5cGVQYXRoKCBwYXRoLCBcInBhdGhcIiApO1xuXG5cdFx0Ly8gMTogdXNlIGJ1bmRsZSBhcyBsb2NhbGUgb24gaXRlbSBsb29rdXAgZm9yIHNpbXBsaWZpY2F0aW9uIHB1cnBvc2VzLCBiZWNhdXNlIG5vIG90aGVyIGV4dGVuZGVkIHN1YnRhZyBpcyB1c2VkIGFueXdheSBvbiBidW5kbGUgcGFyZW50IGxvb2t1cC5cblx0XHQvLyAyOiBkdXJpbmcgaW5pdCgpLCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGJ1dCBidW5kbGUgaXMgeWV0IG5vdCBkZWZpbmVkLiBVc2UgXCJcIiBhcyBhIHdvcmthcm91bmQgaW4gdGhpcyB2ZXJ5IHNwZWNpZmljIHNjZW5hcmlvLlxuXHRcdHJldHVybiBpdGVtTG9va3VwKCBDbGRyLCB0aGlzLmF0dHJpYnV0ZXMgJiYgdGhpcy5hdHRyaWJ1dGVzLmJ1bmRsZSAvKiAxICovIHx8IFwiXCIgLyogMiAqLywgcGF0aCwgdGhpcy5hdHRyaWJ1dGVzICk7XG5cdH07XG5cblx0Ly8gSW4gY2FzZSBjbGRyL3VucmVzb2x2ZWQgaXMgbG9hZGVkIGFmdGVyIGNsZHIvZXZlbnQsIHdlIHRyaWdnZXIgaXRzIG92ZXJsb2FkcyBhZ2Fpbi4gQmVjYXVzZSwgLmdldCBpcyBvdmVyd3JpdHRlbiBpbiBoZXJlLlxuXHRpZiAoIENsZHIuX2V2ZW50SW5pdCApIHtcblx0XHRDbGRyLl9ldmVudEluaXQoKTtcblx0fVxuXG5cdHJldHVybiBDbGRyO1xuXG5cblxuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3VucmVzb2x2ZWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvdW5yZXNvbHZlZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKipcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgUmFmYWVsIFhhdmllciBkZSBTb3V6YVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0xMS0yNlQxNTowM1pcbiAqL1xuLyohXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjggMjAxNi0xMS0yNlQxNTowM1ogTUlUIGxpY2Vuc2UgwqkgUmFmYWVsIFhhdmllclxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcbiAqL1xuXG4vLyBDbGRyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoIFwiLi9jbGRyXCIgKTtcblxuLy8gRXh0ZW50IENsZHIgd2l0aCB0aGUgZm9sbG93aW5nIG1vZHVsZXNcbnJlcXVpcmUoIFwiLi9jbGRyL2V2ZW50XCIgKTtcbnJlcXVpcmUoIFwiLi9jbGRyL3N1cHBsZW1lbnRhbFwiICk7XG5yZXF1aXJlKCBcIi4vY2xkci91bnJlc29sdmVkXCIgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L25vZGVfbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3Qvbm9kZV9tYWluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiY2xkci9ldmVudFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEdsb2JhbFxuXHRcdHJvb3QuR2xvYmFsaXplID0gZmFjdG9yeSggcm9vdC5DbGRyICk7XG5cdH1cbn0oIHRoaXMsIGZ1bmN0aW9uKCBDbGRyICkge1xuXG5cbi8qKlxuICogQSB0b1N0cmluZyBtZXRob2QgdGhhdCBvdXRwdXRzIG1lYW5pbmdmdWwgdmFsdWVzIGZvciBvYmplY3RzIG9yIGFycmF5cyBhbmRcbiAqIHN0aWxsIHBlcmZvcm1zIGFzIGZhc3QgYXMgYSBwbGFpbiBzdHJpbmcgaW4gY2FzZSB2YXJpYWJsZSBpcyBzdHJpbmcsIG9yIGFzXG4gKiBmYXN0IGFzIGBcIlwiICsgbnVtYmVyYCBpbiBjYXNlIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICogUmVmOiBodHRwOi8vanNwZXJmLmNvbS9teS1zdHJpbmdpZnlcbiAqL1xudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oIHZhcmlhYmxlICkge1xuXHRyZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09PSBcInN0cmluZ1wiID8gdmFyaWFibGUgOiAoIHR5cGVvZiB2YXJpYWJsZSA9PT0gXCJudW1iZXJcIiA/IFwiXCIgK1xuXHRcdHZhcmlhYmxlIDogSlNPTi5zdHJpbmdpZnkoIHZhcmlhYmxlICkgKTtcbn07XG5cblxuXG5cbi8qKlxuICogZm9ybWF0TWVzc2FnZSggbWVzc2FnZSwgZGF0YSApXG4gKlxuICogQG1lc3NhZ2UgW1N0cmluZ10gQSBtZXNzYWdlIHdpdGggb3B0aW9uYWwge3ZhcnN9IHRvIGJlIHJlcGxhY2VkLlxuICpcbiAqIEBkYXRhIFtBcnJheSBvciBKU09OXSBPYmplY3Qgd2l0aCByZXBsYWNpbmctdmFyaWFibGVzIGNvbnRlbnQuXG4gKlxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbWVzc2FnZS4gRm9yIGV4YW1wbGU6XG4gKlxuICogLSBmb3JtYXRNZXNzYWdlKCBcInswfSBzZWNvbmRcIiwgWyAxIF0gKTsgLy8gMSBzZWNvbmRcbiAqXG4gKiAtIGZvcm1hdE1lc3NhZ2UoIFwiezB9L3sxfVwiLCBbXCJtXCIsIFwic1wiXSApOyAvLyBtL3NcbiAqXG4gKiAtIGZvcm1hdE1lc3NhZ2UoIFwie25hbWV9IDx7ZW1haWx9PlwiLCB7XG4gKiAgICAgbmFtZTogXCJGb29cIixcbiAqICAgICBlbWFpbDogXCJiYXJAYmF6LnF1eFwiXG4gKiAgIH0pOyAvLyBGb28gPGJhckBiYXoucXV4PlxuICovXG52YXIgZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBkYXRhICkge1xuXG5cdC8vIFJlcGxhY2Uge2F0dHJpYnV0ZX0nc1xuXHRtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKCAve1swLTlhLXpBLVotXy4gXSt9L2csIGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoIC9eeyhbXn1dKil9JC8sIFwiJDFcIiApO1xuXHRcdHJldHVybiB0b1N0cmluZyggZGF0YVsgbmFtZSBdICk7XG5cdH0pO1xuXG5cdHJldHVybiBtZXNzYWdlO1xufTtcblxuXG5cblxudmFyIG9iamVjdEV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgZGVzdGluYXRpb24gPSBhcmd1bWVudHNbIDAgXSxcblx0XHRzb3VyY2VzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cblx0c291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cdFx0dmFyIHByb3A7XG5cdFx0Zm9yICggcHJvcCBpbiBzb3VyY2UgKSB7XG5cdFx0XHRkZXN0aW5hdGlvblsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG5cblxuXG52YXIgY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiggY29kZSwgbWVzc2FnZSwgYXR0cmlidXRlcyApIHtcblx0dmFyIGVycm9yO1xuXG5cdG1lc3NhZ2UgPSBjb2RlICsgKCBtZXNzYWdlID8gXCI6IFwiICsgZm9ybWF0TWVzc2FnZSggbWVzc2FnZSwgYXR0cmlidXRlcyApIDogXCJcIiApO1xuXHRlcnJvciA9IG5ldyBFcnJvciggbWVzc2FnZSApO1xuXHRlcnJvci5jb2RlID0gY29kZTtcblxuXHRvYmplY3RFeHRlbmQoIGVycm9yLCBhdHRyaWJ1dGVzICk7XG5cblx0cmV0dXJuIGVycm9yO1xufTtcblxuXG5cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjE2NDYxL2dlbmVyYXRlLWEtaGFzaC1mcm9tLXN0cmluZy1pbi1qYXZhc2NyaXB0LWpxdWVyeVxudmFyIHN0cmluZ0hhc2ggPSBmdW5jdGlvbiggc3RyICkge1xuXHRyZXR1cm4gW10ucmVkdWNlLmNhbGwoIHN0ciwgZnVuY3Rpb24oIGhhc2gsIGkgKSB7XG5cdFx0dmFyIGNociA9IGkuY2hhckNvZGVBdCggMCApO1xuXHRcdGhhc2ggPSAoICggaGFzaCA8PCA1ICkgLSBoYXNoICkgKyBjaHI7XG5cdFx0cmV0dXJuIGhhc2ggfCAwO1xuXHR9LCAwICk7XG59O1xuXG5cblxuXG52YXIgcnVudGltZUtleSA9IGZ1bmN0aW9uKCBmbk5hbWUsIGxvY2FsZSwgYXJncywgYXJnc1N0ciApIHtcblx0dmFyIGhhc2g7XG5cdGFyZ3NTdHIgPSBhcmdzU3RyIHx8IEpTT04uc3RyaW5naWZ5KCBhcmdzICk7XG5cdGhhc2ggPSBzdHJpbmdIYXNoKCBmbk5hbWUgKyBsb2NhbGUgKyBhcmdzU3RyICk7XG5cdHJldHVybiBoYXNoID4gMCA/IFwiYVwiICsgaGFzaCA6IFwiYlwiICsgTWF0aC5hYnMoIGhhc2ggKTtcbn07XG5cblxuXG5cbnZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiggZm4gKSB7XG5cdGlmICggZm4ubmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiBmbi5uYW1lO1xuXHR9XG5cblx0Ly8gZm4ubmFtZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFLlxuXHR2YXIgbWF0Y2hlcyA9IC9eZnVuY3Rpb25cXHMrKFtcXHdcXCRdKylcXHMqXFwoLy5leGVjKCBmbi50b1N0cmluZygpICk7XG5cblx0aWYgKCBtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMCApIHtcblx0XHRyZXR1cm4gbWF0Y2hlc1sgMSBdO1xuXHR9XG59O1xuXG5cblxuXG52YXIgcnVudGltZUJpbmQgPSBmdW5jdGlvbiggYXJncywgY2xkciwgZm4sIHJ1bnRpbWVBcmdzICkge1xuXG5cdHZhciBhcmdzU3RyID0gSlNPTi5zdHJpbmdpZnkoIGFyZ3MgKSxcblx0XHRmbk5hbWUgPSBmdW5jdGlvbk5hbWUoIGZuICksXG5cdFx0bG9jYWxlID0gY2xkci5sb2NhbGU7XG5cblx0Ly8gSWYgbmFtZSBvZiB0aGUgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBpcyBtb3N0IGxpa2VseSBkdWUgdG8gdWdsaWZpY2F0aW9uLFxuXHQvLyB3aGljaCBtb3N0IGxpa2VseSBtZWFucyB3ZSBhcmUgaW4gcHJvZHVjdGlvbiwgYW5kIHJ1bnRpbWVCaW5kIGhlcmUgaXMgbm90IG5lY2Vzc2FyeS5cblx0aWYgKCAhZm5OYW1lICkge1xuXHRcdHJldHVybiBmbjtcblx0fVxuXG5cdGZuLnJ1bnRpbWVLZXkgPSBydW50aW1lS2V5KCBmbk5hbWUsIGxvY2FsZSwgbnVsbCwgYXJnc1N0ciApO1xuXG5cdGZuLmdlbmVyYXRvclN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIkdsb2JhbGl6ZShcXFwiXCIgKyBsb2NhbGUgKyBcIlxcXCIpLlwiICsgZm5OYW1lICsgXCIoXCIgKyBhcmdzU3RyLnNsaWNlKCAxLCAtMSApICsgXCIpXCI7XG5cdH07XG5cblx0Zm4ucnVudGltZUFyZ3MgPSBydW50aW1lQXJncztcblxuXHRyZXR1cm4gZm47XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiggY29kZSwgbWVzc2FnZSwgY2hlY2ssIGF0dHJpYnV0ZXMgKSB7XG5cdGlmICggIWNoZWNrICkge1xuXHRcdHRocm93IGNyZWF0ZUVycm9yKCBjb2RlLCBtZXNzYWdlLCBhdHRyaWJ1dGVzICk7XG5cdH1cbn07XG5cblxuXG5cbnZhciBhbHdheXNBcnJheSA9IGZ1bmN0aW9uKCBzdHJpbmdPckFycmF5ICkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSggc3RyaW5nT3JBcnJheSApID8gc3RyaW5nT3JBcnJheSA6IHN0cmluZ09yQXJyYXkgPyBbIHN0cmluZ09yQXJyYXkgXSA6IFtdO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlQ2xkciA9IGZ1bmN0aW9uKCBwYXRoLCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFyIHNraXBCb29sZWFuO1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRza2lwQm9vbGVhbiA9IGFsd2F5c0FycmF5KCBvcHRpb25zLnNraXAgKS5zb21lKGZ1bmN0aW9uKCBwYXRoUmUgKSB7XG5cdFx0cmV0dXJuIHBhdGhSZS50ZXN0KCBwYXRoICk7XG5cdH0pO1xuXG5cdHZhbGlkYXRlKCBcIkVfTUlTU0lOR19DTERSXCIsIFwiTWlzc2luZyByZXF1aXJlZCBDTERSIGNvbnRlbnQgYHtwYXRofWAuXCIsIHZhbHVlIHx8IHNraXBCb29sZWFuLCB7XG5cdFx0cGF0aDogcGF0aFxuXHR9KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdHZhbGlkYXRlKCBcIkVfREVGQVVMVF9MT0NBTEVfTk9UX0RFRklORURcIiwgXCJEZWZhdWx0IGxvY2FsZSBoYXMgbm90IGJlZW4gZGVmaW5lZC5cIixcblx0XHR2YWx1ZSAhPT0gdW5kZWZpbmVkLCB7fSApO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlKCBcIkVfTUlTU0lOR19QQVJBTUVURVJcIiwgXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBge25hbWV9YC5cIixcblx0XHR2YWx1ZSAhPT0gdW5kZWZpbmVkLCB7IG5hbWU6IG5hbWUgfSk7XG59O1xuXG5cblxuXG4vKipcbiAqIHJhbmdlKCB2YWx1ZSwgbmFtZSwgbWluaW11bSwgbWF4aW11bSApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdLlxuICpcbiAqIEBuYW1lIFtTdHJpbmddIG5hbWUgb2YgdmFyaWFibGUuXG4gKlxuICogQG1pbmltdW0gW051bWJlcl0uIFRoZSBsb3dlc3QgdmFsaWQgdmFsdWUsIGluY2x1c2l2ZS5cbiAqXG4gKiBAbWF4aW11bSBbTnVtYmVyXS4gVGhlIGdyZWF0ZXN0IHZhbGlkIHZhbHVlLCBpbmNsdXNpdmUuXG4gKi9cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclJhbmdlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lLCBtaW5pbXVtLCBtYXhpbXVtICkge1xuXHR2YWxpZGF0ZShcblx0XHRcIkVfUEFSX09VVF9PRl9SQU5HRVwiLFxuXHRcdFwiUGFyYW1ldGVyIGB7bmFtZX1gIGhhcyB2YWx1ZSBge3ZhbHVlfWAgb3V0IG9mIHJhbmdlIFt7bWluaW11bX0sIHttYXhpbXVtfV0uXCIsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA+PSBtaW5pbXVtICYmIHZhbHVlIDw9IG1heGltdW0sXG5cdFx0e1xuXHRcdFx0bWF4aW11bTogbWF4aW11bSxcblx0XHRcdG1pbmltdW06IG1pbmltdW0sXG5cdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fVxuXHQpO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSwgY2hlY2ssIGV4cGVjdGVkICkge1xuXHR2YWxpZGF0ZShcblx0XHRcIkVfSU5WQUxJRF9QQVJfVFlQRVwiLFxuXHRcdFwiSW52YWxpZCBge25hbWV9YCBwYXJhbWV0ZXIgKHt2YWx1ZX0pLiB7ZXhwZWN0ZWR9IGV4cGVjdGVkLlwiLFxuXHRcdGNoZWNrLFxuXHRcdHtcblx0XHRcdGV4cGVjdGVkOiBleHBlY3RlZCxcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9XG5cdCk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTG9jYWxlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIENsZHIsXG5cdFx0XCJTdHJpbmcgb3IgQ2xkciBpbnN0YW5jZVwiXG5cdCk7XG59O1xuXG5cblxuXG4vKipcbiAqIEZ1bmN0aW9uIGluc3BpcmVkIGJ5IGpRdWVyeSBDb3JlLCBidXQgcmVkdWNlZCB0byBvdXIgdXNlIGNhc2UuXG4gKi9cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24oIG9iaiApIHtcblx0cmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBcIlwiICsgb2JqID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzUGxhaW5PYmplY3QoIHZhbHVlICksXG5cdFx0XCJQbGFpbiBPYmplY3RcIlxuXHQpO1xufTtcblxuXG5cblxudmFyIGFsd2F5c0NsZHIgPSBmdW5jdGlvbiggbG9jYWxlT3JDbGRyICkge1xuXHRyZXR1cm4gbG9jYWxlT3JDbGRyIGluc3RhbmNlb2YgQ2xkciA/IGxvY2FsZU9yQ2xkciA6IG5ldyBDbGRyKCBsb2NhbGVPckNsZHIgKTtcbn07XG5cblxuXG5cbi8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGR3VpZGUlMkZSZWd1bGFyX0V4cHJlc3Npb25zXG52YXIgcmVnZXhwRXNjYXBlID0gZnVuY3Rpb24oIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCAvKFsuKis/Xj0hOiR7fSgpfFxcW1xcXVxcL1xcXFxdKS9nLCBcIlxcXFwkMVwiICk7XG59O1xuXG5cblxuXG52YXIgc3RyaW5nUGFkID0gZnVuY3Rpb24oIHN0ciwgY291bnQsIHJpZ2h0ICkge1xuXHR2YXIgbGVuZ3RoO1xuXHRpZiAoIHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0c3RyID0gU3RyaW5nKCBzdHIgKTtcblx0fVxuXHRmb3IgKCBsZW5ndGggPSBzdHIubGVuZ3RoOyBsZW5ndGggPCBjb3VudDsgbGVuZ3RoICs9IDEgKSB7XG5cdFx0c3RyID0gKCByaWdodCA/ICggc3RyICsgXCIwXCIgKSA6ICggXCIwXCIgKyBzdHIgKSApO1xuXHR9XG5cdHJldHVybiBzdHI7XG59O1xuXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpa2VseVN1YnRhZ3MoIGNsZHIgKSB7XG5cdGNsZHIub25jZSggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cdGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzXCIgKTtcbn1cblxuLyoqXG4gKiBbbmV3XSBHbG9iYWxpemUoIGxvY2FsZXxjbGRyIClcbiAqXG4gKiBAbG9jYWxlIFtTdHJpbmddXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdXG4gKlxuICogQ3JlYXRlIGEgR2xvYmFsaXplIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBHbG9iYWxpemUoIGxvY2FsZSApIHtcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgR2xvYmFsaXplICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBHbG9iYWxpemUoIGxvY2FsZSApO1xuXHR9XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggbG9jYWxlLCBcImxvY2FsZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZUxvY2FsZSggbG9jYWxlLCBcImxvY2FsZVwiICk7XG5cblx0dGhpcy5jbGRyID0gYWx3YXlzQ2xkciggbG9jYWxlICk7XG5cblx0dmFsaWRhdGVMaWtlbHlTdWJ0YWdzKCB0aGlzLmNsZHIgKTtcbn1cblxuLyoqXG4gKiBHbG9iYWxpemUubG9hZCgganNvbiwgLi4uIClcbiAqXG4gKiBAanNvbiBbSlNPTl1cbiAqXG4gKiBMb2FkIHJlc29sdmVkIG9yIHVucmVzb2x2ZWQgY2xkciBkYXRhLlxuICogU29tZXdoYXQgZXF1aXZhbGVudCB0byBwcmV2aW91cyBHbG9iYWxpemUuYWRkQ3VsdHVyZUluZm8oLi4uKS5cbiAqL1xuR2xvYmFsaXplLmxvYWQgPSBmdW5jdGlvbigpIHtcblxuXHQvLyB2YWxpZGF0aW9ucyBhcmUgZGVsZWdhdGVkIHRvIENsZHIubG9hZCgpLlxuXHRDbGRyLmxvYWQuYXBwbHkoIENsZHIsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBHbG9iYWxpemUubG9jYWxlKCBbbG9jYWxlfGNsZHJdIClcbiAqXG4gKiBAbG9jYWxlIFtTdHJpbmddXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdXG4gKlxuICogU2V0IGRlZmF1bHQgQ2xkciBpbnN0YW5jZSBpZiBsb2NhbGUgb3IgY2xkciBhcmd1bWVudCBpcyBwYXNzZWQuXG4gKlxuICogUmV0dXJuIHRoZSBkZWZhdWx0IENsZHIgaW5zdGFuY2UuXG4gKi9cbkdsb2JhbGl6ZS5sb2NhbGUgPSBmdW5jdGlvbiggbG9jYWxlICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVMb2NhbGUoIGxvY2FsZSwgXCJsb2NhbGVcIiApO1xuXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHR0aGlzLmNsZHIgPSBhbHdheXNDbGRyKCBsb2NhbGUgKTtcblx0XHR2YWxpZGF0ZUxpa2VseVN1YnRhZ3MoIHRoaXMuY2xkciApO1xuXHR9XG5cdHJldHVybiB0aGlzLmNsZHI7XG59O1xuXG4vKipcbiAqIE9wdGltaXphdGlvbiB0byBhdm9pZCBkdXBsaWNhdGluZyBzb21lIGludGVybmFsIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cbiAqL1xuR2xvYmFsaXplLl9hbHdheXNBcnJheSA9IGFsd2F5c0FycmF5O1xuR2xvYmFsaXplLl9jcmVhdGVFcnJvciA9IGNyZWF0ZUVycm9yO1xuR2xvYmFsaXplLl9mb3JtYXRNZXNzYWdlID0gZm9ybWF0TWVzc2FnZTtcbkdsb2JhbGl6ZS5faXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5HbG9iYWxpemUuX29iamVjdEV4dGVuZCA9IG9iamVjdEV4dGVuZDtcbkdsb2JhbGl6ZS5fcmVnZXhwRXNjYXBlID0gcmVnZXhwRXNjYXBlO1xuR2xvYmFsaXplLl9ydW50aW1lQmluZCA9IHJ1bnRpbWVCaW5kO1xuR2xvYmFsaXplLl9zdHJpbmdQYWQgPSBzdHJpbmdQYWQ7XG5HbG9iYWxpemUuX3ZhbGlkYXRlID0gdmFsaWRhdGU7XG5HbG9iYWxpemUuX3ZhbGlkYXRlQ2xkciA9IHZhbGlkYXRlQ2xkcjtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gdmFsaWRhdGVEZWZhdWx0TG9jYWxlO1xuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZTtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSA9IHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2U7XG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3Q7XG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IHZhbGlkYXRlUGFyYW1ldGVyVHlwZTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCIuL251bWJlclwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCIsXG5cdFx0XHRcImNsZHIvc3VwcGxlbWVudGFsXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBHbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIGFsd2F5c0FycmF5ID0gR2xvYmFsaXplLl9hbHdheXNBcnJheSxcblx0Zm9ybWF0TWVzc2FnZSA9IEdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSxcblx0bnVtYmVyTnVtYmVyaW5nU3lzdGVtID0gR2xvYmFsaXplLl9udW1iZXJOdW1iZXJpbmdTeXN0ZW0sXG5cdG51bWJlclBhdHRlcm4gPSBHbG9iYWxpemUuX251bWJlclBhdHRlcm4sXG5cdHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0c3RyaW5nUGFkID0gR2xvYmFsaXplLl9zdHJpbmdQYWQsXG5cdHZhbGlkYXRlQ2xkciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyLFxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3Q7XG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZUN1cnJlbmN5ID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAoIC9eW0EtWmEtel17M30kLyApLnRlc3QoIHZhbHVlICksXG5cdFx0XCIzLWxldHRlciBjdXJyZW5jeSBjb2RlIHN0cmluZyBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3XCJcblx0KTtcbn07XG5cblxuXG5cbi8qKlxuICogc3VwcGxlbWVudGFsT3ZlcnJpZGUoIGN1cnJlbmN5LCBwYXR0ZXJuLCBjbGRyIClcbiAqXG4gKiBSZXR1cm4gcGF0dGVybiB3aXRoIGZyYWN0aW9uIGRpZ2l0cyBvdmVycmlkZW4gYnkgc3VwcGxlbWVudGFsIGN1cnJlbmN5IGRhdGEuXG4gKi9cbnZhciBjdXJyZW5jeVN1cHBsZW1lbnRhbE92ZXJyaWRlID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBwYXR0ZXJuLCBjbGRyICkge1xuXHR2YXIgZGlnaXRzLFxuXHRcdGZyYWN0aW9uID0gXCJcIixcblx0XHRmcmFjdGlvbkRhdGEgPSBjbGRyLnN1cHBsZW1lbnRhbChbIFwiY3VycmVuY3lEYXRhL2ZyYWN0aW9uc1wiLCBjdXJyZW5jeSBdKSB8fFxuXHRcdFx0Y2xkci5zdXBwbGVtZW50YWwoIFwiY3VycmVuY3lEYXRhL2ZyYWN0aW9ucy9ERUZBVUxUXCIgKTtcblxuXHRkaWdpdHMgPSArZnJhY3Rpb25EYXRhLl9kaWdpdHM7XG5cblx0aWYgKCBkaWdpdHMgKSB7XG5cdFx0ZnJhY3Rpb24gPSBcIi5cIiArIHN0cmluZ1BhZCggXCIwXCIsIGRpZ2l0cyApLnNsaWNlKCAwLCAtMSApICsgZnJhY3Rpb25EYXRhLl9yb3VuZGluZztcblx0fVxuXG5cdHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoIC9cXC4oIyt8MCpbMC05XXwwK1swLTldPykvZywgZnJhY3Rpb24gKTtcbn07XG5cblxuXG5cbnZhciBvYmplY3RGaWx0ZXIgPSBmdW5jdGlvbiggb2JqZWN0LCB0ZXN0UmUgKSB7XG5cdHZhciBrZXksXG5cdFx0Y29weSA9IHt9O1xuXG5cdGZvciAoIGtleSBpbiBvYmplY3QgKSB7XG5cdFx0aWYgKCB0ZXN0UmUudGVzdCgga2V5ICkgKSB7XG5cdFx0XHRjb3B5WyBrZXkgXSA9IG9iamVjdFsga2V5IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvcHk7XG59O1xuXG5cblxuXG52YXIgY3VycmVuY3lVbml0UGF0dGVybnMgPSBmdW5jdGlvbiggY2xkciApIHtcblx0cmV0dXJuIG9iamVjdEZpbHRlciggY2xkci5tYWluKFtcblx0XHRcIm51bWJlcnNcIixcblx0XHRcImN1cnJlbmN5Rm9ybWF0cy1udW1iZXJTeXN0ZW0tXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKVxuXHRdKSwgL151bml0UGF0dGVybi8gKTtcbn07XG5cblxuXG5cbi8qKlxuICogY29kZVByb3BlcnRpZXMoIGN1cnJlbmN5LCBjbGRyIClcbiAqXG4gKiBSZXR1cm4gbnVtYmVyIHBhdHRlcm4gd2l0aCB0aGUgYXBwcm9wcmlhdGUgY3VycmVuY3kgY29kZSBpbiBhcyBsaXRlcmFsLlxuICovXG52YXIgY3VycmVuY3lDb2RlUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgY2xkciApIHtcblx0dmFyIHBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuKCBcImRlY2ltYWxcIiwgY2xkciApO1xuXG5cdC8vIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYW5kIHRoZSByb3VuZGluZyBmb3IgZWFjaCBjdXJyZW5jeSBpcyBub3QgbG9jYWxlLXNwZWNpZmljLiBUaG9zZVxuXHQvLyB2YWx1ZXMgb3ZlcnJpZGRlbiBieSBTdXBwbGVtZW50YWwgQ3VycmVuY3kgRGF0YS5cblx0cGF0dGVybiA9IGN1cnJlbmN5U3VwcGxlbWVudGFsT3ZlcnJpZGUoIGN1cnJlbmN5LCBwYXR0ZXJuLCBjbGRyICk7XG5cblx0cmV0dXJuIHtcblx0XHRjdXJyZW5jeTogY3VycmVuY3ksXG5cdFx0cGF0dGVybjogcGF0dGVybixcblx0XHR1bml0UGF0dGVybnM6IGN1cnJlbmN5VW5pdFBhdHRlcm5zKCBjbGRyIClcblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogbmFtZUZvcm1hdCggZm9ybWF0dGVkTnVtYmVyLCBwbHVyYWxGb3JtLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5hbWUgZm9ybSBjdXJyZW5jeSBmb3JtYXQuXG4gKi9cbnZhciBjdXJyZW5jeU5hbWVGb3JtYXQgPSBmdW5jdGlvbiggZm9ybWF0dGVkTnVtYmVyLCBwbHVyYWxGb3JtLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgZGlzcGxheU5hbWUsIHVuaXRQYXR0ZXJuLFxuXHRcdGRpc3BsYXlOYW1lcyA9IHByb3BlcnRpZXMuZGlzcGxheU5hbWVzIHx8IHt9LFxuXHRcdHVuaXRQYXR0ZXJucyA9IHByb3BlcnRpZXMudW5pdFBhdHRlcm5zO1xuXG5cdGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWVzWyBcImRpc3BsYXlOYW1lLWNvdW50LVwiICsgcGx1cmFsRm9ybSBdIHx8XG5cdFx0ZGlzcGxheU5hbWVzWyBcImRpc3BsYXlOYW1lLWNvdW50LW90aGVyXCIgXSB8fFxuXHRcdGRpc3BsYXlOYW1lcy5kaXNwbGF5TmFtZSB8fFxuXHRcdHByb3BlcnRpZXMuY3VycmVuY3k7XG5cdHVuaXRQYXR0ZXJuID0gdW5pdFBhdHRlcm5zWyBcInVuaXRQYXR0ZXJuLWNvdW50LVwiICsgcGx1cmFsRm9ybSBdIHx8XG5cdFx0dW5pdFBhdHRlcm5zWyBcInVuaXRQYXR0ZXJuLWNvdW50LW90aGVyXCIgXTtcblxuXHRyZXR1cm4gZm9ybWF0TWVzc2FnZSggdW5pdFBhdHRlcm4sIFsgZm9ybWF0dGVkTnVtYmVyLCBkaXNwbGF5TmFtZSBdKTtcbn07XG5cblxuXG5cbnZhciBjdXJyZW5jeUZvcm1hdHRlckZuID0gZnVuY3Rpb24oIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgZm47XG5cblx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFwiY29kZVwiIG9yIFwibmFtZVwiLlxuXHRpZiAoIHBsdXJhbEdlbmVyYXRvciAmJiBwcm9wZXJ0aWVzICkge1xuXHRcdGZuID0gZnVuY3Rpb24gY3VycmVuY3lGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRyZXR1cm4gY3VycmVuY3lOYW1lRm9ybWF0KFxuXHRcdFx0XHRudW1iZXJGb3JtYXR0ZXIoIHZhbHVlICksXG5cdFx0XHRcdHBsdXJhbEdlbmVyYXRvciggdmFsdWUgKSxcblx0XHRcdFx0cHJvcGVydGllc1xuXHRcdFx0KTtcblx0XHR9O1xuXG5cdC8vIFJldHVybiBmb3JtYXR0ZXIgd2hlbiBzdHlsZSBpcyBcInN5bWJvbFwiIG9yIFwiYWNjb3VudGluZ1wiLlxuXHR9IGVsc2Uge1xuXHRcdGZuID0gZnVuY3Rpb24gY3VycmVuY3lGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIG51bWJlckZvcm1hdHRlciggdmFsdWUgKTtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGZuO1xufTtcblxuXG5cblxuLyoqXG4gKiBuYW1lUHJvcGVydGllcyggY3VycmVuY3ksIGNsZHIgKVxuICpcbiAqIFJldHVybiBudW1iZXIgcGF0dGVybiB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjdXJyZW5jeSBjb2RlIGluIGFzIGxpdGVyYWwuXG4gKi9cbnZhciBjdXJyZW5jeU5hbWVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBjbGRyICkge1xuXHR2YXIgcHJvcGVydGllcyA9IGN1cnJlbmN5Q29kZVByb3BlcnRpZXMoIGN1cnJlbmN5LCBjbGRyICk7XG5cblx0cHJvcGVydGllcy5kaXNwbGF5TmFtZXMgPSBvYmplY3RGaWx0ZXIoIGNsZHIubWFpbihbXG5cdFx0XCJudW1iZXJzL2N1cnJlbmNpZXNcIixcblx0XHRjdXJyZW5jeVxuXHRdKSwgL15kaXNwbGF5TmFtZS8gKTtcblxuXHRyZXR1cm4gcHJvcGVydGllcztcbn07XG5cblxuXG5cbi8qKlxuICogVW5pY29kZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yOiBldmVyeXRoaW5nIGV4Y2VwdCBtYXRoIHN5bWJvbHMsIGN1cnJlbmN5IHNpZ25zLCBkaW5nYmF0cywgYW5kXG4gKiBib3gtZHJhd2luZyBjaGFyYWN0ZXJzLlxuICpcbiAqIEdlbmVyYXRlZCBieTpcbiAqXG4gKiByZWdlbmVyYXRlKClcbiAqICAgLmFkZFJhbmdlKCAweDAsIDB4MTBGRkZGIClcbiAqICAgLnJlbW92ZSggcmVxdWlyZSggXCJ1bmljb2RlLTcuMC4wL2NhdGVnb3JpZXMvUy9zeW1ib2xzXCIgKSApLnRvU3RyaW5nKCk7XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvcmVnZW5lcmF0ZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvdW5pY29kZS03LjAuMFxuICovXG52YXIgcmVnZXhwTm90UyA9IC9bXFwwLSMlLVxcKiwtO1xcPy1cXF1fYS1cXHtcXH1cXHg3Ri1cXHhBMVxceEE3XFx4QUFcXHhBQlxceEFEXFx4QjJcXHhCM1xceEI1LVxceEI3XFx4QjktXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzYtXFx1MDM4M1xcdTAzODYtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDU4Q1xcdTA1OTAtXFx1MDYwNVxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjEwLVxcdTA2RERcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGLVxcdTA3RjVcXHUwN0Y3LVxcdTA5RjFcXHUwOUY0LVxcdTA5RjlcXHUwOUZDLVxcdTBBRjBcXHUwQUYyLVxcdTBCNkZcXHUwQjcxLVxcdTBCRjJcXHUwQkZCLVxcdTBDN0VcXHUwQzgwLVxcdTBENzhcXHUwRDdBLVxcdTBFM0VcXHUwRTQwLVxcdTBGMDBcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMzNcXHUwRjM1XFx1MEYzN1xcdTBGMzktXFx1MEZCRFxcdTBGQzZcXHUwRkNEXFx1MEZEMC1cXHUwRkQ0XFx1MEZEOS1cXHUxMDlEXFx1MTBBMC1cXHUxMzhGXFx1MTM5QS1cXHUxN0RBXFx1MTdEQy1cXHUxOTNGXFx1MTk0MS1cXHUxOUREXFx1MUEwMC1cXHUxQjYwXFx1MUI2Qi1cXHUxQjczXFx1MUI3RC1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDQ1xcdTFGRDAtXFx1MUZEQ1xcdTFGRTAtXFx1MUZFQ1xcdTFGRjAtXFx1MUZGQ1xcdTFGRkYtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA3OVxcdTIwN0QtXFx1MjA4OVxcdTIwOEQtXFx1MjA5RlxcdTIwQkUtXFx1MjBGRlxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTUwLVxcdTIxOEZcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTIzRkItXFx1MjNGRlxcdTI0MjctXFx1MjQzRlxcdTI0NEItXFx1MjQ5QlxcdTI0RUEtXFx1MjRGRlxcdTI3NjgtXFx1Mjc5M1xcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQjc0XFx1MkI3NVxcdTJCOTZcXHUyQjk3XFx1MkJCQS1cXHUyQkJDXFx1MkJDOVxcdTJCRDItXFx1MkNFNFxcdTJDRUItXFx1MkU3RlxcdTJFOUFcXHUyRUY0LVxcdTJFRkZcXHUyRkQ2LVxcdTJGRUZcXHUyRkZDLVxcdTMwMDNcXHUzMDA1LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDIxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0RcXHUzMDQwLVxcdTMwOUFcXHUzMDlELVxcdTMxOEZcXHUzMTkyLVxcdTMxOTVcXHUzMUEwLVxcdTMxQkZcXHUzMUU0LVxcdTMxRkZcXHUzMjFGLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHUzMkZGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHVBNDhGXFx1QTRDNy1cXHVBNkZGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBODI3XFx1QTgyQy1cXHVBODM1XFx1QTgzQS1cXHVBQTc2XFx1QUE3QS1cXHVBQjVBXFx1QUI1Qy1cXHVEN0ZGXFx1REMwMC1cXHVGQjI4XFx1RkIyQS1cXHVGQkIxXFx1RkJDMi1cXHVGREZCXFx1RkRGRS1cXHVGRTYxXFx1RkU2M1xcdUZFNjdcXHVGRTY4XFx1RkU2QS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjFCXFx1RkYxRi1cXHVGRjNEXFx1RkYzRlxcdUZGNDEtXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGREZcXHVGRkU3XFx1RkZFRi1cXHVGRkZCXFx1RkZGRVxcdUZGRkZdfFxcdUQ4MDBbXFx1REMwMC1cXHVERDM2XFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERDhELVxcdUREOEZcXHVERDlDLVxcdUREOUZcXHVEREExLVxcdUREQ0ZcXHVEREZELVxcdURGRkZdfFtcXHVEODAxXFx1RDgwMy1cXHVEODE5XFx1RDgxQi1cXHVEODJFXFx1RDgzMC1cXHVEODMzXFx1RDgzNi1cXHVEODNBXFx1RDgzRi1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzc2XFx1REM3OS1cXHVERUM3XFx1REVDOS1cXHVERkZGXXxcXHVEODFBW1xcdURDMDAtXFx1REYzQlxcdURGNDAtXFx1REY0NFxcdURGNDYtXFx1REZGRl18XFx1RDgyRltcXHVEQzAwLVxcdURDOUJcXHVEQzlELVxcdURGRkZdfFxcdUQ4MzRbXFx1RENGNi1cXHVEQ0ZGXFx1REQyN1xcdUREMjhcXHVERDY1LVxcdURENjlcXHVERDZELVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERERFLVxcdURERkZcXHVERTQyLVxcdURFNDRcXHVERTQ2LVxcdURFRkZcXHVERjU3LVxcdURGRkZdfFxcdUQ4MzVbXFx1REMwMC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkZGXXxcXHVEODNCW1xcdURDMDAtXFx1REVFRlxcdURFRjItXFx1REZGRl18XFx1RDgzQ1tcXHVEQzJDLVxcdURDMkZcXHVEQzk0LVxcdURDOUZcXHVEQ0FGXFx1RENCMFxcdURDQzBcXHVEQ0QwXFx1RENGNi1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ2RlxcdUREOUItXFx1RERFNVxcdURFMDMtXFx1REUwRlxcdURFM0ItXFx1REUzRlxcdURFNDktXFx1REU0RlxcdURFNTItXFx1REVGRlxcdURGMkQtXFx1REYyRlxcdURGN0VcXHVERjdGXFx1REZDRi1cXHVERkQzXFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDRkZcXHVERDRCLVxcdURENEZcXHVERDdBXFx1RERBNFxcdURFNDNcXHVERTQ0XFx1REVEMC1cXHVERURGXFx1REVFRC1cXHVERUVGXFx1REVGNC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0vO1xuXG5cblxuXG4vKipcbiAqIHN5bWJvbFByb3BlcnRpZXMoIGN1cnJlbmN5LCBjbGRyIClcbiAqXG4gKiBSZXR1cm4gcGF0dGVybiByZXBsYWNpbmcgYMKkYCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjdXJyZW5jeSBzeW1ib2wgbGl0ZXJhbC5cbiAqL1xudmFyIGN1cnJlbmN5U3ltYm9sUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgY2xkciwgb3B0aW9ucyApIHtcblx0dmFyIGN1cnJlbmN5U3BhY2luZywgcGF0dGVybixcblx0XHRyZWdleHAgPSB7XG5cdFx0XHRcIls6ZGlnaXQ6XVwiOiAvXFxkLyxcblx0XHRcdFwiWzpeUzpdXCI6IHJlZ2V4cE5vdFNcblx0XHR9LFxuXHRcdHN5bWJvbCA9IGNsZHIubWFpbihbXG5cdFx0XHRcIm51bWJlcnMvY3VycmVuY2llc1wiLFxuXHRcdFx0Y3VycmVuY3ksXG5cdFx0XHRcInN5bWJvbFwiXG5cdFx0XSk7XG5cblx0Y3VycmVuY3lTcGFjaW5nID0gWyBcImJlZm9yZUN1cnJlbmN5XCIsIFwiYWZ0ZXJDdXJyZW5jeVwiIF0ubWFwKGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcblx0XHRyZXR1cm4gY2xkci5tYWluKFtcblx0XHRcdFwibnVtYmVyc1wiLFxuXHRcdFx0XCJjdXJyZW5jeUZvcm1hdHMtbnVtYmVyU3lzdGVtLVwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICksXG5cdFx0XHRcImN1cnJlbmN5U3BhY2luZ1wiLFxuXHRcdFx0cG9zaXRpb25cblx0XHRdKTtcblx0fSk7XG5cblx0cGF0dGVybiA9IGNsZHIubWFpbihbXG5cdFx0XCJudW1iZXJzXCIsXG5cdFx0XCJjdXJyZW5jeUZvcm1hdHMtbnVtYmVyU3lzdGVtLVwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICksXG5cdFx0b3B0aW9ucy5zdHlsZSA9PT0gXCJhY2NvdW50aW5nXCIgPyBcImFjY291bnRpbmdcIiA6IFwic3RhbmRhcmRcIlxuXHRdKTtcblxuXHRwYXR0ZXJuID1cblxuXHRcdC8vIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYW5kIHRoZSByb3VuZGluZyBmb3IgZWFjaCBjdXJyZW5jeSBpcyBub3QgbG9jYWxlLXNwZWNpZmljLlxuXHRcdC8vIFRob3NlIHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSBTdXBwbGVtZW50YWwgQ3VycmVuY3kgRGF0YS5cblx0XHRjdXJyZW5jeVN1cHBsZW1lbnRhbE92ZXJyaWRlKCBjdXJyZW5jeSwgcGF0dGVybiwgY2xkciApXG5cblx0XHQvLyBSZXBsYWNlIFwiwqRcIiAoXFx1MDBBNCkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgc3ltYm9sIGxpdGVyYWwuXG5cdFx0LnNwbGl0KCBcIjtcIiApLm1hcChmdW5jdGlvbiggcGF0dGVybiApIHtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4uc3BsaXQoIFwiXFx1MDBBNFwiICkubWFwKGZ1bmN0aW9uKCBwYXJ0LCBpICkge1xuXHRcdFx0XHR2YXIgY3VycmVuY3lNYXRjaCA9IHJlZ2V4cFsgY3VycmVuY3lTcGFjaW5nWyBpIF0uY3VycmVuY3lNYXRjaCBdLFxuXHRcdFx0XHRcdHN1cnJvdW5kaW5nTWF0Y2ggPSByZWdleHBbIGN1cnJlbmN5U3BhY2luZ1sgaSBdLnN1cnJvdW5kaW5nTWF0Y2ggXSxcblx0XHRcdFx0XHRpbnNlcnRCZXR3ZWVuID0gXCJcIjtcblxuXHRcdFx0XHQvLyBGb3IgY3VycmVuY3lNYXRjaCBhbmQgc3Vycm91bmRpbmdNYXRjaCBkZWZpbml0aW9ucywgcmVhZCBbMV0uXG5cdFx0XHRcdC8vIFdoZW4gaSA9PT0gMCwgYmVmb3JlQ3VycmVuY3kgaXMgYmVpbmcgaGFuZGxlZC4gT3RoZXJ3aXNlLCBhZnRlckN1cnJlbmN5LlxuXHRcdFx0XHQvLyAxOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbCNDdXJyZW5jaWVzXG5cdFx0XHRcdGN1cnJlbmN5TWF0Y2ggPSBjdXJyZW5jeU1hdGNoLnRlc3QoIHN5bWJvbC5jaGFyQXQoIGkgPyBzeW1ib2wubGVuZ3RoIC0gMSA6IDAgKSApO1xuXHRcdFx0XHRzdXJyb3VuZGluZ01hdGNoID0gc3Vycm91bmRpbmdNYXRjaC50ZXN0KFxuXHRcdFx0XHRcdHBhcnQuY2hhckF0KCBpID8gMCA6IHBhcnQubGVuZ3RoIC0gMSApLnJlcGxhY2UoIC9bI0AsLl0vZywgXCIwXCIgKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VycmVuY3lNYXRjaCAmJiBwYXJ0ICYmIHN1cnJvdW5kaW5nTWF0Y2ggKSB7XG5cdFx0XHRcdFx0aW5zZXJ0QmV0d2VlbiA9IGN1cnJlbmN5U3BhY2luZ1sgaSBdLmluc2VydEJldHdlZW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gKCBpID8gaW5zZXJ0QmV0d2VlbiA6IFwiXCIgKSArIHBhcnQgKyAoIGkgPyBcIlwiIDogaW5zZXJ0QmV0d2VlbiApO1xuXHRcdFx0fSkuam9pbiggXCInXCIgKyBzeW1ib2wgKyBcIidcIiApO1xuXHRcdH0pLmpvaW4oIFwiO1wiICk7XG5cblx0cmV0dXJuIHtcblx0XHRwYXR0ZXJuOiBwYXR0ZXJuXG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIG9iamVjdE9taXQoIG9iamVjdCwga2V5cyApXG4gKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0LCBmaWx0ZXJlZCB0byBvbWl0IHRoZSBibGFja2xpc3RlZCBrZXkgb3IgYXJyYXkgb2Yga2V5cy5cbiAqL1xudmFyIG9iamVjdE9taXQgPSBmdW5jdGlvbiggb2JqZWN0LCBrZXlzICkge1xuXHR2YXIga2V5LFxuXHRcdGNvcHkgPSB7fTtcblxuXHRrZXlzID0gYWx3YXlzQXJyYXkoIGtleXMgKTtcblxuXHRmb3IgKCBrZXkgaW4gb2JqZWN0ICkge1xuXHRcdGlmICgga2V5cy5pbmRleE9mKCBrZXkgKSA9PT0gLTEgKSB7XG5cdFx0XHRjb3B5WyBrZXkgXSA9IG9iamVjdFsga2V5IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvcHk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkQ2xkciggcGF0aCwgdmFsdWUgKSB7XG5cdHZhbGlkYXRlQ2xkciggcGF0aCwgdmFsdWUsIHtcblx0XHRza2lwOiBbIC9zdXBwbGVtZW50YWxcXC9jdXJyZW5jeURhdGFcXC9mcmFjdGlvbnNcXC9bQS1aYS16XXszfSQvIF1cblx0fSk7XG59XG5cbi8qKlxuICogLmN1cnJlbmN5Rm9ybWF0dGVyKCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXG4gKlxuICogQGN1cnJlbmN5IFtTdHJpbmddIDMtbGV0dGVyIGN1cnJlbmN5IGNvZGUgYXMgZGVmaW5lZCBieSBJU08gNDIxNy5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTpcbiAqIC0gc3R5bGU6IFtTdHJpbmddIFwic3ltYm9sXCIgKGRlZmF1bHQpLCBcImFjY291bnRpbmdcIiwgXCJjb2RlXCIgb3IgXCJuYW1lXCIuXG4gKiAtIHNlZSBhbHNvIG51bWJlci9mb3JtYXQgb3B0aW9ucy5cbiAqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBjdXJyZW5jeSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIGRlZmF1bHQvaW5zdGFuY2VcbiAqIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmN1cnJlbmN5Rm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuY3VycmVuY3lGb3JtYXR0ZXIgPSBmdW5jdGlvbiggY3VycmVuY3ksIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcywgcmV0dXJuRm4sIHN0eWxlO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIGN1cnJlbmN5LCBcImN1cnJlbmN5XCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlQ3VycmVuY3koIGN1cnJlbmN5LCBcImN1cnJlbmN5XCIgKTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRjbGRyID0gdGhpcy5jbGRyO1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRhcmdzID0gWyBjdXJyZW5jeSwgb3B0aW9ucyBdO1xuXHRzdHlsZSA9IG9wdGlvbnMuc3R5bGUgfHwgXCJzeW1ib2xcIjtcblxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHQvLyBHZXQgcHJvcGVydGllcyBnaXZlbiBzdHlsZSAoXCJzeW1ib2xcIiBkZWZhdWx0LCBcImNvZGVcIiBvciBcIm5hbWVcIikuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XG5cdHByb3BlcnRpZXMgPSAoe1xuXHRcdGFjY291bnRpbmc6IGN1cnJlbmN5U3ltYm9sUHJvcGVydGllcyxcblx0XHRjb2RlOiBjdXJyZW5jeUNvZGVQcm9wZXJ0aWVzLFxuXHRcdG5hbWU6IGN1cnJlbmN5TmFtZVByb3BlcnRpZXMsXG5cdFx0c3ltYm9sOiBjdXJyZW5jeVN5bWJvbFByb3BlcnRpZXNcblx0fVsgc3R5bGUgXSApKCBjdXJyZW5jeSwgY2xkciwgb3B0aW9ucyApO1xuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcblxuXHQvLyBvcHRpb25zID0gb3B0aW9ucyBtaW51cyBzdHlsZSwgcGx1cyByYXcgcGF0dGVybi5cblx0b3B0aW9ucyA9IG9iamVjdE9taXQoIG9wdGlvbnMsIFwic3R5bGVcIiApO1xuXHRvcHRpb25zLnJhdyA9IHByb3BlcnRpZXMucGF0dGVybjtcblxuXHQvLyBSZXR1cm4gZm9ybWF0dGVyIHdoZW4gc3R5bGUgaXMgXCJzeW1ib2xcIiBvciBcImFjY291bnRpbmdcIi5cblx0aWYgKCBzdHlsZSA9PT0gXCJzeW1ib2xcIiB8fCBzdHlsZSA9PT0gXCJhY2NvdW50aW5nXCIgKSB7XG5cdFx0bnVtYmVyRm9ybWF0dGVyID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybkZuID0gY3VycmVuY3lGb3JtYXR0ZXJGbiggbnVtYmVyRm9ybWF0dGVyICk7XG5cblx0XHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyRm9ybWF0dGVyIF0gKTtcblxuXHQvLyBSZXR1cm4gZm9ybWF0dGVyIHdoZW4gc3R5bGUgaXMgXCJjb2RlXCIgb3IgXCJuYW1lXCIuXG5cdH0gZWxzZSB7XG5cdFx0bnVtYmVyRm9ybWF0dGVyID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIoIG9wdGlvbnMgKTtcblx0XHRwbHVyYWxHZW5lcmF0b3IgPSB0aGlzLnBsdXJhbEdlbmVyYXRvcigpO1xuXG5cdFx0cmV0dXJuRm4gPSBjdXJyZW5jeUZvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApO1xuXG5cdFx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzIF0gKTtcblx0fVxuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLmN1cnJlbmN5UGFyc2VyKCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXG4gKlxuICogQGN1cnJlbmN5IFtTdHJpbmddIDMtbGV0dGVyIGN1cnJlbmN5IGNvZGUgYXMgZGVmaW5lZCBieSBJU08gNDIxNy5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgY3VycmVuY3lGb3JtYXR0ZXIuXG4gKlxuICogUmV0dXJuIHRoZSBjdXJyZW5jeSBwYXJzZXIgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5jdXJyZW5jeVBhcnNlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLmN1cnJlbmN5UGFyc2VyID0gZnVuY3Rpb24oIC8qIGN1cnJlbmN5LCBvcHRpb25zICovICkge1xuXG5cdC8vIFRPRE8gaW1wbGVtZW50IHBhcnNlci5cblxufTtcblxuLyoqXG4gKiAuZm9ybWF0Q3VycmVuY3koIHZhbHVlLCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdIG51bWJlciB0byBiZSBmb3JtYXR0ZWQuXG4gKlxuICogQGN1cnJlbmN5IFtTdHJpbmddIDMtbGV0dGVyIGN1cnJlbmN5IGNvZGUgYXMgZGVmaW5lZCBieSBJU08gNDIxNy5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgY3VycmVuY3lGb3JtYXR0ZXIuXG4gKlxuICogRm9ybWF0IGEgY3VycmVuY3kgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXRDdXJyZW5jeSA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdEN1cnJlbmN5ID0gZnVuY3Rpb24oIHZhbHVlLCBjdXJyZW5jeSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5jdXJyZW5jeUZvcm1hdHRlciggY3VycmVuY3ksIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogLnBhcnNlQ3VycmVuY3koIHZhbHVlLCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXG4gKlxuICogQHZhbHVlIFtTdHJpbmddXG4gKlxuICogQGN1cnJlbmN5IFtTdHJpbmddIDMtbGV0dGVyIGN1cnJlbmN5IGNvZGUgYXMgZGVmaW5lZCBieSBJU08gNDIxNy5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTogU2VlIGN1cnJlbmN5Rm9ybWF0dGVyLlxuICpcbiAqIFJldHVybiB0aGUgcGFyc2VkIGN1cnJlbmN5IG9yIE5hTiB3aGVuIHZhbHVlIGlzIGludmFsaWQuXG4gKi9cbkdsb2JhbGl6ZS5wYXJzZUN1cnJlbmN5ID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUucGFyc2VDdXJyZW5jeSA9IGZ1bmN0aW9uKCAvKiB2YWx1ZSwgY3VycmVuY3ksIG9wdGlvbnMgKi8gKSB7XG59O1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9jdXJyZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2N1cnJlbmN5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcIi4vbnVtYmVyXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIixcblx0XHRcdFwiY2xkci9zdXBwbGVtZW50YWxcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEV4dGVuZCBnbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIGNyZWF0ZUVycm9yID0gR2xvYmFsaXplLl9jcmVhdGVFcnJvcixcblx0Y3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUgPSBHbG9iYWxpemUuX2NyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlLFxuXHRmb3JtYXRNZXNzYWdlID0gR2xvYmFsaXplLl9mb3JtYXRNZXNzYWdlLFxuXHRpc1BsYWluT2JqZWN0ID0gR2xvYmFsaXplLl9pc1BsYWluT2JqZWN0LFxuXHRsb29zZU1hdGNoaW5nID0gR2xvYmFsaXplLl9sb29zZU1hdGNoaW5nLFxuXHRudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAgPSBHbG9iYWxpemUuX251bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCxcblx0bnVtYmVyU3ltYm9sID0gR2xvYmFsaXplLl9udW1iZXJTeW1ib2wsXG5cdHJlZ2V4cEVzY2FwZSA9IEdsb2JhbGl6ZS5fcmVnZXhwRXNjYXBlLFxuXHRyZW1vdmVMaXRlcmFsUXVvdGVzID0gR2xvYmFsaXplLl9yZW1vdmVMaXRlcmFsUXVvdGVzLFxuXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHN0cmluZ1BhZCA9IEdsb2JhbGl6ZS5fc3RyaW5nUGFkLFxuXHR2YWxpZGF0ZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGUsXG5cdHZhbGlkYXRlQ2xkciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyLFxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmc7XG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZURhdGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSggdmFsdWUsIG5hbWUsIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlLCBcIkRhdGVcIiApO1xufTtcblxuXG5cblxudmFyIGNyZWF0ZUVycm9ySW52YWxpZFBhcmFtZXRlclZhbHVlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRyZXR1cm4gY3JlYXRlRXJyb3IoIFwiRV9JTlZBTElEX1BBUl9WQUxVRVwiLCBcIkludmFsaWQgYHtuYW1lfWAgdmFsdWUgKHt2YWx1ZX0pLlwiLCB7XG5cdFx0bmFtZTogbmFtZSxcblx0XHR2YWx1ZTogdmFsdWVcblx0fSk7XG59O1xuXG5cblxuXG4vKipcbiAqIENyZWF0ZSBhIG1hcCBiZXR3ZWVuIHRoZSBza2VsZXRvbiBmaWVsZHMgYW5kIHRoZWlyIHBvc2l0aW9ucywgZS5nLixcbiAqIHtcbiAqICAgRzogMFxuICogICB5OiAxXG4gKiAgIC4uLlxuICogfVxuICovXG52YXIgdmFsaWRhdGVTa2VsZXRvbkZpZWxkc1Bvc01hcCA9IFwiR3lZdVVyUXFNTGx3V0VlY2RERmdoSEtrbXNTQXpaT3ZWWHhcIi5zcGxpdCggXCJcIiApLnJlZHVjZShmdW5jdGlvbiggbWVtbywgaXRlbSwgaSApIHtcblx0bWVtb1sgaXRlbSBdID0gaTtcblx0cmV0dXJuIG1lbW87XG59LCB7fSk7XG5cblxuXG5cbi8qKlxuICogdmFsaWRhdGVTa2VsZXRvbiggc2tlbGV0b24gKVxuICpcbiAqIHNrZWxldG9uOiBBc3N1bWUgYGpgIGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkIGludG8gYSBsb2NhbGl6ZWQgaG91ciBmaWVsZC5cbiAqL1xudmFyIHZhbGlkYXRlU2tlbGV0b24gPSBmdW5jdGlvbiB2YWxpZGF0ZVNrZWxldG9uKCBza2VsZXRvbiApIHtcblx0dmFyIGxhc3QsXG5cblx0XHQvLyBVc2luZyBlYXNpZXIgdG8gcmVhZCB2YXJpYWJsZS5cblx0XHRmaWVsZHNQb3NNYXAgPSB2YWxpZGF0ZVNrZWxldG9uRmllbGRzUG9zTWFwO1xuXG5cdC8vIFwiVGhlIGZpZWxkcyBhcmUgZnJvbSB0aGUgRGF0ZSBGaWVsZCBTeW1ib2wgVGFibGUgaW4gRGF0ZSBGb3JtYXQgUGF0dGVybnNcIlxuXHQvLyBSZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNhdmFpbGFibGVGb3JtYXRzX2FwcGVuZEl0ZW1zXG5cdC8vIEkuZS4sIGNoZWNrIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG5cdHNrZWxldG9uLnJlcGxhY2UoIC9bXkd5WXVVclFxTUxsd1dFZWNkREZnaEhLa21zU0F6Wk92Vlh4XS8sIGZ1bmN0aW9uKCBmaWVsZCApIHtcblx0XHR0aHJvdyBjcmVhdGVFcnJvcihcblx0XHRcdFwiRV9JTlZBTElEX09QVElPTlNcIiwgXCJJbnZhbGlkIGZpZWxkIGB7aW52YWxpZEZpZWxkfWAgb2Ygc2tlbGV0b24gYHt2YWx1ZX1gXCIsXG5cdFx0XHR7XG5cdFx0XHRcdGludmFsaWRGaWVsZDogZmllbGQsXG5cdFx0XHRcdHR5cGU6IFwic2tlbGV0b25cIixcblx0XHRcdFx0dmFsdWU6IHNrZWxldG9uXG5cdFx0XHR9XG5cdFx0KTtcblx0fSk7XG5cblx0Ly8gXCJUaGUgY2Fub25pY2FsIG9yZGVyIGlzIGZyb20gdG9wIHRvIGJvdHRvbSBpbiB0aGF0IHRhYmxlOyB0aGF0IGlzLCB5TSBub3QgTXlcIi5cblx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI2F2YWlsYWJsZUZvcm1hdHNfYXBwZW5kSXRlbXNcblx0Ly8gSS5lLiwgY2hlY2sgZm9yIGludmFsaWQgb3JkZXIuXG5cdHNrZWxldG9uLnNwbGl0KCBcIlwiICkuZXZlcnkoZnVuY3Rpb24oIGZpZWxkICkge1xuXHRcdGlmICggZmllbGRzUG9zTWFwWyBmaWVsZCBdIDwgbGFzdCApIHtcblx0XHRcdHRocm93IGNyZWF0ZUVycm9yKFxuXHRcdFx0XHRcIkVfSU5WQUxJRF9PUFRJT05TXCIsIFwiSW52YWxpZCBvcmRlciBge2ludmFsaWRGaWVsZH1gIG9mIHNrZWxldG9uIGB7dmFsdWV9YFwiLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW52YWxpZEZpZWxkOiBmaWVsZCxcblx0XHRcdFx0XHR0eXBlOiBcInNrZWxldG9uXCIsXG5cdFx0XHRcdFx0dmFsdWU6IHNrZWxldG9uXG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGxhc3QgPSBmaWVsZHNQb3NNYXBbIGZpZWxkIF07XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xufTtcblxuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCBjcmVhdGVkIGJ5IHVzaW5nIGBvYmplY3RgJ3MgdmFsdWVzIGFzIGtleXMsIGFuZCB0aGUga2V5cyBhcyB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RJbnZlcnQgPSBmdW5jdGlvbiggb2JqZWN0LCBmbiApIHtcblx0Zm4gPSBmbiB8fCBmdW5jdGlvbiggb2JqZWN0LCBrZXksIHZhbHVlICkge1xuXHRcdG9iamVjdFsgdmFsdWUgXSA9IGtleTtcblx0XHRyZXR1cm4gb2JqZWN0O1xuXHR9O1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoIG9iamVjdCApLnJlZHVjZShmdW5jdGlvbiggbmV3T2JqZWN0LCBrZXkgKSB7XG5cdFx0cmV0dXJuIGZuKCBuZXdPYmplY3QsIGtleSwgb2JqZWN0WyBrZXkgXSApO1xuXHR9LCB7fSk7XG59O1xuXG5cblxuXG4vLyBJbnZlcnQga2V5IGFuZCB2YWx1ZXMsIGUuZy4sIHtcImVcIjogXCJlRWNcIn0gPT0+IHtcImVcIjogXCJlXCIsIFwiRVwiOiBcImVcIiwgXCJjXCI6IFwiZVwifS5cbnZhciBkYXRlRXhwYW5kUGF0dGVyblNpbWlsYXJGaWVsZHNNYXAgPSBvYmplY3RJbnZlcnQoe1xuXHRcImVcIjogXCJlRWNcIixcblx0XCJMXCI6IFwiTUxcIlxufSwgZnVuY3Rpb24oIG9iamVjdCwga2V5LCB2YWx1ZSApIHtcblx0dmFsdWUuc3BsaXQoIFwiXCIgKS5mb3JFYWNoKGZ1bmN0aW9uKCBmaWVsZCApIHtcblx0XHRvYmplY3RbIGZpZWxkIF0gPSBrZXk7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufSk7XG5cblxuXG5cbnZhciBkYXRlRXhwYW5kUGF0dGVybk5vcm1hbGl6ZVBhdHRlcm5UeXBlID0gZnVuY3Rpb24oIGNoYXJhY3RlciApIHtcblx0cmV0dXJuIGRhdGVFeHBhbmRQYXR0ZXJuU2ltaWxhckZpZWxkc01hcFsgY2hhcmFjdGVyIF0gfHwgY2hhcmFjdGVyO1xufTtcblxuXG5cblxudmFyIGRhdGVQYXR0ZXJuUmUgPSAoIC8oW2Etel0pXFwxKnwnKFteJ118JycpKyd8Jyd8Li9pZyApO1xuXG5cblxuXG52YXIgc3RyaW5nUmVwZWF0ID0gZnVuY3Rpb24oIHN0ciwgY291bnQgKSB7XG5cdHZhciBpLCByZXN1bHQgPSBcIlwiO1xuXHRmb3IgKCBpID0gMDsgaSA8IGNvdW50OyBpKysgKSB7XG5cdFx0cmVzdWx0ID0gcmVzdWx0ICsgc3RyO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm5BdWdtZW50Rm9ybWF0ID0gZnVuY3Rpb24oIHJlcXVlc3RlZFNrZWxldG9uLCBiZXN0TWF0Y2hGb3JtYXQgKSB7XG5cdHZhciBpLCBqLCBtYXRjaGVkVHlwZSwgbWF0Y2hlZExlbmd0aCwgcmVxdWVzdGVkVHlwZSwgcmVxdWVzdGVkTGVuZ3RoLFxuXG5cdFx0Ly8gVXNpbmcgYW4gZWFzaWVyIHRvIHJlYWQgdmFyaWFibGUuXG5cdFx0bm9ybWFsaXplUGF0dGVyblR5cGUgPSBkYXRlRXhwYW5kUGF0dGVybk5vcm1hbGl6ZVBhdHRlcm5UeXBlO1xuXG5cdHJlcXVlc3RlZFNrZWxldG9uID0gcmVxdWVzdGVkU2tlbGV0b24ubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKTtcblx0YmVzdE1hdGNoRm9ybWF0ID0gYmVzdE1hdGNoRm9ybWF0Lm1hdGNoKCBkYXRlUGF0dGVyblJlICk7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBiZXN0TWF0Y2hGb3JtYXQubGVuZ3RoOyBpKysgKSB7XG5cdFx0bWF0Y2hlZFR5cGUgPSBiZXN0TWF0Y2hGb3JtYXRbaV0uY2hhckF0KCAwICk7XG5cdFx0bWF0Y2hlZExlbmd0aCA9IGJlc3RNYXRjaEZvcm1hdFtpXS5sZW5ndGg7XG5cdFx0Zm9yICggaiA9IDA7IGogPCByZXF1ZXN0ZWRTa2VsZXRvbi5sZW5ndGg7IGorKyApIHtcblx0XHRcdHJlcXVlc3RlZFR5cGUgPSByZXF1ZXN0ZWRTa2VsZXRvbltqXS5jaGFyQXQoIDAgKTtcblx0XHRcdHJlcXVlc3RlZExlbmd0aCA9IHJlcXVlc3RlZFNrZWxldG9uW2pdLmxlbmd0aDtcblx0XHRcdGlmICggbm9ybWFsaXplUGF0dGVyblR5cGUoIG1hdGNoZWRUeXBlICkgPT09IG5vcm1hbGl6ZVBhdHRlcm5UeXBlKCByZXF1ZXN0ZWRUeXBlICkgJiZcblx0XHRcdFx0bWF0Y2hlZExlbmd0aCA8IHJlcXVlc3RlZExlbmd0aFxuXHRcdFx0KSB7XG5cdFx0XHRcdGJlc3RNYXRjaEZvcm1hdFtpXSA9IHN0cmluZ1JlcGVhdCggbWF0Y2hlZFR5cGUsIHJlcXVlc3RlZExlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBiZXN0TWF0Y2hGb3JtYXQuam9pbiggXCJcIiApO1xufTtcblxuXG5cblxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuQ29tcGFyZUZvcm1hdHMgPSBmdW5jdGlvbiggZm9ybWF0QSwgZm9ybWF0QiApIHtcblx0dmFyIGEsIGIsIGRpc3RhbmNlLCBsZW5BLCBsZW5CLCB0eXBlQSwgdHlwZUIsIGksIGosXG5cblx0XHQvLyBVc2luZyBlYXNpZXIgdG8gcmVhZCB2YXJpYWJsZXMuXG5cdFx0bm9ybWFsaXplUGF0dGVyblR5cGUgPSBkYXRlRXhwYW5kUGF0dGVybk5vcm1hbGl6ZVBhdHRlcm5UeXBlO1xuXG5cdGlmICggZm9ybWF0QSA9PT0gZm9ybWF0QiApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvcm1hdEEgPSBmb3JtYXRBLm1hdGNoKCBkYXRlUGF0dGVyblJlICk7XG5cdGZvcm1hdEIgPSBmb3JtYXRCLm1hdGNoKCBkYXRlUGF0dGVyblJlICk7XG5cblx0aWYgKCBmb3JtYXRBLmxlbmd0aCAhPT0gZm9ybWF0Qi5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0ZGlzdGFuY2UgPSAxO1xuXHRmb3IgKCBpID0gMDsgaSA8IGZvcm1hdEEubGVuZ3RoOyBpKysgKSB7XG5cdFx0YSA9IGZvcm1hdEFbIGkgXS5jaGFyQXQoIDAgKTtcblx0XHR0eXBlQSA9IG5vcm1hbGl6ZVBhdHRlcm5UeXBlKCBhICk7XG5cdFx0dHlwZUIgPSBudWxsO1xuXHRcdGZvciAoIGogPSAwOyBqIDwgZm9ybWF0Qi5sZW5ndGg7IGorKyApIHtcblx0XHRcdGIgPSBmb3JtYXRCWyBqIF0uY2hhckF0KCAwICk7XG5cdFx0XHR0eXBlQiA9IG5vcm1hbGl6ZVBhdHRlcm5UeXBlKCBiICk7XG5cdFx0XHRpZiAoIHR5cGVBID09PSB0eXBlQiApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlQiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggdHlwZUIgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGxlbkEgPSBmb3JtYXRBWyBpIF0ubGVuZ3RoO1xuXHRcdGxlbkIgPSBmb3JtYXRCWyBqIF0ubGVuZ3RoO1xuXHRcdGRpc3RhbmNlID0gZGlzdGFuY2UgKyBNYXRoLmFicyggbGVuQSAtIGxlbkIgKTtcblxuXHRcdC8vIE1vc3Qgc3ltYm9scyBoYXZlIGEgc21hbGwgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLCBlLmcuLCBNIOKJhSBMOyBFIOKJhSBjOyBhIOKJhSBiIOKJhSBCO1xuXHRcdC8vIEgg4omFIGsg4omFIGgg4omFIEs7IC4uLlxuXHRcdGlmICggYSAhPT0gYiApIHtcblx0XHRcdGRpc3RhbmNlICs9IDE7XG5cdFx0fVxuXG5cdFx0Ly8gTnVtZXJpYyAobDwzKSBhbmQgdGV4dCBmaWVsZHMgKGw+PTMpIGFyZSBnaXZlbiBhIGxhcmdlciBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuXG5cdFx0aWYgKCAoIGxlbkEgPCAzICYmIGxlbkIgPj0gMyApIHx8ICggbGVuQSA+PSAzICYmIGxlbkIgPCAzICkgKSB7XG5cdFx0XHRkaXN0YW5jZSArPSAyMDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRpc3RhbmNlO1xufTtcblxuXG5cblxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuR2V0QmVzdE1hdGNoUGF0dGVybiA9IGZ1bmN0aW9uKCBjbGRyLCBhc2tlZFNrZWxldG9uICkge1xuXHR2YXIgYXZhaWxhYmxlRm9ybWF0cywgcGF0dGVybiwgcmF0ZWRGb3JtYXRzLCBza2VsZXRvbixcblx0XHRwYXRoID0gXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RhdGVUaW1lRm9ybWF0cy9hdmFpbGFibGVGb3JtYXRzXCIsXG5cblx0XHQvLyBVc2luZyBlYXNpZXIgdG8gcmVhZCB2YXJpYWJsZXMuXG5cdFx0YXVnbWVudEZvcm1hdCA9IGRhdGVFeHBhbmRQYXR0ZXJuQXVnbWVudEZvcm1hdCxcblx0XHRjb21wYXJlRm9ybWF0cyA9IGRhdGVFeHBhbmRQYXR0ZXJuQ29tcGFyZUZvcm1hdHM7XG5cblx0cGF0dGVybiA9IGNsZHIubWFpbihbIHBhdGgsIGFza2VkU2tlbGV0b24gXSk7XG5cblx0aWYgKCBhc2tlZFNrZWxldG9uICYmICFwYXR0ZXJuICkge1xuXHRcdGF2YWlsYWJsZUZvcm1hdHMgPSBjbGRyLm1haW4oWyBwYXRoIF0pO1xuXHRcdHJhdGVkRm9ybWF0cyA9IFtdO1xuXG5cdFx0Zm9yICggc2tlbGV0b24gaW4gYXZhaWxhYmxlRm9ybWF0cyApIHtcblx0XHRcdHJhdGVkRm9ybWF0cy5wdXNoKHtcblx0XHRcdFx0c2tlbGV0b246IHNrZWxldG9uLFxuXHRcdFx0XHRwYXR0ZXJuOiBhdmFpbGFibGVGb3JtYXRzWyBza2VsZXRvbiBdLFxuXHRcdFx0XHRyYXRlOiBjb21wYXJlRm9ybWF0cyggYXNrZWRTa2VsZXRvbiwgc2tlbGV0b24gKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmF0ZWRGb3JtYXRzID0gcmF0ZWRGb3JtYXRzXG5cdFx0XHQuZmlsdGVyKCBmdW5jdGlvbiggZm9ybWF0ICkge1xuXHRcdFx0XHRyZXR1cm4gZm9ybWF0LnJhdGUgPiAtMTtcblx0XHRcdH0gKVxuXHRcdFx0LnNvcnQoIGZ1bmN0aW9uKCBmb3JtYXRBLCBmb3JtYXRCICkge1xuXHRcdFx0XHRyZXR1cm4gZm9ybWF0QS5yYXRlIC0gZm9ybWF0Qi5yYXRlO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIHJhdGVkRm9ybWF0cy5sZW5ndGggKSB7XG5cdFx0XHRwYXR0ZXJuID0gYXVnbWVudEZvcm1hdCggYXNrZWRTa2VsZXRvbiwgcmF0ZWRGb3JtYXRzWzBdLnBhdHRlcm4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGF0dGVybjtcbn07XG5cblxuXG5cbi8qKlxuICogZXhwYW5kUGF0dGVybiggb3B0aW9ucywgY2xkciApXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gaWYgU3RyaW5nLCBpdCdzIGNvbnNpZGVyZWQgYSBza2VsZXRvbi4gT2JqZWN0IGFjY2VwdHM6XG4gKiAtIHNrZWxldG9uOiBbU3RyaW5nXSBsb29rdXAgYXZhaWxhYmxlRm9ybWF0O1xuICogLSBkYXRlOiBbU3RyaW5nXSAoIFwiZnVsbFwiIHwgXCJsb25nXCIgfCBcIm1lZGl1bVwiIHwgXCJzaG9ydFwiICk7XG4gKiAtIHRpbWU6IFtTdHJpbmddICggXCJmdWxsXCIgfCBcImxvbmdcIiB8IFwibWVkaXVtXCIgfCBcInNob3J0XCIgKTtcbiAqIC0gZGF0ZXRpbWU6IFtTdHJpbmddICggXCJmdWxsXCIgfCBcImxvbmdcIiB8IFwibWVkaXVtXCIgfCBcInNob3J0XCIgKTtcbiAqIC0gcmF3OiBbU3RyaW5nXSBGb3IgbW9yZSBpbmZvIHNlZSBkYXRldGltZS9mb3JtYXQuanMuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiB0aGUgY29ycmVzcG9uZGluZyBwYXR0ZXJuLlxuICogRWcgZm9yIFwiZW5cIjpcbiAqIC0gXCJHeU1NTWRcIiByZXR1cm5zIFwiTU1NIGQsIHkgR1wiO1xuICogLSB7IHNrZWxldG9uOiBcIkd5TU1NZFwiIH0gcmV0dXJucyBcIk1NTSBkLCB5IEdcIjtcbiAqIC0geyBkYXRlOiBcImZ1bGxcIiB9IHJldHVybnMgXCJFRUVFLCBNTU1NIGQsIHlcIjtcbiAqIC0geyB0aW1lOiBcImZ1bGxcIiB9IHJldHVybnMgXCJoOm1tOnNzIGEgenp6elwiO1xuICogLSB7IGRhdGV0aW1lOiBcImZ1bGxcIiB9IHJldHVybnMgXCJFRUVFLCBNTU1NIGQsIHkgJ2F0JyBoOm1tOnNzIGEgenp6elwiO1xuICogLSB7IHJhdzogXCJkZC9tbVwiIH0gcmV0dXJucyBcImRkL21tXCI7XG4gKi9cbnZhciBkYXRlRXhwYW5kUGF0dGVybiA9IGZ1bmN0aW9uKCBvcHRpb25zLCBjbGRyICkge1xuXHR2YXIgZGF0ZVNrZWxldG9uLCByZXN1bHQsIHNrZWxldG9uLCB0aW1lU2tlbGV0b24sIHR5cGUsXG5cblx0XHQvLyBVc2luZyBlYXNpZXIgdG8gcmVhZCB2YXJpYWJsZXMuXG5cdFx0Z2V0QmVzdE1hdGNoUGF0dGVybiA9IGRhdGVFeHBhbmRQYXR0ZXJuR2V0QmVzdE1hdGNoUGF0dGVybjtcblxuXHRmdW5jdGlvbiBjb21iaW5lRGF0ZVRpbWUoIHR5cGUsIGRhdGVQYXR0ZXJuLCB0aW1lUGF0dGVybiApIHtcblx0XHRyZXR1cm4gZm9ybWF0TWVzc2FnZShcblx0XHRcdGNsZHIubWFpbihbXG5cdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXRlVGltZUZvcm1hdHNcIixcblx0XHRcdFx0dHlwZVxuXHRcdFx0XSksXG5cdFx0XHRbIHRpbWVQYXR0ZXJuLCBkYXRlUGF0dGVybiBdXG5cdFx0KTtcblx0fVxuXG5cdHN3aXRjaCAoIHRydWUgKSB7XG5cdFx0Y2FzZSBcInNrZWxldG9uXCIgaW4gb3B0aW9uczpcblx0XHRcdHNrZWxldG9uID0gb3B0aW9ucy5za2VsZXRvbjtcblxuXHRcdFx0Ly8gUHJlZmVycmVkIGhvdXIgKGopLlxuXHRcdFx0c2tlbGV0b24gPSBza2VsZXRvbi5yZXBsYWNlKCAvai9nLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNsZHIuc3VwcGxlbWVudGFsLnRpbWVEYXRhLnByZWZlcnJlZCgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhbGlkYXRlU2tlbGV0b24oIHNrZWxldG9uICk7XG5cblx0XHRcdC8vIFRyeSBkaXJlY3QgbWFwIChub3RlIHRoYXQgZ2V0QmVzdE1hdGNoUGF0dGVybiBoYW5kbGVzIGl0KS5cblx0XHRcdC8vIC4uLiBvciwgdHJ5IHRvIFwiYmVzdCBtYXRjaFwiIHRoZSB3aG9sZSBza2VsZXRvbi5cblx0XHRcdHJlc3VsdCA9IGdldEJlc3RNYXRjaFBhdHRlcm4oXG5cdFx0XHRcdGNsZHIsXG5cdFx0XHRcdHNrZWxldG9uXG5cdFx0XHQpO1xuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAuLi4gb3IsIHRyeSB0byBcImJlc3QgbWF0Y2hcIiB0aGUgZGF0ZSBhbmQgdGltZSBwYXJ0cyBpbmRpdmlkdWFsbHkuXG5cdFx0XHR0aW1lU2tlbGV0b24gPSBza2VsZXRvbi5zcGxpdCggL1teaEhLa21zU0F6Wk92Vlh4XS8gKS5zbGljZSggLTEgKVsgMCBdO1xuXHRcdFx0ZGF0ZVNrZWxldG9uID0gc2tlbGV0b24uc3BsaXQoIC9bXkd5WXVVclFxTUxsd1dkREZnRWVjXS8gKVsgMCBdO1xuXHRcdFx0ZGF0ZVNrZWxldG9uID0gZ2V0QmVzdE1hdGNoUGF0dGVybihcblx0XHRcdFx0Y2xkcixcblx0XHRcdFx0ZGF0ZVNrZWxldG9uXG5cdFx0XHQpO1xuXHRcdFx0dGltZVNrZWxldG9uID0gZ2V0QmVzdE1hdGNoUGF0dGVybihcblx0XHRcdFx0Y2xkcixcblx0XHRcdFx0dGltZVNrZWxldG9uXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoIC8oTU1NTXxMTExMKS4qW0VjXS8udGVzdCggZGF0ZVNrZWxldG9uICkgKSB7XG5cdFx0XHRcdHR5cGUgPSBcImZ1bGxcIjtcblx0XHRcdH0gZWxzZSBpZiAoIC9NTU1NfExMTEwvLnRlc3QoIGRhdGVTa2VsZXRvbiApICkge1xuXHRcdFx0XHR0eXBlID0gXCJsb25nXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCAvTU1NfExMTC8udGVzdCggZGF0ZVNrZWxldG9uICkgKSB7XG5cdFx0XHRcdHR5cGUgPSBcIm1lZGl1bVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFwic2hvcnRcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkYXRlU2tlbGV0b24gJiYgdGltZVNrZWxldG9uICkge1xuXHRcdFx0XHRyZXN1bHQgPSBjb21iaW5lRGF0ZVRpbWUoIHR5cGUsIGRhdGVTa2VsZXRvbiwgdGltZVNrZWxldG9uICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSBkYXRlU2tlbGV0b24gfHwgdGltZVNrZWxldG9uO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJkYXRlXCIgaW4gb3B0aW9uczpcblx0XHRjYXNlIFwidGltZVwiIGluIG9wdGlvbnM6XG5cdFx0XHRyZXN1bHQgPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW5cIixcblx0XHRcdFx0XCJkYXRlXCIgaW4gb3B0aW9ucyA/IFwiZGF0ZUZvcm1hdHNcIiA6IFwidGltZUZvcm1hdHNcIixcblx0XHRcdFx0KCBvcHRpb25zLmRhdGUgfHwgb3B0aW9ucy50aW1lIClcblx0XHRcdF0pO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiZGF0ZXRpbWVcIiBpbiBvcHRpb25zOlxuXHRcdFx0cmVzdWx0ID0gY29tYmluZURhdGVUaW1lKCBvcHRpb25zLmRhdGV0aW1lLFxuXHRcdFx0XHRjbGRyLm1haW4oWyBcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF0ZUZvcm1hdHNcIiwgb3B0aW9ucy5kYXRldGltZSBdKSxcblx0XHRcdFx0Y2xkci5tYWluKFsgXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL3RpbWVGb3JtYXRzXCIsIG9wdGlvbnMuZGF0ZXRpbWUgXSlcblx0XHRcdCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJyYXdcIiBpbiBvcHRpb25zOlxuXHRcdFx0cmVzdWx0ID0gb3B0aW9ucy5yYXc7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBjcmVhdGVFcnJvckludmFsaWRQYXJhbWV0ZXJWYWx1ZSh7XG5cdFx0XHRcdG5hbWU6IFwib3B0aW9uc1wiLFxuXHRcdFx0XHR2YWx1ZTogb3B0aW9uc1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cblxudmFyIGRhdGVXZWVrRGF5cyA9IFsgXCJzdW5cIiwgXCJtb25cIiwgXCJ0dWVcIiwgXCJ3ZWRcIiwgXCJ0aHVcIiwgXCJmcmlcIiwgXCJzYXRcIiBdO1xuXG5cblxuXG4vKipcbiAqIGZpcnN0RGF5T2ZXZWVrXG4gKi9cbnZhciBkYXRlRmlyc3REYXlPZldlZWsgPSBmdW5jdGlvbiggY2xkciApIHtcblx0cmV0dXJuIGRhdGVXZWVrRGF5cy5pbmRleE9mKCBjbGRyLnN1cHBsZW1lbnRhbC53ZWVrRGF0YS5maXJzdERheSgpICk7XG59O1xuXG5cblxuXG4vKipcbiAqIGdldFRpbWVab25lTmFtZSggbGVuZ3RoLCB0eXBlIClcbiAqL1xudmFyIGRhdGVHZXRUaW1lWm9uZU5hbWUgPSBmdW5jdGlvbiggbGVuZ3RoLCB0eXBlLCB0aW1lWm9uZSwgY2xkciApIHtcblx0dmFyIG1ldGFab25lLCByZXN1bHQ7XG5cblx0aWYgKCAhdGltZVpvbmUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0cmVzdWx0ID0gY2xkci5tYWluKFtcblx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZVwiLFxuXHRcdHRpbWVab25lLFxuXHRcdGxlbmd0aCA8IDQgPyBcInNob3J0XCIgOiBcImxvbmdcIixcblx0XHR0eXBlXG5cdF0pO1xuXG5cdGlmICggcmVzdWx0ICkge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBUaGUgbGF0ZXN0IG1ldGF6b25lIGRhdGEgb2YgdGhlIG1ldGF6b25lIGFycmF5LlxuXHQvLyBUT0RPIGV4cGFuZCB0byBzdXBwb3J0IHRoZSBoaXN0b3JpYyBtZXRhem9uZXMgYmFzZWQgb24gdGhlIGdpdmVuIGRhdGUuXG5cdG1ldGFab25lID0gY2xkci5zdXBwbGVtZW50YWwoW1xuXHRcdFwibWV0YVpvbmVzL21ldGF6b25lSW5mby90aW1lem9uZVwiLCB0aW1lWm9uZSwgMCxcblx0XHRcInVzZXNNZXRhem9uZS9fbXpvbmVcIlxuXHRdKTtcblxuXHRyZXR1cm4gY2xkci5tYWluKFtcblx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvbWV0YXpvbmVcIixcblx0XHRtZXRhWm9uZSxcblx0XHRsZW5ndGggPCA0ID8gXCJzaG9ydFwiIDogXCJsb25nXCIsXG5cdFx0dHlwZVxuXHRdKTtcbn07XG5cblxuXG5cbi8qKlxuICogdGltZXpvbmVIb3VyRm9ybWF0U2hvcnRIKCBob3VyRm9ybWF0IClcbiAqXG4gKiBAaG91ckZvcm1hdCBbU3RyaW5nXVxuICpcbiAqIFVub2ZmaWNpYWwgZGVkdWN0aW9uIG9mIHRoZSBzaG9ydCBob3VyRm9ybWF0IGdpdmVuIHRpbWUgem9uZSBgaG91ckZvcm1hdGAgZWxlbWVudC5cbiAqIE9mZmljaWFsIHNwZWMgaXMgcGVuZGluZyByZXNvbHV0aW9uOiBodHRwOi8vdW5pY29kZS5vcmcvY2xkci90cmFjL3RpY2tldC84MjkzXG4gKlxuICogRXhhbXBsZTpcbiAqIC0gXCIrSEgubW07LUhILm1tXCIgPT4gXCIrSDstSFwiXG4gKiAtIFwiK0hIOm1tOy1ISDptbVwiID0+IFwiK0g7LUhcIlxuICogLSBcIitISDptbTviiJJISDptbVwiID0+IFwiK0g74oiSSFwiIChOb3RlIE1JTlVTIFNJR04gXFx1MjIxMilcbiAqIC0gXCIrSEhtbTstSEhtbVwiID0+IFwiK0g6LUhcIlxuICovXG52YXIgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEggPSBmdW5jdGlvbiggaG91ckZvcm1hdCApIHtcblx0cmV0dXJuIGhvdXJGb3JtYXRcblx0XHQuc3BsaXQoIFwiO1wiIClcblx0XHQubWFwKGZ1bmN0aW9uKCBmb3JtYXQgKSB7XG5cdFx0XHRyZXR1cm4gZm9ybWF0LnNsaWNlKCAwLCBmb3JtYXQuaW5kZXhPZiggXCJIXCIgKSArIDEgKTtcblx0XHR9KVxuXHRcdC5qb2luKCBcIjtcIiApO1xufTtcblxuXG5cblxuLyoqXG4gKiB0aW1lem9uZUhvdXJGb3JtYXRMb25nSG0oIGhvdXJGb3JtYXQgKVxuICpcbiAqIEBob3VyRm9ybWF0IFtTdHJpbmddXG4gKlxuICogVW5vZmZpY2lhbCBkZWR1Y3Rpb24gb2YgdGhlIHNob3J0IGhvdXJGb3JtYXQgZ2l2ZW4gdGltZSB6b25lIGBob3VyRm9ybWF0YCBlbGVtZW50LlxuICogT2ZmaWNpYWwgc3BlYyBpcyBwZW5kaW5nIHJlc29sdXRpb246IGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzgyOTNcbiAqXG4gKiBFeGFtcGxlIChoRm9ybWF0ID09PSBcIkhcIik6ICh1c2VkIGZvciBzaG9ydCBIbSlcbiAqIC0gXCIrSEgubW07LUhILm1tXCIgPT4gXCIrSC5tbTstSC5tbVwiXG4gKiAtIFwiK0hIOm1tOy1ISDptbVwiID0+IFwiK0g6bW07LUg6bW1cIlxuICogLSBcIitISDptbTviiJJISDptbVwiID0+IFwiK0g6bW074oiSSDptbVwiIChOb3RlIE1JTlVTIFNJR04gXFx1MjIxMilcbiAqIC0gXCIrSEhtbTstSEhtbVwiID0+IFwiK0htbTotSG1tXCJcbiAqXG4gKiBFeGFtcGxlIChoRm9ybWF0ID09PSBcIkhIXCI6ICh1c2VkIGZvciBsb25nIEhtKVxuICogLSBcIitISC5tbTstSEgubW1cIiA9PiBcIitISC5tbTstSEgubW1cIlxuICogLSBcIitISDptbTstSEg6bW1cIiA9PiBcIitISDptbTstSEg6bW1cIlxuICogLSBcIitIOm1tOy1IOm1tXCIgICA9PiBcIitISDptbTstSEg6bW1cIlxuICogLSBcIitISDptbTviiJJISDptbVwiID0+IFwiK0hIOm1tO+KIkkhIOm1tXCIgKE5vdGUgTUlOVVMgU0lHTiBcXHUyMjEyKVxuICogLSBcIitISG1tOy1ISG1tXCIgPT4gXCIrSEhtbTotSEhtbVwiXG4gKi9cbnZhciBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0gPSBmdW5jdGlvbiggaG91ckZvcm1hdCwgaEZvcm1hdCApIHtcblx0cmV0dXJuIGhvdXJGb3JtYXRcblx0XHQuc3BsaXQoIFwiO1wiIClcblx0XHQubWFwKGZ1bmN0aW9uKCBmb3JtYXQgKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBmb3JtYXQuc3BsaXQoIC9IKy8gKTtcblx0XHRcdHBhcnRzLnNwbGljZSggMSwgMCwgaEZvcm1hdCApO1xuXHRcdFx0cmV0dXJuIHBhcnRzLmpvaW4oIFwiXCIgKTtcblx0XHR9KVxuXHRcdC5qb2luKCBcIjtcIiApO1xufTtcblxuXG5cblxudmFyIHJ1bnRpbWVDYWNoZURhdGFCaW5kID0gZnVuY3Rpb24oIGtleSwgZGF0YSApIHtcblx0dmFyIGZuID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cdGZuLmRhdGFDYWNoZUtleSA9IGtleTtcblx0cmV0dXJuIGZuO1xufTtcblxuXG5cblxuLyoqXG4gKiBwcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyIClcbiAqXG4gKiBAcGF0dGVybiBbU3RyaW5nXSByYXcgcGF0dGVybi5cbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiB0aGUgcHJvcGVydGllcyBnaXZlbiB0aGUgcGF0dGVybiBhbmQgY2xkci5cbiAqXG4gKiBUT0RPIFN1cHBvcnQgb3RoZXIgY2FsZW5kYXIgdHlwZXMuXG4gKi9cbnZhciBkYXRlRm9ybWF0UHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBjbGRyLCB0aW1lWm9uZSApIHtcblx0dmFyIHByb3BlcnRpZXMgPSB7XG5cdFx0XHRudW1iZXJGb3JtYXR0ZXJzOiB7fSxcblx0XHRcdHBhdHRlcm46IHBhdHRlcm4sXG5cdFx0XHR0aW1lU2VwYXJhdG9yOiBudW1iZXJTeW1ib2woIFwidGltZVNlcGFyYXRvclwiLCBjbGRyIClcblx0XHR9LFxuXHRcdHdpZHRocyA9IFsgXCJhYmJyZXZpYXRlZFwiLCBcIndpZGVcIiwgXCJuYXJyb3dcIiBdO1xuXG5cdGZ1bmN0aW9uIHNldE51bWJlckZvcm1hdHRlclBhdHRlcm4oIHBhZCApIHtcblx0XHRwcm9wZXJ0aWVzLm51bWJlckZvcm1hdHRlcnNbIHBhZCBdID0gc3RyaW5nUGFkKCBcIlwiLCBwYWQgKTtcblx0fVxuXG5cdGlmICggdGltZVpvbmUgKSB7XG5cdFx0cHJvcGVydGllcy50aW1lWm9uZURhdGEgPSBydW50aW1lQ2FjaGVEYXRhQmluZCggXCJpYW5hL1wiICsgdGltZVpvbmUsIHtcblx0XHRcdG9mZnNldHM6IGNsZHIuZ2V0KFsgXCJnbG9iYWxpemUtaWFuYS96b25lRGF0YVwiLCB0aW1lWm9uZSwgXCJvZmZzZXRzXCIgXSksXG5cdFx0XHR1bnRpbHM6IGNsZHIuZ2V0KFsgXCJnbG9iYWxpemUtaWFuYS96b25lRGF0YVwiLCB0aW1lWm9uZSwgXCJ1bnRpbHNcIiBdKSxcblx0XHRcdGlzZHN0czogY2xkci5nZXQoWyBcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXCIsIHRpbWVab25lLCBcImlzZHN0c1wiIF0pXG5cdFx0fSk7XG5cdH1cblxuXHRwYXR0ZXJuLnJlcGxhY2UoIGRhdGVQYXR0ZXJuUmUsIGZ1bmN0aW9uKCBjdXJyZW50ICkge1xuXHRcdHZhciBhdXgsIGNociwgZGF5bGlnaHRUek5hbWUsIGZvcm1hdE51bWJlciwgZ2VuZXJpY1R6TmFtZSwgbGVuZ3RoLCBzdGFuZGFyZFR6TmFtZTtcblxuXHRcdGNociA9IGN1cnJlbnQuY2hhckF0KCAwICk7XG5cdFx0bGVuZ3RoID0gY3VycmVudC5sZW5ndGg7XG5cblx0XHRpZiAoIGNociA9PT0gXCJqXCIgKSB7XG5cblx0XHRcdC8vIExvY2FsZSBwcmVmZXJyZWQgaEhLay5cblx0XHRcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNUaW1lX0RhdGFcblx0XHRcdHByb3BlcnRpZXMucHJlZmVycmVkVGltZSA9IGNociA9IGNsZHIuc3VwcGxlbWVudGFsLnRpbWVEYXRhLnByZWZlcnJlZCgpO1xuXHRcdH1cblxuXHRcdC8vIFpaWlo6IHNhbWUgYXMgXCJPT09PXCIuXG5cdFx0aWYgKCBjaHIgPT09IFwiWlwiICYmIGxlbmd0aCA9PT0gNCApIHtcblx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0bGVuZ3RoID0gNDtcblx0XHR9XG5cblx0XHQvLyB6Li4uenp6OiBcIntzaG9ydFJlZ2lvbn1cIiwgZWcuIFwiUFNUXCIgb3IgXCJQRFRcIi5cblx0XHQvLyB6enp6OiBcIntyZWdpb25OYW1lfSB7U3RhbmRhcmQgVGltZX1cIiBvciBcIntyZWdpb25OYW1lfSB7RGF5bGlnaHQgVGltZX1cIixcblx0XHQvLyAgICAgICBlLmcuLCBcIlBhY2lmaWMgU3RhbmRhcmQgVGltZVwiIG9yIFwiUGFjaWZpYyBEYXlsaWdodCBUaW1lXCIuXG5cdFx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcblx0XHRpZiAoIGNociA9PT0gXCJ6XCIgKSB7XG5cdFx0XHRzdGFuZGFyZFR6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXCJzdGFuZGFyZFwiLCB0aW1lWm9uZSwgY2xkciApO1xuXHRcdFx0ZGF5bGlnaHRUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFwiZGF5bGlnaHRcIiwgdGltZVpvbmUsIGNsZHIgKTtcblx0XHRcdGlmICggc3RhbmRhcmRUek5hbWUgKSB7XG5cdFx0XHRcdHByb3BlcnRpZXMuc3RhbmRhcmRUek5hbWUgPSBzdGFuZGFyZFR6TmFtZTtcblx0XHRcdH1cblx0XHRcdGlmICggZGF5bGlnaHRUek5hbWUgKSB7XG5cdFx0XHRcdHByb3BlcnRpZXMuZGF5bGlnaHRUek5hbWUgPSBkYXlsaWdodFR6TmFtZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbCB0aHJvdWdoIHRoZSBcIk9cIiBmb3JtYXQgaW4gY2FzZSBvbmUgbmFtZSBpcyBtaXNzaW5nLlxuXHRcdFx0aWYgKCAhc3RhbmRhcmRUek5hbWUgfHwgIWRheWxpZ2h0VHpOYW1lICkge1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdFx0aWYgKCBsZW5ndGggPCA0ICkge1xuXHRcdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB2Li4udnZ2OiBcIntzaG9ydFJlZ2lvbn1cIiwgZWcuIFwiUFRcIi5cblx0XHQvLyB2dnZ2OiBcIntyZWdpb25OYW1lfSB7VGltZX1cIiBvciBcIntyZWdpb25OYW1lfSB7VGltZX1cIixcblx0XHQvLyBlLmcuLCBcIlBhY2lmaWMgVGltZVwiXG5cdFx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcblx0XHRpZiAoIGNociA9PT0gXCJ2XCIgKSB7XG5cdFx0XHRnZW5lcmljVHpOYW1lID0gZGF0ZUdldFRpbWVab25lTmFtZSggbGVuZ3RoLCBcImdlbmVyaWNcIiwgdGltZVpvbmUsIGNsZHIgKTtcblxuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIFwiVlwiIGZvcm1hdC5cblx0XHRcdGlmICggIWdlbmVyaWNUek5hbWUgKSB7XG5cdFx0XHRcdGNociA9IFwiVlwiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGNociApIHtcblxuXHRcdFx0Ly8gRXJhXG5cdFx0XHRjYXNlIFwiR1wiOlxuXHRcdFx0XHRwcm9wZXJ0aWVzLmVyYXMgPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9lcmFzXCIsXG5cdFx0XHRcdFx0bGVuZ3RoIDw9IDMgPyBcImVyYUFiYnJcIiA6ICggbGVuZ3RoID09PSA0ID8gXCJlcmFOYW1lc1wiIDogXCJlcmFOYXJyb3dcIiApXG5cdFx0XHRcdF0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0Y2FzZSBcInlcIjpcblxuXHRcdFx0XHQvLyBQbGFpbiB5ZWFyLlxuXHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIllcIjpcblxuXHRcdFx0XHQvLyBZZWFyIGluIFwiV2VlayBvZiBZZWFyXCJcblx0XHRcdFx0cHJvcGVydGllcy5maXJzdERheSA9IGRhdGVGaXJzdERheU9mV2VlayggY2xkciApO1xuXHRcdFx0XHRwcm9wZXJ0aWVzLm1pbkRheXMgPSBjbGRyLnN1cHBsZW1lbnRhbC53ZWVrRGF0YS5taW5EYXlzKCk7XG5cdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwidVwiOiAvLyBFeHRlbmRlZCB5ZWFyLiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxuXHRcdFx0Y2FzZSBcIlVcIjogLy8gQ3ljbGljIHllYXIgbmFtZS4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdGZlYXR1cmU6IFwieWVhciBwYXR0ZXJuIGBcIiArIGNociArIFwiYFwiXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBRdWFydGVyXG5cdFx0XHRjYXNlIFwiUVwiOlxuXHRcdFx0Y2FzZSBcInFcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPiAyICkge1xuXHRcdFx0XHRcdGlmICggIXByb3BlcnRpZXMucXVhcnRlcnMgKSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnF1YXJ0ZXJzID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXByb3BlcnRpZXMucXVhcnRlcnNbIGNociBdICkge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5xdWFydGVyc1sgY2hyIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvcGVydGllcy5xdWFydGVyc1sgY2hyIF1bIGxlbmd0aCBdID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9xdWFydGVyc1wiLFxuXHRcdFx0XHRcdFx0Y2hyID09PSBcIlFcIiA/IFwiZm9ybWF0XCIgOiBcInN0YW5kLWFsb25lXCIsXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1vbnRoXG5cdFx0XHRjYXNlIFwiTVwiOlxuXHRcdFx0Y2FzZSBcIkxcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPiAyICkge1xuXHRcdFx0XHRcdGlmICggIXByb3BlcnRpZXMubW9udGhzICkge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5tb250aHMgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhcHJvcGVydGllcy5tb250aHNbIGNociBdICkge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5tb250aHNbIGNociBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByb3BlcnRpZXMubW9udGhzWyBjaHIgXVsgbGVuZ3RoIF0gPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL21vbnRoc1wiLFxuXHRcdFx0XHRcdFx0Y2hyID09PSBcIk1cIiA/IFwiZm9ybWF0XCIgOiBcInN0YW5kLWFsb25lXCIsXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWsgLSBXZWVrIG9mIFllYXIgKHcpIG9yIFdlZWsgb2YgTW9udGggKFcpLlxuXHRcdFx0Y2FzZSBcIndcIjpcblx0XHRcdGNhc2UgXCJXXCI6XG5cdFx0XHRcdHByb3BlcnRpZXMuZmlyc3REYXkgPSBkYXRlRmlyc3REYXlPZldlZWsoIGNsZHIgKTtcblx0XHRcdFx0cHJvcGVydGllcy5taW5EYXlzID0gY2xkci5zdXBwbGVtZW50YWwud2Vla0RhdGEubWluRGF5cygpO1xuXHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRGF5XG5cdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdGNhc2UgXCJGXCI6XG5cdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiZ1wiOlxuXG5cdFx0XHRcdC8vIE1vZGlmaWVkIEp1bGlhbiBkYXkuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXG5cdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRmZWF0dXJlOiBcIkp1bGlhbiBkYXkgcGF0dGVybiBgZ2BcIlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gV2VlayBkYXlcblx0XHRcdGNhc2UgXCJlXCI6XG5cdFx0XHRjYXNlIFwiY1wiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA8PSAyICkge1xuXHRcdFx0XHRcdHByb3BlcnRpZXMuZmlyc3REYXkgPSBkYXRlRmlyc3REYXlPZldlZWsoIGNsZHIgKTtcblx0XHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJFXCI6XG5cdFx0XHRcdGlmICggIXByb3BlcnRpZXMuZGF5cyApIHtcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmRheXMgPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFwcm9wZXJ0aWVzLmRheXNbIGNociBdICkge1xuXHRcdFx0XHRcdHByb3BlcnRpZXMuZGF5c1sgY2hyIF0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNob3J0IGRheSBuYW1lcyBhcmUgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhYmJyZXZpYXRlZCBkYXkgbmFtZXMgYXJlXG5cdFx0XHRcdFx0Ly8gdXNlZCBpbnN0ZWFkLlxuXHRcdFx0XHRcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNtb250aHNfZGF5c19xdWFydGVyc19lcmFzXG5cdFx0XHRcdFx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL2NsZHIvdHJhYy90aWNrZXQvNjc5MFxuXHRcdFx0XHRcdHByb3BlcnRpZXMuZGF5c1sgY2hyIF1bIGxlbmd0aCBdID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFx0Y2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIsXG5cdFx0XHRcdFx0XHRcdFwic2hvcnRcIlxuXHRcdFx0XHRcdFx0XSkgfHwgY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFx0Y2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIsXG5cdFx0XHRcdFx0XHRcdFwiYWJicmV2aWF0ZWRcIlxuXHRcdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvcGVydGllcy5kYXlzWyBjaHIgXVsgbGVuZ3RoIF0gPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggPCAzID8gMCA6IGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBQZXJpb2QgKEFNIG9yIFBNKVxuXHRcdFx0Y2FzZSBcImFcIjpcblx0XHRcdFx0cHJvcGVydGllcy5kYXlQZXJpb2RzID0ge1xuXHRcdFx0XHRcdGFtOiBjbGRyLm1haW4oXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZS9hbVwiXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRwbTogY2xkci5tYWluKFxuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGUvcG1cIlxuXHRcdFx0XHRcdClcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIEhvdXJcblx0XHRcdGNhc2UgXCJoXCI6IC8vIDEtMTJcblx0XHRcdGNhc2UgXCJIXCI6IC8vIDAtMjNcblx0XHRcdGNhc2UgXCJLXCI6IC8vIDAtMTFcblx0XHRcdGNhc2UgXCJrXCI6IC8vIDEtMjRcblxuXHRcdFx0Ly8gTWludXRlXG5cdFx0XHRjYXNlIFwibVwiOlxuXG5cdFx0XHQvLyBTZWNvbmRcblx0XHRcdGNhc2UgXCJzXCI6XG5cdFx0XHRjYXNlIFwiU1wiOlxuXHRcdFx0Y2FzZSBcIkFcIjpcblx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFpvbmVcblx0XHRcdGNhc2UgXCJ2XCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoICE9PSAxICYmIGxlbmd0aCAhPT0gNCApIHtcblx0XHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0XHRmZWF0dXJlOiBcInRpbWV6b25lIHBhdHRlcm4gYFwiICsgcGF0dGVybiArIFwiYFwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvcGVydGllcy5nZW5lcmljVHpOYW1lID0gZ2VuZXJpY1R6TmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJWXCI6XG5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdFx0ZmVhdHVyZTogXCJ0aW1lem9uZSBwYXR0ZXJuIGBcIiArIHBhdHRlcm4gKyBcImBcIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lID0gdGltZVpvbmU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgdGltZVpvbmVOYW1lLFxuXHRcdFx0XHRcdFx0ZXhlbXBsYXJDaXR5ID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3pvbmVcIiwgdGltZVpvbmUsIFwiZXhlbXBsYXJDaXR5XCJcblx0XHRcdFx0XHRcdF0pO1xuXG5cdFx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFleGVtcGxhckNpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdGV4ZW1wbGFyQ2l0eSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3pvbmUvRXRjL1Vua25vd24vZXhlbXBsYXJDaXR5XCJcblx0XHRcdFx0XHRcdFx0XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aW1lWm9uZU5hbWUgPSBleGVtcGxhckNpdHk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBleGVtcGxhckNpdHkgJiYgbGVuZ3RoID09PSA0ICkge1xuXHRcdFx0XHRcdFx0dGltZVpvbmVOYW1lID0gZm9ybWF0TWVzc2FnZShcblx0XHRcdFx0XHRcdFx0Y2xkci5tYWluKFxuXHRcdFx0XHRcdFx0XHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9yZWdpb25Gb3JtYXRcIlxuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHRbIGV4ZW1wbGFyQ2l0eSBdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGltZVpvbmVOYW1lICkge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZU5hbWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwidlwiICkge1xuXHRcdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIk9cIjpcblxuXHRcdFx0XHQvLyBPOiBcIntnbXRGb3JtYXR9K0g7e2dtdEZvcm1hdH0tSFwiIG9yIFwie2dtdFplcm9Gb3JtYXR9XCIsIGVnLiBcIkdNVC04XCIgb3IgXCJHTVRcIi5cblx0XHRcdFx0Ly8gT09PTzogXCJ7Z210Rm9ybWF0fXtob3VyRm9ybWF0fVwiIG9yIFwie2dtdFplcm9Gb3JtYXR9XCIsIGVnLiBcIkdNVC0wODowMFwiIG9yIFwiR01UXCIuXG5cdFx0XHRcdHByb3BlcnRpZXMuZ210Rm9ybWF0ID0gY2xkci5tYWluKCBcImRhdGVzL3RpbWVab25lTmFtZXMvZ210Rm9ybWF0XCIgKTtcblx0XHRcdFx0cHJvcGVydGllcy5nbXRaZXJvRm9ybWF0ID0gY2xkci5tYWluKCBcImRhdGVzL3RpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFwiICk7XG5cblx0XHRcdFx0Ly8gVW5vZmZpY2lhbCBkZWR1Y3Rpb24gb2YgdGhlIGhvdXJGb3JtYXQgdmFyaWF0aW9ucy5cblx0XHRcdFx0Ly8gT2ZmaWNpYWwgc3BlYyBpcyBwZW5kaW5nIHJlc29sdXRpb246IGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzgyOTNcblx0XHRcdFx0YXV4ID0gY2xkci5tYWluKCBcImRhdGVzL3RpbWVab25lTmFtZXMvaG91ckZvcm1hdFwiICk7XG5cdFx0XHRcdHByb3BlcnRpZXMuaG91ckZvcm1hdCA9IGxlbmd0aCA8IDQgP1xuXHRcdFx0XHRcdFsgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEgoIGF1eCApLCBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0oIGF1eCwgXCJIXCIgKSBdIDpcblx0XHRcdFx0XHRkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0oIGF1eCwgXCJISFwiICk7XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJaXCI6XG5cdFx0XHRjYXNlIFwiWFwiOlxuXHRcdFx0Y2FzZSBcInhcIjpcblx0XHRcdFx0c2V0TnVtYmVyRm9ybWF0dGVyUGF0dGVybiggMSApO1xuXHRcdFx0XHRzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCAyICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmICggZm9ybWF0TnVtYmVyICkge1xuXHRcdFx0c2V0TnVtYmVyRm9ybWF0dGVyUGF0dGVybiggbGVuZ3RoICk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcHJvcGVydGllcztcbn07XG5cblxuXG5cbnZhciBkYXRlRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggZGF0ZVRvUGFydHNGb3JtYXR0ZXIgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBkYXRlRm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIHZhbHVlICkubWFwKCBmdW5jdGlvbiggcGFydCApIHtcblx0XHRcdHJldHVybiBwYXJ0LnZhbHVlO1xuXHRcdH0pLmpvaW4oIFwiXCIgKTtcblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogcGFyc2VQcm9wZXJ0aWVzKCBjbGRyIClcbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogQHRpbWVab25lIFtTdHJpbmddIEZJWE1FLlxuICpcbiAqIFJldHVybiBwYXJzZXIgcHJvcGVydGllcy5cbiAqL1xudmFyIGRhdGVQYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY2xkciwgdGltZVpvbmUgKSB7XG5cdHZhciBwcm9wZXJ0aWVzID0ge1xuXHRcdHByZWZlcnJlZFRpbWVEYXRhOiBjbGRyLnN1cHBsZW1lbnRhbC50aW1lRGF0YS5wcmVmZXJyZWQoKVxuXHR9O1xuXG5cdGlmICggdGltZVpvbmUgKSB7XG5cdFx0cHJvcGVydGllcy50aW1lWm9uZURhdGEgPSBydW50aW1lQ2FjaGVEYXRhQmluZCggXCJpYW5hL1wiICsgdGltZVpvbmUsIHtcblx0XHRcdG9mZnNldHM6IGNsZHIuZ2V0KFsgXCJnbG9iYWxpemUtaWFuYS96b25lRGF0YVwiLCB0aW1lWm9uZSwgXCJvZmZzZXRzXCIgXSksXG5cdFx0XHR1bnRpbHM6IGNsZHIuZ2V0KFsgXCJnbG9iYWxpemUtaWFuYS96b25lRGF0YVwiLCB0aW1lWm9uZSwgXCJ1bnRpbHNcIiBdKSxcblx0XHRcdGlzZHN0czogY2xkci5nZXQoWyBcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXCIsIHRpbWVab25lLCBcImlzZHN0c1wiIF0pXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gcHJvcGVydGllcztcbn07XG5cblxudmFyIFpvbmVkRGF0ZVRpbWUgPSAoZnVuY3Rpb24oKSB7XG5mdW5jdGlvbiBkZWZpbmVQcml2YXRlUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFVudGlsc0luZGV4KG9yaWdpbmFsLCB1bnRpbHMpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIG9yaWdpbmFsVGltZSA9IG9yaWdpbmFsLmdldFRpbWUoKTtcblxuICAvLyBUT0RPIFNob3VsZCB3ZSBkbyBiaW5hcnkgc2VhcmNoIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZT9cbiAgd2hpbGUgKGluZGV4IDwgdW50aWxzLmxlbmd0aCAtIDEgJiYgb3JpZ2luYWxUaW1lID49IHVudGlsc1tpbmRleF0pIHtcbiAgICBpbmRleCsrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gc2V0V3JhcChmbikge1xuICB2YXIgb2Zmc2V0MSA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgdmFyIHJldCA9IGZuKCk7XG4gIHRoaXMub3JpZ2luYWwuc2V0VGltZShuZXcgRGF0ZSh0aGlzLmdldFRpbWUoKSkpO1xuICB2YXIgb2Zmc2V0MiA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgaWYgKG9mZnNldDIgLSBvZmZzZXQxKSB7XG4gICAgdGhpcy5vcmlnaW5hbC5zZXRNaW51dGVzKHRoaXMub3JpZ2luYWwuZ2V0TWludXRlcygpICsgb2Zmc2V0MiAtIG9mZnNldDEpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBab25lZERhdGVUaW1lID0gZnVuY3Rpb24oZGF0ZSwgdGltZVpvbmVEYXRhKSB7XG4gIGRlZmluZVByaXZhdGVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsXCIsIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKSk7XG4gIGRlZmluZVByaXZhdGVQcm9wZXJ0eSh0aGlzLCBcImxvY2FsXCIsIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKSk7XG4gIGRlZmluZVByaXZhdGVQcm9wZXJ0eSh0aGlzLCBcInRpbWVab25lRGF0YVwiLCB0aW1lWm9uZURhdGEpO1xuICBkZWZpbmVQcml2YXRlUHJvcGVydHkodGhpcywgXCJzZXRXcmFwXCIsIHNldFdyYXApO1xuICBpZiAoISh0aW1lWm9uZURhdGEudW50aWxzICYmIHRpbWVab25lRGF0YS5vZmZzZXRzICYmIHRpbWVab25lRGF0YS5pc2RzdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJQU5BIGRhdGFcIik7XG4gIH1cbiAgdGhpcy5zZXRUaW1lKHRoaXMubG9jYWwuZ2V0VGltZSgpIC0gdGhpcy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwKTtcbn07XG5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgWm9uZWREYXRlVGltZSh0aGlzLm9yaWdpbmFsLCB0aGlzLnRpbWVab25lRGF0YSk7XG59O1xuXG4vLyBEYXRlIGZpZWxkIGdldHRlcnMuXG5bXCJnZXRGdWxsWWVhclwiLCBcImdldE1vbnRoXCIsIFwiZ2V0RGF0ZVwiLCBcImdldERheVwiLCBcImdldEhvdXJzXCIsIFwiZ2V0TWludXRlc1wiLFxuXCJnZXRTZWNvbmRzXCIsIFwiZ2V0TWlsbGlzZWNvbmRzXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIC8vIENvcnJlc3BvbmRpbmcgVVRDIG1ldGhvZCwgZS5nLiwgXCJnZXRVVENGdWxsWWVhclwiIGlmIG1ldGhvZCA9PT0gXCJnZXRGdWxsWWVhclwiLlxuICB2YXIgdXRjTWV0aG9kID0gXCJnZXRVVENcIiArIG1ldGhvZC5zdWJzdHIoMyk7XG4gIFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFt1dGNNZXRob2RdKCk7XG4gIH07XG59KTtcblxuLy8gTm90ZTogRGVmaW5lIC52YWx1ZU9mID0gLmdldFRpbWUgZm9yIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBsaWtlIGRhdGUxIC0gZGF0ZTIuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS52YWx1ZU9mID1cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0VGltZSgpICsgdGhpcy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwO1xufTtcblxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuZ2V0VGltZXpvbmVPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZGV4ID0gZ2V0VW50aWxzSW5kZXgodGhpcy5vcmlnaW5hbCwgdGhpcy50aW1lWm9uZURhdGEudW50aWxzKTtcbiAgcmV0dXJuIHRoaXMudGltZVpvbmVEYXRhLm9mZnNldHNbaW5kZXhdO1xufTtcblxuLy8gRGF0ZSBmaWVsZCBzZXR0ZXJzLlxuW1wic2V0RnVsbFllYXJcIiwgXCJzZXRNb250aFwiLCBcInNldERhdGVcIiwgXCJzZXRIb3Vyc1wiLCBcInNldE1pbnV0ZXNcIiwgXCJzZXRTZWNvbmRzXCIsIFwic2V0TWlsbGlzZWNvbmRzXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIC8vIENvcnJlc3BvbmRpbmcgVVRDIG1ldGhvZCwgZS5nLiwgXCJzZXRVVENGdWxsWWVhclwiIGlmIG1ldGhvZCA9PT0gXCJzZXRGdWxsWWVhclwiLlxuICB2YXIgdXRjTWV0aG9kID0gXCJzZXRVVENcIiArIG1ldGhvZC5zdWJzdHIoMyk7XG4gIFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBsb2NhbCA9IHRoaXMubG9jYWw7XG4gICAgLy8gTm90ZSBzZXRXcmFwIGlzIG5lZWRlZCBmb3Igc2Vjb25kcyBhbmQgbWlsbGlzZWNvbmRzIGp1c3QgYmVjYXVzZVxuICAgIC8vIGFicyh2YWx1ZSkgY291bGQgYmUgPj0gYSBtaW51dGUuXG4gICAgcmV0dXJuIHRoaXMuc2V0V3JhcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhbFt1dGNNZXRob2RdKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcbn0pO1xuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS5zZXRUaW1lID0gZnVuY3Rpb24odGltZSkge1xuICByZXR1cm4gdGhpcy5sb2NhbC5zZXRUaW1lKHRpbWUpO1xufTtcblxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuaXNEU1QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZGV4ID0gZ2V0VW50aWxzSW5kZXgodGhpcy5vcmlnaW5hbCwgdGhpcy50aW1lWm9uZURhdGEudW50aWxzKTtcbiAgcmV0dXJuIEJvb2xlYW4odGhpcy50aW1lWm9uZURhdGEuaXNkc3RzW2luZGV4XSk7XG59O1xuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbmRleCA9IGdldFVudGlsc0luZGV4KHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhLnVudGlscyk7XG4gIHZhciBhYmJycyA9IHRoaXMudGltZVpvbmVEYXRhLmFiYnJzO1xuICByZXR1cm4gdGhpcy5sb2NhbC50b0lTT1N0cmluZygpLnJlcGxhY2UoL1okLywgXCJcIikgKyBcIiBcIiArXG4gICAgKGFiYnJzICYmIGFiYnJzW2luZGV4XSArIFwiIFwiIHx8ICh0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMSkgKyBcIiBcIikgK1xuICAgICh0aGlzLmlzRFNUKCkgPyBcIihkYXlsaWdodCBzYXZpbmdzKVwiIDogXCJcIik7XG59O1xuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS50b0RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0VGltZSgpKTtcbn07XG5cbi8vIFR5cGUgY2FzdCBnZXR0ZXJzLlxuW1widG9JU09TdHJpbmdcIiwgXCJ0b0pTT05cIiwgXCJ0b1VUQ1N0cmluZ1wiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBab25lZERhdGVUaW1lLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRlKClbbWV0aG9kXSgpO1xuICB9O1xufSk7XG5cbnJldHVybiBab25lZERhdGVUaW1lO1xufSgpKTtcblxuXG4vKipcbiAqIGlzTGVhcFllYXIoIHllYXIgKVxuICpcbiAqIEB5ZWFyIFtOdW1iZXJdXG4gKlxuICogUmV0dXJucyBhbiBpbmRpY2F0aW9uIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB5ZWFyIGlzIGEgbGVhcCB5ZWFyLlxuICovXG52YXIgZGF0ZUlzTGVhcFllYXIgPSBmdW5jdGlvbiggeWVhciApIHtcblx0cmV0dXJuIG5ldyBEYXRlKCB5ZWFyLCAxLCAyOSApLmdldE1vbnRoKCkgPT09IDE7XG59O1xuXG5cblxuXG4vKipcbiAqIGxhc3REYXlPZk1vbnRoKCBkYXRlIClcbiAqXG4gKiBAZGF0ZSBbRGF0ZV1cbiAqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIHRoZSBnaXZlbiBkYXRlJ3MgbW9udGhcbiAqL1xudmFyIGRhdGVMYXN0RGF5T2ZNb250aCA9IGZ1bmN0aW9uKCBkYXRlICkge1xuXHRyZXR1cm4gbmV3IERhdGUoIGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCApLmdldERhdGUoKTtcbn07XG5cblxuXG5cbi8qKlxuICogc3RhcnRPZiBjaGFuZ2VzIHRoZSBpbnB1dCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnaXZlbiB1bml0LlxuICpcbiAqIEZvciBleGFtcGxlLCBzdGFydGluZyBhdCB0aGUgc3RhcnQgb2YgYSBkYXksIHJlc2V0cyBob3VycywgbWludXRlc1xuICogc2Vjb25kcyBhbmQgbWlsbGlzZWNvbmRzIHRvIDAuIFN0YXJ0aW5nIGF0IHRoZSBtb250aCBkb2VzIHRoZSBzYW1lLCBidXRcbiAqIGFsc28gc2V0cyB0aGUgZGF0ZSB0byAxLlxuICpcbiAqIFJldHVybnMgdGhlIG1vZGlmaWVkIGRhdGVcbiAqL1xudmFyIGRhdGVTdGFydE9mID0gZnVuY3Rpb24oIGRhdGUsIHVuaXQgKSB7XG5cdGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSA/IGRhdGUuY2xvbmUoKSA6IG5ldyBEYXRlKCBkYXRlLmdldFRpbWUoKSApO1xuXHRzd2l0Y2ggKCB1bml0ICkge1xuXHRcdGNhc2UgXCJ5ZWFyXCI6XG5cdFx0XHRkYXRlLnNldE1vbnRoKCAwICk7XG5cdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgXCJtb250aFwiOlxuXHRcdFx0ZGF0ZS5zZXREYXRlKCAxICk7XG5cdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgXCJkYXlcIjpcblx0XHRcdGRhdGUuc2V0SG91cnMoIDAgKTtcblx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSBcImhvdXJcIjpcblx0XHRcdGRhdGUuc2V0TWludXRlcyggMCApO1xuXHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlIFwibWludXRlXCI6XG5cdFx0XHRkYXRlLnNldFNlY29uZHMoIDAgKTtcblx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSBcInNlY29uZFwiOlxuXHRcdFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoIDAgKTtcblx0fVxuXHRyZXR1cm4gZGF0ZTtcbn07XG5cblxuXG5cbi8qKlxuICogRGlmZmVyZW50bHkgZnJvbSBuYXRpdmUgZGF0ZS5zZXREYXRlKCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGRhdGUgd2hvc2VcbiAqIGRheSByZW1haW5zIGluc2lkZSB0aGUgbW9udGggYm91bmRhcmllcy4gRm9yIGV4YW1wbGU6XG4gKlxuICogc2V0RGF0ZSggRmViRGF0ZSwgMzEgKTogYSBcIkZlYiAyOFwiIGRhdGUuXG4gKiBzZXREYXRlKCBTZXBEYXRlLCAzMSApOiBhIFwiU2VwIDMwXCIgZGF0ZS5cbiAqL1xudmFyIGRhdGVTZXREYXRlID0gZnVuY3Rpb24oIGRhdGUsIGRheSApIHtcblx0dmFyIGxhc3REYXkgPSBuZXcgRGF0ZSggZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAwICkuZ2V0RGF0ZSgpO1xuXG5cdGRhdGUuc2V0RGF0ZSggZGF5IDwgMSA/IDEgOiBkYXkgPCBsYXN0RGF5ID8gZGF5IDogbGFzdERheSApO1xufTtcblxuXG5cblxuLyoqXG4gKiBEaWZmZXJlbnRseSBmcm9tIG5hdGl2ZSBkYXRlLnNldE1vbnRoKCksIHRoaXMgZnVuY3Rpb24gYWRqdXN0cyBkYXRlIGlmXG4gKiBuZWVkZWQsIHNvIGZpbmFsIG1vbnRoIGlzIGFsd2F5cyB0aGUgb25lIHNldC5cbiAqXG4gKiBzZXRNb250aCggSmFuMzFEYXRlLCAxICk6IGEgXCJGZWIgMjhcIiBkYXRlLlxuICogc2V0RGF0ZSggSmFuMzFEYXRlLCA4ICk6IGEgXCJTZXAgMzBcIiBkYXRlLlxuICovXG52YXIgZGF0ZVNldE1vbnRoID0gZnVuY3Rpb24oIGRhdGUsIG1vbnRoICkge1xuXHR2YXIgb3JpZ2luYWxEYXRlID0gZGF0ZS5nZXREYXRlKCk7XG5cblx0ZGF0ZS5zZXREYXRlKCAxICk7XG5cdGRhdGUuc2V0TW9udGgoIG1vbnRoICk7XG5cdGRhdGVTZXREYXRlKCBkYXRlLCBvcmlnaW5hbERhdGUgKTtcbn07XG5cblxuXG5cbnZhciBvdXRPZlJhbmdlID0gZnVuY3Rpb24oIHZhbHVlLCBsb3csIGhpZ2ggKSB7XG5cdHJldHVybiB2YWx1ZSA8IGxvdyB8fCB2YWx1ZSA+IGhpZ2g7XG59O1xuXG5cblxuXG4vKipcbiAqIHBhcnNlKCB2YWx1ZSwgdG9rZW5zLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBAdmFsdWUgW1N0cmluZ10gc3RyaW5nIGRhdGUuXG4gKlxuICogQHRva2VucyBbT2JqZWN0XSB0b2tlbnMgcmV0dXJuZWQgYnkgZGF0ZS90b2tlbml6ZXIuXG4gKlxuICogQHByb3BlcnRpZXMgW09iamVjdF0gb3V0cHV0IHJldHVybmVkIGJ5IGRhdGUvdG9rZW5pemVyLXByb3BlcnRpZXMuXG4gKlxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcbiAqL1xudmFyIGRhdGVQYXJzZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgdG9rZW5zLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgYW1QbSwgZGF5LCBkYXlzT2ZZZWFyLCBtb250aCwgZXJhLCBob3VyLCBob3VyMTIsIHRpbWV6b25lT2Zmc2V0LCB2YWxpZCxcblx0XHRZRUFSID0gMCxcblx0XHRNT05USCA9IDEsXG5cdFx0REFZID0gMixcblx0XHRIT1VSID0gMyxcblx0XHRNSU5VVEUgPSA0LFxuXHRcdFNFQ09ORCA9IDUsXG5cdFx0TUlMTElTRUNPTkRTID0gNixcblx0XHRkYXRlID0gbmV3IERhdGUoKSxcblx0XHR0cnVuY2F0ZUF0ID0gW10sXG5cdFx0dW5pdHMgPSBbIFwieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kc1wiIF07XG5cblx0Ly8gQ3JlYXRlIGdsb2JhbGl6ZSBkYXRlIHdpdGggZ2l2ZW4gdGltZXpvbmUgZGF0YS5cblx0aWYgKCBwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSApIHtcblx0XHRkYXRlID0gbmV3IFpvbmVkRGF0ZVRpbWUoIGRhdGUsIHByb3BlcnRpZXMudGltZVpvbmVEYXRhKCkgKTtcblx0fVxuXG5cdGlmICggIXRva2Vucy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YWxpZCA9IHRva2Vucy5ldmVyeShmdW5jdGlvbiggdG9rZW4gKSB7XG5cdFx0dmFyIGNlbnR1cnksIGNociwgdmFsdWUsIGxlbmd0aDtcblxuXHRcdGlmICggdG9rZW4udHlwZSA9PT0gXCJsaXRlcmFsXCIgKSB7XG5cblx0XHRcdC8vIGNvbnRpbnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRjaHIgPSB0b2tlbi50eXBlLmNoYXJBdCggMCApO1xuXHRcdGxlbmd0aCA9IHRva2VuLnR5cGUubGVuZ3RoO1xuXG5cdFx0aWYgKCBjaHIgPT09IFwialwiICkge1xuXG5cdFx0XHQvLyBMb2NhbGUgcHJlZmVycmVkIGhIS2suXG5cdFx0XHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjVGltZV9EYXRhXG5cdFx0XHRjaHIgPSBwcm9wZXJ0aWVzLnByZWZlcnJlZFRpbWVEYXRhO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGNociApIHtcblxuXHRcdFx0Ly8gRXJhXG5cdFx0XHRjYXNlIFwiR1wiOlxuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIFlFQVIgKTtcblx0XHRcdFx0ZXJhID0gK3Rva2VuLnZhbHVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0Y2FzZSBcInlcIjpcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XG5cdFx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgOTkgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBtaW1pYyBkb2pvL2RhdGUvbG9jYWxlOiBjaG9vc2UgY2VudHVyeSB0byBhcHBseSwgYWNjb3JkaW5nIHRvIGEgc2xpZGluZ1xuXHRcdFx0XHRcdC8vIHdpbmRvdyBvZiA4MCB5ZWFycyBiZWZvcmUgYW5kIDIwIHllYXJzIGFmdGVyIHByZXNlbnQgeWVhci5cblx0XHRcdFx0XHRjZW50dXJ5ID0gTWF0aC5mbG9vciggZGF0ZS5nZXRGdWxsWWVhcigpIC8gMTAwICkgKiAxMDA7XG5cdFx0XHRcdFx0dmFsdWUgKz0gY2VudHVyeTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlID4gZGF0ZS5nZXRGdWxsWWVhcigpICsgMjAgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSAtPSAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGUuc2V0RnVsbFllYXIoIHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggWUVBUiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIllcIjogLy8gWWVhciBpbiBcIldlZWsgb2YgWWVhclwiXG5cdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRmZWF0dXJlOiBcInllYXIgcGF0dGVybiBgXCIgKyBjaHIgKyBcImBcIlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gUXVhcnRlciAoc2tpcClcblx0XHRcdGNhc2UgXCJRXCI6XG5cdFx0XHRjYXNlIFwicVwiOlxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRjYXNlIFwiTFwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA8PSAyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSArdG9rZW4udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMSwgMTIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXR0aW5nIHRoZSBtb250aCBsYXRlciBzbyB0aGF0IHdlIGhhdmUgdGhlIGNvcnJlY3QgeWVhciBhbmQgY2FuIGRldGVybWluZVxuXHRcdFx0XHQvLyB0aGUgY29ycmVjdCBsYXN0IGRheSBvZiBGZWJydWFyeSBpbiBjYXNlIG9mIGxlYXAgeWVhci5cblx0XHRcdFx0bW9udGggPSB2YWx1ZTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBNT05USCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2VlayAoc2tpcClcblx0XHRcdGNhc2UgXCJ3XCI6IC8vIFdlZWsgb2YgWWVhci5cblx0XHRcdGNhc2UgXCJXXCI6IC8vIFdlZWsgb2YgTW9udGguXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBEYXlcblx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdGRheSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIERBWSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0ZGF5c09mWWVhciA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIERBWSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkZcIjpcblxuXHRcdFx0XHQvLyBEYXkgb2YgV2VlayBpbiBtb250aC4gZWcuIDJuZCBXZWQgaW4gSnVseS5cblx0XHRcdFx0Ly8gU2tpcFxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2VlayBkYXlcblx0XHRcdGNhc2UgXCJlXCI6XG5cdFx0XHRjYXNlIFwiY1wiOlxuXHRcdFx0Y2FzZSBcIkVcIjpcblxuXHRcdFx0XHQvLyBTa2lwLlxuXHRcdFx0XHQvLyB2YWx1ZSA9IGFycmF5SW5kZXhPZiggZGF0ZVdlZWtEYXlzLCB0b2tlbi52YWx1ZSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcblx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdGFtUG0gPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIEhvdXJcblx0XHRcdGNhc2UgXCJoXCI6IC8vIDEtMTJcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMSwgMTIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG91ciA9IGhvdXIxMiA9IHRydWU7XG5cdFx0XHRcdGRhdGUuc2V0SG91cnMoIHZhbHVlID09PSAxMiA/IDAgOiB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIEhPVVIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJLXCI6IC8vIDAtMTFcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgMTEgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG91ciA9IGhvdXIxMiA9IHRydWU7XG5cdFx0XHRcdGRhdGUuc2V0SG91cnMoIHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggSE9VUiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcImtcIjogLy8gMS0yNFxuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAxLCAyNCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob3VyID0gdHJ1ZTtcblx0XHRcdFx0ZGF0ZS5zZXRIb3VycyggdmFsdWUgPT09IDI0ID8gMCA6IHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggSE9VUiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkhcIjogLy8gMC0yM1xuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAwLCAyMyApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob3VyID0gdHJ1ZTtcblx0XHRcdFx0ZGF0ZS5zZXRIb3VycyggdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBIT1VSICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNaW51dGVcblx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDU5ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGUuc2V0TWludXRlcyggdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBNSU5VVEUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFNlY29uZFxuXHRcdFx0Y2FzZSBcInNcIjpcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgNTkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0ZS5zZXRTZWNvbmRzKCB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIFNFQ09ORCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkFcIjpcblx0XHRcdFx0ZGF0ZS5zZXRIb3VycyggMCApO1xuXHRcdFx0XHRkYXRlLnNldE1pbnV0ZXMoIDAgKTtcblx0XHRcdFx0ZGF0ZS5zZXRTZWNvbmRzKCAwICk7XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJTXCI6XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZCggdG9rZW4udmFsdWUgKiBNYXRoLnBvdyggMTAsIDMgLSBsZW5ndGggKSApO1xuXHRcdFx0XHRkYXRlLnNldE1pbGxpc2Vjb25kcyggdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBNSUxMSVNFQ09ORFMgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFpvbmVcblx0XHRcdGNhc2UgXCJ6XCI6XG5cdFx0XHRjYXNlIFwiWlwiOlxuXHRcdFx0Y2FzZSBcIk9cIjpcblx0XHRcdGNhc2UgXCJ2XCI6XG5cdFx0XHRjYXNlIFwiVlwiOlxuXHRcdFx0Y2FzZSBcIlhcIjpcblx0XHRcdGNhc2UgXCJ4XCI6XG5cdFx0XHRcdGlmICggdHlwZW9mIHRva2VuLnZhbHVlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdHRpbWV6b25lT2Zmc2V0ID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xuXG5cdGlmICggIXZhbGlkICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gMTItaG91ciBmb3JtYXQgbmVlZHMgQU0gb3IgUE0sIDI0LWhvdXIgZm9ybWF0IGRvZXNuJ3QsIGllLiByZXR1cm4gbnVsbFxuXHQvLyBpZiBhbVBtICYmICFob3VyMTIgfHwgIWFtUG0gJiYgaG91cjEyLlxuXHRpZiAoIGhvdXIgJiYgISggIWFtUG0gXiBob3VyMTIgKSApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICggZXJhID09PSAwICkge1xuXG5cdFx0Ly8gMSBCQyA9IHllYXIgMFxuXHRcdGRhdGUuc2V0RnVsbFllYXIoIGRhdGUuZ2V0RnVsbFllYXIoKSAqIC0xICsgMSApO1xuXHR9XG5cblx0aWYgKCBtb250aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGRhdGVTZXRNb250aCggZGF0ZSwgbW9udGggLSAxICk7XG5cdH1cblxuXHRpZiAoIGRheSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGlmICggb3V0T2ZSYW5nZSggZGF5LCAxLCBkYXRlTGFzdERheU9mTW9udGgoIGRhdGUgKSApICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0RGF0ZSggZGF5ICk7XG5cdH0gZWxzZSBpZiAoIGRheXNPZlllYXIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIG91dE9mUmFuZ2UoIGRheXNPZlllYXIsIDEsIGRhdGVJc0xlYXBZZWFyKCBkYXRlLmdldEZ1bGxZZWFyKCkgKSA/IDM2NiA6IDM2NSApICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0TW9udGgoIDAgKTtcblx0XHRkYXRlLnNldERhdGUoIGRheXNPZlllYXIgKTtcblx0fVxuXG5cdGlmICggaG91cjEyICYmIGFtUG0gPT09IFwicG1cIiApIHtcblx0XHRkYXRlLnNldEhvdXJzKCBkYXRlLmdldEhvdXJzKCkgKyAxMiApO1xuXHR9XG5cblx0aWYgKCB0aW1lem9uZU9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGRhdGUuc2V0TWludXRlcyggZGF0ZS5nZXRNaW51dGVzKCkgKyB0aW1lem9uZU9mZnNldCAtIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSApO1xuXHR9XG5cblx0Ly8gVHJ1bmNhdGUgZGF0ZSBhdCB0aGUgbW9zdCBwcmVjaXNlIHVuaXQgZGVmaW5lZC4gRWcuXG5cdC8vIElmIHZhbHVlIGlzIFwiMTIvMzFcIiwgYW5kIHBhdHRlcm4gaXMgXCJNTS9kZFwiOlxuXHQvLyA9PiBuZXcgRGF0ZSggPGN1cnJlbnQgWWVhcj4sIDEyLCAzMSwgMCwgMCwgMCwgMCApO1xuXHR0cnVuY2F0ZUF0ID0gTWF0aC5tYXguYXBwbHkoIG51bGwsIHRydW5jYXRlQXQgKTtcblx0ZGF0ZSA9IGRhdGVTdGFydE9mKCBkYXRlLCB1bml0c1sgdHJ1bmNhdGVBdCBdICk7XG5cblx0Ly8gR2V0IGRhdGUgYmFjayBmcm9tIGdsb2JhbGl6ZSBkYXRlLlxuXHRpZiAoIGRhdGUgaW5zdGFuY2VvZiBab25lZERhdGVUaW1lICkge1xuXHRcdGRhdGUgPSBkYXRlLnRvRGF0ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGRhdGU7XG59O1xuXG5cblxuXG4vKipcbiAqIHRva2VuaXplciggdmFsdWUsIG51bWJlclBhcnNlciwgcHJvcGVydGllcyApXG4gKlxuICogQHZhbHVlIFtTdHJpbmddIHN0cmluZyBkYXRlLlxuICpcbiAqIEBudW1iZXJQYXJzZXIgW0Z1bmN0aW9uXVxuICpcbiAqIEBwcm9wZXJ0aWVzIFtPYmplY3RdIG91dHB1dCByZXR1cm5lZCBieSBkYXRlL3Rva2VuaXplci1wcm9wZXJ0aWVzLlxuICpcbiAqIFJldHVybnMgYW4gQXJyYXkgb2YgdG9rZW5zLCBlZy4gdmFsdWUgXCI1IG8nY2xvY2sgUE1cIiwgcGF0dGVybiBcImggJ28nJ2Nsb2NrJyBhXCI6XG4gKiBbe1xuICogICB0eXBlOiBcImhcIixcbiAqICAgbGV4ZW1lOiBcIjVcIlxuICogfSwge1xuICogICB0eXBlOiBcImxpdGVyYWxcIixcbiAqICAgbGV4ZW1lOiBcIiBcIlxuICogfSwge1xuICogICB0eXBlOiBcImxpdGVyYWxcIixcbiAqICAgbGV4ZW1lOiBcIm8nY2xvY2tcIlxuICogfSwge1xuICogICB0eXBlOiBcImxpdGVyYWxcIixcbiAqICAgbGV4ZW1lOiBcIiBcIlxuICogfSwge1xuICogICB0eXBlOiBcImFcIixcbiAqICAgbGV4ZW1lOiBcIlBNXCIsXG4gKiAgIHZhbHVlOiBcInBtXCJcbiAqIH1dXG4gKlxuICogT0JTOiBsZXhlbWUncyBhcmUgYWx3YXlzIFN0cmluZyBhbmQgbWF5IHJldHVybiBpbnZhbGlkIHJhbmdlcyBkZXBlbmRpbmcgb2YgdGhlIHRva2VuIHR5cGUuXG4gKiBFZy4gXCI5OVwiIGZvciBtb250aCBudW1iZXIuXG4gKlxuICogUmV0dXJuIGFuIGVtcHR5IEFycmF5IHdoZW4gbm90IHN1Y2Nlc3NmdWxseSBwYXJzZWQuXG4gKi9cbnZhciBkYXRlVG9rZW5pemVyID0gZnVuY3Rpb24oIHZhbHVlLCBudW1iZXJQYXJzZXIsIHByb3BlcnRpZXMgKSB7XG5cdHZhciBkaWdpdHNSZSwgdmFsaWQsXG5cdFx0dG9rZW5zID0gW10sXG5cdFx0d2lkdGhzID0gWyBcImFiYnJldmlhdGVkXCIsIFwid2lkZVwiLCBcIm5hcnJvd1wiIF07XG5cblx0ZGlnaXRzUmUgPSBwcm9wZXJ0aWVzLmRpZ2l0c1JlO1xuXHR2YWx1ZSA9IGxvb3NlTWF0Y2hpbmcoIHZhbHVlICk7XG5cblx0dmFsaWQgPSBwcm9wZXJ0aWVzLnBhdHRlcm4ubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKS5ldmVyeShmdW5jdGlvbiggY3VycmVudCApIHtcblx0XHR2YXIgYXV4LCBjaHIsIGxlbmd0aCwgbnVtZXJpYywgdG9rZW5SZSxcblx0XHRcdHRva2VuID0ge307XG5cblx0XHRmdW5jdGlvbiBob3VyRm9ybWF0UGFyc2UoIHRva2VuUmUsIG51bWJlclBhcnNlciApIHtcblx0XHRcdHZhciBhdXgsIGlzUG9zaXRpdmUsXG5cdFx0XHRcdG1hdGNoID0gdmFsdWUubWF0Y2goIHRva2VuUmUgKTtcblx0XHRcdG51bWJlclBhcnNlciA9IG51bWJlclBhcnNlciB8fCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpc1Bvc2l0aXZlID0gbWF0Y2hbIDEgXTtcblxuXHRcdFx0Ly8gaG91ckZvcm1hdCBjb250YWluaW5nIEggb25seSwgZS5nLiwgYCtIOy1IYFxuXHRcdFx0aWYgKCBtYXRjaC5sZW5ndGggPCA2ICkge1xuXHRcdFx0XHRhdXggPSBpc1Bvc2l0aXZlID8gMSA6IDM7XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gbnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4IF0gKSAqIDYwO1xuXG5cdFx0XHQvLyBob3VyRm9ybWF0IGNvbnRhaW5pbmcgSCBhbmQgbSwgZS5nLiwgYCtISG1tOy1ISG1tYFxuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2gubGVuZ3RoIDwgMTAgKSB7XG5cdFx0XHRcdGF1eCA9IGlzUG9zaXRpdmUgPyBbIDEsIDMgXSA6IFsgNSwgNyBdO1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IG51bWJlclBhcnNlciggbWF0Y2hbIGF1eFsgMCBdIF0gKSAqIDYwICtcblx0XHRcdFx0XHRudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDEgXSBdICk7XG5cblx0XHRcdC8vIGhvdXJGb3JtYXQgY29udGFpbmluZyBILCBtLCBhbmQgcyBlLmcuLCBgK0hIbW1zczstSEhtbXNzYFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXV4ID0gaXNQb3NpdGl2ZSA/IFsgMSwgMywgNSBdIDogWyA3LCA5LCAxMSBdO1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IG51bWJlclBhcnNlciggbWF0Y2hbIGF1eFsgMCBdIF0gKSAqIDYwICtcblx0XHRcdFx0XHRudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDEgXSBdICkgK1xuXHRcdFx0XHRcdG51bWJlclBhcnNlciggbWF0Y2hbIGF1eFsgMiBdIF0gKSAvIDYwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzUG9zaXRpdmUgKSB7XG5cdFx0XHRcdHRva2VuLnZhbHVlICo9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbmVEaWdpdElmTGVuZ3RoT25lKCkge1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGQvXG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5SZSA9IGRpZ2l0c1JlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmUoKSB7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZFxcZD8vXG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXsxLDJ9XCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbmVPclR3b0RpZ2l0c0lmTGVuZ3RoT25lT3JUd28oKSB7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGRcXGQ/L1xuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7MSwyfVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHdvRGlnaXRzSWZMZW5ndGhUd28oKSB7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcblxuXHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZFxcZC9cblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpezJ9XCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBCcnV0ZS1mb3JjZSB0ZXN0IGV2ZXJ5IGxvY2FsZSBlbnRyeSBpbiBhbiBhdHRlbXB0IHRvIG1hdGNoIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQvLyBSZXR1cm4gdGhlIGZpcnN0IGZvdW5kIG9uZSAoYW5kIHNldCB0b2tlbiBhY2NvcmRpbmdseSksIG9yIG51bGwuXG5cdFx0ZnVuY3Rpb24gbG9va3VwKCBwYXRoICkge1xuXHRcdFx0dmFyIGFycmF5ID0gcHJvcGVydGllc1sgcGF0aC5qb2luKCBcIi9cIiApIF07XG5cblx0XHRcdGlmICggIWFycmF5ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXJyYXkgb2YgcGFpcnMgW2tleSwgdmFsdWVdIHNvcnRlZCBieSBkZXNjIHZhbHVlIGxlbmd0aC5cblx0XHRcdGFycmF5LnNvbWUoZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZVJlID0gaXRlbVsgMSBdO1xuXHRcdFx0XHRpZiAoIHZhbHVlUmUudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IGl0ZW1bIDAgXTtcblx0XHRcdFx0XHR0b2tlblJlID0gaXRlbVsgMSBdO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHRva2VuLnR5cGUgPSBjdXJyZW50O1xuXHRcdGNociA9IGN1cnJlbnQuY2hhckF0KCAwICk7XG5cdFx0bGVuZ3RoID0gY3VycmVudC5sZW5ndGg7XG5cblx0XHRpZiAoIGNociA9PT0gXCJaXCIgKSB7XG5cblx0XHRcdC8vIFouLlpaWjogc2FtZSBhcyBcInh4eHhcIi5cblx0XHRcdGlmICggbGVuZ3RoIDwgNCApIHtcblx0XHRcdFx0Y2hyID0gXCJ4XCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cblx0XHRcdC8vIFpaWlo6IHNhbWUgYXMgXCJPT09PXCIuXG5cdFx0XHR9IGVsc2UgaWYgKCBsZW5ndGggPCA1ICkge1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblxuXHRcdFx0Ly8gWlpaWlo6IHNhbWUgYXMgXCJYWFhYWFwiXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHIgPSBcIlhcIjtcblx0XHRcdFx0bGVuZ3RoID0gNTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGNociA9PT0gXCJ6XCIgKSB7XG5cdFx0XHRpZiAoIHByb3BlcnRpZXMuc3RhbmRhcmRPckRheWxpZ2h0VHpOYW1lICkge1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IG51bGw7XG5cdFx0XHRcdHRva2VuUmUgPSBwcm9wZXJ0aWVzLnN0YW5kYXJkT3JEYXlsaWdodFR6TmFtZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB2Li4udnZ2OiBcIntzaG9ydFJlZ2lvbn1cIiwgZWcuIFwiUFRcIi5cblx0XHQvLyB2dnZ2OiBcIntyZWdpb25OYW1lfSB7VGltZX1cIiBvciBcIntyZWdpb25OYW1lfSB7VGltZX1cIixcblx0XHQvLyBlLmcuLCBcIlBhY2lmaWMgVGltZVwiXG5cdFx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcblx0XHRpZiAoIGNociA9PT0gXCJ2XCIgKSB7XG5cdFx0XHRpZiAoIHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZSApIHtcblx0XHRcdFx0dG9rZW4udmFsdWUgPSBudWxsO1xuXHRcdFx0XHR0b2tlblJlID0gcHJvcGVydGllcy5nZW5lcmljVHpOYW1lO1xuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gXCJWXCIgZm9ybWF0LlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hyID0gXCJWXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBjaHIgPT09IFwiVlwiICYmIHByb3BlcnRpZXMudGltZVpvbmVOYW1lICkge1xuXHRcdFx0dG9rZW4udmFsdWUgPSBsZW5ndGggPT09IDIgPyBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA6IG51bGw7XG5cdFx0XHR0b2tlblJlID0gcHJvcGVydGllcy50aW1lWm9uZU5hbWVSZTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBjaHIgKSB7XG5cblx0XHRcdC8vIEVyYVxuXHRcdFx0Y2FzZSBcIkdcIjpcblx0XHRcdFx0bG9va3VwKFtcblx0XHRcdFx0XHRcImdyZWdvcmlhbi9lcmFzXCIsXG5cdFx0XHRcdFx0bGVuZ3RoIDw9IDMgPyBcImVyYUFiYnJcIiA6ICggbGVuZ3RoID09PSA0ID8gXCJlcmFOYW1lc1wiIDogXCJlcmFOYXJyb3dcIiApXG5cdFx0XHRcdF0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0Y2FzZSBcInlcIjpcblx0XHRcdGNhc2UgXCJZXCI6XG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIG51bWJlciBsPTE6KywgbD0yOnsyfSwgbD0zOnszLH0sIGw9NDp7NCx9LCAuLi5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZCsvLlxuXHRcdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIikrXCIgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggbGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdFx0Ly8gTGVuaWVudCBwYXJzaW5nOiB0aGVyZSdzIG5vIHllYXIgcGF0dGVybiB0byBpbmRpY2F0ZSBub24temVyby1wYWRkZWQgMi1kaWdpdHNcblx0XHRcdFx0XHQvLyB5ZWFyLCBzbyBwYXJzZXIgYWNjZXB0cyBib3RoIHplcm8tcGFkZGVkIGFuZCBub24temVyby1wYWRkZWQgZm9yIGB5eWAuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZFxcZD8vXG5cdFx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXsxLDJ9XCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxke2xlbmd0aCx9L1xuXHRcdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7XCIgKyBsZW5ndGggKyBcIix9XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUXVhcnRlclxuXHRcdFx0Y2FzZSBcIlFcIjpcblx0XHRcdGNhc2UgXCJxXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGw9MTp7MX0sIGw9Mjp7Mn0uXG5cdFx0XHRcdC8vIGxvb2t1cCBsPTMuLi5cblx0XHRcdFx0b25lRGlnaXRJZkxlbmd0aE9uZSgpIHx8IHR3b0RpZ2l0c0lmTGVuZ3RoVHdvKCkgfHxcblx0XHRcdFx0XHRsb29rdXAoW1xuXHRcdFx0XHRcdFx0XCJncmVnb3JpYW4vcXVhcnRlcnNcIixcblx0XHRcdFx0XHRcdGNociA9PT0gXCJRXCIgPyBcImZvcm1hdFwiIDogXCJzdGFuZC1hbG9uZVwiLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1vbnRoXG5cdFx0XHRjYXNlIFwiTVwiOlxuXHRcdFx0Y2FzZSBcIkxcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbD0xOnsxLDJ9LCBsPTI6ezJ9LlxuXHRcdFx0XHQvLyBsb29rdXAgbD0zLi4uXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIExlbmllbnQgcGFyc2luZzogc2tlbGV0b24gXCJ5TWRcIiAoaS5lLiwgb25lIE0pIG1heSBpbmNsdWRlIE1NIGZvciB0aGUgcGF0dGVybixcblx0XHRcdFx0Ly8gdGhlcmVmb3JlIHBhcnNlciBhY2NlcHRzIGJvdGggemVyby1wYWRkZWQgYW5kIG5vbi16ZXJvLXBhZGRlZCBmb3IgTSBhbmQgTU0uXG5cdFx0XHRcdC8vIFNpbWlsYXIgZm9yIEwuXG5cdFx0XHRcdG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmVPclR3bygpIHx8IGxvb2t1cChbXG5cdFx0XHRcdFx0XCJncmVnb3JpYW4vbW9udGhzXCIsXG5cdFx0XHRcdFx0Y2hyID09PSBcIk1cIiA/IFwiZm9ybWF0XCIgOiBcInN0YW5kLWFsb25lXCIsXG5cdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cblx0XHRcdFx0XSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBEYXlcblx0XHRcdGNhc2UgXCJEXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIHtsLDN9LlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA8PSAzICkge1xuXG5cdFx0XHRcdFx0Ly8gRXF1aXZhbGVudCB0byAvXFxke2xlbmd0aCwzfS9cblx0XHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpe1wiICsgbGVuZ3RoICsgXCIsM31cIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiV1wiOlxuXHRcdFx0Y2FzZSBcIkZcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbD0xOnsxfS5cblx0XHRcdFx0b25lRGlnaXRJZkxlbmd0aE9uZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2VlayBkYXlcblx0XHRcdGNhc2UgXCJlXCI6XG5cdFx0XHRjYXNlIFwiY1wiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsPTE6ezF9LCBsPTI6ezJ9LlxuXHRcdFx0XHQvLyBsb29rdXAgZm9yIGxlbmd0aCA+PTMuXG5cdFx0XHRcdGlmICggbGVuZ3RoIDw9IDIgKSB7XG5cdFx0XHRcdFx0b25lRGlnaXRJZkxlbmd0aE9uZSgpIHx8IHR3b0RpZ2l0c0lmTGVuZ3RoVHdvKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIkVcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHQvLyBOb3RlOiBpZiBzaG9ydCBkYXkgbmFtZXMgYXJlIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgYWJicmV2aWF0ZWQgZGF5XG5cdFx0XHRcdFx0Ly8gbmFtZXMgYXJlIHVzZWQgaW5zdGVhZCBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjbW9udGhzX2RheXNfcXVhcnRlcnNfZXJhc1xuXHRcdFx0XHRcdGxvb2t1cChbXG5cdFx0XHRcdFx0XHRcImdyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRbIGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiIF0sXG5cdFx0XHRcdFx0XHRcInNob3J0XCJcblx0XHRcdFx0XHRdKSB8fCBsb29rdXAoW1xuXHRcdFx0XHRcdFx0XCJncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0WyBjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIiBdLFxuXHRcdFx0XHRcdFx0XCJhYmJyZXZpYXRlZFwiXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9va3VwKFtcblx0XHRcdFx0XHRcdFwiZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFsgY2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIgXSxcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIDwgMyA/IDAgOiBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcblx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdGxvb2t1cChbXG5cdFx0XHRcdFx0XCJncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZVwiXG5cdFx0XHRcdF0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2Vla1xuXHRcdFx0Y2FzZSBcIndcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbDE6ezEsMn0sIGwyOnsyfS5cblx0XHRcdFx0b25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZSgpIHx8IHR3b0RpZ2l0c0lmTGVuZ3RoVHdvKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBEYXksIEhvdXIsIE1pbnV0ZSwgb3IgU2Vjb25kXG5cdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0Y2FzZSBcImhcIjpcblx0XHRcdGNhc2UgXCJIXCI6XG5cdFx0XHRjYXNlIFwiS1wiOlxuXHRcdFx0Y2FzZSBcImtcIjpcblx0XHRcdGNhc2UgXCJqXCI6XG5cdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0Y2FzZSBcInNcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbDE6ezEsMn0sIGwyOnsyfS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gTGVuaWVudCBwYXJzaW5nOlxuXHRcdFx0XHQvLyAtIHNrZWxldG9uIFwiaG1zXCIgKGkuZS4sIG9uZSBtKSBhbHdheXMgaW5jbHVkZXMgbW0gZm9yIHRoZSBwYXR0ZXJuLCBpLmUuLCBpdCdzXG5cdFx0XHRcdC8vICAgaW1wb3NzaWJsZSB0byB1c2UgYSBkaWZmZXJlbnQgc2tlbGV0b24gdG8gcGFyc2Ugbm9uLXplcm8tcGFkZGVkIG1pbnV0ZXMsXG5cdFx0XHRcdC8vICAgdGhlcmVmb3JlIHBhcnNlciBhY2NlcHRzIGJvdGggemVyby1wYWRkZWQgYW5kIG5vbi16ZXJvLXBhZGRlZCBmb3IgbS4gU2ltaWxhclxuXHRcdFx0XHQvLyAgIGZvciBzZWNvbmRzIHMuXG5cdFx0XHRcdC8vIC0gc2tlbGV0b24gXCJobXNcIiAoaS5lLiwgb25lIGgpIG1heSBpbmNsdWRlIGggb3IgaGggZm9yIHRoZSBwYXR0ZXJuLCBpLmUuLCBpdCdzXG5cdFx0XHRcdC8vICAgaW1wb3NzaWJsZSB0byB1c2UgYSBkaWZmZXJlbnQgc2tlbGV0b24gdG8gcGFyc2VyIG5vbi16ZXJvLXBhZGRlZCBob3VycyBmb3Igc29tZVxuXHRcdFx0XHQvLyAgIGxvY2FsZXMsIHRoZXJlZm9yZSBwYXJzZXIgYWNjZXB0cyBib3RoIHplcm8tcGFkZGVkIGFuZCBub24temVyby1wYWRkZWQgZm9yIGguXG5cdFx0XHRcdC8vICAgU2ltaWxhciBmb3IgZCAoaW4gc2tlbGV0b24geU1kKS5cblx0XHRcdFx0b25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZU9yVHdvKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiU1wiOlxuXG5cdFx0XHRcdC8vIG51bWJlciB7bH0uXG5cblx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGR7bGVuZ3RofS9cblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7XCIgKyBsZW5ndGggKyBcIn1cIiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkFcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIge2wrNX0uXG5cblx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGR7bGVuZ3RoKzV9L1xuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXtcIiArICggbGVuZ3RoICsgNSApICsgXCJ9XCIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFpvbmVcblx0XHRcdGNhc2UgXCJ2XCI6XG5cdFx0XHRjYXNlIFwiVlwiOlxuXHRcdFx0Y2FzZSBcInpcIjpcblx0XHRcdFx0aWYgKCB0b2tlblJlICYmIHRva2VuUmUudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNociA9PT0gXCJWXCIgJiYgbGVuZ3RoID09PSAyICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJPXCI6XG5cblx0XHRcdFx0Ly8gTzogXCJ7Z210Rm9ybWF0fStIO3tnbXRGb3JtYXR9LUhcIiBvciBcIntnbXRaZXJvRm9ybWF0fVwiLCBlZy4gXCJHTVQtOFwiIG9yIFwiR01UXCIuXG5cdFx0XHRcdC8vIE9PT086IFwie2dtdEZvcm1hdH17aG91ckZvcm1hdH1cIiBvciBcIntnbXRaZXJvRm9ybWF0fVwiLCBlZy4gXCJHTVQtMDg6MDBcIiBvciBcIkdNVFwiLlxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFwiIF0gKSB7XG5cdFx0XHRcdFx0dG9rZW4udmFsdWUgPSAwO1xuXHRcdFx0XHRcdHRva2VuUmUgPSBwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFJlXCIgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdXggPSBwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvaG91ckZvcm1hdFwiIF0uc29tZShmdW5jdGlvbiggaG91ckZvcm1hdFJlICkge1xuXHRcdFx0XHRcdFx0aWYgKCBob3VyRm9ybWF0UGFyc2UoIGhvdXJGb3JtYXRSZSwgbnVtYmVyUGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0XHRcdHRva2VuUmUgPSBob3VyRm9ybWF0UmU7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmICggIWF1eCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIlhcIjpcblxuXHRcdFx0XHQvLyBTYW1lIGFzIHgqLCBleGNlcHQgaXQgdXNlcyBcIlpcIiBmb3IgemVybyBvZmZzZXQuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiWlwiICkge1xuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gMDtcblx0XHRcdFx0XHR0b2tlblJlID0gL15aLztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwieFwiOlxuXG5cdFx0XHRcdC8vIHg6IGhvdXJGb3JtYXQoXCIrSEhbbW1dOy1ISFttbV1cIilcblx0XHRcdFx0Ly8geHg6IGhvdXJGb3JtYXQoXCIrSEhtbTstSEhtbVwiKVxuXHRcdFx0XHQvLyB4eHg6IGhvdXJGb3JtYXQoXCIrSEg6bW07LUhIOm1tXCIpXG5cdFx0XHRcdC8vIHh4eHg6IGhvdXJGb3JtYXQoXCIrSEhtbVtzc107LUhIbW1bc3NdXCIpXG5cdFx0XHRcdC8vIHh4eHh4OiBob3VyRm9ybWF0KFwiK0hIOm1tWzpzc107LUhIOm1tWzpzc11cIilcblx0XHRcdFx0YXV4ID0gcHJvcGVydGllcy54LnNvbWUoZnVuY3Rpb24oIGhvdXJGb3JtYXRSZSApIHtcblx0XHRcdFx0XHRpZiAoIGhvdXJGb3JtYXRQYXJzZSggaG91ckZvcm1hdFJlICkgKSB7XG5cdFx0XHRcdFx0XHR0b2tlblJlID0gaG91ckZvcm1hdFJlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKCAhYXV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHR0b2tlbi50eXBlID0gXCJsaXRlcmFsXCI7XG5cdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggcmVtb3ZlTGl0ZXJhbFF1b3RlcyggY3VycmVudCApICkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRva2VuLnR5cGUgPSBcImxpdGVyYWxcIjtcblx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBjdXJyZW50ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoICF0b2tlblJlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEdldCBsZXhlbWUgYW5kIGNvbnN1bWUgaXQuXG5cdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCB0b2tlblJlLCBmdW5jdGlvbiggbGV4ZW1lICkge1xuXHRcdFx0dG9rZW4ubGV4ZW1lID0gbGV4ZW1lO1xuXHRcdFx0aWYgKCBudW1lcmljICkge1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IG51bWJlclBhcnNlciggbGV4ZW1lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9KTtcblxuXHRcdGlmICggIXRva2VuLmxleGVtZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIG51bWVyaWMgJiYgaXNOYU4oIHRva2VuLnZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xuXG5cdGlmICggdmFsdWUgIT09IFwiXCIgKSB7XG5cdFx0dmFsaWQgPSBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB2YWxpZCA/IHRva2VucyA6IFtdO1xufTtcblxuXG5cblxudmFyIGRhdGVQYXJzZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJQYXJzZXIsIHBhcnNlUHJvcGVydGllcywgdG9rZW5pemVyUHJvcGVydGllcyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGRhdGVQYXJzZXIoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnM7XG5cblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHR0b2tlbnMgPSBkYXRlVG9rZW5pemVyKCB2YWx1ZSwgbnVtYmVyUGFyc2VyLCB0b2tlbml6ZXJQcm9wZXJ0aWVzICk7XG5cdFx0cmV0dXJuIGRhdGVQYXJzZSggdmFsdWUsIHRva2VucywgcGFyc2VQcm9wZXJ0aWVzICkgfHwgbnVsbDtcblx0fTtcbn07XG5cblxuXG5cbnZhciBvYmplY3RGaWx0ZXIgPSBmdW5jdGlvbiggb2JqZWN0LCB0ZXN0UmUgKSB7XG5cdHZhciBrZXksXG5cdFx0Y29weSA9IHt9O1xuXG5cdGZvciAoIGtleSBpbiBvYmplY3QgKSB7XG5cdFx0aWYgKCB0ZXN0UmUudGVzdCgga2V5ICkgKSB7XG5cdFx0XHRjb3B5WyBrZXkgXSA9IG9iamVjdFsga2V5IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvcHk7XG59O1xuXG5cblxuXG4vKipcbiAqIHRva2VuaXplclByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgKVxuICpcbiAqIEBwYXR0ZXJuIFtTdHJpbmddIHJhdyBwYXR0ZXJuLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gT2JqZWN0IHdpdGggZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBieSB0b2tlbml6ZXIuXG4gKi9cbnZhciBkYXRlVG9rZW5pemVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBjbGRyLCB0aW1lWm9uZSApIHtcblx0dmFyIGRpZ2l0c1JlU291cmNlLFxuXHRcdHByb3BlcnRpZXMgPSB7XG5cdFx0XHRwYXR0ZXJuOiBsb29zZU1hdGNoaW5nKCBwYXR0ZXJuIClcblx0XHR9LFxuXHRcdHRpbWVTZXBhcmF0b3IgPSBudW1iZXJTeW1ib2woIFwidGltZVNlcGFyYXRvclwiLCBjbGRyICksXG5cdFx0d2lkdGhzID0gWyBcImFiYnJldmlhdGVkXCIsIFwid2lkZVwiLCBcIm5hcnJvd1wiIF07XG5cblx0ZGlnaXRzUmVTb3VyY2UgPSBudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAoIGNsZHIgKTtcblx0ZGlnaXRzUmVTb3VyY2UgPSBkaWdpdHNSZVNvdXJjZSA/IFwiW1wiICsgZGlnaXRzUmVTb3VyY2UgKyBcIl1cIiA6IFwiXFxcXGRcIjtcblx0cHJvcGVydGllcy5kaWdpdHNSZSA9IG5ldyBSZWdFeHAoIGRpZ2l0c1JlU291cmNlICk7XG5cblx0Ly8gVHJhbnNmb3JtOlxuXHQvLyAtIFwiK0g7LUhcIiAtPiAvXFwrKFxcZFxcZD8pfC0oXFxkXFxkPykvXG5cdC8vIC0gXCIrSEg7LUhIXCIgLT4gL1xcKyhcXGRcXGQpfC0oXFxkXFxkKS9cblx0Ly8gLSBcIitISG1tOy1ISG1tXCIgLT4gL1xcKyhcXGRcXGQpKFxcZFxcZCl8LShcXGRcXGQpKFxcZFxcZCkvXG5cdC8vIC0gXCIrSEg6bW07LUhIOm1tXCIgLT4gL1xcKyhcXGRcXGQpOihcXGRcXGQpfC0oXFxkXFxkKTooXFxkXFxkKS9cblx0Ly9cblx0Ly8gSWYgZ210Rm9ybWF0IGlzIEdNVHswfSwgdGhlIHJlZ2V4cCBtdXN0IGZpbGwgezB9IGluIGVhY2ggc2lkZSwgZS5nLjpcblx0Ly8gLSBcIitIOy1IXCIgLT4gL0dNVFxcKyhcXGRcXGQ/KXxHTVQtKFxcZFxcZD8pL1xuXHRmdW5jdGlvbiBob3VyRm9ybWF0UmUoIGhvdXJGb3JtYXQsIGdtdEZvcm1hdCwgZGlnaXRzUmVTb3VyY2UsIHRpbWVTZXBhcmF0b3IgKSB7XG5cdFx0dmFyIHJlO1xuXG5cdFx0aWYgKCAhZGlnaXRzUmVTb3VyY2UgKSB7XG5cdFx0XHRkaWdpdHNSZVNvdXJjZSA9IFwiXFxcXGRcIjtcblx0XHR9XG5cdFx0aWYgKCAhZ210Rm9ybWF0ICkge1xuXHRcdFx0Z210Rm9ybWF0ID0gXCJ7MH1cIjtcblx0XHR9XG5cblx0XHRyZSA9IGhvdXJGb3JtYXRcblx0XHRcdC5yZXBsYWNlKCBcIitcIiwgXCJcXFxcK1wiIClcblxuXHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIChcXFxcZFxcXFxkKVxuXHRcdFx0LnJlcGxhY2UoIC9ISHxtbXxzcy9nLCBcIigoXCIgKyBkaWdpdHNSZVNvdXJjZSArIFwiKXsyfSlcIiApXG5cblx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAoXFxcXGRcXFxcZD8pXG5cdFx0XHQucmVwbGFjZSggL0h8bS9nLCBcIigoXCIgKyBkaWdpdHNSZVNvdXJjZSArIFwiKXsxLDJ9KVwiICk7XG5cblx0XHRpZiAoIHRpbWVTZXBhcmF0b3IgKSB7XG5cdFx0XHRyZSA9IHJlLnJlcGxhY2UoIC86L2csIHRpbWVTZXBhcmF0b3IgKTtcblx0XHR9XG5cblx0XHRyZSA9IHJlLnNwbGl0KCBcIjtcIiApLm1hcChmdW5jdGlvbiggcGFydCApIHtcblx0XHRcdHJldHVybiBnbXRGb3JtYXQucmVwbGFjZSggXCJ7MH1cIiwgcGFydCApO1xuXHRcdH0pLmpvaW4oIFwifFwiICk7XG5cblx0XHRyZXR1cm4gbmV3IFJlZ0V4cCggXCJeXCIgKyByZSApO1xuXHR9XG5cblx0ZnVuY3Rpb24gcG9wdWxhdGVQcm9wZXJ0aWVzKCBwYXRoLCB2YWx1ZSApIHtcblxuXHRcdC8vIFNraXBcblx0XHR2YXIgc2tpcFJlID0gLyh0aW1lWm9uZU5hbWVzXFwvem9uZXxzdXBwbGVtZW50YWxcXC9tZXRhWm9uZXN8dGltZVpvbmVOYW1lc1xcL21ldGF6b25lfHRpbWVab25lTmFtZXNcXC9yZWdpb25Gb3JtYXR8dGltZVpvbmVOYW1lc1xcL2dtdEZvcm1hdCkvO1xuXHRcdGlmICggc2tpcFJlLnRlc3QoIHBhdGggKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUaGUgYGRhdGVzYCBhbmQgYGNhbGVuZGFyc2AgdHJpbSdzIHB1cnBvc2UgaXMgdG8gcmVkdWNlIHByb3BlcnRpZXMnIGtleSBzaXplIG9ubHkuXG5cdFx0cGF0aCA9IHBhdGgucmVwbGFjZSggL14uKlxcL2RhdGVzXFwvLywgXCJcIiApLnJlcGxhY2UoIC9jYWxlbmRhcnNcXC8vLCBcIlwiICk7XG5cblx0XHQvLyBTcGVjaWZpYyBmaWx0ZXIgZm9yIFwiZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGVcIi5cblx0XHRpZiAoIHBhdGggPT09IFwiZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGVcIiApIHtcblx0XHRcdHZhbHVlID0gb2JqZWN0RmlsdGVyKCB2YWx1ZSwgL15hbXxecG0vICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJhbnNmb3JtIG9iamVjdCBpbnRvIGFycmF5IG9mIHBhaXJzIFtrZXksIC92YWx1ZS9dLCBzb3J0IGJ5IGRlc2MgdmFsdWUgbGVuZ3RoLlxuXHRcdGlmICggaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdHZhbHVlID0gT2JqZWN0LmtleXMoIHZhbHVlICkubWFwKGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBbIGtleSwgbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIGxvb3NlTWF0Y2hpbmcoIHZhbHVlWyBrZXkgXSApICkgKSBdO1xuXHRcdFx0fSkuc29ydChmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0cmV0dXJuIGJbIDEgXS5zb3VyY2UubGVuZ3RoIC0gYVsgMSBdLnNvdXJjZS5sZW5ndGg7XG5cdFx0XHR9KTtcblxuXHRcdC8vIElmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIi5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBsb29zZU1hdGNoaW5nKCB2YWx1ZSApO1xuXHRcdH1cblx0XHRwcm9wZXJ0aWVzWyBwYXRoIF0gPSB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlZ2V4cFNvdXJjZVNvbWVUZXJtKCB0ZXJtcyApIHtcblx0XHRyZXR1cm4gXCIoXCIgKyB0ZXJtcy5maWx0ZXIoZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9KS5yZWR1Y2UoZnVuY3Rpb24oIG1lbW8sIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gbWVtbyArIFwifFwiICsgaXRlbTtcblx0XHR9KSArIFwiKVwiO1xuXHR9XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgcG9wdWxhdGVQcm9wZXJ0aWVzICk7XG5cblx0cGF0dGVybi5tYXRjaCggZGF0ZVBhdHRlcm5SZSApLmZvckVhY2goZnVuY3Rpb24oIGN1cnJlbnQgKSB7XG5cdFx0dmFyIGF1eCwgY2hyLCBkYXlsaWdodFR6TmFtZSwgZ210Rm9ybWF0LCBsZW5ndGgsIHN0YW5kYXJkVHpOYW1lO1xuXG5cdFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKTtcblx0XHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcblxuXHRcdGlmICggY2hyID09PSBcIlpcIiApIHtcblx0XHRcdGlmICggbGVuZ3RoIDwgNSApIHtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHIgPSBcIlhcIjtcblx0XHRcdFx0bGVuZ3RoID0gNTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB6Li4uenp6OiBcIntzaG9ydFJlZ2lvbn1cIiwgZWcuIFwiUFNUXCIgb3IgXCJQRFRcIi5cblx0XHQvLyB6enp6OiBcIntyZWdpb25OYW1lfSB7U3RhbmRhcmQgVGltZX1cIiBvciBcIntyZWdpb25OYW1lfSB7RGF5bGlnaHQgVGltZX1cIixcblx0XHQvLyAgICAgICBlLmcuLCBcIlBhY2lmaWMgU3RhbmRhcmQgVGltZVwiIG9yIFwiUGFjaWZpYyBEYXlsaWdodCBUaW1lXCIuXG5cdFx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcblx0XHRpZiAoIGNociA9PT0gXCJ6XCIgKSB7XG5cdFx0XHRzdGFuZGFyZFR6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXCJzdGFuZGFyZFwiLCB0aW1lWm9uZSwgY2xkciApO1xuXHRcdFx0ZGF5bGlnaHRUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFwiZGF5bGlnaHRcIiwgdGltZVpvbmUsIGNsZHIgKTtcblx0XHRcdGlmICggc3RhbmRhcmRUek5hbWUgKSB7XG5cdFx0XHRcdHN0YW5kYXJkVHpOYW1lID0gcmVnZXhwRXNjYXBlKCBsb29zZU1hdGNoaW5nKCBzdGFuZGFyZFR6TmFtZSApICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRheWxpZ2h0VHpOYW1lICkge1xuXHRcdFx0XHRkYXlsaWdodFR6TmFtZSA9IHJlZ2V4cEVzY2FwZSggbG9vc2VNYXRjaGluZyggZGF5bGlnaHRUek5hbWUgKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBzdGFuZGFyZFR6TmFtZSB8fCBkYXlsaWdodFR6TmFtZSApIHtcblx0XHRcdFx0cHJvcGVydGllcy5zdGFuZGFyZE9yRGF5bGlnaHRUek5hbWUgPSBuZXcgUmVnRXhwKFxuXHRcdFx0XHRcdFwiXlwiICsgcmVnZXhwU291cmNlU29tZVRlcm0oWyBzdGFuZGFyZFR6TmFtZSwgZGF5bGlnaHRUek5hbWUgXSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbCB0aHJvdWdoIHRoZSBcIk9cIiBmb3JtYXQgaW4gY2FzZSBvbmUgbmFtZSBpcyBtaXNzaW5nLlxuXHRcdFx0aWYgKCAhc3RhbmRhcmRUek5hbWUgfHwgIWRheWxpZ2h0VHpOYW1lICkge1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdFx0aWYgKCBsZW5ndGggPCA0ICkge1xuXHRcdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB2Li4udnZ2OiBcIntzaG9ydFJlZ2lvbn1cIiwgZWcuIFwiUFRcIi5cblx0XHQvLyB2dnZ2OiBcIntyZWdpb25OYW1lfSB7VGltZX1cIiBvciBcIntyZWdpb25OYW1lfSB7VGltZX1cIixcblx0XHQvLyBlLmcuLCBcIlBhY2lmaWMgVGltZVwiXG5cdFx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcblx0XHRpZiAoIGNociA9PT0gXCJ2XCIgKSB7XG5cdFx0XHRpZiAoIGxlbmd0aCAhPT0gMSAmJiBsZW5ndGggIT09IDQgKSB7XG5cdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRmZWF0dXJlOiBcInRpbWV6b25lIHBhdHRlcm4gYFwiICsgcGF0dGVybiArIFwiYFwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGdlbmVyaWNUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFwiZ2VuZXJpY1wiLCB0aW1lWm9uZSwgY2xkciApO1xuXHRcdFx0aWYgKCBnZW5lcmljVHpOYW1lICkge1xuXHRcdFx0XHRwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWUgPSBuZXcgUmVnRXhwKFxuXHRcdFx0XHRcdFwiXlwiICsgcmVnZXhwRXNjYXBlKCBsb29zZU1hdGNoaW5nKCBnZW5lcmljVHpOYW1lICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblxuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIFwiVlwiIGZvcm1hdC5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNociA9IFwiVlwiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGNociApIHtcblxuXHRcdFx0Ly8gRXJhXG5cdFx0XHRjYXNlIFwiR1wiOlxuXHRcdFx0XHRjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9lcmFzXCIsXG5cdFx0XHRcdFx0bGVuZ3RoIDw9IDMgPyBcImVyYUFiYnJcIiA6ICggbGVuZ3RoID09PSA0ID8gXCJlcmFOYW1lc1wiIDogXCJlcmFOYXJyb3dcIiApXG5cdFx0XHRcdF0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0Y2FzZSBcInVcIjogLy8gRXh0ZW5kZWQgeWVhci4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHRcdGNhc2UgXCJVXCI6IC8vIEN5Y2xpYyB5ZWFyIG5hbWUuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXG5cdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRmZWF0dXJlOiBcInllYXIgcGF0dGVybiBgXCIgKyBjaHIgKyBcImBcIlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gUXVhcnRlclxuXHRcdFx0Y2FzZSBcIlFcIjpcblx0XHRcdGNhc2UgXCJxXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gMiApIHtcblx0XHRcdFx0XHRjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL3F1YXJ0ZXJzXCIsXG5cdFx0XHRcdFx0XHRjaHIgPT09IFwiUVwiID8gXCJmb3JtYXRcIiA6IFwic3RhbmQtYWxvbmVcIixcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1vbnRoXG5cdFx0XHRjYXNlIFwiTVwiOlxuXHRcdFx0Y2FzZSBcIkxcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbD0xOnsxLDJ9LCBsPTI6ezJ9LlxuXHRcdFx0XHQvLyBsb29rdXAgbD0zLi4uXG5cdFx0XHRcdGlmICggbGVuZ3RoID4gMiApIHtcblx0XHRcdFx0XHRjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL21vbnRoc1wiLFxuXHRcdFx0XHRcdFx0Y2hyID09PSBcIk1cIiA/IFwiZm9ybWF0XCIgOiBcInN0YW5kLWFsb25lXCIsXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBEYXlcblx0XHRcdGNhc2UgXCJnXCI6XG5cblx0XHRcdFx0Ly8gTW9kaWZpZWQgSnVsaWFuIGRheS4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdGZlYXR1cmU6IFwiSnVsaWFuIGRheSBwYXR0ZXJuIGBnYFwiXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBXZWVrIGRheVxuXHRcdFx0Y2FzZSBcImVcIjpcblx0XHRcdGNhc2UgXCJjXCI6XG5cblx0XHRcdFx0Ly8gbG9va3VwIGZvciBsZW5ndGggPj0zLlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA8PSAyICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJFXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdFx0Ly8gTm90ZTogaWYgc2hvcnQgZGF5IG5hbWVzIGFyZSBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFiYnJldmlhdGVkIGRheVxuXHRcdFx0XHRcdC8vIG5hbWVzIGFyZSB1c2VkIGluc3RlYWQgaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI21vbnRoc19kYXlzX3F1YXJ0ZXJzX2VyYXNcblx0XHRcdFx0XHRjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFsgY2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIgXSxcblx0XHRcdFx0XHRcdFwic2hvcnRcIlxuXHRcdFx0XHRcdF0pIHx8IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0WyBjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIiBdLFxuXHRcdFx0XHRcdFx0XCJhYmJyZXZpYXRlZFwiXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRbIGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiIF0sXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCA8IDMgPyAwIDogbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFBlcmlvZCAoQU0gb3IgUE0pXG5cdFx0XHRjYXNlIFwiYVwiOlxuXHRcdFx0XHRjbGRyLm1haW4oXG5cdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGVcIlxuXHRcdFx0XHQpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWm9uZVxuXHRcdFx0Y2FzZSBcIlZcIjpcblxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0XHRmZWF0dXJlOiBcInRpbWV6b25lIHBhdHRlcm4gYFwiICsgcGF0dGVybiArIFwiYFwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRpbWVab25lICkge1xuXHRcdFx0XHRcdGlmICggbGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTa2lwIGxvb3NlTWF0Y2hpbmcgcHJvY2Vzc2luZyBzaW5jZSB0aW1lWm9uZSBpcyBhIGNhbm9uaWNhbCBwb3NpeCB2YWx1ZS5cblx0XHRcdFx0XHRcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lID0gdGltZVpvbmU7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZVJlID0gbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIHRpbWVab25lICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciB0aW1lWm9uZU5hbWUsXG5cdFx0XHRcdFx0XHRleGVtcGxhckNpdHkgPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZVwiLCB0aW1lWm9uZSwgXCJleGVtcGxhckNpdHlcIlxuXHRcdFx0XHRcdFx0XSk7XG5cblx0XHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMyApIHtcblx0XHRcdFx0XHRcdGlmICggIWV4ZW1wbGFyQ2l0eSApIHtcblx0XHRcdFx0XHRcdFx0ZXhlbXBsYXJDaXR5ID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZS9FdGMvVW5rbm93bi9leGVtcGxhckNpdHlcIlxuXHRcdFx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRpbWVab25lTmFtZSA9IGV4ZW1wbGFyQ2l0eTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGV4ZW1wbGFyQ2l0eSAmJiBsZW5ndGggPT09IDQgKSB7XG5cdFx0XHRcdFx0XHR0aW1lWm9uZU5hbWUgPSBmb3JtYXRNZXNzYWdlKFxuXHRcdFx0XHRcdFx0XHRjbGRyLm1haW4oXG5cdFx0XHRcdFx0XHRcdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3JlZ2lvbkZvcm1hdFwiXG5cdFx0XHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0XHRcdFsgZXhlbXBsYXJDaXR5IF1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0aW1lWm9uZU5hbWUgKSB7XG5cdFx0XHRcdFx0XHR0aW1lWm9uZU5hbWUgPSBsb29zZU1hdGNoaW5nKCB0aW1lWm9uZU5hbWUgKTtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWVSZSA9IG5ldyBSZWdFeHAoXG5cdFx0XHRcdFx0XHRcdFwiXlwiICsgcmVnZXhwRXNjYXBlKCB0aW1lWm9uZU5hbWUgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwidlwiICkge1xuXHRcdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcInpcIjpcblx0XHRcdGNhc2UgXCJPXCI6XG5cdFx0XHRcdGdtdEZvcm1hdCA9IGNsZHIubWFpbiggXCJkYXRlcy90aW1lWm9uZU5hbWVzL2dtdEZvcm1hdFwiICk7XG5cdFx0XHRcdGNsZHIubWFpbiggXCJkYXRlcy90aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRcIiApO1xuXHRcdFx0XHRjbGRyLm1haW4oIFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XCIgKTtcblx0XHRcdFx0cHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRSZVwiIF0gPVxuXHRcdFx0XHRcdG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFwiIF0gKSApO1xuXHRcdFx0XHRhdXggPSBwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvaG91ckZvcm1hdFwiIF07XG5cdFx0XHRcdHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XCIgXSA9IChcblx0XHRcdFx0XHRsZW5ndGggPCA0ID9cblx0XHRcdFx0XHRcdFsgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEhtKCBhdXgsIFwiSFwiICksIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIKCBhdXggKSBdIDpcblx0XHRcdFx0XHRcdFsgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEhtKCBhdXgsIFwiSEhcIiApIF1cblx0XHRcdFx0KS5tYXAoZnVuY3Rpb24oIGhvdXJGb3JtYXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGhvdXJGb3JtYXRSZShcblx0XHRcdFx0XHRcdGhvdXJGb3JtYXQsXG5cdFx0XHRcdFx0XHRnbXRGb3JtYXQsXG5cdFx0XHRcdFx0XHRkaWdpdHNSZVNvdXJjZSxcblx0XHRcdFx0XHRcdHRpbWVTZXBhcmF0b3Jcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIlhcIjpcblx0XHRcdGNhc2UgXCJ4XCI6XG5cblx0XHRcdFx0Ly8geDogaG91ckZvcm1hdChcIitISFttbV07LUhIW21tXVwiKVxuXHRcdFx0XHQvLyB4eDogaG91ckZvcm1hdChcIitISG1tOy1ISG1tXCIpXG5cdFx0XHRcdC8vIHh4eDogaG91ckZvcm1hdChcIitISDptbTstSEg6bW1cIilcblx0XHRcdFx0Ly8geHh4eDogaG91ckZvcm1hdChcIitISG1tW3NzXTstSEhtbVtzc11cIilcblx0XHRcdFx0Ly8geHh4eHg6IGhvdXJGb3JtYXQoXCIrSEg6bW1bOnNzXTstSEg6bW1bOnNzXVwiKVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnggPSBbXG5cdFx0XHRcdFx0WyBcIitISG1tOy1ISG1tXCIsIFwiK0hIOy1ISFwiIF0sXG5cdFx0XHRcdFx0WyBcIitISG1tOy1ISG1tXCIgXSxcblx0XHRcdFx0XHRbIFwiK0hIOm1tOy1ISDptbVwiIF0sXG5cdFx0XHRcdFx0WyBcIitISG1tc3M7LUhIbW1zc1wiLCBcIitISG1tOy1ISG1tXCIgXSxcblx0XHRcdFx0XHRbIFwiK0hIOm1tOnNzOy1ISDptbTpzc1wiLCBcIitISDptbTstSEg6bW1cIiBdXG5cdFx0XHRcdF1bIGxlbmd0aCAtIDEgXS5tYXAoZnVuY3Rpb24oIGhvdXJGb3JtYXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGhvdXJGb3JtYXRSZSggaG91ckZvcm1hdCApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdGNsZHIub2ZmKCBcImdldFwiLCBwb3B1bGF0ZVByb3BlcnRpZXMgKTtcblxuXHRyZXR1cm4gcHJvcGVydGllcztcbn07XG5cblxuXG5cbi8qKlxuICogZGF5T2ZXZWVrKCBkYXRlLCBmaXJzdERheSApXG4gKlxuICogQGRhdGVcbiAqXG4gKiBAZmlyc3REYXkgdGhlIHJlc3VsdCBvZiBgZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyIClgXG4gKlxuICogUmV0dXJuIHRoZSBkYXkgb2YgdGhlIHdlZWsgbm9ybWFsaXplZCBieSB0aGUgdGVycml0b3J5J3MgZmlyc3REYXkgWzAtNl0uXG4gKiBFZyBmb3IgXCJtb25cIjpcbiAqIC0gcmV0dXJuIDAgaWYgdGVycml0b3J5IGlzIEdCLCBvciBCUiwgb3IgREUsIG9yIEZSICh3ZWVrIHN0YXJ0cyBvbiBcIm1vblwiKTtcbiAqIC0gcmV0dXJuIDEgaWYgdGVycml0b3J5IGlzIFVTICh3ZWVrIHN0YXJ0cyBvbiBcInN1blwiKTtcbiAqIC0gcmV0dXJuIDIgaWYgdGVycml0b3J5IGlzIEVHICh3ZWVrIHN0YXJ0cyBvbiBcInNhdFwiKTtcbiAqL1xudmFyIGRhdGVEYXlPZldlZWsgPSBmdW5jdGlvbiggZGF0ZSwgZmlyc3REYXkgKSB7XG5cdHJldHVybiAoIGRhdGUuZ2V0RGF5KCkgLSBmaXJzdERheSArIDcgKSAlIDc7XG59O1xuXG5cblxuXG4vKipcbiAqIGRpc3RhbmNlSW5EYXlzKCBmcm9tLCB0byApXG4gKlxuICogUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBkYXlzIGJldHdlZW4gZnJvbSBhbmQgdG8gRGF0ZXMuXG4gKi9cbnZhciBkYXRlRGlzdGFuY2VJbkRheXMgPSBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdHZhciBpbkRheXMgPSA4NjRlNTtcblx0cmV0dXJuICggdG8uZ2V0VGltZSgpIC0gZnJvbS5nZXRUaW1lKCkgKSAvIGluRGF5cztcbn07XG5cblxuXG5cbi8qKlxuICogZGF5T2ZZZWFyXG4gKlxuICogUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBkYXlzIG9mIHRoZSBkYXRlIHRvIHRoZSBiZWdpbiBvZiB0aGUgeWVhciBbMC1kXS5cbiAqL1xudmFyIGRhdGVEYXlPZlllYXIgPSBmdW5jdGlvbiggZGF0ZSApIHtcblx0cmV0dXJuIE1hdGguZmxvb3IoIGRhdGVEaXN0YW5jZUluRGF5cyggZGF0ZVN0YXJ0T2YoIGRhdGUsIFwieWVhclwiICksIGRhdGUgKSApO1xufTtcblxuXG5cblxuLy8gSW52ZXJ0IGtleSBhbmQgdmFsdWVzLCBlLmcuLCB7XCJ5ZWFyXCI6IFwieVlcIn0gPT0+IHtcInlcIjogXCJ5ZWFyXCIsIFwiWVwiOiBcInllYXJcIn1cbnZhciBkYXRlRmllbGRzTWFwID0gb2JqZWN0SW52ZXJ0KHtcblx0XCJlcmFcIjogXCJHXCIsXG5cdFwieWVhclwiOiBcInlZXCIsXG5cdFwicXVhcnRlclwiOiBcInFRXCIsXG5cdFwibW9udGhcIjogXCJNTFwiLFxuXHRcIndlZWtcIjogXCJ3V1wiLFxuXHRcImRheVwiOiBcImRERlwiLFxuXHRcIndlZWtkYXlcIjogXCJlY0VcIixcblx0XCJkYXlwZXJpb2RcIjogXCJhXCIsXG5cdFwiaG91clwiOiBcImhIa0tcIixcblx0XCJtaW51dGVcIjogXCJtXCIsXG5cdFwic2Vjb25kXCI6IFwic1NBXCIsXG5cdFwiem9uZVwiOiBcInp2Vk94WFwiXG59LCBmdW5jdGlvbiggb2JqZWN0LCBrZXksIHZhbHVlICkge1xuXHR2YWx1ZS5zcGxpdCggXCJcIiApLmZvckVhY2goZnVuY3Rpb24oIHN5bWJvbCApIHtcblx0XHRvYmplY3RbIHN5bWJvbCBdID0ga2V5O1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn0pO1xuXG5cblxuXG4vKipcbiAqIG1pbGxpc2Vjb25kc0luRGF5XG4gKi9cbnZhciBkYXRlTWlsbGlzZWNvbmRzSW5EYXkgPSBmdW5jdGlvbiggZGF0ZSApIHtcblxuXHQvLyBUT0RPIEhhbmRsZSBkYXlsaWdodCBzYXZpbmdzIGRpc2NvbnRpbnVpdGllc1xuXHRyZXR1cm4gZGF0ZSAtIGRhdGVTdGFydE9mKCBkYXRlLCBcImRheVwiICk7XG59O1xuXG5cblxuXG4vKipcbiAqIGhvdXJGb3JtYXQoIGRhdGUsIGZvcm1hdCwgdGltZVNlcGFyYXRvciwgZm9ybWF0TnVtYmVyIClcbiAqXG4gKiBSZXR1cm4gZGF0ZSdzIHRpbWV6b25lIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdCBwYXNzZWQuXG4gKiBFZyBmb3IgZm9ybWF0IHdoZW4gdGltZXpvbmUgb2Zmc2V0IGlzIDE4MDpcbiAqIC0gXCIrSDstSFwiOiAtM1xuICogLSBcIitISG1tOy1ISG1tXCI6IC0wMzAwXG4gKiAtIFwiK0hIOm1tOy1ISDptbVwiOiAtMDM6MDBcbiAqIC0gXCIrSEg6bW06c3M7LUhIOm1tOnNzXCI6IC0wMzowMDowMFxuICovXG52YXIgZGF0ZVRpbWV6b25lSG91ckZvcm1hdCA9IGZ1bmN0aW9uKCBkYXRlLCBmb3JtYXQsIHRpbWVTZXBhcmF0b3IsIGZvcm1hdE51bWJlciApIHtcblx0dmFyIGFic09mZnNldCxcblx0XHRvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cblx0YWJzT2Zmc2V0ID0gTWF0aC5hYnMoIG9mZnNldCApO1xuXHRmb3JtYXROdW1iZXIgPSBmb3JtYXROdW1iZXIgfHwge1xuXHRcdDE6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBzdHJpbmdQYWQoIHZhbHVlLCAxICk7XG5cdFx0fSxcblx0XHQyOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nUGFkKCB2YWx1ZSwgMiApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gZm9ybWF0XG5cblx0XHQvLyBQaWNrIHRoZSBjb3JyZWN0IHNpZ24gc2lkZSAoKyBvciAtKS5cblx0XHQuc3BsaXQoIFwiO1wiIClbIG9mZnNldCA+IDAgPyAxIDogMCBdXG5cblx0XHQvLyBMb2NhbGl6ZSB0aW1lIHNlcGFyYXRvclxuXHRcdC5yZXBsYWNlKCBcIjpcIiwgdGltZVNlcGFyYXRvciApXG5cblx0XHQvLyBVcGRhdGUgaG91cnMgb2Zmc2V0LlxuXHRcdC5yZXBsYWNlKCAvSEg/LywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIGZvcm1hdE51bWJlclsgbWF0Y2gubGVuZ3RoIF0oIE1hdGguZmxvb3IoIGFic09mZnNldCAvIDYwICkgKTtcblx0XHR9KVxuXG5cdFx0Ly8gVXBkYXRlIG1pbnV0ZXMgb2Zmc2V0IGFuZCByZXR1cm4uXG5cdFx0LnJlcGxhY2UoIC9tbS8sIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZvcm1hdE51bWJlclsgMiBdKCBNYXRoLmZsb29yKCBhYnNPZmZzZXQgJSA2MCApICk7XG5cdFx0fSlcblxuXHRcdC8vIFVwZGF0ZSBtaW51dGVzIG9mZnNldCBhbmQgcmV0dXJuLlxuXHRcdC5yZXBsYWNlKCAvc3MvLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmb3JtYXROdW1iZXJbIDIgXSggTWF0aC5mbG9vciggYWJzT2Zmc2V0ICUgMSAqIDYwICkgKTtcblx0XHR9KTtcbn07XG5cblxuXG5cbi8qKlxuICogZm9ybWF0KCBkYXRlLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBAZGF0ZSBbRGF0ZSBpbnN0YW5jZV0uXG4gKlxuICogQHByb3BlcnRpZXNcbiAqXG4gKiBUT0RPIFN1cHBvcnQgb3RoZXIgY2FsZW5kYXIgdHlwZXMuXG4gKlxuICogRGlzY2xvc3VyZTogdGhpcyBmdW5jdGlvbiBib3Jyb3dzIGV4Y2VycHRzIG9mIGRvam8vZGF0ZS9sb2NhbGUuXG4gKi9cbnZhciBkYXRlRm9ybWF0ID0gZnVuY3Rpb24oIGRhdGUsIG51bWJlckZvcm1hdHRlcnMsIHByb3BlcnRpZXMgKSB7XG5cdHZhciBwYXJ0cyA9IFtdO1xuXG5cdHZhciB0aW1lU2VwYXJhdG9yID0gcHJvcGVydGllcy50aW1lU2VwYXJhdG9yO1xuXG5cdC8vIGNyZWF0ZSBnbG9iYWxpemUgZGF0ZSB3aXRoIGdpdmVuIHRpbWV6b25lIGRhdGFcblx0aWYgKCBwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSApIHtcblx0XHRkYXRlID0gbmV3IFpvbmVkRGF0ZVRpbWUoIGRhdGUsIHByb3BlcnRpZXMudGltZVpvbmVEYXRhKCkgKTtcblx0fVxuXG5cdHByb3BlcnRpZXMucGF0dGVybi5yZXBsYWNlKCBkYXRlUGF0dGVyblJlLCBmdW5jdGlvbiggY3VycmVudCApIHtcblx0XHR2YXIgYXV4LCBkYXRlRmllbGQsIHR5cGUsIHZhbHVlLFxuXHRcdFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKSxcblx0XHRcdGxlbmd0aCA9IGN1cnJlbnQubGVuZ3RoO1xuXG5cdFx0aWYgKCBjaHIgPT09IFwialwiICkge1xuXG5cdFx0XHQvLyBMb2NhbGUgcHJlZmVycmVkIGhIS2suXG5cdFx0XHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjVGltZV9EYXRhXG5cdFx0XHRjaHIgPSBwcm9wZXJ0aWVzLnByZWZlcnJlZFRpbWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBjaHIgPT09IFwiWlwiICkge1xuXG5cdFx0XHQvLyBaLi5aWlo6IHNhbWUgYXMgXCJ4eHh4XCIuXG5cdFx0XHRpZiAoIGxlbmd0aCA8IDQgKSB7XG5cdFx0XHRcdGNociA9IFwieFwiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXG5cdFx0XHQvLyBaWlpaOiBzYW1lIGFzIFwiT09PT1wiLlxuXHRcdFx0fSBlbHNlIGlmICggbGVuZ3RoIDwgNSApIHtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cblx0XHRcdC8vIFpaWlpaOiBzYW1lIGFzIFwiWFhYWFhcIlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hyID0gXCJYXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gei4uLnp6ejogXCJ7c2hvcnRSZWdpb259XCIsIGUuZy4sIFwiUFNUXCIgb3IgXCJQRFRcIi5cblx0XHQvLyB6enp6OiBcIntyZWdpb25OYW1lfSB7U3RhbmRhcmQgVGltZX1cIiBvciBcIntyZWdpb25OYW1lfSB7RGF5bGlnaHQgVGltZX1cIixcblx0XHQvLyAgICAgICBlLmcuLCBcIlBhY2lmaWMgU3RhbmRhcmQgVGltZVwiIG9yIFwiUGFjaWZpYyBEYXlsaWdodCBUaW1lXCIuXG5cdFx0aWYgKCBjaHIgPT09IFwielwiICkge1xuXHRcdFx0aWYgKCBkYXRlLmlzRFNUICkge1xuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuaXNEU1QoKSA/IHByb3BlcnRpZXMuZGF5bGlnaHRUek5hbWUgOiBwcm9wZXJ0aWVzLnN0YW5kYXJkVHpOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gXCJPXCIgZm9ybWF0LlxuXHRcdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA8IDQgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGNociApIHtcblxuXHRcdFx0Ly8gRXJhXG5cdFx0XHRjYXNlIFwiR1wiOlxuXHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMuZXJhc1sgZGF0ZS5nZXRGdWxsWWVhcigpIDwgMCA/IDAgOiAxIF07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBZZWFyXG5cdFx0XHRjYXNlIFwieVwiOlxuXG5cdFx0XHRcdC8vIFBsYWluIHllYXIuXG5cdFx0XHRcdC8vIFRoZSBsZW5ndGggc3BlY2lmaWVzIHRoZSBwYWRkaW5nLCBidXQgZm9yIHR3byBsZXR0ZXJzIGl0IGFsc28gc3BlY2lmaWVzIHRoZVxuXHRcdFx0XHQvLyBtYXhpbXVtIGxlbmd0aC5cblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gU3RyaW5nKCB2YWx1ZSApO1xuXHRcdFx0XHRcdHZhbHVlID0gK3ZhbHVlLnN1YnN0ciggdmFsdWUubGVuZ3RoIC0gMiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiWVwiOlxuXG5cdFx0XHRcdC8vIFllYXIgaW4gXCJXZWVrIG9mIFllYXJcIlxuXHRcdFx0XHQvLyBUaGUgbGVuZ3RoIHNwZWNpZmllcyB0aGUgcGFkZGluZywgYnV0IGZvciB0d28gbGV0dGVycyBpdCBhbHNvIHNwZWNpZmllcyB0aGVcblx0XHRcdFx0Ly8gbWF4aW11bSBsZW5ndGguXG5cdFx0XHRcdC8vIHllYXJJbldlZWtvZlllYXIgPSBkYXRlICsgRGF5c0luQVdlZWsgLSAoZGF5T2ZXZWVrIC0gZmlyc3REYXkpIC0gbWluRGF5c1xuXHRcdFx0XHR2YWx1ZSA9IG5ldyBEYXRlKCBkYXRlLmdldFRpbWUoKSApO1xuXHRcdFx0XHR2YWx1ZS5zZXREYXRlKFxuXHRcdFx0XHRcdHZhbHVlLmdldERhdGUoKSArIDcgLVxuXHRcdFx0XHRcdGRhdGVEYXlPZldlZWsoIGRhdGUsIHByb3BlcnRpZXMuZmlyc3REYXkgKSAtXG5cdFx0XHRcdFx0cHJvcGVydGllcy5maXJzdERheSAtXG5cdFx0XHRcdFx0cHJvcGVydGllcy5taW5EYXlzXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBTdHJpbmcoIHZhbHVlICk7XG5cdFx0XHRcdFx0dmFsdWUgPSArdmFsdWUuc3Vic3RyKCB2YWx1ZS5sZW5ndGggLSAyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFF1YXJ0ZXJcblx0XHRcdGNhc2UgXCJRXCI6XG5cdFx0XHRjYXNlIFwicVwiOlxuXHRcdFx0XHR2YWx1ZSA9IE1hdGguY2VpbCggKCBkYXRlLmdldE1vbnRoKCkgKyAxICkgLyAzICk7XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gMiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMucXVhcnRlcnNbIGNociBdWyBsZW5ndGggXVsgdmFsdWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRjYXNlIFwiTFwiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gMiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMubW9udGhzWyBjaHIgXVsgbGVuZ3RoIF1bIHZhbHVlIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWtcblx0XHRcdGNhc2UgXCJ3XCI6XG5cblx0XHRcdFx0Ly8gV2VlayBvZiBZZWFyLlxuXHRcdFx0XHQvLyB3b3kgPSBjZWlsKCAoIGRveSArIGRvdyBvZiAxLzEgKSAvIDcgKSAtIG1pbkRheXNTdHVmZiA/IDEgOiAwLlxuXHRcdFx0XHQvLyBUT0RPIHNob3VsZCBwYWQgb24gd3c/IE5vdCBkb2N1bWVudGVkLCBidXQgSSBndWVzcyBzby5cblx0XHRcdFx0dmFsdWUgPSBkYXRlRGF5T2ZXZWVrKCBkYXRlU3RhcnRPZiggZGF0ZSwgXCJ5ZWFyXCIgKSwgcHJvcGVydGllcy5maXJzdERheSApO1xuXHRcdFx0XHR2YWx1ZSA9IE1hdGguY2VpbCggKCBkYXRlRGF5T2ZZZWFyKCBkYXRlICkgKyB2YWx1ZSApIC8gNyApIC1cblx0XHRcdFx0XHQoIDcgLSB2YWx1ZSA+PSBwcm9wZXJ0aWVzLm1pbkRheXMgPyAwIDogMSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIldcIjpcblxuXHRcdFx0XHQvLyBXZWVrIG9mIE1vbnRoLlxuXHRcdFx0XHQvLyB3b20gPSBjZWlsKCAoIGRvbSArIGRvdyBvZiBgMS9tb250aGAgKSAvIDcgKSAtIG1pbkRheXNTdHVmZiA/IDEgOiAwLlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGVEYXlPZldlZWsoIGRhdGVTdGFydE9mKCBkYXRlLCBcIm1vbnRoXCIgKSwgcHJvcGVydGllcy5maXJzdERheSApO1xuXHRcdFx0XHR2YWx1ZSA9IE1hdGguY2VpbCggKCBkYXRlLmdldERhdGUoKSArIHZhbHVlICkgLyA3ICkgLVxuXHRcdFx0XHRcdCggNyAtIHZhbHVlID49IHByb3BlcnRpZXMubWluRGF5cyA/IDAgOiAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBEYXlcblx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGVEYXlPZlllYXIoIGRhdGUgKSArIDE7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiRlwiOlxuXG5cdFx0XHRcdC8vIERheSBvZiBXZWVrIGluIG1vbnRoLiBlZy4gMm5kIFdlZCBpbiBKdWx5LlxuXHRcdFx0XHR2YWx1ZSA9IE1hdGguZmxvb3IoIGRhdGUuZ2V0RGF0ZSgpIC8gNyApICsgMTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWsgZGF5XG5cdFx0XHRjYXNlIFwiZVwiOlxuXHRcdFx0Y2FzZSBcImNcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPD0gMiApIHtcblxuXHRcdFx0XHRcdC8vIFJhbmdlIGlzIFsxLTddIChkZWR1Y2VkIGJ5IGV4YW1wbGUgcHJvdmlkZWQgb24gZG9jdW1lbnRhdGlvbilcblx0XHRcdFx0XHQvLyBUT0RPIFNob3VsZCBwYWQgd2l0aCB6ZXJvcyAobm90IHNwZWNpZmllZCBpbiB0aGUgZG9jcyk/XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRlRGF5T2ZXZWVrKCBkYXRlLCBwcm9wZXJ0aWVzLmZpcnN0RGF5ICkgKyAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJFXCI6XG5cdFx0XHRcdHZhbHVlID0gZGF0ZVdlZWtEYXlzWyBkYXRlLmdldERheSgpIF07XG5cdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5kYXlzWyBjaHIgXVsgbGVuZ3RoIF1bIHZhbHVlIF07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBQZXJpb2QgKEFNIG9yIFBNKVxuXHRcdFx0Y2FzZSBcImFcIjpcblx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmRheVBlcmlvZHNbIGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gXCJhbVwiIDogXCJwbVwiIF07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBIb3VyXG5cdFx0XHRjYXNlIFwiaFwiOiAvLyAxLTEyXG5cdFx0XHRcdHZhbHVlID0gKCBkYXRlLmdldEhvdXJzKCkgJSAxMiApIHx8IDEyO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkhcIjogLy8gMC0yM1xuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0SG91cnMoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJLXCI6IC8vIDAtMTFcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldEhvdXJzKCkgJSAxMjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJrXCI6IC8vIDEtMjRcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldEhvdXJzKCkgfHwgMjQ7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNaW51dGVcblx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBTZWNvbmRcblx0XHRcdGNhc2UgXCJzXCI6XG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiU1wiOlxuXHRcdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQoIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiBNYXRoLnBvdyggMTAsIGxlbmd0aCAtIDMgKSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkFcIjpcblx0XHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKCBkYXRlTWlsbGlzZWNvbmRzSW5EYXkoIGRhdGUgKSAqIE1hdGgucG93KCAxMCwgbGVuZ3RoIC0gMyApICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBab25lXG5cdFx0XHRjYXNlIFwielwiOlxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcInZcIjpcblxuXHRcdFx0XHQvLyB2Li4udnZ2OiBcIntzaG9ydFJlZ2lvbn1cIiwgZWcuIFwiUFRcIi5cblx0XHRcdFx0Ly8gdnZ2djogXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIsXG5cdFx0XHRcdC8vICAgICAgIGUuZy4sIFwiUGFjaWZpYyBUaW1lXCIuXG5cdFx0XHRcdGlmICggcHJvcGVydGllcy5nZW5lcmljVHpOYW1lICkge1xuXHRcdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5nZW5lcmljVHpOYW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJWXCI6XG5cblx0XHRcdFx0Ly9WVlZWOiBcIntleHBsYXJDaXR5fSB7VGltZX1cIiwgZS5nLiwgXCJMb3MgQW5nZWxlcyBUaW1lXCJcblx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMudGltZVpvbmVOYW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50ID09PSBcInZcIiApIHtcblx0XHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJPXCI6XG5cblx0XHRcdFx0Ly8gTzogXCJ7Z210Rm9ybWF0fStIO3tnbXRGb3JtYXR9LUhcIiBvciBcIntnbXRaZXJvRm9ybWF0fVwiLCBlZy4gXCJHTVQtOFwiIG9yIFwiR01UXCIuXG5cdFx0XHRcdC8vIE9PT086IFwie2dtdEZvcm1hdH17aG91ckZvcm1hdH1cIiBvciBcIntnbXRaZXJvRm9ybWF0fVwiLCBlZy4gXCJHTVQtMDg6MDBcIiBvciBcIkdNVFwiLlxuXHRcdFx0XHRpZiAoIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PT0gMCApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMuZ210WmVyb0Zvcm1hdDtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIE8uLk9PTyBhbmQgdGltZXpvbmUgb2Zmc2V0IGhhcyBub24temVybyBtaW51dGVzLCBzaG93IG1pbnV0ZXMuXG5cdFx0XHRcdFx0aWYgKCBsZW5ndGggPCA0ICkge1xuXHRcdFx0XHRcdFx0YXV4ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXHRcdFx0XHRcdFx0YXV4ID0gcHJvcGVydGllcy5ob3VyRm9ybWF0WyBhdXggJSA2MCAtIGF1eCAlIDEgPT09IDAgPyAwIDogMSBdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhdXggPSBwcm9wZXJ0aWVzLmhvdXJGb3JtYXQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRlVGltZXpvbmVIb3VyRm9ybWF0KFxuXHRcdFx0XHRcdFx0ZGF0ZSxcblx0XHRcdFx0XHRcdGF1eCxcblx0XHRcdFx0XHRcdHRpbWVTZXBhcmF0b3IsXG5cdFx0XHRcdFx0XHRudW1iZXJGb3JtYXR0ZXJzXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMuZ210Rm9ybWF0LnJlcGxhY2UoIC9cXHswXFx9LywgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIlhcIjpcblxuXHRcdFx0XHQvLyBTYW1lIGFzIHgqLCBleGNlcHQgaXQgdXNlcyBcIlpcIiBmb3IgemVybyBvZmZzZXQuXG5cdFx0XHRcdGlmICggZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09PSAwICkge1xuXHRcdFx0XHRcdHZhbHVlID0gXCJaXCI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcInhcIjpcblxuXHRcdFx0XHQvLyB4OiBob3VyRm9ybWF0KFwiK0hIW21tXTstSEhbbW1dXCIpXG5cdFx0XHRcdC8vIHh4OiBob3VyRm9ybWF0KFwiK0hIbW07LUhIbW1cIilcblx0XHRcdFx0Ly8geHh4OiBob3VyRm9ybWF0KFwiK0hIOm1tOy1ISDptbVwiKVxuXHRcdFx0XHQvLyB4eHh4OiBob3VyRm9ybWF0KFwiK0hIbW1bc3NdOy1ISG1tW3NzXVwiKVxuXHRcdFx0XHQvLyB4eHh4eDogaG91ckZvcm1hdChcIitISDptbVs6c3NdOy1ISDptbVs6c3NdXCIpXG5cdFx0XHRcdGF1eCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuXHRcdFx0XHQvLyBJZiB4IGFuZCB0aW1lem9uZSBvZmZzZXQgaGFzIG5vbi16ZXJvIG1pbnV0ZXMsIHVzZSB4eCAoaS5lLiwgc2hvdyBtaW51dGVzKS5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDEgJiYgYXV4ICUgNjAgLSBhdXggJSAxICE9PSAwICkge1xuXHRcdFx0XHRcdGxlbmd0aCArPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgKHh4eHggb3IgeHh4eHgpIGFuZCB0aW1lem9uZSBvZmZzZXQgaGFzIHplcm8gc2Vjb25kcywgdXNlIHh4IG9yIHh4eFxuXHRcdFx0XHQvLyByZXNwZWN0aXZlbHkgKGkuZS4sIGRvbid0IHNob3cgb3B0aW9uYWwgc2Vjb25kcykuXG5cdFx0XHRcdGlmICggKCBsZW5ndGggPT09IDQgfHwgbGVuZ3RoID09PSA1ICkgJiYgYXV4ICUgMSA9PT0gMCApIHtcblx0XHRcdFx0XHRsZW5ndGggLT0gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhbHVlID0gW1xuXHRcdFx0XHRcdFwiK0hIOy1ISFwiLFxuXHRcdFx0XHRcdFwiK0hIbW07LUhIbW1cIixcblx0XHRcdFx0XHRcIitISDptbTstSEg6bW1cIixcblx0XHRcdFx0XHRcIitISG1tc3M7LUhIbW1zc1wiLFxuXHRcdFx0XHRcdFwiK0hIOm1tOnNzOy1ISDptbTpzc1wiXG5cdFx0XHRcdF1bIGxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHR2YWx1ZSA9IGRhdGVUaW1lem9uZUhvdXJGb3JtYXQoIGRhdGUsIHZhbHVlLCBcIjpcIiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gdGltZVNlcGFyYXRvclxuXHRcdFx0Y2FzZSBcIjpcIjpcblx0XHRcdFx0dmFsdWUgPSB0aW1lU2VwYXJhdG9yO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gJyBsaXRlcmFscy5cblx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdHZhbHVlID0gcmVtb3ZlTGl0ZXJhbFF1b3RlcyggY3VycmVudCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGEgbGl0ZXJhbCwgaW5jbHVkaW5nIFsgLDovLkAjXSwgY2hpbmVzZSwgamFwb25lc2UsIGFuZFxuXHRcdFx0Ly8gYXJhYmljIGNoYXJhY3RlcnMuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR2YWx1ZSA9IGN1cnJlbnQ7XG5cblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHR2YWx1ZSA9IG51bWJlckZvcm1hdHRlcnNbIGxlbmd0aCBdKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGRhdGVGaWVsZCA9IGRhdGVGaWVsZHNNYXBbIGNociBdO1xuXHRcdHR5cGUgPSBkYXRlRmllbGQgPyBkYXRlRmllbGQgOiBcImxpdGVyYWxcIjtcblxuXHRcdC8vIENvbmNhdCB0d28gY29uc2VjdXRpdmUgbGl0ZXJhbHNcblx0XHRpZiAoIHR5cGUgPT09IFwibGl0ZXJhbFwiICYmIHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1sgcGFydHMubGVuZ3RoIC0gMSBdLnR5cGUgPT09IFwibGl0ZXJhbFwiICkge1xuXHRcdFx0cGFydHNbIHBhcnRzLmxlbmd0aCAtIDEgXS52YWx1ZSArPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRwYXJ0cy5wdXNoKCB7IHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9ICk7XG5cblx0fSk7XG5cblx0cmV0dXJuIHBhcnRzO1xuXG59O1xuXG5cblxuXG52YXIgZGF0ZVRvUGFydHNGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJGb3JtYXR0ZXJzLCBwcm9wZXJ0aWVzICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVEYXRlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHRyZXR1cm4gZGF0ZUZvcm1hdCggdmFsdWUsIG51bWJlckZvcm1hdHRlcnMsIHByb3BlcnRpZXMgKTtcblx0fTtcblxufTtcblxuXG5cblxuZnVuY3Rpb24gb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkge1xuXHRyZXR1cm4gb3B0aW9ucy5za2VsZXRvbiAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0b3B0aW9ucy5kYXRlICE9PSB1bmRlZmluZWQgfHxcblx0XHRvcHRpb25zLnRpbWUgIT09IHVuZGVmaW5lZCB8fFxuXHRcdG9wdGlvbnMuZGF0ZXRpbWUgIT09IHVuZGVmaW5lZCB8fFxuXHRcdG9wdGlvbnMucmF3ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVxdWlyZWRDbGRyKCBwYXRoLCB2YWx1ZSApIHtcblx0dmFsaWRhdGVDbGRyKCBwYXRoLCB2YWx1ZSwge1xuXHRcdHNraXA6IFtcblx0XHRcdC9kYXRlc1xcL2NhbGVuZGFyc1xcL2dyZWdvcmlhblxcL2RhdGVUaW1lRm9ybWF0c1xcL2F2YWlsYWJsZUZvcm1hdHMvLFxuXHRcdFx0L2RhdGVzXFwvY2FsZW5kYXJzXFwvZ3JlZ29yaWFuXFwvZGF5c1xcLy4qXFwvc2hvcnQvLFxuXHRcdFx0L2RhdGVzXFwvdGltZVpvbmVOYW1lc1xcL3pvbmUvLFxuXHRcdFx0L2RhdGVzXFwvdGltZVpvbmVOYW1lc1xcL21ldGF6b25lLyxcblx0XHRcdC9nbG9iYWxpemUtaWFuYS8sXG5cdFx0XHQvc3VwcGxlbWVudGFsXFwvbWV0YVpvbmVzLyxcblx0XHRcdC9zdXBwbGVtZW50YWxcXC90aW1lRGF0YVxcLyg/ITAwMSkvLFxuXHRcdFx0L3N1cHBsZW1lbnRhbFxcL3dlZWtEYXRhXFwvKD8hMDAxKS9cblx0XHRdXG5cdH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNQcmVzZXQoIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlT3B0aW9uc1ByZXNldEVhY2goIFwiZGF0ZVwiLCBvcHRpb25zICk7XG5cdHZhbGlkYXRlT3B0aW9uc1ByZXNldEVhY2goIFwidGltZVwiLCBvcHRpb25zICk7XG5cdHZhbGlkYXRlT3B0aW9uc1ByZXNldEVhY2goIFwiZGF0ZXRpbWVcIiwgb3B0aW9ucyApO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCB0eXBlLCBvcHRpb25zICkge1xuXHR2YXIgdmFsdWUgPSBvcHRpb25zWyB0eXBlIF07XG5cdHZhbGlkYXRlKFxuXHRcdFwiRV9JTlZBTElEX09QVElPTlNcIixcblx0XHRcIkludmFsaWQgYHt7dHlwZX06IFxcXCJ7dmFsdWV9XFxcIn1gLlwiLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgWyBcInNob3J0XCIsIFwibWVkaXVtXCIsIFwibG9uZ1wiLCBcImZ1bGxcIiBdLmluZGV4T2YoIHZhbHVlICkgIT09IC0xLFxuXHRcdHsgdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlIH1cblx0KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zU2tlbGV0b24oIHBhdHRlcm4sIHNrZWxldG9uICkge1xuXHR2YWxpZGF0ZShcblx0XHRcIkVfSU5WQUxJRF9PUFRJT05TXCIsXG5cdFx0XCJJbnZhbGlkIGB7c2tlbGV0b246IFxcXCJ7dmFsdWV9XFxcIn1gIGJhc2VkIG9uIHByb3ZpZGVkIENMRFIuXCIsXG5cdFx0c2tlbGV0b24gPT09IHVuZGVmaW5lZCB8fCAoIHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gKSxcblx0XHR7IHR5cGU6IFwic2tlbGV0b25cIiwgdmFsdWU6IHNrZWxldG9uIH1cblx0KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIHBhdGgsIHZhbHVlICkge1xuXG5cdFx0aWYgKCAhL2dsb2JhbGl6ZS1pYW5hLy50ZXN0KCBwYXRoICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsaWRhdGUoXG5cdFx0XHRcIkVfTUlTU0lOR19JQU5BX1RaXCIsXG5cdFx0XHRcIk1pc3NpbmcgcmVxdWlyZWQgSUFOQSB0aW1lem9uZSBjb250ZW50IGZvciBge3RpbWVab25lfWA6IGB7cGF0aH1gLlwiLFxuXHRcdFx0dmFsdWUsXG5cdFx0XHR7XG5cdFx0XHRcdHBhdGg6IHBhdGgucmVwbGFjZSggL2dsb2JhbGl6ZS1pYW5hXFwvLywgXCJcIiApLFxuXHRcdFx0XHR0aW1lWm9uZTogdGltZVpvbmVcblx0XHRcdH1cblx0XHQpO1xuXHR9O1xufVxuXG4vKipcbiAqIC5sb2FkVGltZVpvbmUoIGpzb24gKVxuICpcbiAqIEBqc29uIFtKU09OXVxuICpcbiAqIExvYWQgSUFOQSB0aW1lem9uZSBkYXRhLlxuICovXG5HbG9iYWxpemUubG9hZFRpbWVab25lID0gZnVuY3Rpb24oIGpzb24gKSB7XG5cdHZhciBjdXN0b21EYXRhID0ge1xuXHRcdFx0XCJnbG9iYWxpemUtaWFuYVwiOiBqc29uXG5cdFx0fTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBqc29uLCBcImpzb25cIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCgganNvbiwgXCJqc29uXCIgKTtcblxuXHRDbGRyLmxvYWQoIGN1c3RvbURhdGEgKTtcbn07XG5cbi8qKlxuICogLmRhdGVGb3JtYXR0ZXIoIG9wdGlvbnMgKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXG4gKlxuICogUmV0dXJuIGEgZGF0ZSBmb3JtYXR0ZXIgZnVuY3Rpb24gKG9mIHRoZSBmb3JtIGJlbG93KSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZVxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKlxuICogZm4oIHZhbHVlIClcbiAqXG4gKiBAdmFsdWUgW0RhdGVdXG4gKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGBmb3JtYXRgIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZVxuICogbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZGF0ZUZvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLmRhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGRhdGVUb1BhcnRzRm9ybWF0dGVyLCByZXR1cm5GbjtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0aWYgKCAhb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkgKSB7XG5cdFx0b3B0aW9ucy5za2VsZXRvbiA9IFwieU1kXCI7XG5cdH1cblx0YXJncyA9IFsgb3B0aW9ucyBdO1xuXG5cdGRhdGVUb1BhcnRzRm9ybWF0dGVyID0gdGhpcy5kYXRlVG9QYXJ0c0Zvcm1hdHRlciggb3B0aW9ucyApO1xuXHRyZXR1cm5GbiA9IGRhdGVGb3JtYXR0ZXJGbiggZGF0ZVRvUGFydHNGb3JtYXR0ZXIgKTtcblx0cnVudGltZUJpbmQoIGFyZ3MsIHRoaXMuY2xkciwgcmV0dXJuRm4sIFsgZGF0ZVRvUGFydHNGb3JtYXR0ZXIgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLmRhdGVUb1BhcnRzRm9ybWF0dGVyKCBvcHRpb25zIClcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIFJldHVybiBhIGRhdGUgZm9ybWF0dGVyIGZ1bmN0aW9uIChvZiB0aGUgZm9ybSBiZWxvdykgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGVcbiAqIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICpcbiAqIGZuKCB2YWx1ZSApXG4gKlxuICogQHZhbHVlIFtEYXRlXVxuICpcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIGRhdGUgdG8gcGFydHMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgZm9ybWF0YFxuICogYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlXG4gKiBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5kYXRlVG9QYXJ0c0Zvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLmRhdGVUb1BhcnRzRm9ybWF0dGVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBudW1iZXJGb3JtYXR0ZXJzLCBwYWQsIHBhdHRlcm4sIHByb3BlcnRpZXMsIHJldHVybkZuLFxuXHRcdHRpbWVab25lO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRpZiAoICFvcHRpb25zSGFzU3R5bGUoIG9wdGlvbnMgKSApIHtcblx0XHRvcHRpb25zLnNrZWxldG9uID0gXCJ5TWRcIjtcblx0fVxuXG5cdHZhbGlkYXRlT3B0aW9uc1ByZXNldCggb3B0aW9ucyApO1xuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHR0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdGltZVpvbmUsIFwib3B0aW9ucy50aW1lWm9uZVwiICk7XG5cblx0YXJncyA9IFsgb3B0aW9ucyBdO1xuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XG5cdGlmICggdGltZVpvbmUgKSB7XG5cdFx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkgKTtcblx0fVxuXHRwYXR0ZXJuID0gZGF0ZUV4cGFuZFBhdHRlcm4oIG9wdGlvbnMsIGNsZHIgKTtcblx0dmFsaWRhdGVPcHRpb25zU2tlbGV0b24oIHBhdHRlcm4sIG9wdGlvbnMuc2tlbGV0b24gKTtcblx0cHJvcGVydGllcyA9IGRhdGVGb3JtYXRQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyLCB0aW1lWm9uZSApO1xuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcblx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBuZWVkZWQgbnVtYmVyIGZvcm1hdHRlcnMuXG5cdG51bWJlckZvcm1hdHRlcnMgPSBwcm9wZXJ0aWVzLm51bWJlckZvcm1hdHRlcnM7XG5cdGRlbGV0ZSBwcm9wZXJ0aWVzLm51bWJlckZvcm1hdHRlcnM7XG5cdGZvciAoIHBhZCBpbiBudW1iZXJGb3JtYXR0ZXJzICkge1xuXHRcdG51bWJlckZvcm1hdHRlcnNbIHBhZCBdID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIoe1xuXHRcdFx0cmF3OiBudW1iZXJGb3JtYXR0ZXJzWyBwYWQgXVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuRm4gPSBkYXRlVG9QYXJ0c0Zvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXJzLCBwcm9wZXJ0aWVzICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlckZvcm1hdHRlcnMsIHByb3BlcnRpZXMgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLmRhdGVQYXJzZXIoIG9wdGlvbnMgKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXG4gKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGBmb3JtYXRzYCBhbmQgdGhlXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmRhdGVQYXJzZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5kYXRlUGFyc2VyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBudW1iZXJQYXJzZXIsIHBhcnNlUHJvcGVydGllcywgcGF0dGVybiwgcmV0dXJuRm4sIHRpbWVab25lLFxuXHRcdHRva2VuaXplclByb3BlcnRpZXM7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0Y2xkciA9IHRoaXMuY2xkcjtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdGlmICggIW9wdGlvbnNIYXNTdHlsZSggb3B0aW9ucyApICkge1xuXHRcdG9wdGlvbnMuc2tlbGV0b24gPSBcInlNZFwiO1xuXHR9XG5cblx0dmFsaWRhdGVPcHRpb25zUHJlc2V0KCBvcHRpb25zICk7XG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdHRpbWVab25lID0gb3B0aW9ucy50aW1lWm9uZTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB0aW1lWm9uZSwgXCJvcHRpb25zLnRpbWVab25lXCIgKTtcblxuXHRhcmdzID0gWyBvcHRpb25zIF07XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcblx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkSWFuYSggdGltZVpvbmUgKSApO1xuXHR9XG5cdHBhdHRlcm4gPSBkYXRlRXhwYW5kUGF0dGVybiggb3B0aW9ucywgY2xkciApO1xuXHR2YWxpZGF0ZU9wdGlvbnNTa2VsZXRvbiggcGF0dGVybiwgb3B0aW9ucy5za2VsZXRvbiApO1xuXHR0b2tlbml6ZXJQcm9wZXJ0aWVzID0gZGF0ZVRva2VuaXplclByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIsIHRpbWVab25lICk7XG5cdHBhcnNlUHJvcGVydGllcyA9IGRhdGVQYXJzZVByb3BlcnRpZXMoIGNsZHIsIHRpbWVab25lICk7XG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xuXHRpZiAoIHRpbWVab25lICkge1xuXHRcdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkSWFuYSggdGltZVpvbmUgKSApO1xuXHR9XG5cblx0bnVtYmVyUGFyc2VyID0gdGhpcy5udW1iZXJQYXJzZXIoeyByYXc6IFwiMFwiIH0pO1xuXG5cdHJldHVybkZuID0gZGF0ZVBhcnNlckZuKCBudW1iZXJQYXJzZXIsIHBhcnNlUHJvcGVydGllcywgdG9rZW5pemVyUHJvcGVydGllcyApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJQYXJzZXIsIHBhcnNlUHJvcGVydGllcywgdG9rZW5pemVyUHJvcGVydGllcyBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAuZm9ybWF0RGF0ZSggdmFsdWUsIG9wdGlvbnMgKVxuICpcbiAqIEB2YWx1ZSBbRGF0ZV1cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIEZvcm1hdHMgYSBkYXRlIG9yIG51bWJlciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgc3RyaW5nIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXREYXRlID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVEYXRlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMuZGF0ZUZvcm1hdHRlciggb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiAuZm9ybWF0RGF0ZVRvUGFydHMoIHZhbHVlLCBvcHRpb25zIClcbiAqXG4gKiBAdmFsdWUgW0RhdGVdXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBGb3JtYXRzIGEgZGF0ZSBvciBudW1iZXIgdG8gcGFydHMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXREYXRlVG9QYXJ0cyA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdERhdGVUb1BhcnRzID0gZnVuY3Rpb24oIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZURhdGUoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5kYXRlVG9QYXJ0c0Zvcm1hdHRlciggb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiAucGFyc2VEYXRlKCB2YWx1ZSwgb3B0aW9ucyApXG4gKlxuICogQHZhbHVlIFtTdHJpbmddXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBSZXR1cm4gYSBEYXRlIGluc3RhbmNlIG9yIG51bGwuXG4gKi9cbkdsb2JhbGl6ZS5wYXJzZURhdGUgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5wYXJzZURhdGUgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMuZGF0ZVBhcnNlciggb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvZGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2RhdGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiY2xkci9ldmVudFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gRXh0ZW5kIGdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgYWx3YXlzQXJyYXkgPSBHbG9iYWxpemUuX2Fsd2F5c0FycmF5LFxuXHRjcmVhdGVFcnJvciA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IsXG5cdGlzUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX2lzUGxhaW5PYmplY3QsXG5cdHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXG5cdHZhbGlkYXRlID0gR2xvYmFsaXplLl92YWxpZGF0ZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcbnZhciBNZXNzYWdlRm9ybWF0O1xuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuTWVzc2FnZUZvcm1hdCA9IChmdW5jdGlvbigpIHtcbk1lc3NhZ2VGb3JtYXQuX3BhcnNlID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXG4gICAqXG4gICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAgICovXG5cbiAgZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICAgIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XG4gICAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcblxuICAgIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG4gIH1cblxuICBwZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTtcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSxcblxuICAgICAgICBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgc3RhcnQ6IHBlZyRwYXJzZXN0YXJ0IH0sXG4gICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiAgPSBwZWckcGFyc2VzdGFydCxcblxuICAgICAgICBwZWckYzAgPSBbXSxcbiAgICAgICAgcGVnJGMxID0gZnVuY3Rpb24oc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ21lc3NhZ2VGb3JtYXRQYXR0ZXJuJywgc3RhdGVtZW50czogc3QgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMiA9IHBlZyRGQUlMRUQsXG4gICAgICAgIHBlZyRjMyA9IFwie1wiLFxuICAgICAgICBwZWckYzQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ7XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ7XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNSA9IG51bGwsXG4gICAgICAgIHBlZyRjNiA9IFwiLFwiLFxuICAgICAgICBwZWckYzcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjOCA9IFwifVwiLFxuICAgICAgICBwZWckYzkgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ9XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTAgPSBmdW5jdGlvbihhcmdJZHgsIGVmbXQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VGb3JtYXRFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRJbmRleDogYXJnSWR4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChlZm10ICYmIGVmbXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVsZW1lbnRGb3JtYXQgPSBlZm10WzFdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5vdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzExID0gXCJwbHVyYWxcIixcbiAgICAgICAgcGVnJGMxMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInBsdXJhbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwicGx1cmFsXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTMgPSBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZWxlbWVudEZvcm1hdFwiLCBrZXk6IHQsIHZhbDogcyB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxNCA9IFwic2VsZWN0b3JkaW5hbFwiLFxuICAgICAgICBwZWckYzE1ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2VsZWN0b3JkaW5hbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2VsZWN0b3JkaW5hbFxcXCJcIiB9LFxuICAgICAgICBwZWckYzE2ID0gXCJzZWxlY3RcIixcbiAgICAgICAgcGVnJGMxNyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNlbGVjdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2VsZWN0XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTggPSBmdW5jdGlvbih0LCBwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZWxlbWVudEZvcm1hdFwiLCBrZXk6IHQsIHZhbDogcCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxOSA9IGZ1bmN0aW9uKG9wLCBwZikge1xuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInBsdXJhbEZvcm1hdFBhdHRlcm5cIiwgcGx1cmFsRm9ybXM6IHBmLCBvZmZzZXQ6IG9wIHx8IDAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMjAgPSBcIm9mZnNldFwiLFxuICAgICAgICBwZWckYzIxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwib2Zmc2V0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJvZmZzZXRcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMyMiA9IFwiOlwiLFxuICAgICAgICBwZWckYzIzID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOlxcXCJcIiB9LFxuICAgICAgICBwZWckYzI0ID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSxcbiAgICAgICAgcGVnJGMyNSA9IGZ1bmN0aW9uKGssIG1mcCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbDogbWZwIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzI2ID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gaTsgfSxcbiAgICAgICAgcGVnJGMyNyA9IFwiPVwiLFxuICAgICAgICBwZWckYzI4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPVxcXCJcIiB9LFxuICAgICAgICBwZWckYzI5ID0gZnVuY3Rpb24ocGYpIHsgcmV0dXJuIHsgdHlwZTogXCJzZWxlY3RGb3JtYXRQYXR0ZXJuXCIsIHBsdXJhbEZvcm1zOiBwZiB9OyB9LFxuICAgICAgICBwZWckYzMwID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gcDsgfSxcbiAgICAgICAgcGVnJGMzMSA9IFwiI1wiLFxuICAgICAgICBwZWckYzMyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiI1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiI1xcXCJcIiB9LFxuICAgICAgICBwZWckYzMzID0gZnVuY3Rpb24oKSB7IHJldHVybiB7dHlwZTogJ29jdG90aG9ycGUnfTsgfSxcbiAgICAgICAgcGVnJGMzNCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsOiBzLmpvaW4oJycpIH07IH0sXG4gICAgICAgIHBlZyRjMzUgPSB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IFwiaWRlbnRpZmllclwiIH0sXG4gICAgICAgIHBlZyRjMzYgPSAvXlswLTlhLXpBLVokX10vLFxuICAgICAgICBwZWckYzM3ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTlhLXpBLVokX11cIiwgZGVzY3JpcHRpb246IFwiWzAtOWEtekEtWiRfXVwiIH0sXG4gICAgICAgIHBlZyRjMzggPSAvXlteIFxcdFxcblxcciwuKz17fV0vLFxuICAgICAgICBwZWckYzM5ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlteIFxcXFx0XFxcXG5cXFxcciwuKz17fV1cIiwgZGVzY3JpcHRpb246IFwiW14gXFxcXHRcXFxcblxcXFxyLC4rPXt9XVwiIH0sXG4gICAgICAgIHBlZyRjNDAgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzOyB9LFxuICAgICAgICBwZWckYzQxID0gZnVuY3Rpb24oY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oJycpOyB9LFxuICAgICAgICBwZWckYzQyID0gL15bXnt9I1xcXFxcXDAtXFx4MUZ/IFxcdFxcblxccl0vLFxuICAgICAgICBwZWckYzQzID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltee30jXFxcXFxcXFxcXFxcMC1cXFxceDFGfyBcXFxcdFxcXFxuXFxcXHJdXCIsIGRlc2NyaXB0aW9uOiBcIltee30jXFxcXFxcXFxcXFxcMC1cXFxceDFGfyBcXFxcdFxcXFxuXFxcXHJdXCIgfSxcbiAgICAgICAgcGVnJGM0NCA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAgICAgIHBlZyRjNDUgPSBcIlxcXFxcXFxcXCIsXG4gICAgICAgIHBlZyRjNDYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcXFxcXFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJcIiB9LFxuICAgICAgICBwZWckYzQ3ID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcXFxcIjsgfSxcbiAgICAgICAgcGVnJGM0OCA9IFwiXFxcXCNcIixcbiAgICAgICAgcGVnJGM0OSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFwjXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXCNcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1MCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIjXCI7IH0sXG4gICAgICAgIHBlZyRjNTEgPSBcIlxcXFx7XCIsXG4gICAgICAgIHBlZyRjNTIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxce1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFx7XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFx1MDA3QlwiOyB9LFxuICAgICAgICBwZWckYzU0ID0gXCJcXFxcfVwiLFxuICAgICAgICBwZWckYzU1ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXH1cIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcfVxcXCJcIiB9LFxuICAgICAgICBwZWckYzU2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcdTAwN0RcIjsgfSxcbiAgICAgICAgcGVnJGM1NyA9IFwiXFxcXHVcIixcbiAgICAgICAgcGVnJGM1OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFx1XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXHVcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1OSA9IGZ1bmN0aW9uKGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KFwiMHhcIiArIGgxICsgaDIgKyBoMyArIGg0KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzYwID0gL15bMC05XS8sXG4gICAgICAgIHBlZyRjNjEgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOV1cIiwgZGVzY3JpcHRpb246IFwiWzAtOV1cIiB9LFxuICAgICAgICBwZWckYzYyID0gZnVuY3Rpb24oZHMpIHtcbiAgICAgICAgICAgIC8vdGhlIG51bWJlciBtaWdodCBzdGFydCB3aXRoIDAgYnV0IG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGFuIG9jdGFsIG51bWJlclxuICAgICAgICAgICAgLy9IZW5jZSwgdGhlIGJhc2UgaXMgcGFzc2VkIHRvIHBhcnNlSW50IGV4cGxpY2l0ZWx5XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoKGRzLmpvaW4oJycpKSwgMTApO1xuICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjNjMgPSAvXlswLTlhLWZBLUZdLyxcbiAgICAgICAgcGVnJGM2NCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05YS1mQS1GXVwiLCBkZXNjcmlwdGlvbjogXCJbMC05YS1mQS1GXVwiIH0sXG4gICAgICAgIHBlZyRjNjUgPSB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IFwid2hpdGVzcGFjZVwiIH0sXG4gICAgICAgIHBlZyRjNjYgPSBmdW5jdGlvbih3KSB7IHJldHVybiB3LmpvaW4oJycpOyB9LFxuICAgICAgICBwZWckYzY3ID0gL15bIFxcdFxcblxccl0vLFxuICAgICAgICBwZWckYzY4ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsgXFxcXHRcXFxcblxcXFxyXVwiLCBkZXNjcmlwdGlvbjogXCJbIFxcXFx0XFxcXG5cXFxccl1cIiB9LFxuXG4gICAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfSxcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgICBwZWckc2lsZW50RmFpbHMgICAgICA9IDAsXG5cbiAgICAgICAgcGVnJHJlc3VsdDtcblxuICAgIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHJlcG9ydGVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHBlZyRyZXBvcnRlZFBvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmxpbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sdW1uKCkge1xuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmNvbHVtbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbikge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKFxuICAgICAgICBudWxsLFxuICAgICAgICBbeyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9XSxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBudWxsLCBwZWckcmVwb3J0ZWRQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICAgIGZ1bmN0aW9uIGFkdmFuY2UoZGV0YWlscywgc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgcCwgY2g7XG5cbiAgICAgICAgZm9yIChwID0gc3RhcnRQb3M7IHAgPCBlbmRQb3M7IHArKykge1xuICAgICAgICAgIGNoID0gaW5wdXQuY2hhckF0KHApO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfVxuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgIT09IHBvcykge1xuICAgICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykge1xuICAgICAgICAgIHBlZyRjYWNoZWRQb3MgPSAwO1xuICAgICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBhZHZhbmNlKHBlZyRjYWNoZWRQb3NEZXRhaWxzLCBwZWckY2FjaGVkUG9zLCBwb3MpO1xuICAgICAgICBwZWckY2FjaGVkUG9zID0gcG9zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVnJGNhY2hlZFBvc0RldGFpbHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgICB9XG5cbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIGV4cGVjdGVkLCBwb3MpIHtcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgICB2YXIgaSA9IDE7XG5cbiAgICAgICAgZXhwZWN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChhLmRlc2NyaXB0aW9uID4gYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRbaSAtIDFdID09PSBleHBlY3RlZFtpXSkge1xuICAgICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDE4MC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTEwODAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZERlc2NzID0gbmV3IEFycmF5KGV4cGVjdGVkLmxlbmd0aCksXG4gICAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXG4gICAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgICArIGV4cGVjdGVkRGVzY3NbZXhwZWN0ZWQubGVuZ3RoIC0gMV1cbiAgICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XG5cbiAgICAgICAgZm91bmREZXNjID0gZm91bmQgPyBcIlxcXCJcIiArIHN0cmluZ0VzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG5cbiAgICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZERlc2MgKyBcIiBidXQgXCIgKyBmb3VuZERlc2MgKyBcIiBmb3VuZC5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSxcbiAgICAgICAgICBmb3VuZCAgICAgID0gcG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBvcykgOiBudWxsO1xuXG4gICAgICBpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgbWVzc2FnZSAhPT0gbnVsbCA/IG1lc3NhZ2UgOiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGZvdW5kLFxuICAgICAgICBwb3MsXG4gICAgICAgIHBvc0RldGFpbHMubGluZSxcbiAgICAgICAgcG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RhcnQoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdFBhdHRlcm4oKTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRQYXR0ZXJuKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0RWxlbWVudCgpO1xuICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlb2N0b3Rob3JwZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VzdHJpbmcoKTtcbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlb2N0b3Rob3JwZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdEVsZW1lbnQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICBzMSA9IHBlZyRjMztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlaWQoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJGM2O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZWVsZW1lbnRGb3JtYXQoKTtcbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczUgPSBbczUsIHM2XTtcbiAgICAgICAgICAgICAgICBzNCA9IHM1O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7XG4gICAgICAgICAgICAgICAgczQgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGM1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNSkge1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckYzg7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMChzMywgczQpO1xuICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWVsZW1lbnRGb3JtYXQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMTEpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjNjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlcGx1cmFsRm9ybWF0UGF0dGVybigpO1xuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMyhzMiwgczYpO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEzKSA9PT0gcGVnJGMxNCkge1xuICAgICAgICAgICAgczIgPSBwZWckYzE0O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgczQgPSBwZWckYzY7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZXBsdXJhbEZvcm1hdFBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzEzKHMyLCBzNik7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGMxNikge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRjMTY7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgICAgczQgPSBwZWckYzY7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZXNlbGVjdEZvcm1hdFBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMyhzMiwgczYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRwYXJzZWlkKCk7XG4gICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMzID0gW107XG4gICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VhcmdTdHlsZVBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VhcmdTdHlsZVBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxOChzMiwgczMpO1xuICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXBsdXJhbEZvcm1hdFBhdHRlcm4oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW9mZnNldFBhdHRlcm4oKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRjNTtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZXBsdXJhbEZvcm0oKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlcGx1cmFsRm9ybSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMTkoczEsIHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlb2Zmc2V0UGF0dGVybigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczc7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGMyMCkge1xuICAgICAgICAgIHMyID0gcGVnJGMyMDtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjEpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGMyMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZWRpZ2l0cygpO1xuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNChzNik7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXBsdXJhbEZvcm0oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzODtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlcGx1cmFsS2V5KCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjMpIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzM7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNSkge1xuICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJGM4O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNShzMiwgczYpO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VwbHVyYWxLZXkoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlaWQoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzI2KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2MSkge1xuICAgICAgICAgIHMxID0gcGVnJGMyNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VkaWdpdHMoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzI0KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2VsZWN0Rm9ybWF0UGF0dGVybigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIHMyID0gcGVnJHBhcnNlc2VsZWN0Rm9ybSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlc2VsZWN0Rm9ybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMjtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzI5KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzZWxlY3RGb3JtKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczg7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWlkKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjMpIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzM7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNSkge1xuICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJGM4O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNShzMiwgczYpO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VhcmdTdHlsZVBhdHRlcm4oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjNjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlaWQoKTtcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzMwKHM0KTtcbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlb2N0b3Rob3JwZSgpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM1KSB7XG4gICAgICAgIHMxID0gcGVnJGMzMTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMyKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMzMoKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzdHJpbmcoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBzMiA9IHBlZyRwYXJzZWNoYXJzKCk7XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2V3aGl0ZXNwYWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VjaGFycygpO1xuICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2V3aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMjtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzM0KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VpZCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKHBlZyRjMzYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzcpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczUgPSBbXTtcbiAgICAgICAgICBpZiAocGVnJGMzOC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzNiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzkpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICBpZiAocGVnJGMzOC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM5KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5zdWJzdHJpbmcoczIsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBzMiA9IHMzO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzQwKHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNSk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNoYXJzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VjaGFyKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VjaGFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNDEoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNoYXIoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChwZWckYzQyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDMpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM0NChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzQ1KSB7XG4gICAgICAgICAgczEgPSBwZWckYzQ1O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Nik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNDcoKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzQ4KSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNDg7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDkpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNTAoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM1MSkge1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjNTE7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzUzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzU0KSB7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzU0O1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1NSk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNTYoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzU3KSB7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNTc7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNTkoczIsIHMzLCBzNCwgczUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWRpZ2l0cygpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzYwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjEpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjNjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYxKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM2MihzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaGV4RGlnaXQoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChwZWckYzYzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjQpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VfKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBzMiA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBwZWckcGFyc2V3aGl0ZXNwYWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM2NihzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjUpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2V3aGl0ZXNwYWNlKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGM2Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY4KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdCA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbigpO1xuXG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHBlZyRmYWlsKHsgdHlwZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiZW5kIG9mIGlucHV0XCIgfSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihudWxsLCBwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTeW50YXhFcnJvcjogU3ludGF4RXJyb3IsXG4gICAgcGFyc2U6ICAgICAgIHBhcnNlXG4gIH07XG59KCkpLnBhcnNlO1xuXG5cbi8qKiBAZmlsZSBtZXNzYWdlZm9ybWF0LmpzIC0gSUNVIFBsdXJhbEZvcm1hdCArIFNlbGVjdEZvcm1hdCBmb3IgSmF2YVNjcmlwdFxuICogIEBhdXRob3IgQWxleCBTZXh0b24gLSBAU2xleEF4dG9uXG4gKiAgQHZlcnNpb24gMC4zLjAtMVxuICogIEBjb3B5cmlnaHQgMjAxMi0yMDE1IEFsZXggU2V4dG9uLCBFZW1lbGkgQXJvLCBhbmQgQ29udHJpYnV0b3JzXG4gKiAgQGxpY2Vuc2UgVG8gdXNlIG9yIGZvcmssIE1JVC4gVG8gY29udHJpYnV0ZSBiYWNrLCBEb2pvIENMQSAgKi9cblxuXG4vKiogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcXVvdGluZyBhbiBPYmplY3QncyBrZXkgdmFsdWUgaWZmIHJlcXVpcmVkXG4gKiAgQHByaXZhdGUgICovXG5mdW5jdGlvbiBwcm9wbmFtZShrZXksIG9iaikge1xuICBpZiAoL15bQS1aXyRdWzAtOUEtWl8kXSokL2kudGVzdChrZXkpKSB7XG4gICAgcmV0dXJuIG9iaiA/IG9iaiArICcuJyArIGtleSA6IGtleTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgamtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgcmV0dXJuIG9iaiA/IG9iaiArICdbJyArIGprZXkgKyAnXScgOiBqa2V5O1xuICB9XG59O1xuXG5cbi8qKiBDcmVhdGUgYSBuZXcgbWVzc2FnZSBmb3JtYXR0ZXJcbiAqXG4gKiAgQGNsYXNzXG4gKiAgQGdsb2JhbFxuICogIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbbG9jYWxlPVwiZW5cIl0gLSBUaGUgbG9jYWxlIHRvIHVzZSwgd2l0aCBmYWxsYmFja3NcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbcGx1cmFsRnVuY10gLSBPcHRpb25hbCBjdXN0b20gcGx1cmFsaXphdGlvbiBmdW5jdGlvblxuICogIEBwYXJhbSB7ZnVuY3Rpb25bXX0gW2Zvcm1hdHRlcnNdIC0gT3B0aW9uYWwgY3VzdG9tIGZvcm1hdHRpbmcgZnVuY3Rpb25zICAqL1xuZnVuY3Rpb24gTWVzc2FnZUZvcm1hdChsb2NhbGUsIHBsdXJhbEZ1bmMsIGZvcm1hdHRlcnMpIHtcbiAgdGhpcy5sYyA9IFtsb2NhbGVdOyAgXG4gIHRoaXMucnVudGltZS5wbHVyYWxGdW5jcyA9IHt9O1xuICB0aGlzLnJ1bnRpbWUucGx1cmFsRnVuY3NbdGhpcy5sY1swXV0gPSBwbHVyYWxGdW5jO1xuICB0aGlzLnJ1bnRpbWUuZm10ID0ge307XG4gIGlmIChmb3JtYXR0ZXJzKSBmb3IgKHZhciBmIGluIGZvcm1hdHRlcnMpIHtcbiAgICB0aGlzLnJ1bnRpbWUuZm10W2ZdID0gZm9ybWF0dGVyc1tmXTtcbiAgfVxufVxuXG5cblxuXG4vKiogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIHRvIGl0cyBBU1RcbiAqXG4gKiAgUHJlY29tcGlsZWQgZnJvbSBgbGliL21lc3NhZ2Vmb3JtYXQtcGFyc2VyLnBlZ2pzYCBieVxuICogIHtAbGluayBodHRwOi8vcGVnanMub3JnLyBQRUcuanN9LiBJbmNsdWRlZCBpbiBNZXNzYWdlRm9ybWF0IG9iamVjdFxuICogIHRvIGVuYWJsZSB0ZXN0aW5nLlxuICpcbiAqICBAcHJpdmF0ZSAgKi9cblxuXG5cbi8qKiBQbHVyYWxpemF0aW9uIGZ1bmN0aW9ucyBmcm9tXG4gKiAge0BsaW5rIGh0dHA6Ly9naXRodWIuY29tL2VlbWVsaS9tYWtlLXBsdXJhbC5qcyBtYWtlLXBsdXJhbH1cbiAqXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcbiAqICBAdHlwZSBPYmplY3QuPHN0cmluZyxmdW5jdGlvbj4gICovXG5NZXNzYWdlRm9ybWF0LnBsdXJhbHMgPSB7fTtcblxuXG4vKiogRGVmYXVsdCBudW1iZXIgZm9ybWF0dGluZyBmdW5jdGlvbnMgaW4gdGhlIHN0eWxlIG9mIElDVSdzXG4gKiAge0BsaW5rIGh0dHA6Ly9pY3UtcHJvamVjdC5vcmcvYXBpcmVmL2ljdTRqL2NvbS9pYm0vaWN1L3RleHQvTWVzc2FnZUZvcm1hdC5odG1sIHNpbXBsZUFyZyBzeW50YXh9XG4gKiAgaW1wbGVtZW50ZWQgdXNpbmcgdGhlXG4gKiAge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwgSW50bH1cbiAqICBvYmplY3QgZGVmaW5lZCBieSBFQ01BLTQwMi5cbiAqXG4gKiAgKipOb3RlKio6IEludGwgaXMgbm90IGRlZmluZWQgaW4gZGVmYXVsdCBOb2RlIHVudGlsIDAuMTEuMTUgLyAwLjEyLjAsIHNvXG4gKiAgZWFybGllciB2ZXJzaW9ucyByZXF1aXJlIGEge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2ludGwgcG9seWZpbGx9LlxuICogIFRoZXJlZm9yZSB7QGxpbmsgTWVzc2FnZUZvcm1hdC53aXRoSW50bFN1cHBvcnR9IG5lZWRzIHRvIGJlIHRydWUgZm9yIHRoZXNlXG4gKiAgZnVuY3Rpb25zIHRvIGJlIGF2YWlsYWJsZSBmb3IgaW5jbHVzaW9uIGluIHRoZSBvdXRwdXQuXG4gKlxuICogIEBzZWUgTWVzc2FnZUZvcm1hdCNzZXRJbnRsU3VwcG9ydFxuICpcbiAqICBAbmFtZXNwYWNlXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcbiAqICBAcHJvcGVydHkge2Z1bmN0aW9ufSBudW1iZXIgLSBSZXByZXNlbnQgYSBudW1iZXIgYXMgYW4gaW50ZWdlciwgcGVyY2VudCBvciBjdXJyZW5jeSB2YWx1ZVxuICogIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGRhdGUgLSBSZXByZXNlbnQgYSBkYXRlIGFzIGEgZnVsbC9sb25nL2RlZmF1bHQvc2hvcnQgc3RyaW5nXG4gKiAgQHByb3BlcnR5IHtmdW5jdGlvbn0gdGltZSAtIFJlcHJlc2VudCBhIHRpbWUgYXMgYSBmdWxsL2xvbmcvZGVmYXVsdC9zaG9ydCBzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICA+IHZhciBNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnbWVzc2FnZWZvcm1hdCcpO1xuICogID4gdmFyIG1mID0gKG5ldyBNZXNzYWdlRm9ybWF0KCdlbicpKS5zZXRJbnRsU3VwcG9ydCh0cnVlKTtcbiAqICA+IG1mLmN1cnJlbmN5ID0gJ0VVUic7XG4gKiAgPiB2YXIgbWZ1bmMgPSBtZi5jb21waWxlKFwiVGhlIHRvdGFsIGlzIHtWLG51bWJlcixjdXJyZW5jeX0uXCIpO1xuICogID4gbWZ1bmMoe1Y6NS41fSlcbiAqICBcIlRoZSB0b3RhbCBpcyDigqw1LjUwLlwiXG4gKlxuICogIEBleGFtcGxlXG4gKiAgPiB2YXIgTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ21lc3NhZ2Vmb3JtYXQnKTtcbiAqICA+IHZhciBtZiA9IG5ldyBNZXNzYWdlRm9ybWF0KCdlbicsIG51bGwsIHtudW1iZXI6IE1lc3NhZ2VGb3JtYXQubnVtYmVyfSk7XG4gKiAgPiBtZi5jdXJyZW5jeSA9ICdFVVInO1xuICogID4gdmFyIG1mdW5jID0gbWYuY29tcGlsZShcIlRoZSB0b3RhbCBpcyB7VixudW1iZXIsY3VycmVuY3l9LlwiKTtcbiAqICA+IG1mdW5jKHtWOjUuNX0pXG4gKiAgXCJUaGUgdG90YWwgaXMg4oKsNS41MC5cIiAgKi9cbk1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVycyA9IHt9O1xuXG4vKiogRW5hYmxlIG9yIGRpc2FibGUgc3VwcG9ydCBmb3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVycywgd2hpY2ggcmVxdWlyZSB0aGVcbiAqICBgSW50bGAgb2JqZWN0LiBOb3RlIHRoYXQgdGhpcyBjYW4ndCBiZSBhdXRvZGV0ZWN0ZWQsIGFzIHRoZSBlbnZpcm9ubWVudFxuICogIGluIHdoaWNoIHRoZSBmb3JtYXR0ZWQgdGV4dCBpcyBjb21waWxlZCBpbnRvIEphdmFzY3JpcHQgZnVuY3Rpb25zIGlzIG5vdFxuICogIG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGVudmlyb25tZW50IGluIHdoaWNoIHRoZXkgd2lsbCBnZXQgZXhlY3V0ZWQuXG4gKlxuICogIEBzZWUgTWVzc2FnZUZvcm1hdC5mb3JtYXR0ZXJzXG4gKlxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XG4gKiAgQHBhcmFtIHtib29sZWFufSBbZW5hYmxlPXRydWVdXG4gKiAgQHJldHVybnMge09iamVjdH0gVGhlIE1lc3NhZ2VGb3JtYXQgaW5zdGFuY2UsIHRvIGFsbG93IGZvciBjaGFpbmluZ1xuICogIEBleGFtcGxlXG4gKiAgPiB2YXIgSW50bCA9IHJlcXVpcmUoJ2ludGwnKTtcbiAqICA+IHZhciBNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnbWVzc2FnZWZvcm1hdCcpO1xuICogID4gdmFyIG1mID0gKG5ldyBNZXNzYWdlRm9ybWF0KCdlbicpKS5zZXRJbnRsU3VwcG9ydCh0cnVlKTtcbiAqICA+IG1mLmN1cnJlbmN5ID0gJ0VVUic7XG4gKiAgPiBtZi5jb21waWxlKFwiVGhlIHRvdGFsIGlzIHtWLG51bWJlcixjdXJyZW5jeX0uXCIpKHtWOjUuNX0pO1xuICogIFwiVGhlIHRvdGFsIGlzIOKCrDUuNTAuXCIgICovXG5cblxuXG4vKiogQSBzZXQgb2YgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBhcmUgY2FsbGVkIGJ5IHRoZSBjb21waWxlZCBKYXZhc2NyaXB0XG4gKiAgZnVuY3Rpb25zLCB0aGVzZSBhcmUgaW5jbHVkZWQgbG9jYWxseSBpbiB0aGUgb3V0cHV0IG9mIHtAbGlua1xuICogIE1lc3NhZ2VGb3JtYXQjY29tcGlsZSBjb21waWxlKCl9LlxuICpcbiAqICBAbmFtZXNwYWNlXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXQgICovXG5NZXNzYWdlRm9ybWF0LnByb3RvdHlwZS5ydW50aW1lID0ge1xuXG4gIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBgI2AgaW4gcGx1cmFsIHJ1bGVzXG4gICAqXG4gICAqICBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gb3BlcmF0ZSBvblxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBBbiBvcHRpb25hbCBvZmZzZXQsIHNldCBieSB0aGUgc3Vycm91bmRpbmcgY29udGV4dCAgKi9cbiAgbnVtYmVyOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgdmFsdWUgKyBcIicgaXNuJ3QgYSBudW1iZXIuXCIpO1xuICAgIHJldHVybiB2YWx1ZSAtIChvZmZzZXQgfHwgMCk7XG4gIH0sXG5cbiAgLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGB7TiwgcGx1cmFsfHNlbGVjdG9yZGluYWwsIC4uLn1gXG4gICAqXG4gICAqICBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUga2V5IHRvIHVzZSB0byBmaW5kIGEgcGx1cmFsaXphdGlvbiBydWxlXG4gICAqICBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gQW4gb2Zmc2V0IHRvIGFwcGx5IHRvIGB2YWx1ZWBcbiAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGxjZnVuYyAtIEEgbG9jYWxlIGZ1bmN0aW9uIGZyb20gYHBsdXJhbEZ1bmNzYFxuICAgKiAgQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBkYXRhIC0gVGhlIG9iamVjdCBmcm9tIHdoaWNoIHJlc3VsdHMgYXJlIGxvb2tlZCB1cFxuICAgKiAgQHBhcmFtIHs/Ym9vbGVhbn0gaXNPcmRpbmFsIC0gSWYgdHJ1ZSwgdXNlIG9yZGluYWwgcmF0aGVyIHRoYW4gY2FyZGluYWwgcnVsZXNcbiAgICogIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXN1bHQgb2YgdGhlIHBsdXJhbGl6YXRpb24gICovXG4gIHBsdXJhbDogZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbGNmdW5jLCBkYXRhLCBpc09yZGluYWwpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCB2YWx1ZSkpIHJldHVybiBkYXRhW3ZhbHVlXSgpO1xuICAgIGlmIChvZmZzZXQpIHZhbHVlIC09IG9mZnNldDtcbiAgICB2YXIga2V5ID0gbGNmdW5jKHZhbHVlLCBpc09yZGluYWwpO1xuICAgIGlmIChrZXkgaW4gZGF0YSkgcmV0dXJuIGRhdGFba2V5XSgpO1xuICAgIHJldHVybiBkYXRhLm90aGVyKCk7XG4gIH0sXG5cbiAgLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGB7Tiwgc2VsZWN0LCAuLi59YFxuICAgKlxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGtleSB0byB1c2UgdG8gZmluZCBhIHNlbGVjdGlvblxuICAgKiAgQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBkYXRhIC0gVGhlIG9iamVjdCBmcm9tIHdoaWNoIHJlc3VsdHMgYXJlIGxvb2tlZCB1cFxuICAgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBvZiB0aGUgc2VsZWN0IHN0YXRlbWVudCAgKi9cbiAgc2VsZWN0OiBmdW5jdGlvbih2YWx1ZSwgZGF0YSkge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHZhbHVlKSkgcmV0dXJuIGRhdGFbdmFsdWVdKCk7XG4gICAgcmV0dXJuIGRhdGEub3RoZXIoKVxuICB9LFxuXG4gIC8qKiBQbHVyYWxpemF0aW9uIGZ1bmN0aW9ucyBpbmNsdWRlZCBpbiBjb21waWxlZCBvdXRwdXRcbiAgICogIEBpbnN0YW5jZVxuICAgKiAgQHR5cGUgT2JqZWN0LjxzdHJpbmcsZnVuY3Rpb24+ICAqL1xuICBwbHVyYWxGdW5jczoge30sXG5cbiAgLyoqIEN1c3RvbSBmb3JtYXR0aW5nIGZ1bmN0aW9ucyBjYWxsZWQgYnkgYHt2YXIsIGZuWywgYXJnc10qfWAgc3ludGF4XG4gICAqXG4gICAqICBGb3IgZXhhbXBsZXMsIHNlZSB7QGxpbmsgTWVzc2FnZUZvcm1hdC5mb3JtYXR0ZXJzfVxuICAgKlxuICAgKiAgQGluc3RhbmNlXG4gICAqICBAc2VlIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVyc1xuICAgKiAgQHR5cGUgT2JqZWN0LjxzdHJpbmcsZnVuY3Rpb24+ICAqL1xuICBmbXQ6IHt9LFxuXG4gIC8qKiBDdXN0b20gc3RyaW5naWZpZXIgdG8gY2xlYW4gdXAgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXNcbiAgICogIEBpbnN0YW5jZSAgKi9cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3N0cmluZ2lmeSA9IGZ1bmN0aW9uKG8sIGxldmVsKSB7XG4gICAgICBpZiAodHlwZW9mIG8gIT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGZ1bmNTdHIgPSBvLnRvU3RyaW5nKCkucmVwbGFjZSgvXihmdW5jdGlvbiApXFx3Ki8sICckMScpO1xuICAgICAgICB2YXIgaW5kZW50ID0gLyhbIFxcdF0qKVxcUy4qJC8uZXhlYyhmdW5jU3RyKTtcbiAgICAgICAgcmV0dXJuIGluZGVudCA/IGZ1bmNTdHIucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGluZGVudFsxXSwgJ21nJyksICcnKSA6IGZ1bmNTdHI7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSBpbiBvKSBpZiAoaSAhPSAndG9TdHJpbmcnKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PSAwKSBzLnB1c2goJ3ZhciAnICsgaSArICcgPSAnICsgX3N0cmluZ2lmeShvW2ldLCBsZXZlbCArIDEpICsgJztcXG4nKTtcbiAgICAgICAgZWxzZSBzLnB1c2gocHJvcG5hbWUoaSkgKyAnOiAnICsgX3N0cmluZ2lmeShvW2ldLCBsZXZlbCArIDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PSAwKSByZXR1cm4gcy5qb2luKCcnKTtcbiAgICAgIGlmIChzLmxlbmd0aCA9PSAwKSByZXR1cm4gJ3t9JztcbiAgICAgIHZhciBpbmRlbnQgPSAnICAnOyB3aGlsZSAoLS1sZXZlbCkgaW5kZW50ICs9ICcgICc7XG4gICAgICByZXR1cm4gJ3tcXG4nICsgcy5qb2luKCcsXFxuJykucmVwbGFjZSgvXi9nbSwgaW5kZW50KSArICdcXG59JztcbiAgICB9O1xuICAgIHJldHVybiBfc3RyaW5naWZ5KHRoaXMsIDApO1xuICB9XG59O1xuXG5cbi8qKiBSZWN1cnNpdmVseSBtYXAgYW4gQVNUIHRvIGl0cyByZXN1bHRpbmcgc3RyaW5nXG4gKlxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XG4gKlxuICogIEBwYXJhbSBhc3QgLSB0aGUgQXN0IG5vZGUgZm9yIHdoaWNoIHRoZSBKUyBjb2RlIHNob3VsZCBiZSBnZW5lcmF0ZWRcbiAqXG4gKiAgQHByaXZhdGUgICovXG5NZXNzYWdlRm9ybWF0LnByb3RvdHlwZS5fcHJlY29tcGlsZSA9IGZ1bmN0aW9uKGFzdCwgZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7IGtleXM6IHt9LCBvZmZzZXQ6IHt9IH07XG4gIHZhciByID0gW10sIGksIHRtcCwgYXJncyA9IFtdO1xuXG4gIHN3aXRjaCAoIGFzdC50eXBlICkge1xuICAgIGNhc2UgJ21lc3NhZ2VGb3JtYXRQYXR0ZXJuJzpcbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXN0LnN0YXRlbWVudHMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgIHIucHVzaCh0aGlzLl9wcmVjb21waWxlKCBhc3Quc3RhdGVtZW50c1tpXSwgZGF0YSApKTtcbiAgICAgIH1cbiAgICAgIHRtcCA9IHIuam9pbignICsgJykgfHwgJ1wiXCInO1xuICAgICAgcmV0dXJuIGRhdGEucGZfY291bnQgPyB0bXAgOiAnZnVuY3Rpb24oZCkgeyByZXR1cm4gJyArIHRtcCArICc7IH0nO1xuXG4gICAgY2FzZSAnbWVzc2FnZUZvcm1hdEVsZW1lbnQnOlxuICAgICAgZGF0YS5wZl9jb3VudCA9IGRhdGEucGZfY291bnQgfHwgMDtcbiAgICAgIGlmICggYXN0Lm91dHB1dCApIHtcbiAgICAgICAgcmV0dXJuIHByb3BuYW1lKGFzdC5hcmd1bWVudEluZGV4LCAnZCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRhdGEua2V5c1tkYXRhLnBmX2NvdW50XSA9IGFzdC5hcmd1bWVudEluZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlY29tcGlsZSggYXN0LmVsZW1lbnRGb3JtYXQsIGRhdGEgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcblxuICAgIGNhc2UgJ2VsZW1lbnRGb3JtYXQnOlxuICAgICAgYXJncyA9IFsgcHJvcG5hbWUoZGF0YS5rZXlzW2RhdGEucGZfY291bnRdLCAnZCcpIF07XG4gICAgICBzd2l0Y2ggKGFzdC5rZXkpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICBhcmdzLnB1c2godGhpcy5fcHJlY29tcGlsZShhc3QudmFsLCBkYXRhKSk7XG4gICAgICAgICAgcmV0dXJuICdzZWxlY3QoJyArIGFyZ3Muam9pbignLCAnKSArICcpJztcbiAgICAgICAgY2FzZSAnc2VsZWN0b3JkaW5hbCc6XG4gICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFsgMCwgcHJvcG5hbWUodGhpcy5sY1swXSwgJ3BsdXJhbEZ1bmNzJyksIHRoaXMuX3ByZWNvbXBpbGUoYXN0LnZhbCwgZGF0YSksIDEgXSk7XG4gICAgICAgICAgcmV0dXJuICdwbHVyYWwoJyArIGFyZ3Muam9pbignLCAnKSArICcpJztcbiAgICAgICAgY2FzZSAncGx1cmFsJzpcbiAgICAgICAgICBkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50IHx8IDBdID0gYXN0LnZhbC5vZmZzZXQgfHwgMDtcbiAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoWyBkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50XSB8fCAwLCBwcm9wbmFtZSh0aGlzLmxjWzBdLCAncGx1cmFsRnVuY3MnKSwgdGhpcy5fcHJlY29tcGlsZShhc3QudmFsLCBkYXRhKSBdKTtcbiAgICAgICAgICByZXR1cm4gJ3BsdXJhbCgnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0aGlzLndpdGhJbnRsU3VwcG9ydCAmJiAhKGFzdC5rZXkgaW4gdGhpcy5ydW50aW1lLmZtdCkgJiYgKGFzdC5rZXkgaW4gTWVzc2FnZUZvcm1hdC5mb3JtYXR0ZXJzKSkge1xuICAgICAgICAgICAgdG1wID0gTWVzc2FnZUZvcm1hdC5mb3JtYXR0ZXJzW2FzdC5rZXldO1xuICAgICAgICAgICAgdGhpcy5ydW50aW1lLmZtdFthc3Qua2V5XSA9ICh0eXBlb2YgdG1wKHRoaXMpID09ICdmdW5jdGlvbicpID8gdG1wKHRoaXMpIDogdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzLnB1c2goSlNPTi5zdHJpbmdpZnkodGhpcy5sYykpO1xuICAgICAgICAgIGlmIChhc3QudmFsICYmIGFzdC52YWwubGVuZ3RoKSBhcmdzLnB1c2goSlNPTi5zdHJpbmdpZnkoYXN0LnZhbC5sZW5ndGggPT0gMSA/IGFzdC52YWxbMF0gOiBhc3QudmFsKSk7XG4gICAgICAgICAgcmV0dXJuICdmbXQuJyArIGFzdC5rZXkgKyAnKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICB9XG5cbiAgICBjYXNlICdwbHVyYWxGb3JtYXRQYXR0ZXJuJzpcbiAgICBjYXNlICdzZWxlY3RGb3JtYXRQYXR0ZXJuJzpcbiAgICAgIGRhdGEucGZfY291bnQgPSBkYXRhLnBmX2NvdW50IHx8IDA7XG4gICAgICBpZiAoYXN0LnR5cGUgPT0gJ3NlbGVjdEZvcm1hdFBhdHRlcm4nKSBkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50XSA9IDA7XG4gICAgICB2YXIgbmVlZE90aGVyID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhc3QucGx1cmFsRm9ybXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGFzdC5wbHVyYWxGb3Jtc1tpXS5rZXk7XG4gICAgICAgIGlmIChrZXkgPT09ICdvdGhlcicpIG5lZWRPdGhlciA9IGZhbHNlO1xuICAgICAgICB2YXIgZGF0YV9jb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGRhdGFfY29weS5wZl9jb3VudCsrO1xuICAgICAgICByLnB1c2gocHJvcG5hbWUoa2V5KSArICc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJyArIHRoaXMuX3ByZWNvbXBpbGUoYXN0LnBsdXJhbEZvcm1zW2ldLnZhbCwgZGF0YV9jb3B5KSArICc7fScpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRPdGhlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gJ290aGVyJyBmb3JtIGZvdW5kIGluIFwiICsgYXN0LnR5cGUgKyBcIiBcIiArIGRhdGEucGZfY291bnQpO1xuICAgICAgcmV0dXJuICd7ICcgKyByLmpvaW4oJywgJykgKyAnIH0nO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhc3QudmFsIHx8IFwiXCIpO1xuXG4gICAgY2FzZSAnb2N0b3Rob3JwZSc6XG4gICAgICBpZiAoIWRhdGEucGZfY291bnQpIHJldHVybiAnXCIjXCInO1xuICAgICAgYXJncyA9IFsgcHJvcG5hbWUoZGF0YS5rZXlzW2RhdGEucGZfY291bnQtMV0sICdkJykgXTtcbiAgICAgIGlmIChkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50LTFdKSBhcmdzLnB1c2goZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudC0xXSk7XG4gICAgICByZXR1cm4gJ251bWJlcignICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvciggJ0JhZCBBU1QgdHlwZTogJyArIGFzdC50eXBlICk7XG4gIH1cbn07XG5cbi8qKiBDb21waWxlIG1lc3NhZ2VzIGludG8gYW4gZXhlY3V0YWJsZSBmdW5jdGlvbiB3aXRoIGNsZWFuIHN0cmluZ1xuICogIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqICBJZiBgbWVzc2FnZXNgIGlzIGEgc2luZ2xlIHN0cmluZyBpbmNsdWRpbmcgSUNVIE1lc3NhZ2VGb3JtYXQgZGVjbGFyYXRpb25zLFxuICogIGBvcHRgIGlzIGlnbm9yZWQgYW5kIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHNpbmdsZSBPYmplY3QgcGFyYW1ldGVyXG4gKiAgYGRgIHJlcHJlc2VudGluZyBlYWNoIG9mIHRoZSBpbnB1dCdzIGRlZmluZWQgdmFyaWFibGVzLiBUaGUgcmV0dXJuZWRcbiAqICBmdW5jdGlvbiB3aWxsIGJlIGRlZmluZWQgaW4gYSBsb2NhbCBzY29wZSB0aGF0IGluY2x1ZGVzIGFsbCB0aGUgcmVxdWlyZWRcbiAqICBydW50aW1lIHZhcmlhYmxlcy5cbiAqXG4gKiAgSWYgYG1lc3NhZ2VzYCBpcyBhIG1hcCBvZiBrZXlzIHRvIHN0cmluZ3MsIG9yIGEgbWFwIG9mIG5hbWVzcGFjZSBrZXlzIHRvXG4gKiAgc3VjaCBrZXkvc3RyaW5nIG1hcHMsIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGZpbGwgdGhlIHNwZWNpZmllZCBnbG9iYWxcbiAqICB3aXRoIGphdmFzY3JpcHQgZnVuY3Rpb25zIG1hdGNoaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGlucHV0LiBJbiBzdWNoIHVzZSxcbiAqICB0aGUgb3V0cHV0IG9mIGBjb21waWxlKClgIGlzIGV4cGVjdGVkIHRvIGJlIHNlcmlhbGl6ZWQgdXNpbmcgYC50b1N0cmluZygpYCxcbiAqICBhbmQgd2lsbCBpbmNsdWRlIGRlZmluaXRpb25zIG9mIHRoZSBydW50aW1lIGZ1bmN0aW9ucy4gSWYgYG9wdC5nbG9iYWxgIGlzXG4gKiAgbnVsbCwgY2FsbGluZyB0aGUgb3V0cHV0IGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBvYmplY3QgaXRzZWxmLlxuICpcbiAqICBUb2dldGhlciwgdGhlIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmcgcGF0dGVybnM6XG4gKiAgYGBganNcbiAqICBtZXNzYWdlcyA9IFwic3RyaW5nXCIgfHwgeyBrZXkwOiBcInN0cmluZzBcIiwga2V5MTogXCJzdHJpbmcxXCIsIC4uLiB9IHx8IHtcbiAqICAgIG5zMDogeyBrZXkwOiBcInN0cmluZzBcIiwga2V5MTogXCJzdHJpbmcxXCIsIC4uLiAgfSxcbiAqICAgIG5zMTogeyBrZXkwOiBcInN0cmluZzBcIiwga2V5MTogXCJzdHJpbmcxXCIsIC4uLiAgfSxcbiAqICAgIC4uLlxuICogIH1cbiAqXG4gKiAgb3B0ID0gbnVsbCB8fCB7XG4gKiAgICBsb2NhbGU6IG51bGwgfHwge1xuICogICAgICBuczA6IFwibGMwXCIgfHwgWyBcImxjMFwiLCAuLi4gXSxcbiAqICAgICAgbnMxOiBcImxjMVwiIHx8IFsgXCJsYzFcIiwgLi4uIF0sXG4gKiAgICAgIC4uLlxuICogICAgfSxcbiAqICAgIGdsb2JhbDogbnVsbCB8fCBcIm1vZHVsZS5leHBvcnRzXCIgfHwgXCJleHBvcnRzXCIgfHwgXCJpMThuXCIgfHwgLi4uXG4gKiAgfVxuICogIGBgYFxuICpcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdFxuICogIEBwYXJhbSB7c3RyaW5nfE9iamVjdH1cbiAqICAgICAgbWVzc2FnZXMgLSBUaGUgaW5wdXQgbWVzc2FnZShzKSB0byBiZSBjb21waWxlZCwgaW4gSUNVIE1lc3NhZ2VGb3JtYXRcbiAqICBAcGFyYW0ge09iamVjdH0gW29wdD17fV0gLSBPcHRpb25zIGNvbnRyb2xsaW5nIG91dHB1dCBmb3Igbm9uLXNpbXBsZSBpbnRwdXRcbiAqICBAcGFyYW0ge09iamVjdH0gW29wdC5sb2NhbGVdIC0gVGhlIGxvY2FsZXMgdG8gdXNlIGZvciB0aGUgbWVzc2FnZXMsIHdpdGggYVxuICogICAgICBzdHJ1Y3R1cmUgbWF0Y2hpbmcgdGhhdCBvZiBgbWVzc2FnZXNgXG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtvcHQuZ2xvYmFsPVwiXCJdIC0gVGhlIGdsb2JhbCB2YXJpYWJsZSB0aGF0IHRoZSBvdXRwdXRcbiAqICAgICAgZnVuY3Rpb24gc2hvdWxkIHVzZSwgb3IgYSBudWxsIHN0cmluZyBmb3Igbm9uZS4gXCJleHBvcnRzXCIgYW5kXG4gKiAgICAgIFwibW9kdWxlLmV4cG9ydHNcIiBhcmUgcmVjb2duaXNlZCBhcyBzcGVjaWFsIGNhc2VzLlxuICogIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIGZpcnN0IG1hdGNoIGZvdW5kIGZvciB0aGUgZ2l2ZW4gbG9jYWxlKHMpXG4gKlxuICogIEBleGFtcGxlXG4gKiA+IHZhciBNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnbWVzc2FnZWZvcm1hdCcpLFxuICogLi4uICAgbWYgPSBuZXcgTWVzc2FnZUZvcm1hdCgnZW4nKSxcbiAqIC4uLiAgIG1mdW5jMCA9IG1mLmNvbXBpbGUoJ0Ege1RZUEV9IGV4YW1wbGUuJyk7XG4gKiA+IG1mdW5jMCh7VFlQRTonc2ltcGxlJ30pXG4gKiAnQSBzaW1wbGUgZXhhbXBsZS4nXG4gKiA+IG1mdW5jMC50b1N0cmluZygpXG4gKiAnZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFwiQSBcIiArIGQuVFlQRSArIFwiIGV4YW1wbGUuXCI7IH0nXG4gKlxuICogIEBleGFtcGxlXG4gKiA+IHZhciBtc2dTZXQgPSB7IGE6ICdBIHtUWVBFfSBleGFtcGxlLicsXG4gKiAuLi4gICAgICAgICAgICAgIGI6ICdUaGlzIGhhcyB7Q09VTlQsIHBsdXJhbCwgb25le29uZSBtZW1iZXJ9IG90aGVyeyMgbWVtYmVyc319LicgfSxcbiAqIC4uLiAgIG1mdW5jU2V0ID0gbWYuY29tcGlsZShtc2dTZXQpO1xuICogPiBtZnVuY1NldCgpLmEoe1RZUEU6J21vcmUgY29tcGxleCd9KVxuICogJ0EgbW9yZSBjb21wbGV4IGV4YW1wbGUuJ1xuICogPiBtZnVuY1NldCgpLmIoe0NPVU5UOjJ9KVxuICogJ1RoaXMgaGFzIDIgbWVtYmVycy4nXG4gKlxuICogPiBjb25zb2xlLmxvZyhtZnVuY1NldC50b1N0cmluZygpKVxuICogZnVuY3Rpb24gYW5vbnltb3VzKCkge1xuICogdmFyIG51bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0KSB7XG4gKiAgIGlmIChpc05hTih2YWx1ZSkpIHRocm93IG5ldyBFcnJvcihcIidcIiArIHZhbHVlICsgXCInIGlzbid0IGEgbnVtYmVyLlwiKTtcbiAqICAgcmV0dXJuIHZhbHVlIC0gKG9mZnNldCB8fCAwKTtcbiAqIH07XG4gKiB2YXIgcGx1cmFsID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGxjZnVuYywgZGF0YSwgaXNPcmRpbmFsKSB7XG4gKiAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHZhbHVlKSkgcmV0dXJuIGRhdGFbdmFsdWVdKCk7XG4gKiAgIGlmIChvZmZzZXQpIHZhbHVlIC09IG9mZnNldDtcbiAqICAgdmFyIGtleSA9IGxjZnVuYyh2YWx1ZSwgaXNPcmRpbmFsKTtcbiAqICAgaWYgKGtleSBpbiBkYXRhKSByZXR1cm4gZGF0YVtrZXldKCk7XG4gKiAgIHJldHVybiBkYXRhLm90aGVyKCk7XG4gKiB9O1xuICogdmFyIHNlbGVjdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGF0YSkge1xuICogICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCB2YWx1ZSkpIHJldHVybiBkYXRhW3ZhbHVlXSgpO1xuICogICByZXR1cm4gZGF0YS5vdGhlcigpXG4gKiB9O1xuICogdmFyIHBsdXJhbEZ1bmNzID0ge1xuICogICBlbjogZnVuY3Rpb24gKG4sIG9yZCkge1xuICogICAgIHZhciBzID0gU3RyaW5nKG4pLnNwbGl0KCcuJyksIHYwID0gIXNbMV0sIHQwID0gTnVtYmVyKHNbMF0pID09IG4sXG4gKiAgICAgICAgIG4xMCA9IHQwICYmIHNbMF0uc2xpY2UoLTEpLCBuMTAwID0gdDAgJiYgc1swXS5zbGljZSgtMik7XG4gKiAgICAgaWYgKG9yZCkgcmV0dXJuIChuMTAgPT0gMSAmJiBuMTAwICE9IDExKSA/ICdvbmUnXG4gKiAgICAgICAgIDogKG4xMCA9PSAyICYmIG4xMDAgIT0gMTIpID8gJ3R3bydcbiAqICAgICAgICAgOiAobjEwID09IDMgJiYgbjEwMCAhPSAxMykgPyAnZmV3J1xuICogICAgICAgICA6ICdvdGhlcic7XG4gKiAgICAgcmV0dXJuIChuID09IDEgJiYgdjApID8gJ29uZScgOiAnb3RoZXInO1xuICogICB9XG4gKiB9O1xuICogdmFyIGZtdCA9IHt9O1xuICpcbiAqIHJldHVybiB7XG4gKiAgIGE6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiQSBcIiArIGQuVFlQRSArIFwiIGV4YW1wbGUuXCI7IH0sXG4gKiAgIGI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiVGhpcyBoYXMgXCIgKyBwbHVyYWwoZC5DT1VOVCwgMCwgcGx1cmFsRnVuY3MuZW4sIHsgb25lOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwib25lIG1lbWJlclwiO30sIG90aGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIG51bWJlcihkLkNPVU5UKStcIiBtZW1iZXJzXCI7fSB9KSArIFwiLlwiOyB9XG4gKiB9XG4gKiB9XG4gKlxuICogIEBleGFtcGxlXG4gKiA+IG1mLnJ1bnRpbWUucGx1cmFsRnVuY3MuZmkgPSBNZXNzYWdlRm9ybWF0LnBsdXJhbHMuZmk7XG4gKiA+IHZhciBtdWx0aVNldCA9IHsgZW46IHsgYTogJ0Ege1RZUEV9IGV4YW1wbGUuJyxcbiAqIC4uLiAgICAgICAgICAgICAgICAgICAgICBiOiAnVGhpcyBpcyB0aGUge0NPVU5ULCBzZWxlY3RvcmRpbmFsLCBvbmV7I3N0fSB0d297I25kfSBmZXd7I3JkfSBvdGhlcnsjdGh9fSBleGFtcGxlLicgfSxcbiAqIC4uLiAgICAgICAgICAgICAgICBmaTogeyBhOiAne1RZUEV9IGVzaW1lcmtraS4nLFxuICogLi4uICAgICAgICAgICAgICAgICAgICAgIGI6ICdUw6Rtw6Qgb24ge0NPVU5ULCBzZWxlY3RvcmRpbmFsLCBvdGhlcnsjLn19IGVzaW1lcmtraS4nIH0gfSxcbiAqIC4uLiAgIG11bHRpU2V0TG9jYWxlcyA9IHsgZW46ICdlbicsIGZpOiAnZmknIH0sXG4gKiAuLi4gICBtZnVuY1NldCA9IG1mLmNvbXBpbGUobXVsdGlTZXQsIHsgbG9jYWxlOiBtdWx0aVNldExvY2FsZXMsIGdsb2JhbDogJ2kxOG4nIH0pO1xuICogPiBtZnVuY1NldCh0aGlzKTtcbiAqID4gaTE4bi5lbi5iKHtDT1VOVDozfSlcbiAqICdUaGlzIGlzIHRoZSAzcmQgZXhhbXBsZS4nXG4gKiA+IGkxOG4uZmkuYih7Q09VTlQ6M30pXG4gKiAnVMOkbcOkIG9uIDMuIGVzaW1lcmtraS4nICAqL1xuTWVzc2FnZUZvcm1hdC5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICggbWVzc2FnZXMsIG9wdCApIHtcbiAgdmFyIHIgPSB7fSwgbGMwID0gdGhpcy5sYyxcbiAgICAgIGNvbXBpbGVNc2cgPSBmdW5jdGlvbihzZWxmLCBtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgYXN0ID0gTWVzc2FnZUZvcm1hdC5fcGFyc2UobXNnKTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fcHJlY29tcGlsZShhc3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChhc3QgPyAnUHJlY29tcGlsZXInIDogJ1BhcnNlcicpICsgJyBlcnJvcjogJyArIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdHJpbmdpZnkgPSBmdW5jdGlvbihyLCBsZXZlbCkge1xuICAgICAgICBpZiAoIWxldmVsKSBsZXZlbCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgciAhPSAnb2JqZWN0JykgcmV0dXJuIHI7XG4gICAgICAgIHZhciBvID0gW10sIGluZGVudCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsOyArK2kpIGluZGVudCArPSAnICAnO1xuICAgICAgICBmb3IgKHZhciBrIGluIHIpIG8ucHVzaCgnXFxuJyArIGluZGVudCArICcgICcgKyBwcm9wbmFtZShrKSArICc6ICcgKyBzdHJpbmdpZnkocltrXSwgbGV2ZWwgKyAxKSk7XG4gICAgICAgIHJldHVybiAneycgKyBvLmpvaW4oJywnKSArICdcXG4nICsgaW5kZW50ICsgJ30nO1xuICAgICAgfTtcblxuICBpZiAodHlwZW9mIG1lc3NhZ2VzID09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oXG4gICAgICAgICdudW1iZXIsIHBsdXJhbCwgc2VsZWN0LCBwbHVyYWxGdW5jcywgZm10JyxcbiAgICAgICAgJ3JldHVybiAnICsgY29tcGlsZU1zZyh0aGlzLCBtZXNzYWdlcykpO1xuICAgIHJldHVybiBmKHRoaXMucnVudGltZS5udW1iZXIsIHRoaXMucnVudGltZS5wbHVyYWwsIHRoaXMucnVudGltZS5zZWxlY3QsXG4gICAgICAgIHRoaXMucnVudGltZS5wbHVyYWxGdW5jcywgdGhpcy5ydW50aW1lLmZtdCk7XG4gIH1cblxuICBvcHQgPSBvcHQgfHwge307XG5cbiAgZm9yICh2YXIgbnMgaW4gbWVzc2FnZXMpIHtcbiAgICBpZiAob3B0LmxvY2FsZSkgdGhpcy5sYyA9IG9wdC5sb2NhbGVbbnNdICYmIFtdLmNvbmNhdChvcHQubG9jYWxlW25zXSkgfHwgbGMwO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZXNbbnNdID09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkgeyByW25zXSA9IGNvbXBpbGVNc2codGhpcywgbWVzc2FnZXNbbnNdKTsgfVxuICAgICAgY2F0Y2ggKGUpIHsgZS5tZXNzYWdlID0gZS5tZXNzYWdlLnJlcGxhY2UoJzonLCAnIHdpdGggYCcgKyBucyArICdgOicpOyB0aHJvdyBlOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJbbnNdID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWVzc2FnZXNbbnNdKSB7XG4gICAgICAgIHRyeSB7IHJbbnNdW2tleV0gPSBjb21waWxlTXNnKHRoaXMsIG1lc3NhZ2VzW25zXVtrZXldKTsgfVxuICAgICAgICBjYXRjaCAoZSkgeyBlLm1lc3NhZ2UgPSBlLm1lc3NhZ2UucmVwbGFjZSgnOicsICcgd2l0aCBgJyArIGtleSArICdgIGluIGAnICsgbnMgKyAnYDonKTsgdGhyb3cgZTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMubGMgPSBsYzA7XG4gIHZhciBzID0gdGhpcy5ydW50aW1lLnRvU3RyaW5nKCkgKyAnXFxuJztcbiAgc3dpdGNoIChvcHQuZ2xvYmFsIHx8ICcnKSB7XG4gICAgY2FzZSAnZXhwb3J0cyc6XG4gICAgICB2YXIgbyA9IFtdO1xuICAgICAgZm9yICh2YXIgayBpbiByKSBvLnB1c2gocHJvcG5hbWUoaywgJ2V4cG9ydHMnKSArICcgPSAnICsgc3RyaW5naWZ5KHJba10pKTtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocyArIG8uam9pbignO1xcbicpKTtcbiAgICBjYXNlICdtb2R1bGUuZXhwb3J0cyc6XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHMgKyAnbW9kdWxlLmV4cG9ydHMgPSAnICsgc3RyaW5naWZ5KHIpKTtcbiAgICBjYXNlICcnOlxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzICsgJ3JldHVybiAnICsgc3RyaW5naWZ5KHIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignRycsIHMgKyBwcm9wbmFtZShvcHQuZ2xvYmFsLCAnRycpICsgJyA9ICcgKyBzdHJpbmdpZnkocikpO1xuICB9XG59O1xuXG5cbnJldHVybiBNZXNzYWdlRm9ybWF0O1xufSgpKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxudmFyIGNyZWF0ZUVycm9yUGx1cmFsTW9kdWxlUHJlc2VuY2UgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIGNyZWF0ZUVycm9yKCBcIkVfTUlTU0lOR19QTFVSQUxfTU9EVUxFXCIsIFwiUGx1cmFsIG1vZHVsZSBub3QgbG9hZGVkLlwiICk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVNZXNzYWdlQnVuZGxlID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHZhbGlkYXRlKFxuXHRcdFwiRV9NSVNTSU5HX01FU1NBR0VfQlVORExFXCIsXG5cdFx0XCJNaXNzaW5nIG1lc3NhZ2UgYnVuZGxlIGZvciBsb2NhbGUgYHtsb2NhbGV9YC5cIixcblx0XHRjbGRyLmF0dHJpYnV0ZXMuYnVuZGxlICYmIGNsZHIuZ2V0KCBcImdsb2JhbGl6ZS1tZXNzYWdlcy97YnVuZGxlfVwiICkgIT09IHVuZGVmaW5lZCxcblx0XHR7XG5cdFx0XHRsb2NhbGU6IGNsZHIubG9jYWxlXG5cdFx0fVxuXHQpO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlTWVzc2FnZVByZXNlbmNlID0gZnVuY3Rpb24oIHBhdGgsIHZhbHVlICkge1xuXHRwYXRoID0gcGF0aC5qb2luKCBcIi9cIiApO1xuXHR2YWxpZGF0ZSggXCJFX01JU1NJTkdfTUVTU0FHRVwiLCBcIk1pc3NpbmcgcmVxdWlyZWQgbWVzc2FnZSBjb250ZW50IGB7cGF0aH1gLlwiLFxuXHRcdHZhbHVlICE9PSB1bmRlZmluZWQsIHsgcGF0aDogcGF0aCB9ICk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVNZXNzYWdlVHlwZSA9IGZ1bmN0aW9uKCBwYXRoLCB2YWx1ZSApIHtcblx0cGF0aCA9IHBhdGguam9pbiggXCIvXCIgKTtcblx0dmFsaWRhdGUoXG5cdFx0XCJFX0lOVkFMSURfTUVTU0FHRVwiLFxuXHRcdFwiSW52YWxpZCBtZXNzYWdlIGNvbnRlbnQgYHtwYXRofWAuIHtleHBlY3RlZH0gZXhwZWN0ZWQuXCIsXG5cdFx0dHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLFxuXHRcdHtcblx0XHRcdGV4cGVjdGVkOiBcImEgc3RyaW5nXCIsXG5cdFx0XHRwYXRoOiBwYXRoXG5cdFx0fVxuXHQpO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZU1lc3NhZ2VWYXJpYWJsZXMgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNQbGFpbk9iamVjdCggdmFsdWUgKSB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApLFxuXHRcdFwiQXJyYXkgb3IgUGxhaW4gT2JqZWN0XCJcblx0KTtcbn07XG5cblxuXG5cbnZhciBtZXNzYWdlRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggZm9ybWF0dGVyICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gbWVzc2FnZUZvcm1hdHRlciggdmFyaWFibGVzICkge1xuXHRcdGlmICggdHlwZW9mIHZhcmlhYmxlcyA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFyaWFibGVzID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dmFyaWFibGVzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cdFx0fVxuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU1lc3NhZ2VWYXJpYWJsZXMoIHZhcmlhYmxlcywgXCJ2YXJpYWJsZXNcIiApO1xuXHRcdHJldHVybiBmb3JtYXR0ZXIoIHZhcmlhYmxlcyApO1xuXHR9O1xufTtcblxuXG5cblxudmFyIG1lc3NhZ2VGb3JtYXR0ZXJSdW50aW1lQmluZCA9IGZ1bmN0aW9uKCBjbGRyLCBtZXNzYWdlZm9ybWF0dGVyICkge1xuXHR2YXIgbG9jYWxlID0gY2xkci5sb2NhbGUsXG5cdFx0b3JpZ1RvU3RyaW5nID0gbWVzc2FnZWZvcm1hdHRlci50b1N0cmluZztcblxuXHRtZXNzYWdlZm9ybWF0dGVyLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ05hbWVzLCBhcmdWYWx1ZXMsIG91dHB1dCxcblx0XHRcdGFyZ3MgPSB7fTtcblxuXHRcdC8vIFByb3Blcmx5IGFkanVzdCBTbGV4QXh0b24vbWVzc2FnZWZvcm1hdC5qcyBjb21waWxlZCB2YXJpYWJsZXMgd2l0aCBHbG9iYWxpemUgdmFyaWFibGVzOlxuXHRcdG91dHB1dCA9IG9yaWdUb1N0cmluZy5jYWxsKCBtZXNzYWdlZm9ybWF0dGVyICk7XG5cblx0XHRpZiAoIC9udW1iZXJcXCgvLnRlc3QoIG91dHB1dCApICkge1xuXHRcdFx0YXJncy5udW1iZXIgPSBcIm1lc3NhZ2VGb3JtYXQubnVtYmVyXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCAvcGx1cmFsXFwoLy50ZXN0KCBvdXRwdXQgKSApIHtcblx0XHRcdGFyZ3MucGx1cmFsID0gXCJtZXNzYWdlRm9ybWF0LnBsdXJhbFwiO1xuXHRcdH1cblxuXHRcdGlmICggL3NlbGVjdFxcKC8udGVzdCggb3V0cHV0ICkgKSB7XG5cdFx0XHRhcmdzLnNlbGVjdCA9IFwibWVzc2FnZUZvcm1hdC5zZWxlY3RcIjtcblx0XHR9XG5cblx0XHRvdXRwdXQucmVwbGFjZSggL3BsdXJhbEZ1bmNzKFxcWyhbXlxcXV0rKVxcXXxcXC4oW2EtekEtWl0rKSkvLCBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRhcmdzLnBsdXJhbEZ1bmNzID0gXCJ7XCIgK1xuXHRcdFx0XHRcIlxcXCJcIiArIGxvY2FsZSArIFwiXFxcIjogR2xvYmFsaXplKFxcXCJcIiArIGxvY2FsZSArIFwiXFxcIikucGx1cmFsR2VuZXJhdG9yKClcIiArXG5cdFx0XHRcdFwifVwiO1xuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0pO1xuXG5cdFx0YXJnTmFtZXMgPSBPYmplY3Qua2V5cyggYXJncyApLmpvaW4oIFwiLCBcIiApO1xuXHRcdGFyZ1ZhbHVlcyA9IE9iamVjdC5rZXlzKCBhcmdzICkubWFwKGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gYXJnc1sga2V5IF07XG5cdFx0fSkuam9pbiggXCIsIFwiICk7XG5cblx0XHRyZXR1cm4gXCIoZnVuY3Rpb24oIFwiICsgYXJnTmFtZXMgKyBcIiApIHtcXG5cIiArXG5cdFx0XHRcIiAgcmV0dXJuIFwiICsgb3V0cHV0ICsgXCJcXG5cIiArXG5cdFx0XHRcIn0pKFwiICsgYXJnVmFsdWVzICsgXCIpXCI7XG5cdH07XG5cblx0cmV0dXJuIG1lc3NhZ2Vmb3JtYXR0ZXI7XG59O1xuXG5cblxuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiAubG9hZE1lc3NhZ2VzKCBqc29uIClcbiAqXG4gKiBAanNvbiBbSlNPTl1cbiAqXG4gKiBMb2FkIHRyYW5zbGF0aW9uIGRhdGEuXG4gKi9cbkdsb2JhbGl6ZS5sb2FkTWVzc2FnZXMgPSBmdW5jdGlvbigganNvbiApIHtcblx0dmFyIGxvY2FsZSxcblx0XHRjdXN0b21EYXRhID0ge1xuXHRcdFx0XCJnbG9iYWxpemUtbWVzc2FnZXNcIjoganNvbixcblx0XHRcdFwibWFpblwiOiB7fVxuXHRcdH07XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSgganNvbiwgXCJqc29uXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIGpzb24sIFwianNvblwiICk7XG5cblx0Ly8gU2V0IGF2YWlsYWJsZSBidW5kbGVzIGJ5IHBvcHVsYXRpbmcgY3VzdG9tRGF0YSBtYWluIGRhdGFzZXQuXG5cdGZvciAoIGxvY2FsZSBpbiBqc29uICkge1xuXHRcdGlmICgganNvbi5oYXNPd25Qcm9wZXJ0eSggbG9jYWxlICkgKSB7XG5cdFx0XHRjdXN0b21EYXRhLm1haW5bIGxvY2FsZSBdID0ge307XG5cdFx0fVxuXHR9XG5cblx0Q2xkci5sb2FkKCBjdXN0b21EYXRhICk7XG59O1xuXG4vKipcbiAqIC5tZXNzYWdlRm9ybWF0dGVyKCBwYXRoIClcbiAqXG4gKiBAcGF0aCBbU3RyaW5nIG9yIEFycmF5XVxuICpcbiAqIEZvcm1hdCBhIG1lc3NhZ2UgZ2l2ZW4gaXRzIHBhdGguXG4gKi9cbkdsb2JhbGl6ZS5tZXNzYWdlRm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUubWVzc2FnZUZvcm1hdHRlciA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXHR2YXIgY2xkciwgZm9ybWF0dGVyLCBtZXNzYWdlLCBwbHVyYWxHZW5lcmF0b3IsIHJldHVybkZuLFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBwYXRoLCBcInBhdGhcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoIHBhdGgsIFwicGF0aFwiLCB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCBwYXRoICksXG5cdFx0XCJhIFN0cmluZyBub3IgYW4gQXJyYXlcIiApO1xuXG5cdHBhdGggPSBhbHdheXNBcnJheSggcGF0aCApO1xuXHRjbGRyID0gdGhpcy5jbGRyO1xuXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXHR2YWxpZGF0ZU1lc3NhZ2VCdW5kbGUoIGNsZHIgKTtcblxuXHRtZXNzYWdlID0gY2xkci5nZXQoIFsgXCJnbG9iYWxpemUtbWVzc2FnZXMve2J1bmRsZX1cIiBdLmNvbmNhdCggcGF0aCApICk7XG5cdHZhbGlkYXRlTWVzc2FnZVByZXNlbmNlKCBwYXRoLCBtZXNzYWdlICk7XG5cblx0Ly8gSWYgbWVzc2FnZSBpcyBhbiBBcnJheSwgY29uY2F0ZW5hdGUgaXQuXG5cdGlmICggQXJyYXkuaXNBcnJheSggbWVzc2FnZSApICkge1xuXHRcdG1lc3NhZ2UgPSBtZXNzYWdlLmpvaW4oIFwiIFwiICk7XG5cdH1cblx0dmFsaWRhdGVNZXNzYWdlVHlwZSggcGF0aCwgbWVzc2FnZSApO1xuXG5cdC8vIElzIHBsdXJhbCBtb2R1bGUgcHJlc2VudD8gWWVzLCB1c2UgaXRzIGdlbmVyYXRvci4gTm9wZSwgdXNlIGFuIGVycm9yIGdlbmVyYXRvci5cblx0cGx1cmFsR2VuZXJhdG9yID0gdGhpcy5wbHVyYWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dGhpcy5wbHVyYWxHZW5lcmF0b3IoKSA6XG5cdFx0Y3JlYXRlRXJyb3JQbHVyYWxNb2R1bGVQcmVzZW5jZTtcblxuXHRmb3JtYXR0ZXIgPSBuZXcgTWVzc2FnZUZvcm1hdCggY2xkci5sb2NhbGUsIHBsdXJhbEdlbmVyYXRvciApLmNvbXBpbGUoIG1lc3NhZ2UgKTtcblxuXHRyZXR1cm5GbiA9IG1lc3NhZ2VGb3JtYXR0ZXJGbiggZm9ybWF0dGVyICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLFxuXHRcdFsgbWVzc2FnZUZvcm1hdHRlclJ1bnRpbWVCaW5kKCBjbGRyLCBmb3JtYXR0ZXIgKSwgcGx1cmFsR2VuZXJhdG9yIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5mb3JtYXRNZXNzYWdlKCBwYXRoIFssIHZhcmlhYmxlc10gKVxuICpcbiAqIEBwYXRoIFtTdHJpbmcgb3IgQXJyYXldXG4gKlxuICogQHZhcmlhYmxlcyBbTnVtYmVyLCBTdHJpbmcsIEFycmF5IG9yIE9iamVjdF1cbiAqXG4gKiBGb3JtYXQgYSBtZXNzYWdlIGdpdmVuIGl0cyBwYXRoLlxuICovXG5HbG9iYWxpemUuZm9ybWF0TWVzc2FnZSA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdE1lc3NhZ2UgPSBmdW5jdGlvbiggcGF0aCAvKiAsIHZhcmlhYmxlcyAqLyApIHtcblx0cmV0dXJuIHRoaXMubWVzc2FnZUZvcm1hdHRlciggcGF0aCApLmFwcGx5KCB7fSwgc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkgKTtcbn07XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL21lc3NhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9tZXNzYWdlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIixcblx0XHRcdFwiY2xkci9zdXBwbGVtZW50YWxcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgY3JlYXRlRXJyb3IgPSBHbG9iYWxpemUuX2NyZWF0ZUVycm9yLFxuXHRyZWdleHBFc2NhcGUgPSBHbG9iYWxpemUuX3JlZ2V4cEVzY2FwZSxcblx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHRzdHJpbmdQYWQgPSBHbG9iYWxpemUuX3N0cmluZ1BhZCxcblx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclJhbmdlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xuXG5cbnZhciBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSA9IGZ1bmN0aW9uKCBmZWF0dXJlICkge1xuXHRyZXR1cm4gY3JlYXRlRXJyb3IoIFwiRV9VTlNVUFBPUlRFRFwiLCBcIlVuc3VwcG9ydGVkIHtmZWF0dXJlfS5cIiwge1xuXHRcdGZlYXR1cmU6IGZlYXR1cmVcblx0fSk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIixcblx0XHRcIk51bWJlclwiXG5cdCk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIixcblx0XHRcImEgc3RyaW5nXCJcblx0KTtcbn07XG5cblxuXG5cbi8qKlxuICogZ291cGluZ1NlcGFyYXRvciggbnVtYmVyLCBwcmltYXJ5R3JvdXBpbmdTaXplLCBzZWNvbmRhcnlHcm91cGluZ1NpemUgKVxuICpcbiAqIEBudW1iZXIgW051bWJlcl0uXG4gKlxuICogQHByaW1hcnlHcm91cGluZ1NpemUgW051bWJlcl1cbiAqXG4gKiBAc2Vjb25kYXJ5R3JvdXBpbmdTaXplIFtOdW1iZXJdXG4gKlxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbnVtYmVyIHdpdGggZ3JvdXAgc2VwYXJhdG9yLlxuICovXG52YXIgbnVtYmVyRm9ybWF0R3JvdXBpbmdTZXBhcmF0b3IgPSBmdW5jdGlvbiggbnVtYmVyLCBwcmltYXJ5R3JvdXBpbmdTaXplLCBzZWNvbmRhcnlHcm91cGluZ1NpemUgKSB7XG5cdHZhciBpbmRleCxcblx0XHRjdXJyZW50R3JvdXBpbmdTaXplID0gcHJpbWFyeUdyb3VwaW5nU2l6ZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdHNlcCA9IFwiLFwiLFxuXHRcdHN3aXRjaFRvU2Vjb25kYXJ5ID0gc2Vjb25kYXJ5R3JvdXBpbmdTaXplID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdG51bWJlciA9IFN0cmluZyggbnVtYmVyICkuc3BsaXQoIFwiLlwiICk7XG5cdGluZGV4ID0gbnVtYmVyWyAwIF0ubGVuZ3RoO1xuXG5cdHdoaWxlICggaW5kZXggPiBjdXJyZW50R3JvdXBpbmdTaXplICkge1xuXHRcdHJldCA9IG51bWJlclsgMCBdLnNsaWNlKCBpbmRleCAtIGN1cnJlbnRHcm91cGluZ1NpemUsIGluZGV4ICkgK1xuXHRcdFx0KCByZXQubGVuZ3RoID8gc2VwIDogXCJcIiApICsgcmV0O1xuXHRcdGluZGV4IC09IGN1cnJlbnRHcm91cGluZ1NpemU7XG5cdFx0aWYgKCBzd2l0Y2hUb1NlY29uZGFyeSApIHtcblx0XHRcdGN1cnJlbnRHcm91cGluZ1NpemUgPSBzZWNvbmRhcnlHcm91cGluZ1NpemU7XG5cdFx0XHRzd2l0Y2hUb1NlY29uZGFyeSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdG51bWJlclsgMCBdID0gbnVtYmVyWyAwIF0uc2xpY2UoIDAsIGluZGV4ICkgKyAoIHJldC5sZW5ndGggPyBzZXAgOiBcIlwiICkgKyByZXQ7XG5cdHJldHVybiBudW1iZXIuam9pbiggXCIuXCIgKTtcbn07XG5cblxuXG5cbi8qKlxuICogaW50ZWdlckZyYWN0aW9uRGlnaXRzKCBudW1iZXIsIG1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsXG4gKiBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIHJvdW5kLCByb3VuZEluY3JlbWVudCApXG4gKlxuICogQG51bWJlciBbTnVtYmVyXVxuICpcbiAqIEBtaW5pbXVtSW50ZWdlckRpZ2l0cyBbTnVtYmVyXVxuICpcbiAqIEBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgW051bWJlcl1cbiAqXG4gKiBAbWF4aW11bUZyYWN0aW9uRGlnaXRzIFtOdW1iZXJdXG4gKlxuICogQHJvdW5kIFtGdW5jdGlvbl1cbiAqXG4gKiBAcm91bmRJbmNyZW1lbnQgW0Z1bmN0aW9uXVxuICpcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGludGVnZXIgYW5kIGZyYWN0aW9uIGRpZ2l0cy5cbiAqL1xudmFyIG51bWJlckZvcm1hdEludGVnZXJGcmFjdGlvbkRpZ2l0cyA9IGZ1bmN0aW9uKCBudW1iZXIsIG1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgcm91bmQsXG5cdHJvdW5kSW5jcmVtZW50ICkge1xuXG5cdC8vIEZyYWN0aW9uXG5cdGlmICggbWF4aW11bUZyYWN0aW9uRGlnaXRzICkge1xuXG5cdFx0Ly8gUm91bmRpbmdcblx0XHRpZiAoIHJvdW5kSW5jcmVtZW50ICkge1xuXHRcdFx0bnVtYmVyID0gcm91bmQoIG51bWJlciwgcm91bmRJbmNyZW1lbnQgKTtcblxuXHRcdC8vIE1heGltdW0gZnJhY3Rpb24gZGlnaXRzXG5cdFx0fSBlbHNlIHtcblx0XHRcdG51bWJlciA9IHJvdW5kKCBudW1iZXIsIHsgZXhwb25lbnQ6IC1tYXhpbXVtRnJhY3Rpb25EaWdpdHMgfSApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdG51bWJlciA9IHJvdW5kKCBudW1iZXIgKTtcblx0fVxuXG5cdG51bWJlciA9IFN0cmluZyggbnVtYmVyICk7XG5cblx0Ly8gTWF4aW11bSBpbnRlZ2VyIGRpZ2l0cyAocG9zdCBzdHJpbmcgcGhhc2UpXG5cdGlmICggbWF4aW11bUZyYWN0aW9uRGlnaXRzICYmIC9lLS8udGVzdCggbnVtYmVyICkgKSB7XG5cblx0XHQvLyBVc2UgdG9GaXhlZCggbWF4aW11bUZyYWN0aW9uRGlnaXRzICkgdG8gbWFrZSBzdXJlIHNtYWxsIG51bWJlcnMgbGlrZSAxZS03IGFyZVxuXHRcdC8vIGRpc3BsYXllZCB1c2luZyBwbGFpbiBkaWdpdHMgaW5zdGVhZCBvZiBzY2llbnRpZmljIG5vdGF0aW9uLlxuXHRcdC8vIDE6IFJlbW92ZSBsZWFkaW5nIGRlY2ltYWwgemVyb3MuXG5cdFx0Ly8gMjogUmVtb3ZlIGxlYWRpbmcgZGVjaW1hbCBzZXBhcmF0b3IuXG5cdFx0Ly8gTm90ZTogU3RyaW5nKCkgaXMgc3RpbGwgcHJlZmVycmVkIHNvIGl0IGRvZXNuJ3QgbWVzcyB1cCB3aXRoIGEgbnVtYmVyIHByZWNpc2lvblxuXHRcdC8vIHVubmVjZXNzYXJpbHksIGUuZy4sICgxMjM0NTY3ODkuMTIzKS50b0ZpeGVkKDEwKSA9PT0gXCIxMjM0NTY3ODkuMTIyOTk5OTk1OVwiLFxuXHRcdC8vIFN0cmluZygxMjM0NTY3ODkuMTIzKSA9PT0gXCIxMjM0NTY3ODkuMTIzXCIuXG5cdFx0bnVtYmVyID0gKCArbnVtYmVyICkudG9GaXhlZCggbWF4aW11bUZyYWN0aW9uRGlnaXRzIClcblx0XHRcdC5yZXBsYWNlKCAvMCskLywgXCJcIiApIC8qIDEgKi9cblx0XHRcdC5yZXBsYWNlKCAvXFwuJC8sIFwiXCIgKSAvKiAyICovO1xuXHR9XG5cblx0Ly8gTWluaW11bSBmcmFjdGlvbiBkaWdpdHMgKHBvc3Qgc3RyaW5nIHBoYXNlKVxuXHRpZiAoIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyApIHtcblx0XHRudW1iZXIgPSBudW1iZXIuc3BsaXQoIFwiLlwiICk7XG5cdFx0bnVtYmVyWyAxIF0gPSBzdHJpbmdQYWQoIG51bWJlclsgMSBdIHx8IFwiXCIsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgdHJ1ZSApO1xuXHRcdG51bWJlciA9IG51bWJlci5qb2luKCBcIi5cIiApO1xuXHR9XG5cblx0Ly8gTWluaW11bSBpbnRlZ2VyIGRpZ2l0c1xuXHRpZiAoIG1pbmltdW1JbnRlZ2VyRGlnaXRzICkge1xuXHRcdG51bWJlciA9IG51bWJlci5zcGxpdCggXCIuXCIgKTtcblx0XHRudW1iZXJbIDAgXSA9IHN0cmluZ1BhZCggbnVtYmVyWyAwIF0sIG1pbmltdW1JbnRlZ2VyRGlnaXRzICk7XG5cdFx0bnVtYmVyID0gbnVtYmVyLmpvaW4oIFwiLlwiICk7XG5cdH1cblxuXHRyZXR1cm4gbnVtYmVyO1xufTtcblxuXG5cblxuLyoqXG4gKiB0b1ByZWNpc2lvbiggbnVtYmVyLCBwcmVjaXNpb24sIHJvdW5kIClcbiAqXG4gKiBAbnVtYmVyIChOdW1iZXIpXG4gKlxuICogQHByZWNpc2lvbiAoTnVtYmVyKSBzaWduaWZpY2FudCBmaWd1cmVzIHByZWNpc2lvbiAobm90IGRlY2ltYWwgcHJlY2lzaW9uKS5cbiAqXG4gKiBAcm91bmQgKEZ1bmN0aW9uKVxuICpcbiAqIFJldHVybiBudW1iZXIudG9QcmVjaXNpb24oIHByZWNpc2lvbiApIHVzaW5nIHRoZSBnaXZlbiByb3VuZCBmdW5jdGlvbi5cbiAqL1xudmFyIG51bWJlclRvUHJlY2lzaW9uID0gZnVuY3Rpb24oIG51bWJlciwgcHJlY2lzaW9uLCByb3VuZCApIHtcblx0dmFyIHJvdW5kT3JkZXI7XG5cblx0Ly8gR2V0IG51bWJlciBhdCB0d28gZXh0cmEgc2lnbmlmaWNhbnQgZmlndXJlIHByZWNpc2lvbi5cblx0bnVtYmVyID0gbnVtYmVyLnRvUHJlY2lzaW9uKCBwcmVjaXNpb24gKyAyICk7XG5cblx0Ly8gVGhlbiwgcm91bmQgaXQgdG8gdGhlIHJlcXVpcmVkIHNpZ25pZmljYW50IGZpZ3VyZSBwcmVjaXNpb24uXG5cdHJvdW5kT3JkZXIgPSBNYXRoLmNlaWwoIE1hdGgubG9nKCBNYXRoLmFicyggbnVtYmVyICkgKSAvIE1hdGgubG9nKCAxMCApICk7XG5cdHJvdW5kT3JkZXIgLT0gcHJlY2lzaW9uO1xuXG5cdHJldHVybiByb3VuZCggbnVtYmVyLCB7IGV4cG9uZW50OiByb3VuZE9yZGVyIH0gKTtcbn07XG5cblxuXG5cbi8qKlxuICogdG9QcmVjaXNpb24oIG51bWJlciwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kIClcbiAqXG4gKiBAbnVtYmVyIFtOdW1iZXJdXG4gKlxuICogQG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyBbTnVtYmVyXVxuICpcbiAqIEBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgW051bWJlcl1cbiAqXG4gKiBAcm91bmQgW0Z1bmN0aW9uXVxuICpcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIHNpZ25pZmljYW50IGRpZ2l0cyBudW1iZXIuXG4gKi9cbnZhciBudW1iZXJGb3JtYXRTaWduaWZpY2FudERpZ2l0cyA9IGZ1bmN0aW9uKCBudW1iZXIsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApIHtcblx0dmFyIGF0TWluaW11bSwgYXRNYXhpbXVtO1xuXG5cdC8vIFNhbml0eSBjaGVjay5cblx0aWYgKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSB7XG5cdFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzO1xuXHR9XG5cblx0YXRNaW5pbXVtID0gbnVtYmVyVG9QcmVjaXNpb24oIG51bWJlciwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApO1xuXHRhdE1heGltdW0gPSBudW1iZXJUb1ByZWNpc2lvbiggbnVtYmVyLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kICk7XG5cblx0Ly8gVXNlIGF0TWF4aW11bSBvbmx5IGlmIGl0IGhhcyBtb3JlIHNpZ25pZmljYW50IGRpZ2l0cyB0aGFuIGF0TWluaW11bS5cblx0bnVtYmVyID0gK2F0TWluaW11bSA9PT0gK2F0TWF4aW11bSA/IGF0TWluaW11bSA6IGF0TWF4aW11bTtcblxuXHQvLyBFeHBhbmQgaW50ZWdlciBudW1iZXJzLCBlZy4gMTIzZTUgdG8gMTIzMDAuXG5cdG51bWJlciA9ICggK251bWJlciApLnRvU3RyaW5nKCAxMCApO1xuXG5cdGlmICggKCAvZS8gKS50ZXN0KCBudW1iZXIgKSApIHtcblx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRmZWF0dXJlOiBcImludGVnZXJzIG91dCBvZiAoMWUyMSwgMWUtNylcIlxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gQWRkIHRyYWlsaW5nIHplcm9zIGlmIG5lY2Vzc2FyeS5cblx0aWYgKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgLSBudW1iZXIucmVwbGFjZSggL14wK3xcXC4vZywgXCJcIiApLmxlbmd0aCA+IDAgKSB7XG5cdFx0bnVtYmVyID0gbnVtYmVyLnNwbGl0KCBcIi5cIiApO1xuXHRcdG51bWJlclsgMSBdID0gc3RyaW5nUGFkKCBudW1iZXJbIDEgXSB8fCBcIlwiLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgLSBudW1iZXJbIDAgXS5yZXBsYWNlKCAvXjArLywgXCJcIiApLmxlbmd0aCwgdHJ1ZSApO1xuXHRcdG51bWJlciA9IG51bWJlci5qb2luKCBcIi5cIiApO1xuXHR9XG5cblx0cmV0dXJuIG51bWJlcjtcbn07XG5cblxuXG5cbi8qKlxuICogcmVtb3ZlTGl0ZXJhbFF1b3Rlcyggc3RyaW5nIClcbiAqXG4gKiBSZXR1cm46XG4gKiAtIGBgIGlmIGlucHV0IHN0cmluZyBpcyBgJydgLlxuICogLSBgbydjbG9ja2AgaWYgaW5wdXQgc3RyaW5nIGlzIGAnbycnY2xvY2snYC5cbiAqIC0gYGZvb2AgaWYgaW5wdXQgc3RyaW5nIGlzIGBmb29gLCBpLmUuLCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgaW4gY2FzZSBpdCBpc24ndCBhIHNpbmdsZS1xdW90ZWRcbiAqICAgc3RyaW5nLlxuICovXG52YXIgcmVtb3ZlTGl0ZXJhbFF1b3RlcyA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdGlmICggc3RyaW5nWyAwIF0gKyBzdHJpbmdbIHN0cmluZy5sZW5ndGggLSAxIF0gIT09IFwiJydcIiApIHtcblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9XG5cdGlmICggc3RyaW5nID09PSBcIicnXCIgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCAvJycvZywgXCInXCIgKS5zbGljZSggMSwgLTEgKTtcbn07XG5cblxuXG5cbi8qKlxuICogZm9ybWF0KCBudW1iZXIsIHByb3BlcnRpZXMgKVxuICpcbiAqIEBudW1iZXIgW051bWJlcl0uXG4gKlxuICogQHByb3BlcnRpZXMgW09iamVjdF0gT3V0cHV0IG9mIG51bWJlci9mb3JtYXQtcHJvcGVydGllcy5cbiAqXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBudW1iZXIuXG4gKiByZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sXG4gKi9cbnZhciBudW1iZXJGb3JtYXQgPSBmdW5jdGlvbiggbnVtYmVyLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgaW5maW5pdHlTeW1ib2wsIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsXG5cdG1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG5hblN5bWJvbCwgbnVEaWdpdHNNYXAsIHBhZGRpbmcsIHByZWZpeCxcblx0cHJpbWFyeUdyb3VwaW5nU2l6ZSwgcGF0dGVybiwgcmV0LCByb3VuZCwgcm91bmRJbmNyZW1lbnQsIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSwgc3VmZml4LFxuXHRzeW1ib2xNYXA7XG5cblx0cGFkZGluZyA9IHByb3BlcnRpZXNbIDEgXTtcblx0bWluaW11bUludGVnZXJEaWdpdHMgPSBwcm9wZXJ0aWVzWyAyIF07XG5cdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IHByb3BlcnRpZXNbIDMgXTtcblx0bWF4aW11bUZyYWN0aW9uRGlnaXRzID0gcHJvcGVydGllc1sgNCBdO1xuXHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBwcm9wZXJ0aWVzWyA1IF07XG5cdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IHByb3BlcnRpZXNbIDYgXTtcblx0cm91bmRJbmNyZW1lbnQgPSBwcm9wZXJ0aWVzWyA3IF07XG5cdHByaW1hcnlHcm91cGluZ1NpemUgPSBwcm9wZXJ0aWVzWyA4IF07XG5cdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA9IHByb3BlcnRpZXNbIDkgXTtcblx0cm91bmQgPSBwcm9wZXJ0aWVzWyAxNSBdO1xuXHRpbmZpbml0eVN5bWJvbCA9IHByb3BlcnRpZXNbIDE2IF07XG5cdG5hblN5bWJvbCA9IHByb3BlcnRpZXNbIDE3IF07XG5cdHN5bWJvbE1hcCA9IHByb3BlcnRpZXNbIDE4IF07XG5cdG51RGlnaXRzTWFwID0gcHJvcGVydGllc1sgMTkgXTtcblxuXHQvLyBOYU5cblx0aWYgKCBpc05hTiggbnVtYmVyICkgKSB7XG5cdFx0cmV0dXJuIG5hblN5bWJvbDtcblx0fVxuXG5cdGlmICggbnVtYmVyIDwgMCApIHtcblx0XHRwYXR0ZXJuID0gcHJvcGVydGllc1sgMTIgXTtcblx0XHRwcmVmaXggPSBwcm9wZXJ0aWVzWyAxMyBdO1xuXHRcdHN1ZmZpeCA9IHByb3BlcnRpZXNbIDE0IF07XG5cdH0gZWxzZSB7XG5cdFx0cGF0dGVybiA9IHByb3BlcnRpZXNbIDExIF07XG5cdFx0cHJlZml4ID0gcHJvcGVydGllc1sgMCBdO1xuXHRcdHN1ZmZpeCA9IHByb3BlcnRpZXNbIDEwIF07XG5cdH1cblxuXHQvLyBJbmZpbml0eVxuXHRpZiAoICFpc0Zpbml0ZSggbnVtYmVyICkgKSB7XG5cdFx0cmV0dXJuIHByZWZpeCArIGluZmluaXR5U3ltYm9sICsgc3VmZml4O1xuXHR9XG5cblx0cmV0ID0gcHJlZml4O1xuXG5cdC8vIFBlcmNlbnRcblx0aWYgKCBwYXR0ZXJuLmluZGV4T2YoIFwiJVwiICkgIT09IC0xICkge1xuXHRcdG51bWJlciAqPSAxMDA7XG5cblx0Ly8gUGVyIG1pbGxlXG5cdH0gZWxzZSBpZiAoIHBhdHRlcm4uaW5kZXhPZiggXCJcXHUyMDMwXCIgKSAhPT0gLTEgKSB7XG5cdFx0bnVtYmVyICo9IDEwMDA7XG5cdH1cblxuXHQvLyBTaWduaWZpY2FudCBkaWdpdCBmb3JtYXRcblx0aWYgKCAhaXNOYU4oIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAqIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyApICkge1xuXHRcdG51bWJlciA9IG51bWJlckZvcm1hdFNpZ25pZmljYW50RGlnaXRzKCBudW1iZXIsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyxcblx0XHRcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgcm91bmQgKTtcblxuXHQvLyBJbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIGZvcm1hdFxuXHR9IGVsc2Uge1xuXHRcdG51bWJlciA9IG51bWJlckZvcm1hdEludGVnZXJGcmFjdGlvbkRpZ2l0cyggbnVtYmVyLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyxcblx0XHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzLCByb3VuZCwgcm91bmRJbmNyZW1lbnQgKTtcblx0fVxuXG5cdC8vIFJlbW92ZSB0aGUgcG9zc2libGUgbnVtYmVyIG1pbnVzIHNpZ25cblx0bnVtYmVyID0gbnVtYmVyLnJlcGxhY2UoIC9eLS8sIFwiXCIgKTtcblxuXHQvLyBHcm91cGluZyBzZXBhcmF0b3JzXG5cdGlmICggcHJpbWFyeUdyb3VwaW5nU2l6ZSApIHtcblx0XHRudW1iZXIgPSBudW1iZXJGb3JtYXRHcm91cGluZ1NlcGFyYXRvciggbnVtYmVyLCBwcmltYXJ5R3JvdXBpbmdTaXplLFxuXHRcdFx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplICk7XG5cdH1cblxuXHRyZXQgKz0gbnVtYmVyO1xuXG5cdC8vIFNjaWVudGlmaWMgbm90YXRpb25cblx0Ly8gVE9ETyBpbXBsZW1lbnQgaGVyZVxuXG5cdC8vIFBhZGRpbmcvJyhbXiddfCcnKSsnfCcnfFsuLFxcLStFJVxcdTIwMzBdL2dcblx0Ly8gVE9ETyBpbXBsZW1lbnQgaGVyZVxuXG5cdHJldCArPSBzdWZmaXg7XG5cblx0cmV0dXJuIHJldC5yZXBsYWNlKCAvKCcoW14nXXwnJykrJ3wnJyl8Li9nLCBmdW5jdGlvbiggY2hhcmFjdGVyLCBsaXRlcmFsICkge1xuXG5cdFx0Ly8gTGl0ZXJhbHNcblx0XHRpZiAoIGxpdGVyYWwgKSB7XG5cdFx0XHRyZXR1cm4gcmVtb3ZlTGl0ZXJhbFF1b3RlcyggbGl0ZXJhbCApO1xuXHRcdH1cblxuXHRcdC8vIFN5bWJvbHNcblx0XHRjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIucmVwbGFjZSggL1suLFxcLStFJVxcdTIwMzBdLywgZnVuY3Rpb24oIHN5bWJvbCApIHtcblx0XHRcdHJldHVybiBzeW1ib2xNYXBbIHN5bWJvbCBdO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTnVtYmVyaW5nIHN5c3RlbVxuXHRcdGlmICggbnVEaWdpdHNNYXAgKSB7XG5cdFx0XHRjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIucmVwbGFjZSggL1swLTldLywgZnVuY3Rpb24oIGRpZ2l0ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVEaWdpdHNNYXBbICtkaWdpdCBdO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYXJhY3Rlcjtcblx0fSk7XG59O1xuXG5cblxuXG52YXIgbnVtYmVyRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggcHJvcGVydGllcyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIG51bWJlckZvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0cmV0dXJuIG51bWJlckZvcm1hdCggdmFsdWUsIHByb3BlcnRpZXMgKTtcblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogTnVtYmVyaW5nU3lzdGVtKCBjbGRyIClcbiAqXG4gKiAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sI290aGVyTnVtYmVyaW5nU3lzdGVtc1xuICogLSBodHRwOi8vY2xkci51bmljb2RlLm9yZy9pbmRleC9iY3A0Ny1leHRlbnNpb25cbiAqIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI3VfRXh0ZW5zaW9uXG4gKi9cbnZhciBudW1iZXJOdW1iZXJpbmdTeXN0ZW0gPSBmdW5jdGlvbiggY2xkciApIHtcblx0dmFyIG51ID0gY2xkci5hdHRyaWJ1dGVzWyBcInUtbnVcIiBdO1xuXG5cdGlmICggbnUgKSB7XG5cdFx0aWYgKCBudSA9PT0gXCJ0cmFkaXRpb1wiICkge1xuXHRcdFx0bnUgPSBcInRyYWRpdGlvbmFsXCI7XG5cdFx0fVxuXHRcdGlmICggWyBcIm5hdGl2ZVwiLCBcInRyYWRpdGlvbmFsXCIsIFwiZmluYW5jZVwiIF0uaW5kZXhPZiggbnUgKSAhPT0gLTEgKSB7XG5cblx0XHRcdC8vIFVuaWNvZGUgbG9jYWxlIGV4dGVuc2lvbiBgdS1udWAgaXMgc2V0IHVzaW5nIGVpdGhlciAobmF0aXZlLCB0cmFkaXRpb25hbCBvclxuXHRcdFx0Ly8gZmluYW5jZSkuIFNvLCBsb29rdXAgdGhlIHJlc3BlY3RpdmUgbG9jYWxlJ3MgbnVtYmVyaW5nU3lzdGVtIGFuZCByZXR1cm4gaXQuXG5cdFx0XHRyZXR1cm4gY2xkci5tYWluKFsgXCJudW1iZXJzL290aGVyTnVtYmVyaW5nU3lzdGVtc1wiLCBudSBdKTtcblx0XHR9XG5cblx0XHQvLyBVbmljb2RlIGxvY2FsZSBleHRlbnNpb24gYHUtbnVgIGlzIHNldCB3aXRoIGFuIGV4cGxpY2l0IG51bWJlcmluZ1N5c3RlbS4gUmV0dXJuIGl0LlxuXHRcdHJldHVybiBudTtcblx0fVxuXG5cdC8vIFJldHVybiB0aGUgZGVmYXVsdCBudW1iZXJpbmdTeXN0ZW0uXG5cdHJldHVybiBjbGRyLm1haW4oIFwibnVtYmVycy9kZWZhdWx0TnVtYmVyaW5nU3lzdGVtXCIgKTtcbn07XG5cblxuXG5cbi8qKlxuICogbnVNYXAoIGNsZHIgKVxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gZGlnaXRzIG1hcCBpZiBudW1iZXJpbmcgc3lzdGVtIGlzIGRpZmZlcmVudCB0aGFuIGBsYXRuYC5cbiAqL1xudmFyIG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHR2YXIgYXV4LFxuXHRcdG51ID0gbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICk7XG5cblx0aWYgKCBudSA9PT0gXCJsYXRuXCIgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YXV4ID0gY2xkci5zdXBwbGVtZW50YWwoWyBcIm51bWJlcmluZ1N5c3RlbXNcIiwgbnUgXSk7XG5cblx0aWYgKCBhdXguX3R5cGUgIT09IFwibnVtZXJpY1wiICkge1xuXHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKCBcImBcIiArIGF1eC5fdHlwZSArIFwiYCBudW1iZXJpbmcgc3lzdGVtXCIgKTtcblx0fVxuXG5cdHJldHVybiBhdXguX2RpZ2l0cztcbn07XG5cblxuXG5cbi8qKlxuICogRUJORiByZXByZXNlbnRhdGlvbjpcbiAqXG4gKiBudW1iZXJfcGF0dGVybl9yZSA9ICAgICAgICBwcmVmaXg/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgKGludGVnZXJfZnJhY3Rpb25fcGF0dGVybiB8IHNpZ25pZmljYW50X3BhdHRlcm4pXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2llbnRpZmljX25vdGF0aW9uP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4P1xuICpcbiAqIHByZWZpeCA9ICAgICAgICAgICAgICAgICAgIG5vbl9udW1iZXJfc3R1ZmZcbiAqXG4gKiBwYWRkaW5nID0gICAgICAgICAgICAgICAgICBcIipcIiByZWdleHAoLilcbiAqXG4gKiBpbnRlZ2VyX2ZyYWN0aW9uX3BhdHRlcm4gPSBpbnRlZ2VyX3BhdHRlcm5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uX3BhdHRlcm4/XG4gKlxuICogaW50ZWdlcl9wYXR0ZXJuID0gICAgICAgICAgcmVnZXhwKFsjLF0qWzAsXSowKylcbiAqXG4gKiBmcmFjdGlvbl9wYXR0ZXJuID0gICAgICAgICBcIi5cIiByZWdleHAoMCpbMC05XSojKilcbiAqXG4gKiBzaWduaWZpY2FudF9wYXR0ZXJuID0gICAgICByZWdleHAoWyMsXSpAKyMqKVxuICpcbiAqIHNjaWVudGlmaWNfbm90YXRpb24gPSAgICAgIHJlZ2V4cChFXFwrPzArKVxuICpcbiAqIHN1ZmZpeCA9ICAgICAgICAgICAgICAgICAgIG5vbl9udW1iZXJfc3R1ZmZcbiAqXG4gKiBub25fbnVtYmVyX3N0dWZmID0gICAgICAgICByZWdleHAoKCdbXiddKyd8Jyd8W14qI0AwLC5FXSkqKVxuICpcbiAqXG4gKiBSZWdleHAgZ3JvdXBzOlxuICpcbiAqICAwOiBudW1iZXJfcGF0dGVybl9yZVxuICogIDE6IHByZWZpeFxuICogIDI6IC1cbiAqICAzOiAtXG4gKiAgNDogcGFkZGluZ1xuICogIDU6IChpbnRlZ2VyX2ZyYWN0aW9uX3BhdHRlcm4gfCBzaWduaWZpY2FudF9wYXR0ZXJuKVxuICogIDY6IGludGVnZXJfZnJhY3Rpb25fcGF0dGVyblxuICogIDc6IGludGVnZXJfcGF0dGVyblxuICogIDg6IGZyYWN0aW9uX3BhdHRlcm5cbiAqICA5OiBzaWduaWZpY2FudF9wYXR0ZXJuXG4gKiAxMDogc2NpZW50aWZpY19ub3RhdGlvblxuICogMTE6IHN1ZmZpeFxuICogMTI6IC1cbiAqL1xudmFyIG51bWJlclBhdHRlcm5SZSA9ICggL14oKCcoW14nXXwnJykqJ3xbXiojQDAsLkVdKSopKFxcKi4pPygoKFsjLF0qWzAsXSowKykoXFwuMCpbMC05XSojKik/KXwoWyMsXSpAKyMqKSkoRVxcKz8wKyk/KCgnW14nXSsnfCcnfFteKiNAMCwuRV0pKikkLyApO1xuXG5cblxuXG4vKipcbiAqIGZvcm1hdCggbnVtYmVyLCBwYXR0ZXJuIClcbiAqXG4gKiBAbnVtYmVyIFtOdW1iZXJdLlxuICpcbiAqIEBwYXR0ZXJuIFtTdHJpbmddIHJhdyBwYXR0ZXJuIGZvciBudW1iZXJzLlxuICpcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIG51bWJlci5cbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWxcbiAqL1xudmFyIG51bWJlclBhdHRlcm5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG5cdHZhciBhdXgxLCBhdXgyLCBmcmFjdGlvblBhdHRlcm4sIGludGVnZXJGcmFjdGlvbk9yU2lnbmlmaWNhbnRQYXR0ZXJuLCBpbnRlZ2VyUGF0dGVybixcblx0XHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzLFxuXHRcdG1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIHBhZGRpbmcsIHByZWZpeCwgcHJpbWFyeUdyb3VwaW5nU2l6ZSxcblx0XHRyb3VuZEluY3JlbWVudCwgc2NpZW50aWZpY05vdGF0aW9uLCBzZWNvbmRhcnlHcm91cGluZ1NpemUsIHNpZ25pZmljYW50UGF0dGVybiwgc3VmZml4O1xuXG5cdHBhdHRlcm4gPSBwYXR0ZXJuLm1hdGNoKCBudW1iZXJQYXR0ZXJuUmUgKTtcblx0aWYgKCAhcGF0dGVybiApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiSW52YWxpZCBwYXR0ZXJuOiBcIiArIHBhdHRlcm4gKTtcblx0fVxuXG5cdHByZWZpeCA9IHBhdHRlcm5bIDEgXTtcblx0cGFkZGluZyA9IHBhdHRlcm5bIDQgXTtcblx0aW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4gPSBwYXR0ZXJuWyA1IF07XG5cdHNpZ25pZmljYW50UGF0dGVybiA9IHBhdHRlcm5bIDkgXTtcblx0c2NpZW50aWZpY05vdGF0aW9uID0gcGF0dGVyblsgMTAgXTtcblx0c3VmZml4ID0gcGF0dGVyblsgMTEgXTtcblxuXHQvLyBTaWduaWZpY2FudCBkaWdpdCBmb3JtYXRcblx0aWYgKCBzaWduaWZpY2FudFBhdHRlcm4gKSB7XG5cdFx0c2lnbmlmaWNhbnRQYXR0ZXJuLnJlcGxhY2UoIC8oQCspKCMqKS8sIGZ1bmN0aW9uKCBtYXRjaCwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2gsIG1heGltdW1TaWduaWZpY2FudERpZ2l0c01hdGNoICkge1xuXHRcdFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzID0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2gubGVuZ3RoO1xuXHRcdFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzICtcblx0XHRcdFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2gubGVuZ3RoO1xuXHRcdH0pO1xuXG5cdC8vIEludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0XG5cdH0gZWxzZSB7XG5cdFx0ZnJhY3Rpb25QYXR0ZXJuID0gcGF0dGVyblsgOCBdO1xuXHRcdGludGVnZXJQYXR0ZXJuID0gcGF0dGVyblsgNyBdO1xuXG5cdFx0aWYgKCBmcmFjdGlvblBhdHRlcm4gKSB7XG5cblx0XHRcdC8vIE1pbmltdW0gZnJhY3Rpb24gZGlnaXRzLCBhbmQgcm91bmRpbmcuXG5cdFx0XHRmcmFjdGlvblBhdHRlcm4ucmVwbGFjZSggL1swLTldKy8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gbWF0Y2g7XG5cdFx0XHR9KTtcblx0XHRcdGlmICggbWluaW11bUZyYWN0aW9uRGlnaXRzICkge1xuXHRcdFx0XHRyb3VuZEluY3JlbWVudCA9ICsoIFwiMC5cIiArIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyApO1xuXHRcdFx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBtaW5pbXVtRnJhY3Rpb25EaWdpdHMubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF4aW11bSBmcmFjdGlvbiBkaWdpdHNcblx0XHRcdC8vIDE6IGlnbm9yZSBkZWNpbWFsIGNoYXJhY3RlclxuXHRcdFx0bWF4aW11bUZyYWN0aW9uRGlnaXRzID0gZnJhY3Rpb25QYXR0ZXJuLmxlbmd0aCAtIDEgLyogMSAqLztcblx0XHR9XG5cblx0XHQvLyBNaW5pbXVtIGludGVnZXIgZGlnaXRzXG5cdFx0aW50ZWdlclBhdHRlcm4ucmVwbGFjZSggLzArJC8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1pbmltdW1JbnRlZ2VyRGlnaXRzID0gbWF0Y2gubGVuZ3RoO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gU2NpZW50aWZpYyBub3RhdGlvblxuXHRpZiAoIHNjaWVudGlmaWNOb3RhdGlvbiApIHtcblx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRmZWF0dXJlOiBcInNjaWVudGlmaWMgbm90YXRpb24gKG5vdCBpbXBsZW1lbnRlZClcIlxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUGFkZGluZ1xuXHRpZiAoIHBhZGRpbmcgKSB7XG5cdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0ZmVhdHVyZTogXCJwYWRkaW5nIChub3QgaW1wbGVtZW50ZWQpXCJcblx0XHR9KTtcblx0fVxuXG5cdC8vIEdyb3VwaW5nXG5cdGlmICggKCBhdXgxID0gaW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4ubGFzdEluZGV4T2YoIFwiLFwiICkgKSAhPT0gLTEgKSB7XG5cblx0XHQvLyBQcmltYXJ5IGdyb3VwaW5nIHNpemUgaXMgdGhlIGludGVydmFsIGJldHdlZW4gdGhlIGxhc3QgZ3JvdXAgc2VwYXJhdG9yIGFuZCB0aGUgZW5kIG9mXG5cdFx0Ly8gdGhlIGludGVnZXIgKG9yIHRoZSBlbmQgb2YgdGhlIHNpZ25pZmljYW50IHBhdHRlcm4pLlxuXHRcdGF1eDIgPSBpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybi5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXHRcdHByaW1hcnlHcm91cGluZ1NpemUgPSBhdXgyLmxlbmd0aCAtIGF1eDEgLSAxO1xuXG5cdFx0Ly8gU2Vjb25kYXJ5IGdyb3VwaW5nIHNpemUgaXMgdGhlIGludGVydmFsIGJldHdlZW4gdGhlIGxhc3QgdHdvIGdyb3VwIHNlcGFyYXRvcnMuXG5cdFx0aWYgKCAoIGF1eDIgPSBpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybi5sYXN0SW5kZXhPZiggXCIsXCIsIGF1eDEgLSAxICkgKSAhPT0gLTEgKSB7XG5cdFx0XHRzZWNvbmRhcnlHcm91cGluZ1NpemUgPSBhdXgxIC0gMSAtIGF1eDI7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuOlxuXHQvLyAgMDogQHByZWZpeCBTdHJpbmdcblx0Ly8gIDE6IEBwYWRkaW5nIEFycmF5IFsgPGNoYXJhY3Rlcj4sIDxjb3VudD4gXSBUT0RPXG5cdC8vICAyOiBAbWluaW11bUludGVnZXJEaWdpdHMgbm9uLW5lZ2F0aXZlIGludGVnZXIgTnVtYmVyIHZhbHVlIGluZGljYXRpbmcgdGhlIG1pbmltdW0gaW50ZWdlclxuXHQvLyAgICAgICAgZGlnaXRzIHRvIGJlIHVzZWQuIE51bWJlcnMgd2lsbCBiZSBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm9lcyBpZiBuZWNlc3NhcnkuXG5cdC8vICAzOiBAbWluaW11bUZyYWN0aW9uRGlnaXRzIGFuZFxuXHQvLyAgNDogQG1heGltdW1GcmFjdGlvbkRpZ2l0cyBhcmUgbm9uLW5lZ2F0aXZlIGludGVnZXIgTnVtYmVyIHZhbHVlcyBpbmRpY2F0aW5nIHRoZSBtaW5pbXVtIGFuZFxuXHQvLyAgICAgICAgbWF4aW11bSBmcmFjdGlvbiBkaWdpdHMgdG8gYmUgdXNlZC4gTnVtYmVycyB3aWxsIGJlIHJvdW5kZWQgb3IgcGFkZGVkIHdpdGggdHJhaWxpbmdcblx0Ly8gICAgICAgIHplcm9lcyBpZiBuZWNlc3NhcnkuXG5cdC8vICA1OiBAbWluaW11bVNpZ25pZmljYW50RGlnaXRzIGFuZFxuXHQvLyAgNjogQG1heGltdW1TaWduaWZpY2FudERpZ2l0cyBhcmUgcG9zaXRpdmUgaW50ZWdlciBOdW1iZXIgdmFsdWVzIGluZGljYXRpbmcgdGhlIG1pbmltdW0gYW5kXG5cdC8vICAgICAgICBtYXhpbXVtIGZyYWN0aW9uIGRpZ2l0cyB0byBiZSBzaG93bi4gRWl0aGVyIG5vbmUgb3IgYm90aCBvZiB0aGVzZSBwcm9wZXJ0aWVzIGFyZVxuXHQvLyAgICAgICAgcHJlc2VudDsgaWYgdGhleSBhcmUsIHRoZXkgb3ZlcnJpZGUgbWluaW11bSBhbmQgbWF4aW11bSBpbnRlZ2VyIGFuZCBmcmFjdGlvbiBkaWdpdHNcblx0Ly8gICAgICAgIOKAkyB0aGUgZm9ybWF0dGVyIHVzZXMgaG93ZXZlciBtYW55IGludGVnZXIgYW5kIGZyYWN0aW9uIGRpZ2l0cyBhcmUgcmVxdWlyZWQgdG8gZGlzcGxheVxuXHQvLyAgICAgICAgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzLlxuXHQvLyAgNzogQHJvdW5kSW5jcmVtZW50IERlY2ltYWwgcm91bmQgaW5jcmVtZW50IG9yIG51bGxcblx0Ly8gIDg6IEBwcmltYXJ5R3JvdXBpbmdTaXplXG5cdC8vICA5OiBAc2Vjb25kYXJ5R3JvdXBpbmdTaXplXG5cdC8vIDEwOiBAc3VmZml4IFN0cmluZ1xuXHRyZXR1cm4gW1xuXHRcdHByZWZpeCxcblx0XHRwYWRkaW5nLFxuXHRcdG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxuXHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcblx0XHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMsXG5cdFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzLFxuXHRcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyxcblx0XHRyb3VuZEluY3JlbWVudCxcblx0XHRwcmltYXJ5R3JvdXBpbmdTaXplLFxuXHRcdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSxcblx0XHRzdWZmaXhcblx0XTtcbn07XG5cblxuXG5cbi8qKlxuICogU3ltYm9sKCBuYW1lLCBjbGRyIClcbiAqXG4gKiBAbmFtZSBbU3RyaW5nXSBTeW1ib2wgbmFtZS5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHRoZSBsb2NhbGl6ZWQgc3ltYm9sIGdpdmVuIGl0cyBuYW1lLlxuICovXG52YXIgbnVtYmVyU3ltYm9sID0gZnVuY3Rpb24oIG5hbWUsIGNsZHIgKSB7XG5cdHJldHVybiBjbGRyLm1haW4oW1xuXHRcdFwibnVtYmVycy9zeW1ib2xzLW51bWJlclN5c3RlbS1cIiArIG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApLFxuXHRcdG5hbWVcblx0XSk7XG59O1xuXG5cblxuXG52YXIgbnVtYmVyU3ltYm9sTmFtZSA9IHtcblx0XCIuXCI6IFwiZGVjaW1hbFwiLFxuXHRcIixcIjogXCJncm91cFwiLFxuXHRcIiVcIjogXCJwZXJjZW50U2lnblwiLFxuXHRcIitcIjogXCJwbHVzU2lnblwiLFxuXHRcIi1cIjogXCJtaW51c1NpZ25cIixcblx0XCJFXCI6IFwiZXhwb25lbnRpYWxcIixcblx0XCJcXHUyMDMwXCI6IFwicGVyTWlsbGVcIlxufTtcblxuXG5cblxuLyoqXG4gKiBzeW1ib2xNYXAoIGNsZHIgKVxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gdGhlIChsb2NhbGl6ZWQgc3ltYm9sLCBwYXR0ZXJuIHN5bWJvbCkga2V5IHZhbHVlIHBhaXIsIGVnLiB7XG4gKiAgIFwiLlwiOiBcItmrXCIsXG4gKiAgIFwiLFwiOiBcItmsXCIsXG4gKiAgIFwiJVwiOiBcItmqXCIsXG4gKiAgIC4uLlxuICogfTtcbiAqL1xudmFyIG51bWJlclN5bWJvbE1hcCA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHR2YXIgc3ltYm9sLFxuXHRcdHN5bWJvbE1hcCA9IHt9O1xuXG5cdGZvciAoIHN5bWJvbCBpbiBudW1iZXJTeW1ib2xOYW1lICkge1xuXHRcdHN5bWJvbE1hcFsgc3ltYm9sIF0gPSBudW1iZXJTeW1ib2woIG51bWJlclN5bWJvbE5hbWVbIHN5bWJvbCBdLCBjbGRyICk7XG5cdH1cblxuXHRyZXR1cm4gc3ltYm9sTWFwO1xufTtcblxuXG5cblxudmFyIG51bWJlclRydW5jYXRlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdHJldHVybiBOYU47XG5cdH1cblx0cmV0dXJuIE1hdGhbIHZhbHVlIDwgMCA/IFwiY2VpbFwiIDogXCJmbG9vclwiIF0oIHZhbHVlICk7XG59O1xuXG5cblxuXG4vKipcbiAqIHJvdW5kKCBtZXRob2QgKVxuICpcbiAqIEBtZXRob2QgW1N0cmluZ10gd2l0aCBlaXRoZXIgXCJyb3VuZFwiLCBcImNlaWxcIiwgXCJmbG9vclwiLCBvciBcInRydW5jYXRlXCIuXG4gKlxuICogUmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSwgaW5jcmVtZW50T3JFeHAgKTpcbiAqXG4gKiAgIEB2YWx1ZSBbTnVtYmVyXSBlZy4gMTIzLjQ1LlxuICpcbiAqICAgQGluY3JlbWVudE9yRXhwIFtOdW1iZXJdIG9wdGlvbmFsLCBlZy4gMC4xOyBvclxuICogICAgIFtPYmplY3RdIEVpdGhlciB7IGluY3JlbWVudDogPHZhbHVlPiB9IG9yIHsgZXhwb25lbnQ6IDx2YWx1ZT4gfVxuICpcbiAqICAgUmV0dXJuIHRoZSByb3VuZGVkIG51bWJlciwgZWc6XG4gKiAgIC0gcm91bmQoIFwicm91bmRcIiApKCAxMjMuNDUgKTogMTIzO1xuICogICAtIHJvdW5kKCBcImNlaWxcIiApKCAxMjMuNDUgKTogMTI0O1xuICogICAtIHJvdW5kKCBcImZsb29yXCIgKSggMTIzLjQ1ICk6IDEyMztcbiAqICAgLSByb3VuZCggXCJ0cnVuY2F0ZVwiICkoIDEyMy40NSApOiAxMjM7XG4gKiAgIC0gcm91bmQoIFwicm91bmRcIiApKCAxMjMuNDUsIDAuMSApOiAxMjMuNTtcbiAqICAgLSByb3VuZCggXCJyb3VuZFwiICkoIDEyMy40NSwgMTAgKTogMTIwO1xuICpcbiAqICAgQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9yb3VuZFxuICogICBSZWY6ICMzNzZcbiAqL1xudmFyIG51bWJlclJvdW5kID0gZnVuY3Rpb24oIG1ldGhvZCApIHtcblx0bWV0aG9kID0gbWV0aG9kIHx8IFwicm91bmRcIjtcblx0bWV0aG9kID0gbWV0aG9kID09PSBcInRydW5jYXRlXCIgPyBudW1iZXJUcnVuY2F0ZSA6IE1hdGhbIG1ldGhvZCBdO1xuXG5cdHJldHVybiBmdW5jdGlvbiggdmFsdWUsIGluY3JlbWVudE9yRXhwICkge1xuXHRcdHZhciBleHAsIGluY3JlbWVudDtcblxuXHRcdHZhbHVlID0gK3ZhbHVlO1xuXG5cdFx0Ly8gSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlciwgcmV0dXJuIE5hTi5cblx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cblx0XHQvLyBFeHBvbmVudCBnaXZlbi5cblx0XHRpZiAoIHR5cGVvZiBpbmNyZW1lbnRPckV4cCA9PT0gXCJvYmplY3RcIiAmJiBpbmNyZW1lbnRPckV4cC5leHBvbmVudCApIHtcblx0XHRcdGV4cCA9ICtpbmNyZW1lbnRPckV4cC5leHBvbmVudDtcblx0XHRcdGluY3JlbWVudCA9IDE7XG5cblx0XHRcdGlmICggZXhwID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgZXhwIGlzIG5vdCBhbiBpbnRlZ2VyLCByZXR1cm4gTmFOLlxuXHRcdFx0aWYgKCAhKCB0eXBlb2YgZXhwID09PSBcIm51bWJlclwiICYmIGV4cCAlIDEgPT09IDAgKSApIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH1cblxuXHRcdC8vIEluY3JlbWVudCBnaXZlbi5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5jcmVtZW50ID0gK2luY3JlbWVudE9yRXhwIHx8IDE7XG5cblx0XHRcdGlmICggaW5jcmVtZW50ID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgaW5jcmVtZW50IGlzIG5vdCBhIG51bWJlciwgcmV0dXJuIE5hTi5cblx0XHRcdGlmICggaXNOYU4oIGluY3JlbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fVxuXG5cdFx0XHRpbmNyZW1lbnQgPSBpbmNyZW1lbnQudG9FeHBvbmVudGlhbCgpLnNwbGl0KCBcImVcIiApO1xuXHRcdFx0ZXhwID0gK2luY3JlbWVudFsgMSBdO1xuXHRcdFx0aW5jcmVtZW50ID0gK2luY3JlbWVudFsgMCBdO1xuXHRcdH1cblxuXHRcdC8vIFNoaWZ0ICYgUm91bmRcblx0XHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoIFwiZVwiICk7XG5cdFx0dmFsdWVbIDAgXSA9ICt2YWx1ZVsgMCBdIC8gaW5jcmVtZW50O1xuXHRcdHZhbHVlWyAxIF0gPSB2YWx1ZVsgMSBdID8gKCArdmFsdWVbIDEgXSAtIGV4cCApIDogLWV4cDtcblx0XHR2YWx1ZSA9IG1ldGhvZCggKyggdmFsdWVbIDAgXSArIFwiZVwiICsgdmFsdWVbIDEgXSApICk7XG5cblx0XHQvLyBTaGlmdCBiYWNrXG5cdFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCBcImVcIiApO1xuXHRcdHZhbHVlWyAwIF0gPSArdmFsdWVbIDAgXSAqIGluY3JlbWVudDtcblx0XHR2YWx1ZVsgMSBdID0gdmFsdWVbIDEgXSA/ICggK3ZhbHVlWyAxIF0gKyBleHAgKSA6IGV4cDtcblx0XHRyZXR1cm4gKyggdmFsdWVbIDAgXSArIFwiZVwiICsgdmFsdWVbIDEgXSApO1xuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiBmb3JtYXRQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyIFssIG9wdGlvbnNdIClcbiAqXG4gKiBAcGF0dGVybiBbU3RyaW5nXSByYXcgcGF0dGVybiBmb3IgbnVtYmVycy5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06XG4gKiAtIG1pbmltdW1JbnRlZ2VyRGlnaXRzIFtOdW1iZXJdXG4gKiAtIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzIFtOdW1iZXJdXG4gKiAtIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzIFtOdW1iZXJdXG4gKiAtIHJvdW5kIFtTdHJpbmddIFwiY2VpbFwiLCBcImZsb29yXCIsIFwicm91bmRcIiAoZGVmYXVsdCksIG9yIFwidHJ1bmNhdGVcIi5cbiAqIC0gdXNlR3JvdXBpbmcgW0Jvb2xlYW5dIGRlZmF1bHQgdHJ1ZS5cbiAqXG4gKiBSZXR1cm4gdGhlIHByb2Nlc3NlZCBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB1c2VkIGluIG51bWJlci9mb3JtYXQuXG4gKiByZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sXG4gKi9cbnZhciBudW1iZXJGb3JtYXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHBhdHRlcm4sIGNsZHIsIG9wdGlvbnMgKSB7XG5cdHZhciBuZWdhdGl2ZVBhdHRlcm4sIG5lZ2F0aXZlUHJlZml4LCBuZWdhdGl2ZVByb3BlcnRpZXMsIG5lZ2F0aXZlU3VmZml4LCBwb3NpdGl2ZVBhdHRlcm4sXG5cdFx0cm91bmRGbiwgcHJvcGVydGllcztcblxuXHRmdW5jdGlvbiBnZXRPcHRpb25zKCBhdHRyaWJ1dGUsIHByb3BlcnR5SW5kZXggKSB7XG5cdFx0aWYgKCBhdHRyaWJ1dGUgaW4gb3B0aW9ucyApIHtcblx0XHRcdHByb3BlcnRpZXNbIHByb3BlcnR5SW5kZXggXSA9IG9wdGlvbnNbIGF0dHJpYnV0ZSBdO1xuXHRcdH1cblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRwYXR0ZXJuID0gcGF0dGVybi5zcGxpdCggXCI7XCIgKTtcblxuXHRwb3NpdGl2ZVBhdHRlcm4gPSBwYXR0ZXJuWyAwIF07XG5cblx0bmVnYXRpdmVQYXR0ZXJuID0gcGF0dGVyblsgMSBdIHx8IFwiLVwiICsgcG9zaXRpdmVQYXR0ZXJuO1xuXHRuZWdhdGl2ZVByb3BlcnRpZXMgPSBudW1iZXJQYXR0ZXJuUHJvcGVydGllcyggbmVnYXRpdmVQYXR0ZXJuICk7XG5cdG5lZ2F0aXZlUHJlZml4ID0gbmVnYXRpdmVQcm9wZXJ0aWVzWyAwIF07XG5cdG5lZ2F0aXZlU3VmZml4ID0gbmVnYXRpdmVQcm9wZXJ0aWVzWyAxMCBdO1xuXG5cdC8vIEhhdmUgcnVudGltZSBjb2RlIHRvIHJlZmVyIHRvIG51bWJlclJvdW5kKCkgaW5zdGVhZCBvZiBpbmNsdWRpbmcgaXQgZXhwbGljaXRseS5cblx0cm91bmRGbiA9IG51bWJlclJvdW5kKCBvcHRpb25zLnJvdW5kICk7XG5cdHJvdW5kRm4uZ2VuZXJhdG9yU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwibnVtYmVyUm91bmQoXCIgKyAoIG9wdGlvbnMucm91bmQgPyBcIlxcXCJcIiArIG9wdGlvbnMucm91bmQgKyBcIlxcXCJcIiA6IFwiXCIgKSArIFwiKVwiO1xuXHR9O1xuXG5cdHByb3BlcnRpZXMgPSBudW1iZXJQYXR0ZXJuUHJvcGVydGllcyggcG9zaXRpdmVQYXR0ZXJuICkuY29uY2F0KFtcblx0XHRwb3NpdGl2ZVBhdHRlcm4sXG5cdFx0bmVnYXRpdmVQcmVmaXggKyBwb3NpdGl2ZVBhdHRlcm4gKyBuZWdhdGl2ZVN1ZmZpeCxcblx0XHRuZWdhdGl2ZVByZWZpeCxcblx0XHRuZWdhdGl2ZVN1ZmZpeCxcblx0XHRyb3VuZEZuLFxuXHRcdG51bWJlclN5bWJvbCggXCJpbmZpbml0eVwiLCBjbGRyICksXG5cdFx0bnVtYmVyU3ltYm9sKCBcIm5hblwiLCBjbGRyICksXG5cdFx0bnVtYmVyU3ltYm9sTWFwKCBjbGRyICksXG5cdFx0bnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwKCBjbGRyIClcblx0XSk7XG5cblx0Z2V0T3B0aW9ucyggXCJtaW5pbXVtSW50ZWdlckRpZ2l0c1wiLCAyICk7XG5cdGdldE9wdGlvbnMoIFwibWluaW11bUZyYWN0aW9uRGlnaXRzXCIsIDMgKTtcblx0Z2V0T3B0aW9ucyggXCJtYXhpbXVtRnJhY3Rpb25EaWdpdHNcIiwgNCApO1xuXHRnZXRPcHRpb25zKCBcIm1pbmltdW1TaWduaWZpY2FudERpZ2l0c1wiLCA1ICk7XG5cdGdldE9wdGlvbnMoIFwibWF4aW11bVNpZ25pZmljYW50RGlnaXRzXCIsIDYgKTtcblxuXHQvLyBHcm91cGluZyBzZXBhcmF0b3JzXG5cdGlmICggb3B0aW9ucy51c2VHcm91cGluZyA9PT0gZmFsc2UgKSB7XG5cdFx0cHJvcGVydGllc1sgOCBdID0gbnVsbDtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBudW1iZXIgb2YgZGlnaXRzIGlmIG9ubHkgb25lIG9mIGVpdGhlciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3Jcblx0Ly8gbWF4aW11bUZyYWN0aW9uRGlnaXRzIGlzIHBhc3NlZCBpbiBhcyBhbiBvcHRpb25cblx0aWYgKCBcIm1pbmltdW1GcmFjdGlvbkRpZ2l0c1wiIGluIG9wdGlvbnMgJiYgISggXCJtYXhpbXVtRnJhY3Rpb25EaWdpdHNcIiBpbiBvcHRpb25zICkgKSB7XG5cblx0XHQvLyBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBNYXRoLm1heCggbWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKTtcblx0XHRwcm9wZXJ0aWVzWyA0IF0gPSBNYXRoLm1heCggcHJvcGVydGllc1sgMyBdLCBwcm9wZXJ0aWVzWyA0IF0gKTtcblx0fSBlbHNlIGlmICggISggXCJtaW5pbXVtRnJhY3Rpb25EaWdpdHNcIiBpbiBvcHRpb25zICkgJiZcblx0XHRcdFwibWF4aW11bUZyYWN0aW9uRGlnaXRzXCIgaW4gb3B0aW9ucyApIHtcblxuXHRcdC8vIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IE1hdGgubWluKCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyApO1xuXHRcdHByb3BlcnRpZXNbIDMgXSA9IE1hdGgubWluKCBwcm9wZXJ0aWVzWyAzIF0sIHByb3BlcnRpZXNbIDQgXSApO1xuXHR9XG5cblx0Ly8gUmV0dXJuOlxuXHQvLyAwLTEwOiBzZWUgbnVtYmVyL3BhdHRlcm4tcHJvcGVydGllcy5cblx0Ly8gMTE6IEBwb3NpdGl2ZVBhdHRlcm4gW1N0cmluZ10gUG9zaXRpdmUgcGF0dGVybi5cblx0Ly8gMTI6IEBuZWdhdGl2ZVBhdHRlcm4gW1N0cmluZ10gTmVnYXRpdmUgcGF0dGVybi5cblx0Ly8gMTM6IEBuZWdhdGl2ZVByZWZpeCBbU3RyaW5nXSBOZWdhdGl2ZSBwcmVmaXguXG5cdC8vIDE0OiBAbmVnYXRpdmVTdWZmaXggW1N0cmluZ10gTmVnYXRpdmUgc3VmZml4LlxuXHQvLyAxNTogQHJvdW5kIFtGdW5jdGlvbl0gUm91bmQgZnVuY3Rpb24uXG5cdC8vIDE2OiBAaW5maW5pdHlTeW1ib2wgW1N0cmluZ10gSW5maW5pdHkgc3ltYm9sLlxuXHQvLyAxNzogQG5hblN5bWJvbCBbU3RyaW5nXSBOYU4gc3ltYm9sLlxuXHQvLyAxODogQHN5bWJvbE1hcCBbT2JqZWN0XSBBIGJ1bmNoIG9mIG90aGVyIHN5bWJvbHMuXG5cdC8vIDE5OiBAbnVEaWdpdHNNYXAgW0FycmF5XSBEaWdpdHMgbWFwIGlmIG51bWJlcmluZyBzeXN0ZW0gaXMgZGlmZmVyZW50IHRoYW4gYGxhdG5gLlxuXHRyZXR1cm4gcHJvcGVydGllcztcbn07XG5cblxuXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ5OlxuICpcbiAqIHZhciByZWdlbmVyYXRlID0gcmVxdWlyZSggXCJyZWdlbmVyYXRlXCIgKTtcbiAqIHZhciBmb3JtYXRTeW1ib2xzID0gcmVxdWlyZSggKiBcInVuaWNvZGUtOC4wLjAvR2VuZXJhbF9DYXRlZ29yeS9Gb3JtYXQvc3ltYm9sc1wiICk7XG4gKiByZWdlbmVyYXRlKCkuYWRkKCBmb3JtYXRTeW1ib2xzICkudG9TdHJpbmcoKTtcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9yZWdlbmVyYXRlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTguMC4wXG4gKi9cbnZhciByZWdleHBDZkcgPSAvW1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRcXHVEQ0JEfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS9nO1xuXG5cblxuXG4vKipcbiAqIEdlbmVyYXRlZCBieTpcbiAqXG4gKiB2YXIgcmVnZW5lcmF0ZSA9IHJlcXVpcmUoIFwicmVnZW5lcmF0ZVwiICk7XG4gKiB2YXIgZGFzaFN5bWJvbHMgPSByZXF1aXJlKCAqIFwidW5pY29kZS04LjAuMC9HZW5lcmFsX0NhdGVnb3J5L0Rhc2hfUHVuY3R1YXRpb24vc3ltYm9sc1wiICk7XG4gKiByZWdlbmVyYXRlKCkuYWRkKCBkYXNoU3ltYm9scyApLnRvU3RyaW5nKCk7XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvcmVnZW5lcmF0ZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvdW5pY29kZS04LjAuMFxuICpcbiAqIE5PVEU6IEluIGFkZGl0aW9uIHRvIFs6ZGFzaDpdLCAgdGhlIGJlbG93IGluY2x1ZGVzIE1JTlVTIFNJR04gVSsyMjEyLlxuICovXG52YXIgcmVnZXhwRGFzaEcgPSAvW1xcLVxcdTA1OEFcXHUwNUJFXFx1MTQwMFxcdTE4MDZcXHUyMDEwLVxcdTIwMTVcXHUyRTE3XFx1MkUxQVxcdTJFM0FcXHUyRTNCXFx1MkU0MFxcdTMwMUNcXHUzMDMwXFx1MzBBMFxcdUZFMzFcXHVGRTMyXFx1RkU1OFxcdUZFNjNcXHVGRjBEXFx1MjIxMl0vZztcblxuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnk6XG4gKlxuICogdmFyIHJlZ2VuZXJhdGUgPSByZXF1aXJlKCBcInJlZ2VuZXJhdGVcIiApO1xuICogdmFyIHNwYWNlU2VwYXJhdG9yU3ltYm9scyA9IHJlcXVpcmUoIFwidW5pY29kZS04LjAuMC9HZW5lcmFsX0NhdGVnb3J5L1NwYWNlX1NlcGFyYXRvci9zeW1ib2xzXCIgKTtcbiAqIHJlZ2VuZXJhdGUoKS5hZGQoIHNwYWNlU2VwYXJhdG9yU3ltYm9scyApLnRvU3RyaW5nKCk7XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvcmVnZW5lcmF0ZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvdW5pY29kZS04LjAuMFxuICovXG52YXIgcmVnZXhwWnNHID0gL1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS9nO1xuXG5cblxuXG4vKipcbiAqIExvb3NlIE1hdGNoaW5nOlxuICogLSBJZ25vcmUgYWxsIGZvcm1hdCBjaGFyYWN0ZXJzLCB3aGljaCBpbmNsdWRlcyBSTE0sIExSTSBvciBBTE0gdXNlZCB0byBjb250cm9sIEJJRElcbiAqICAgZm9ybWF0dGluZy5cbiAqIC0gTWFwIGFsbCBjaGFyYWN0ZXJzIGluIFs6WnM6XSB0byBVKzAwMjAgU1BBQ0U7XG4gKiAtIE1hcCBhbGwgY2hhcmFjdGVycyBpbiBbOkRhc2g6XSB0byBVKzAwMkQgSFlQSEVOLU1JTlVTO1xuICovXG52YXIgbG9vc2VNYXRjaGluZyA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0cmV0dXJuIHZhbHVlXG5cdFx0LnJlcGxhY2UoIHJlZ2V4cENmRywgXCJcIiApXG5cdFx0LnJlcGxhY2UoIHJlZ2V4cERhc2hHLCBcIi1cIiApXG5cdFx0LnJlcGxhY2UoIHJlZ2V4cFpzRywgXCIgXCIgKTtcbn07XG5cblxuXG5cbi8qKlxuICogcGFyc2UoIHZhbHVlLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBAdmFsdWUgW1N0cmluZ10uXG4gKlxuICogQHByb3BlcnRpZXMgW09iamVjdF0gUGFyc2VyIHByb3BlcnRpZXMgaXMgYSByZWR1Y2VkIHByZS1wcm9jZXNzZWQgY2xkclxuICogZGF0YSBzZXQgcmV0dXJuZWQgYnkgbnVtYmVyUGFyc2VyUHJvcGVydGllcygpLlxuICpcbiAqIFJldHVybiB0aGUgcGFyc2VkIE51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5KSBvciBOYU4gd2hlbiB2YWx1ZSBpcyBpbnZhbGlkLlxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxuICovXG52YXIgbnVtYmVyUGFyc2UgPSBmdW5jdGlvbiggdmFsdWUsIHByb3BlcnRpZXMgKSB7XG5cdHZhciBncmFtbWFyLCBpbnZlcnRlZE51RGlnaXRzTWFwLCBpbnZlcnRlZFN5bWJvbE1hcCwgbmVnYXRpdmUsIG51bWJlciwgcHJlZml4LCBwcmVmaXhOU3VmZml4LFxuXHRcdHN1ZmZpeCwgdG9rZW5pemVyLCB2YWxpZDtcblxuXHQvLyBHcmFtbWFyOlxuXHQvLyAtIFZhbHVlIDw9ICAgICAgICAgICBOYU4gfCBQb3NpdGl2ZU51bWJlciB8IE5lZ2F0aXZlTnVtYmVyXG5cdC8vIC0gUG9zaXRpdmVOdW1iZXIgPD0gIFBvc2l0aXZlUHJlZml4IE51bWJlck9ySW5mIFBvc2l0aXZlU3VmaXhcblx0Ly8gLSBOZWdhdGl2ZU51bWJlciA8PSAgTmVnYXRpdmVQcmVmaXggTnVtYmVyT3JJbmZcblx0Ly8gLSBOdW1iZXJPckluZiA8PSAgICAgTnVtYmVyIHwgSW5mXG5cdGdyYW1tYXIgPSBbXG5cdFx0WyBcIm5hblwiIF0sXG5cdFx0WyBcInByZWZpeFwiLCBcImluZmluaXR5XCIsIFwic3VmZml4XCIgXSxcblx0XHRbIFwicHJlZml4XCIsIFwibnVtYmVyXCIsIFwic3VmZml4XCIgXSxcblx0XHRbIFwibmVnYXRpdmVQcmVmaXhcIiwgXCJpbmZpbml0eVwiLCBcIm5lZ2F0aXZlU3VmZml4XCIgXSxcblx0XHRbIFwibmVnYXRpdmVQcmVmaXhcIiwgXCJudW1iZXJcIiwgXCJuZWdhdGl2ZVN1ZmZpeFwiIF1cblx0XTtcblxuXHRpbnZlcnRlZFN5bWJvbE1hcCA9IHByb3BlcnRpZXNbIDAgXTtcblx0aW52ZXJ0ZWROdURpZ2l0c01hcCA9IHByb3BlcnRpZXNbIDEgXSB8fCB7fTtcblx0dG9rZW5pemVyID0gcHJvcGVydGllc1sgMiBdO1xuXG5cdHZhbHVlID0gbG9vc2VNYXRjaGluZyggdmFsdWUgKTtcblxuXHRmdW5jdGlvbiBwYXJzZSggdHlwZSApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGxleGVtZSApIHtcblxuXHRcdFx0Ly8gUmV2ZXJzZSBsb2NhbGl6ZWQgc3ltYm9scyBhbmQgbnVtYmVyaW5nIHN5c3RlbS5cblx0XHRcdGxleGVtZSA9IGxleGVtZS5zcGxpdCggXCJcIiApLm1hcChmdW5jdGlvbiggY2hhcmFjdGVyICkge1xuXHRcdFx0XHRyZXR1cm4gaW52ZXJ0ZWRTeW1ib2xNYXBbIGNoYXJhY3RlciBdIHx8XG5cdFx0XHRcdFx0aW52ZXJ0ZWROdURpZ2l0c01hcFsgY2hhcmFjdGVyIF0gfHxcblx0XHRcdFx0XHRjaGFyYWN0ZXI7XG5cdFx0XHR9KS5qb2luKCBcIlwiICk7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cdFx0XHRcdGNhc2UgXCJpbmZpbml0eVwiOlxuXHRcdFx0XHRcdG51bWJlciA9IEluZmluaXR5O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJuYW5cIjpcblx0XHRcdFx0XHRudW1iZXIgPSBOYU47XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIm51bWJlclwiOlxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGdyb3VwaW5nIHNlcGFyYXRvcnMuXG5cdFx0XHRcdFx0bGV4ZW1lID0gbGV4ZW1lLnJlcGxhY2UoIC8sL2csIFwiXCIgKTtcblxuXHRcdFx0XHRcdG51bWJlciA9ICtsZXhlbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcInByZWZpeFwiOlxuXHRcdFx0XHRjYXNlIFwibmVnYXRpdmVQcmVmaXhcIjpcblx0XHRcdFx0XHRwcmVmaXggPSBsZXhlbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcInN1ZmZpeFwiOlxuXHRcdFx0XHRcdHN1ZmZpeCA9IGxleGVtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwibmVnYXRpdmVTdWZmaXhcIjpcblx0XHRcdFx0XHRzdWZmaXggPSBsZXhlbWU7XG5cdFx0XHRcdFx0bmVnYXRpdmUgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIkludGVybmFsIGVycm9yXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiB0b2tlbml6ZU5QYXJzZSggX3ZhbHVlLCBncmFtbWFyICkge1xuXHRcdHJldHVybiBncmFtbWFyLnNvbWUoZnVuY3Rpb24oIHN0YXRlbWVudCApIHtcblx0XHRcdHZhciB2YWx1ZSA9IF92YWx1ZTtcblxuXHRcdFx0Ly8gVGhlIHdob2xlIGdyYW1tYXIgc3RhdGVtZW50IHNob3VsZCBiZSB1c2VkIChpLmUuLCAuZXZlcnkoKSByZXR1cm4gdHJ1ZSkgYW5kIHZhbHVlIGJlXG5cdFx0XHQvLyBlbnRpcmVseSBjb25zdW1lZCAoaS5lLiwgIXZhbHVlLmxlbmd0aCkuXG5cdFx0XHRyZXR1cm4gc3RhdGVtZW50LmV2ZXJ5KGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRpZiAoIHZhbHVlLm1hdGNoKCB0b2tlbml6ZXJbIHR5cGUgXSApID09PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbnN1bWUgYW5kIHBhcnNlIGl0LlxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHRva2VuaXplclsgdHlwZSBdLCBwYXJzZSggdHlwZSApICk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSkgJiYgIXZhbHVlLmxlbmd0aDtcblx0XHR9KTtcblx0fVxuXG5cdHZhbGlkID0gdG9rZW5pemVOUGFyc2UoIHZhbHVlLCBncmFtbWFyICk7XG5cblx0Ly8gTmFOXG5cdGlmICggIXZhbGlkIHx8IGlzTmFOKCBudW1iZXIgKSApIHtcblx0XHRyZXR1cm4gTmFOO1xuXHR9XG5cblx0cHJlZml4TlN1ZmZpeCA9IFwiXCIgKyBwcmVmaXggKyBzdWZmaXg7XG5cblx0Ly8gUGVyY2VudFxuXHRpZiAoIHByZWZpeE5TdWZmaXguaW5kZXhPZiggXCIlXCIgKSAhPT0gLTEgKSB7XG5cdFx0bnVtYmVyIC89IDEwMDtcblxuXHQvLyBQZXIgbWlsbGVcblx0fSBlbHNlIGlmICggcHJlZml4TlN1ZmZpeC5pbmRleE9mKCBcIlxcdTIwMzBcIiApICE9PSAtMSApIHtcblx0XHRudW1iZXIgLz0gMTAwMDtcblx0fVxuXG5cdC8vIE5lZ2F0aXZlIG51bWJlclxuXHRpZiAoIG5lZ2F0aXZlICkge1xuXHRcdG51bWJlciAqPSAtMTtcblx0fVxuXG5cdHJldHVybiBudW1iZXI7XG59O1xuXG5cblxuXG52YXIgbnVtYmVyUGFyc2VyRm4gPSBmdW5jdGlvbiggcHJvcGVydGllcyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIG51bWJlclBhcnNlciggdmFsdWUgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0cmV0dXJuIG51bWJlclBhcnNlKCB2YWx1ZSwgcHJvcGVydGllcyApO1xuXHR9O1xuXG59O1xuXG5cblxuXG4vKipcbiAqIHN5bWJvbE1hcCggY2xkciApXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiB0aGUgKGxvY2FsaXplZCBzeW1ib2wsIHBhdHRlcm4gc3ltYm9sKSBrZXkgdmFsdWUgcGFpciwgZWcuIHtcbiAqICAgXCLZq1wiOiBcIi5cIixcbiAqICAgXCLZrFwiOiBcIixcIixcbiAqICAgXCLZqlwiOiBcIiVcIixcbiAqICAgLi4uXG4gKiB9O1xuICovXG52YXIgbnVtYmVyU3ltYm9sSW52ZXJ0ZWRNYXAgPSBmdW5jdGlvbiggY2xkciApIHtcblx0dmFyIHN5bWJvbCxcblx0XHRzeW1ib2xNYXAgPSB7fTtcblxuXHRmb3IgKCBzeW1ib2wgaW4gbnVtYmVyU3ltYm9sTmFtZSApIHtcblx0XHRzeW1ib2xNYXBbIG51bWJlclN5bWJvbCggbnVtYmVyU3ltYm9sTmFtZVsgc3ltYm9sIF0sIGNsZHIgKSBdID0gc3ltYm9sO1xuXHR9XG5cblx0cmV0dXJuIHN5bWJvbE1hcDtcbn07XG5cblxuXG5cbi8qKlxuICogb2JqZWN0TWFwKCBvYmplY3QsIGZuKVxuICpcbiAqIC0gb2JqZWN0XG4gKlxuICogLSBmbiggcGFpciApID0+IHBhaXJcbiAqL1xudmFyIG9iamVjdE1hcCA9IGZ1bmN0aW9uKCBvYmplY3QsIGZuICkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoIG9iamVjdCApLm1hcChmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiBmbihbIGtleSwgb2JqZWN0WyBrZXkgXSBdKTtcblx0fSkucmVkdWNlKGZ1bmN0aW9uKCBvYmplY3QsIHBhaXIgKSB7XG5cdFx0b2JqZWN0WyBwYWlyWyAwIF0gXSA9IHBhaXJbIDEgXTtcblx0XHRyZXR1cm4gb2JqZWN0O1xuXHR9LCB7fSk7XG59O1xuXG5cblxuXG4vKipcbiAqIHBhcnNlUHJvcGVydGllcyggcGF0dGVybiwgY2xkciApXG4gKlxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4gZm9yIG51bWJlcnMuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiBwYXJzZXIgcHJvcGVydGllcywgdXNlZCB0byBmZWVkIHBhcnNlciBmdW5jdGlvbi5cbiAqXG4gKiBUT0RPOlxuICogLSBTY2llbnRpZmljX25vdGF0aW9uO1xuICogLSBQYWRkaW5nO1xuICovXG52YXIgbnVtYmVyUGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHBhdHRlcm4sIGNsZHIsIG9wdGlvbnMgKSB7XG5cdHZhciBhdXgsIGRlY2ltYWxTeW1ib2xSZSwgZGlnaXRzUmUsIGdyb3VwaW5nU2VwYXJhdG9yUmUsIGluZmluaXR5U3ltYm9sLCBpbnZlcnRlZE51RGlnaXRzTWFwLFxuXHRcdGludmVydGVkU3ltYm9sTWFwLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyxcblx0XHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG5hblN5bWJvbCwgbmVnYXRpdmVQcmVmaXgsIG5lZ2F0aXZlU3VmZml4LCBudURpZ2l0c01hcCxcblx0XHRudW1iZXJUb2tlbml6ZXIsIHByZWZpeCwgcHJpbWFyeUdyb3VwaW5nU2l6ZSwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplLCBzdWZmaXgsIHN5bWJvbE1hcCxcblx0XHRmb3JtYXRQcm9wZXJ0aWVzID0gbnVtYmVyRm9ybWF0UHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApO1xuXG5cdHByZWZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDAgXSApO1xuXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBmb3JtYXRQcm9wZXJ0aWVzWyA0IF07XG5cdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA9IGZvcm1hdFByb3BlcnRpZXNbIDUgXTtcblx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gZm9ybWF0UHJvcGVydGllc1sgNiBdO1xuXHRwcmltYXJ5R3JvdXBpbmdTaXplID0gZm9ybWF0UHJvcGVydGllc1sgOCBdO1xuXHRzZWNvbmRhcnlHcm91cGluZ1NpemUgPSBmb3JtYXRQcm9wZXJ0aWVzWyA5IF07XG5cdHN1ZmZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDEwIF0gKTtcblx0bmVnYXRpdmVQcmVmaXggPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAxMyBdICk7XG5cdG5lZ2F0aXZlU3VmZml4ID0gbG9vc2VNYXRjaGluZyggZm9ybWF0UHJvcGVydGllc1sgMTQgXSApO1xuXHRpbmZpbml0eVN5bWJvbCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDE2IF0gKTtcblx0bmFuU3ltYm9sID0gbG9vc2VNYXRjaGluZyggZm9ybWF0UHJvcGVydGllc1sgMTcgXSApO1xuXHRzeW1ib2xNYXAgPSBvYmplY3RNYXAoIGZvcm1hdFByb3BlcnRpZXNbIDE4IF0sIGZ1bmN0aW9uKCBwYWlyICkge1xuXHRcdHJldHVybiBbIHBhaXJbIDAgXSwgbG9vc2VNYXRjaGluZyggcGFpclsgMSBdICkgXTtcblx0fSk7XG5cdG51RGlnaXRzTWFwID0gZm9ybWF0UHJvcGVydGllc1sgMTkgXTtcblxuXHRpbnZlcnRlZFN5bWJvbE1hcCA9IG9iamVjdE1hcCggbnVtYmVyU3ltYm9sSW52ZXJ0ZWRNYXAoIGNsZHIgKSwgZnVuY3Rpb24oIHBhaXIgKSB7XG5cdFx0cmV0dXJuIFsgbG9vc2VNYXRjaGluZyggcGFpclsgMCBdICksIHBhaXJbIDEgXSBdO1xuXHR9KTtcblxuXHRkaWdpdHNSZSA9IG51RGlnaXRzTWFwID8gXCJbXCIgKyBudURpZ2l0c01hcCArIFwiXVwiIDogXCJcXFxcZFwiO1xuXHRncm91cGluZ1NlcGFyYXRvclJlID0gcmVnZXhwRXNjYXBlKCBzeW1ib2xNYXBbIFwiLFwiIF0gKTtcblx0ZGVjaW1hbFN5bWJvbFJlID0gcmVnZXhwRXNjYXBlKCBzeW1ib2xNYXBbIFwiLlwiIF0gKTtcblxuXHRpZiAoIG51RGlnaXRzTWFwICkge1xuXHRcdGludmVydGVkTnVEaWdpdHNNYXAgPSBudURpZ2l0c01hcC5zcGxpdCggXCJcIiApLnJlZHVjZShmdW5jdGlvbiggb2JqZWN0LCBsb2NhbGl6ZWREaWdpdCwgaSApIHtcblx0XHRcdG9iamVjdFsgbG9jYWxpemVkRGlnaXQgXSA9IFN0cmluZyggaSApO1xuXHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHR9LCB7fSApO1xuXHR9XG5cblx0YXV4ID0gWyBwcmVmaXgsIHN1ZmZpeCwgbmVnYXRpdmVQcmVmaXgsIG5lZ2F0aXZlU3VmZml4IF0ubWFwKGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSggLygnKFteJ118JycpKyd8JycpfC4vZywgZnVuY3Rpb24oIGNoYXJhY3RlciwgbGl0ZXJhbCApIHtcblxuXHRcdFx0Ly8gTGl0ZXJhbHNcblx0XHRcdGlmICggbGl0ZXJhbCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZUxpdGVyYWxRdW90ZXMoIGxpdGVyYWwgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3ltYm9sc1xuXHRcdFx0Y2hhcmFjdGVyID0gY2hhcmFjdGVyLnJlcGxhY2UoIC9bXFwtK0UlXFx1MjAzMF0vLCBmdW5jdGlvbiggc3ltYm9sICkge1xuXHRcdFx0XHRyZXR1cm4gc3ltYm9sTWFwWyBzeW1ib2wgXTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gY2hhcmFjdGVyO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRwcmVmaXggPSBhdXhbIDAgXTtcblx0c3VmZml4ID0gYXV4WyAxIF07XG5cdG5lZ2F0aXZlUHJlZml4ID0gYXV4WyAyIF07XG5cdG5lZ2F0aXZlU3VmZml4ID0gYXV4WyAzIF07XG5cblx0Ly8gTnVtYmVyXG5cdC8vXG5cdC8vIG51bWJlcl9yZSA9ICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ2VyIGZyYWN0aW9uP1xuXHQvL1xuXHQvLyBpbnRlZ2VyID0gICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzIHwgZGlnaXRzX3VzaW5nX2dyb3VwaW5nX3NlcGFyYXRvcnNcblx0Ly9cblx0Ly8gZnJhY3Rpb24gPSAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCgoLlxcZCspPylcblx0Ly9cblx0Ly8gZGlnaXRzID0gICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cChcXGQrKVxuXHQvL1xuXHQvLyBkaWdpdHNfd19ncm91cGluZ19zZXBhcmF0b3JzID0gICAgZGlnaXRzX3dfMV9ncm91cGluZ19zZXBhcmF0b3JzIHxcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c193XzJfZ3JvdXBpbmdfc2VwYXJhdG9yc1xuXHQvL1xuXHQvLyBkaWdpdHNfd18xX2dyb3VwaW5nX3NlcGFyYXRvcnMgPSAgcmVnZXhwKFxcZHsxLDN9KCxcXGR7M30pKylcblx0Ly9cblx0Ly8gZGlnaXRzX3dfMl9ncm91cGluZ19zZXBhcmF0b3JzID0gIHJlZ2V4cChcXGR7MSwyfSgoLFxcZHsyfSkqKCxcXGR7M30pKSlcblxuXHQvLyBJbnRlZ2VyIHBhcnRcblx0bnVtYmVyVG9rZW5pemVyID0gZGlnaXRzUmUgKyBcIitcIjtcblxuXHQvLyBHcm91cGluZyBzZXBhcmF0b3JzXG5cdGlmICggcHJpbWFyeUdyb3VwaW5nU2l6ZSApIHtcblx0XHRpZiAoIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSApIHtcblx0XHRcdGF1eCA9IGRpZ2l0c1JlICsgXCJ7MSxcIiArIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSArIFwifSgoXCIgKyBncm91cGluZ1NlcGFyYXRvclJlICtcblx0XHRcdFx0ZGlnaXRzUmUgKyBcIntcIiArIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSArIFwifSkqKFwiICsgZ3JvdXBpbmdTZXBhcmF0b3JSZSArXG5cdFx0XHRcdGRpZ2l0c1JlICsgXCJ7XCIgKyBwcmltYXJ5R3JvdXBpbmdTaXplICsgXCJ9KSlcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXV4ID0gZGlnaXRzUmUgKyBcInsxLFwiICsgcHJpbWFyeUdyb3VwaW5nU2l6ZSArIFwifShcIiArIGdyb3VwaW5nU2VwYXJhdG9yUmUgK1xuXHRcdFx0XHRkaWdpdHNSZSArIFwie1wiICsgcHJpbWFyeUdyb3VwaW5nU2l6ZSArIFwifSkrXCI7XG5cdFx0fVxuXHRcdG51bWJlclRva2VuaXplciA9IFwiKFwiICsgYXV4ICsgXCJ8XCIgKyBudW1iZXJUb2tlbml6ZXIgKyBcIilcIjtcblx0fVxuXG5cdC8vIEZyYWN0aW9uIHBhcnQ/IE9ubHkgaW5jbHVkZWQgaWYgMSBvciAyLlxuXHQvLyAxOiBVc2luZyBzaWduaWZpY2FudCBkaWdpdCBmb3JtYXQuXG5cdC8vIDI6IFVzaW5nIGludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0ICYmIGl0IGhhcyBhIG1heGltdW1GcmFjdGlvbkRpZ2l0cy5cblx0aWYgKCAhaXNOYU4oIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAqIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyApIHx8IC8qIDEgKi9cblx0XHRcdFx0bWF4aW11bUZyYWN0aW9uRGlnaXRzIC8qIDIgKi8gKSB7XG5cblx0XHQvLyAxOiBIYW5kbGUgdHJhaWxpbmcgZGVjaW1hbCBzZXBhcmF0b3IsIGUuZy4sIGBcIjEuXCIgPT4gYDFgYC5cblx0XHRhdXggPSBkZWNpbWFsU3ltYm9sUmUgKyBkaWdpdHNSZSArIFwiK1wiO1xuXHRcdG51bWJlclRva2VuaXplciA9IG51bWJlclRva2VuaXplciArIFwiKFwiICsgYXV4ICsgXCJ8XCIgKyBkZWNpbWFsU3ltYm9sUmUgLyogMSAqLyArIFwiKT9cIiArXG5cblx0XHRcdC8vIEhhbmRsZSBub24tcGFkZGVkIGRlY2ltYWxzLCBlLmcuLCBgXCIuMTJcImAgPT4gYDAuMTJgIGJ5IG1ha2luZyB0aGUgaW50ZWdlciBwYXJ0XG5cdFx0XHQvLyBvcHRpb25hbC5cblx0XHRcdFwifChcIiArIG51bWJlclRva2VuaXplciArIFwiKT9cIiArIGF1eDtcblxuXHRcdG51bWJlclRva2VuaXplciA9IFwiKFwiICsgbnVtYmVyVG9rZW5pemVyICsgXCIpXCI7XG5cdH1cblxuXHQvLyAwOiBAaW52ZXJ0ZWRTeW1ib2xNYXAgW09iamVjdF0gSW52ZXJ0ZWQgc3ltYm9sIG1hcC5cblx0Ly8gMTogQGludmVydGVkTnVEaWdpdHNNYXAgW09iamVjdF0gSW52ZXJ0ZWQgZGlnaXRzIG1hcCBpZiBudW1iZXJpbmcgc3lzdGVtIGlzIGRpZmZlcmVudCB0aGFuXG5cdC8vICAgIGBsYXRuYC5cblx0Ly8gMjogQHRva2VuaXplciBbT2JqZWN0XSBUb2tlbml6ZXIgbWFwLCB1c2VkIGJ5IHBhcnNlciB0byBjb25zdW1lIGlucHV0LlxuXHRyZXR1cm4gW1xuXHRcdGludmVydGVkU3ltYm9sTWFwLFxuXHRcdGludmVydGVkTnVEaWdpdHNNYXAsXG5cdFx0e1xuXHRcdFx0aW5maW5pdHk6IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBpbmZpbml0eVN5bWJvbCApICksXG5cdFx0XHRuYW46ICBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggbmFuU3ltYm9sICkgKSxcblx0XHRcdG5lZ2F0aXZlUHJlZml4OiBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggbmVnYXRpdmVQcmVmaXggKSApLFxuXHRcdFx0bmVnYXRpdmVTdWZmaXg6IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBuZWdhdGl2ZVN1ZmZpeCApICksXG5cdFx0XHRudW1iZXI6IG5ldyBSZWdFeHAoIFwiXlwiICsgbnVtYmVyVG9rZW5pemVyICksXG5cdFx0XHRwcmVmaXg6IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBwcmVmaXggKSApLFxuXHRcdFx0c3VmZml4OiBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggc3VmZml4ICkgKVxuXHRcdH1cblx0XTtcblxufTtcblxuXG5cblxuLyoqXG4gKiBQYXR0ZXJuKCBzdHlsZSApXG4gKlxuICogQHN0eWxlIFtTdHJpbmddIFwiZGVjaW1hbFwiIChkZWZhdWx0KSBvciBcInBlcmNlbnRcIi5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKi9cbnZhciBudW1iZXJQYXR0ZXJuID0gZnVuY3Rpb24oIHN0eWxlLCBjbGRyICkge1xuXHRpZiAoIHN0eWxlICE9PSBcImRlY2ltYWxcIiAmJiBzdHlsZSAhPT0gXCJwZXJjZW50XCIgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIkludmFsaWQgc3R5bGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGNsZHIubWFpbihbXG5cdFx0XCJudW1iZXJzXCIsXG5cdFx0c3R5bGUgKyBcIkZvcm1hdHMtbnVtYmVyU3lzdGVtLVwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICksXG5cdFx0XCJzdGFuZGFyZFwiXG5cdF0pO1xufTtcblxuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVEaWdpdHMoIHByb3BlcnRpZXMgKSB7XG5cdHZhciBtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IHByb3BlcnRpZXNbIDIgXSxcblx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBwcm9wZXJ0aWVzWyAzIF0sXG5cdFx0bWF4aW11bUZyYWN0aW9uRGlnaXRzID0gcHJvcGVydGllc1sgNCBdLFxuXHRcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA9IHByb3BlcnRpZXNbIDUgXSxcblx0XHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBwcm9wZXJ0aWVzWyA2IF07XG5cblx0Ly8gVmFsaWRhdGUgc2lnbmlmaWNhbnQgZGlnaXQgZm9ybWF0IHByb3BlcnRpZXNcblx0aWYgKCAhaXNOYU4oIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAqIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyApICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UoIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgXCJtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHNcIiwgMSwgMjEgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIFwibWF4aW11bVNpZ25pZmljYW50RGlnaXRzXCIsXG5cdFx0XHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIDIxICk7XG5cblx0fSBlbHNlIGlmICggIWlzTmFOKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgKSB8fCAhaXNOYU4oIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyApICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggXCJOZWl0aGVyIG9yIGJvdGggdGhlIG1pbmltdW0gYW5kIG1heGltdW0gc2lnbmlmaWNhbnQgZGlnaXRzIG11c3QgYmUgXCIgK1xuXHRcdFx0XCJwcmVzZW50XCIgKTtcblxuXHQvLyBWYWxpZGF0ZSBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIGZvcm1hdFxuXHR9IGVsc2Uge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UoIG1pbmltdW1JbnRlZ2VyRGlnaXRzLCBcIm1pbmltdW1JbnRlZ2VyRGlnaXRzXCIsIDEsIDIxICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSggbWluaW11bUZyYWN0aW9uRGlnaXRzLCBcIm1pbmltdW1GcmFjdGlvbkRpZ2l0c1wiLCAwLCAyMCApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UoIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgXCJtYXhpbXVtRnJhY3Rpb25EaWdpdHNcIixcblx0XHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgMjAgKTtcblx0fVxufVxuXG4vKipcbiAqIC5udW1iZXJGb3JtYXR0ZXIoIFtvcHRpb25zXSApXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06XG4gKiAtIHN0eWxlOiBbU3RyaW5nXSBcImRlY2ltYWxcIiAoZGVmYXVsdCkgb3IgXCJwZXJjZW50XCIuXG4gKiAtIHNlZSBhbHNvIG51bWJlci9mb3JtYXQgb3B0aW9ucy5cbiAqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBudW1iZXIgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBkZWZhdWx0L2luc3RhbmNlXG4gKiBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5udW1iZXJGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5udW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIHBhdHRlcm4sIHByb3BlcnRpZXMsIHJldHVybkZuO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRjbGRyID0gdGhpcy5jbGRyO1xuXG5cdGFyZ3MgPSBbIG9wdGlvbnMgXTtcblxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblxuXHRpZiAoIG9wdGlvbnMucmF3ICkge1xuXHRcdHBhdHRlcm4gPSBvcHRpb25zLnJhdztcblx0fSBlbHNlIHtcblx0XHRwYXR0ZXJuID0gbnVtYmVyUGF0dGVybiggb3B0aW9ucy5zdHlsZSB8fCBcImRlY2ltYWxcIiwgY2xkciApO1xuXHR9XG5cblx0cHJvcGVydGllcyA9IG51bWJlckZvcm1hdFByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIsIG9wdGlvbnMgKTtcblxuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cblx0dmFsaWRhdGVEaWdpdHMoIHByb3BlcnRpZXMgKTtcblxuXHRyZXR1cm5GbiA9IG51bWJlckZvcm1hdHRlckZuKCBwcm9wZXJ0aWVzICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIHByb3BlcnRpZXMgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLm51bWJlclBhcnNlciggW29wdGlvbnNdIClcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTpcbiAqIC0gc3R5bGU6IFtTdHJpbmddIFwiZGVjaW1hbFwiIChkZWZhdWx0KSBvciBcInBlcmNlbnRcIi5cbiAqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBwYXJzZXIgYWNjb3JkaW5nIHRvIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLm51bWJlclBhcnNlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLm51bWJlclBhcnNlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgcGF0dGVybiwgcHJvcGVydGllcywgcmV0dXJuRm47XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cblx0YXJncyA9IFsgb3B0aW9ucyBdO1xuXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXG5cdGlmICggb3B0aW9ucy5yYXcgKSB7XG5cdFx0cGF0dGVybiA9IG9wdGlvbnMucmF3O1xuXHR9IGVsc2Uge1xuXHRcdHBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuKCBvcHRpb25zLnN0eWxlIHx8IFwiZGVjaW1hbFwiLCBjbGRyICk7XG5cdH1cblxuXHRwcm9wZXJ0aWVzID0gbnVtYmVyUGFyc2VQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICk7XG5cblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXG5cdHJldHVybkZuID0gbnVtYmVyUGFyc2VyRm4oIHByb3BlcnRpZXMgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgcHJvcGVydGllcyBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAuZm9ybWF0TnVtYmVyKCB2YWx1ZSBbLCBvcHRpb25zXSApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdIG51bWJlciB0byBiZSBmb3JtYXR0ZWQuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06IHNlZSBudW1iZXIvZm9ybWF0LXByb3BlcnRpZXMuXG4gKlxuICogRm9ybWF0IGEgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXROdW1iZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMubnVtYmVyRm9ybWF0dGVyKCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIC5wYXJzZU51bWJlciggdmFsdWUgWywgb3B0aW9uc10gKVxuICpcbiAqIEB2YWx1ZSBbU3RyaW5nXVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOiBTZWUgbnVtYmVyUGFyc2VyKCkuXG4gKlxuICogUmV0dXJuIHRoZSBwYXJzZWQgTnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkpIG9yIE5hTiB3aGVuIHZhbHVlIGlzIGludmFsaWQuXG4gKi9cbkdsb2JhbGl6ZS5wYXJzZU51bWJlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLnBhcnNlTnVtYmVyID0gZnVuY3Rpb24oIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLm51bWJlclBhcnNlciggb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiBPcHRpbWl6YXRpb24gdG8gYXZvaWQgZHVwbGljYXRpbmcgc29tZSBpbnRlcm5hbCBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXG4gKi9cbkdsb2JhbGl6ZS5fY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUgPSBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZTtcbkdsb2JhbGl6ZS5fbnVtYmVyTnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyTnVtYmVyaW5nU3lzdGVtO1xuR2xvYmFsaXplLl9udW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAgPSBudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXA7XG5HbG9iYWxpemUuX251bWJlclBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuO1xuR2xvYmFsaXplLl9udW1iZXJTeW1ib2wgPSBudW1iZXJTeW1ib2w7XG5HbG9iYWxpemUuX2xvb3NlTWF0Y2hpbmcgPSBsb29zZU1hdGNoaW5nO1xuR2xvYmFsaXplLl9yZW1vdmVMaXRlcmFsUXVvdGVzID0gcmVtb3ZlTGl0ZXJhbFF1b3Rlcztcbkdsb2JhbGl6ZS5fc3RyaW5nUGFkID0gc3RyaW5nUGFkO1xuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXI7XG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyA9IHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZztcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbnVtYmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIixcblx0XHRcdFwiY2xkci9zdXBwbGVtZW50YWxcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgcnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3Q7XG52YXIgTWFrZVBsdXJhbDtcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbk1ha2VQbHVyYWwgPSAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdG9BcnJheSA9IGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6IEFycmF5LmZyb20oYXJyKTsgfTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9O1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5cbi8qKlxuICogbWFrZS1wbHVyYWwuanMgLS0gaHR0cHM6Ly9naXRodWIuY29tL2VlbWVsaS9tYWtlLXBsdXJhbC5qcy9cbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1IGJ5IEVlbWVsaSBBcm8gPGVlbWVsaUBnbWFpbC5jb20+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRoZSBzb2Z0d2FyZSBpcyBwcm92aWRlZCBcImFzIGlzXCIgYW5kIHRoZSBhdXRob3IgZGlzY2xhaW1zIGFsbCB3YXJyYW50aWVzXG4gKiB3aXRoIHJlZ2FyZCB0byB0aGlzIHNvZnR3YXJlIGluY2x1ZGluZyBhbGwgaW1wbGllZCB3YXJyYW50aWVzIG9mXG4gKiBtZXJjaGFudGFiaWxpdHkgYW5kIGZpdG5lc3MuIEluIG5vIGV2ZW50IHNoYWxsIHRoZSBhdXRob3IgYmUgbGlhYmxlIGZvclxuICogYW55IHNwZWNpYWwsIGRpcmVjdCwgaW5kaXJlY3QsIG9yIGNvbnNlcXVlbnRpYWwgZGFtYWdlcyBvciBhbnkgZGFtYWdlc1xuICogd2hhdHNvZXZlciByZXN1bHRpbmcgZnJvbSBsb3NzIG9mIHVzZSwgZGF0YSBvciBwcm9maXRzLCB3aGV0aGVyIGluIGFuXG4gKiBhY3Rpb24gb2YgY29udHJhY3QsIG5lZ2xpZ2VuY2Ugb3Igb3RoZXIgdG9ydGlvdXMgYWN0aW9uLCBhcmlzaW5nIG91dCBvZlxuICogb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSB1c2Ugb3IgcGVyZm9ybWFuY2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbiAqL1xuXG52YXIgUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzZXIpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQYXJzZXIsIFt7XG4gICAgICAgIGtleTogJ3BhcnNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbmQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChjb25kID09PSAnaSA9IDAgb3IgbiA9IDEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduID49IDAgJiYgbiA8PSAxJztcbiAgICAgICAgICAgIH1pZiAoY29uZCA9PT0gJ2kgPSAwLDEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduID49IDAgJiYgbiA8IDInO1xuICAgICAgICAgICAgfWlmIChjb25kID09PSAnaSA9IDEgYW5kIHYgPSAwJykge1xuICAgICAgICAgICAgICAgIHRoaXMudjAgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnbiA9PSAxICYmIHYwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25kLnJlcGxhY2UoLyhbdHZdKSAoIT8pPSAwL2csIGZ1bmN0aW9uIChtLCBzeW0sIG5vdGVxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNuID0gc3ltICsgJzAnO1xuICAgICAgICAgICAgICAgIF90aGlzW3NuXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGVxID8gJyEnICsgc24gOiBzbjtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL1xcYltmaW50dl1cXGIvZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBfdGhpc1ttXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC8oW2Zpbl0pICUgKDEwKykvZywgZnVuY3Rpb24gKG0sIHN5bSwgbnVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNuID0gc3ltICsgbnVtO1xuICAgICAgICAgICAgICAgIF90aGlzW3NuXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvbjEwKyA9IDAvZywgJ3QwICYmICQmJykucmVwbGFjZSgvKFxcdysgKCE/KT0gKShbMC05Ll0rLFswLTkuLF0rKS9nLCBmdW5jdGlvbiAobSwgc2UsIG5vdGVxLCB4KSB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT09ICduID0gMCwxJykgcmV0dXJuICcobiA9PSAwIHx8IG4gPT0gMSknO1xuICAgICAgICAgICAgICAgIGlmIChub3RlcSkgcmV0dXJuIHNlICsgeC5zcGxpdCgnLCcpLmpvaW4oJyAmJiAnICsgc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBzZSArIHguc3BsaXQoJywnKS5qb2luKCcgfHwgJyArIHNlKSArICcpJztcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLyhcXHcrKSAoIT8pPSAoWzAtOV0rKVxcLlxcLihbMC05XSspL2csIGZ1bmN0aW9uIChtLCBzeW0sIG5vdGVxLCB4MCwgeDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyKHgwKSArIDEgPT09IE51bWJlcih4MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGVxKSByZXR1cm4gJycgKyBzeW0gKyAnICE9ICcgKyB4MCArICcgJiYgJyArIHN5bSArICcgIT0gJyArIHgxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgc3ltICsgJyA9PSAnICsgeDAgKyAnIHx8ICcgKyBzeW0gKyAnID09ICcgKyB4MSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdGVxKSByZXR1cm4gJygnICsgc3ltICsgJyA8ICcgKyB4MCArICcgfHwgJyArIHN5bSArICcgPiAnICsgeDEgKyAnKSc7XG4gICAgICAgICAgICAgICAgaWYgKHN5bSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnQwID0gMTtyZXR1cm4gJyh0MCAmJiBuID49ICcgKyB4MCArICcgJiYgbiA8PSAnICsgeDEgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBzeW0gKyAnID49ICcgKyB4MCArICcgJiYgJyArIHN5bSArICcgPD0gJyArIHgxICsgJyknO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvIGFuZCAvZywgJyAmJiAnKS5yZXBsYWNlKC8gb3IgL2csICcgfHwgJykucmVwbGFjZSgvID0gL2csICcgPT0gJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZhcnMnLFxuICAgICAgICB2YWx1ZTogKGZ1bmN0aW9uIChfdmFycykge1xuICAgICAgICAgICAgZnVuY3Rpb24gdmFycygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFycy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZhcnMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB2YXJzO1xuICAgICAgICB9KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaSkgdmFycy5wdXNoKCdpID0gc1swXScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZiB8fCB0aGlzLnYpIHZhcnMucHVzaCgnZiA9IHNbMV0gfHwgXFwnXFwnJyk7XG4gICAgICAgICAgICBpZiAodGhpcy50KSB2YXJzLnB1c2goJ3QgPSAoc1sxXSB8fCBcXCdcXCcpLnJlcGxhY2UoLzArJC8sIFxcJ1xcJyknKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnYpIHZhcnMucHVzaCgndiA9IGYubGVuZ3RoJyk7XG4gICAgICAgICAgICBpZiAodGhpcy52MCkgdmFycy5wdXNoKCd2MCA9ICFzWzFdJyk7XG4gICAgICAgICAgICBpZiAodGhpcy50MCB8fCB0aGlzLm4xMCB8fCB0aGlzLm4xMDApIHZhcnMucHVzaCgndDAgPSBOdW1iZXIoc1swXSkgPT0gbicpO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eLjEwKyQvLnRlc3QoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGswID0ga1swXSA9PT0gJ24nID8gJ3QwICYmIHNbMF0nIDoga1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFycy5wdXNoKCcnICsgayArICcgPSAnICsgazAgKyAnLnNsaWNlKC0nICsgay5zdWJzdHIoMikubGVuZ3RoICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9aWYgKCF2YXJzLmxlbmd0aCkgcmV0dXJuICcnO1xuICAgICAgICAgICAgcmV0dXJuICd2YXIgJyArIFsncyA9IFN0cmluZyhuKS5zcGxpdChcXCcuXFwnKSddLmNvbmNhdCh2YXJzKS5qb2luKCcsICcpO1xuICAgICAgICB9KVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQYXJzZXI7XG59KSgpO1xuXG5cblxudmFyIE1ha2VQbHVyYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ha2VQbHVyYWwobGMpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IE1ha2VQbHVyYWwgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIGNhcmRpbmFscyA9IF9yZWYuY2FyZGluYWxzO1xuICAgICAgICB2YXIgb3JkaW5hbHMgPSBfcmVmLm9yZGluYWxzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYWtlUGx1cmFsKTtcblxuICAgICAgICBpZiAoIWNhcmRpbmFscyAmJiAhb3JkaW5hbHMpIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHR5cGUgb2YgcGx1cmFsIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIHRoaXMubGMgPSBsYztcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0geyBjYXJkaW5hbDogW10sIG9yZGluYWw6IFtdIH07XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5mbiA9IHRoaXMuYnVpbGRGdW5jdGlvbihjYXJkaW5hbHMsIG9yZGluYWxzKTtcbiAgICAgICAgdGhpcy5mbi5fb2JqID0gdGhpcztcbiAgICAgICAgdGhpcy5mbi5jYXRlZ29yaWVzID0gdGhpcy5jYXRlZ29yaWVzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5mbi50b1N0cmluZyA9IHRoaXMuZm5Ub1N0cmluZy5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbjtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTWFrZVBsdXJhbCwgW3tcbiAgICAgICAga2V5OiAnY29tcGlsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKHR5cGUsIHJlcSkge1xuICAgICAgICAgICAgdmFyIGNhc2VzID0gW107XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBNYWtlUGx1cmFsLnJ1bGVzW3R5cGVdW3RoaXMubGNdO1xuICAgICAgICAgICAgaWYgKCFydWxlcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXEpIHRocm93IG5ldyBFcnJvcignTG9jYWxlIFwiJyArIHRoaXMubGMgKyAnXCIgJyArIHR5cGUgKyAnIHJ1bGVzIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2F0ZWdvcmllc1t0eXBlXSA9IFsnb3RoZXInXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcJ290aGVyXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHIgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3J1bGVzJHIkdHJpbSRzcGxpdCA9IHJ1bGVzW3JdLnRyaW0oKS5zcGxpdCgvXFxzKkBcXHcqLyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3J1bGVzJHIkdHJpbSRzcGxpdDIgPSBfdG9BcnJheShfcnVsZXMkciR0cmltJHNwbGl0KTtcblxuICAgICAgICAgICAgICAgIHZhciBjb25kID0gX3J1bGVzJHIkdHJpbSRzcGxpdDJbMF07XG4gICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVzID0gX3J1bGVzJHIkdHJpbSRzcGxpdDIuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhdCA9IHIucmVwbGFjZSgncGx1cmFsUnVsZS1jb3VudC0nLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmQpIGNhc2VzLnB1c2goW3RoaXMucGFyc2VyLnBhcnNlKGNvbmQpLCBjYXRdKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2F0ZWdvcmllc1t0eXBlXSA9IGNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjWzFdO1xuICAgICAgICAgICAgfSkuY29uY2F0KCdvdGhlcicpO1xuICAgICAgICAgICAgaWYgKGNhc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBjYXNlc1swXVswXSArICcpID8gXFwnJyArIGNhc2VzWzBdWzFdICsgJ1xcJyA6IFxcJ290aGVyXFwnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2FzZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBjWzBdICsgJykgPyBcXCcnICsgY1sxXSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH0pKSwgWydcXCdvdGhlclxcJyddKS5qb2luKCdcXG4gICAgICA6ICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdidWlsZEZ1bmN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRnVuY3Rpb24oY2FyZGluYWxzLCBvcmRpbmFscykge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjb21waWxlID0gZnVuY3Rpb24gY29tcGlsZShjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgPyAoY1sxXSA/ICdyZXR1cm4gJyA6ICdpZiAob3JkKSByZXR1cm4gJykgKyBfdGhpczMuY29tcGlsZS5hcHBseShfdGhpczMsIF90b0NvbnN1bWFibGVBcnJheShjKSkgOiAnJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9sZCA9IHsgdmFyczogZnVuY3Rpb24gdmFycyhzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnICAnICsgc3RyICsgJzsnKS5yZXBsYWNlKC8oLnsxLDc4fSkoLHwkKSA/L2csICckMSQyXFxuICAgICAgJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25kOiBmdW5jdGlvbiBjb25kKHN0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcgICcgKyBzdHIgKyAnOycpLnJlcGxhY2UoLyguezEsNzh9KSAoXFx8XFx8IHwkKSA/L2dtLCAnJDFcXG4gICAgICAgICAgJDInKTtcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgY29uZCA9IFtvcmRpbmFscyAmJiBbJ29yZGluYWwnLCAhY2FyZGluYWxzXSwgY2FyZGluYWxzICYmIFsnY2FyZGluYWwnLCB0cnVlXV0ubWFwKGNvbXBpbGUpLm1hcChmb2xkLmNvbmQpLFxuICAgICAgICAgICAgICAgIGJvZHkgPSBbZm9sZC52YXJzKHRoaXMucGFyc2VyLnZhcnMoKSldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY29uZCkpLmpvaW4oJ1xcbicpLnJlcGxhY2UoL1xccyskL2dtLCAnJykucmVwbGFjZSgvXltcXHM7XSpbXFxyXFxuXSsvZ20sICcnKSxcbiAgICAgICAgICAgICAgICBhcmdzID0gb3JkaW5hbHMgJiYgY2FyZGluYWxzID8gJ24sIG9yZCcgOiAnbic7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGFyZ3MsIGJvZHkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmblRvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZuVG9TdHJpbmcobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuZm4pLnJlcGxhY2UoL15mdW5jdGlvbiggXFx3Kyk/LywgbmFtZSA/ICdmdW5jdGlvbiAnICsgbmFtZSA6ICdmdW5jdGlvbicpLnJlcGxhY2UoJ1xcbi8qKi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnbG9hZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNsZHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNsZHIgJiYgY2xkci5zdXBwbGVtZW50YWwgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignRGF0YSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgQ0xEUiBkYXRhJyk7XG4gICAgICAgICAgICAgICAgTWFrZVBsdXJhbC5ydWxlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FyZGluYWw6IGRhdGFbJ3BsdXJhbHMtdHlwZS1jYXJkaW5hbCddIHx8IE1ha2VQbHVyYWwucnVsZXMuY2FyZGluYWwsXG4gICAgICAgICAgICAgICAgICAgIG9yZGluYWw6IGRhdGFbJ3BsdXJhbHMtdHlwZS1vcmRpbmFsJ10gfHwgTWFrZVBsdXJhbC5ydWxlcy5vcmRpbmFsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE1ha2VQbHVyYWw7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTWFrZVBsdXJhbDtcbn0pKCk7XG5cblxuXG5NYWtlUGx1cmFsLmNhcmRpbmFscyA9IHRydWU7XG5NYWtlUGx1cmFsLm9yZGluYWxzID0gZmFsc2U7XG5NYWtlUGx1cmFsLnJ1bGVzID0geyBjYXJkaW5hbDoge30sIG9yZGluYWw6IHt9IH07XG5cblxucmV0dXJuIE1ha2VQbHVyYWw7XG59KCkpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIixcblx0XHRcIk51bWJlclwiXG5cdCk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGx1cmFsVHlwZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gXCJjYXJkaW5hbFwiIHx8IHZhbHVlID09PSBcIm9yZGluYWxcIixcblx0XHRcIlN0cmluZyBcXFwiY2FyZGluYWxcXFwiIG9yIFxcXCJvcmRpbmFsXFxcIlwiXG5cdCk7XG59O1xuXG5cblxuXG52YXIgcGx1cmFsR2VuZXJhdG9yRm4gPSBmdW5jdGlvbiggcGx1cmFsICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gcGx1cmFsR2VuZXJhdG9yKCB2YWx1ZSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHRyZXR1cm4gcGx1cmFsKCB2YWx1ZSApO1xuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiAucGx1cmFsKCB2YWx1ZSApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdXG4gKlxuICogUmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIGZvcm0gKHplcm8gfCBvbmUgfCB0d28gfCBmZXcgfCBtYW55IHwgb3RoZXIpIG9mIGFcbiAqIHZhbHVlIGdpdmVuIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLnBsdXJhbCA9XG5HbG9iYWxpemUucHJvdG90eXBlLnBsdXJhbCA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0cmV0dXJuIHRoaXMucGx1cmFsR2VuZXJhdG9yKCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIC5wbHVyYWxHZW5lcmF0b3IoIFtvcHRpb25zXSApXG4gKlxuICogUmV0dXJuIGEgcGx1cmFsIGZ1bmN0aW9uIChvZiB0aGUgZm9ybSBiZWxvdykuXG4gKlxuICogZm4oIHZhbHVlIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl1cbiAqXG4gKiBSZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgZm9ybSAoemVybyB8IG9uZSB8IHR3byB8IGZldyB8IG1hbnkgfCBvdGhlcikgb2YgYSB2YWx1ZSBnaXZlbiB0aGVcbiAqIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUucGx1cmFsR2VuZXJhdG9yID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUucGx1cmFsR2VuZXJhdG9yID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBpc09yZGluYWwsIHBsdXJhbCwgcmV0dXJuRm4sIHR5cGU7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cblx0YXJncyA9IFsgb3B0aW9ucyBdO1xuXHR0eXBlID0gb3B0aW9ucy50eXBlIHx8IFwiY2FyZGluYWxcIjtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbHVyYWxUeXBlKCBvcHRpb25zLnR5cGUsIFwib3B0aW9ucy50eXBlXCIgKTtcblxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHRpc09yZGluYWwgPSB0eXBlID09PSBcIm9yZGluYWxcIjtcblxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblx0Y2xkci5zdXBwbGVtZW50YWwoWyBcInBsdXJhbHMtdHlwZS1cIiArIHR5cGUsIFwie2xhbmd1YWdlfVwiIF0pO1xuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cblx0TWFrZVBsdXJhbC5ydWxlcyA9IHt9O1xuXHRNYWtlUGx1cmFsLnJ1bGVzWyB0eXBlIF0gPSBjbGRyLnN1cHBsZW1lbnRhbCggXCJwbHVyYWxzLXR5cGUtXCIgKyB0eXBlICk7XG5cblx0cGx1cmFsID0gbmV3IE1ha2VQbHVyYWwoIGNsZHIuYXR0cmlidXRlcy5sYW5ndWFnZSwge1xuXHRcdFwib3JkaW5hbHNcIjogaXNPcmRpbmFsLFxuXHRcdFwiY2FyZGluYWxzXCI6ICFpc09yZGluYWxcblx0fSk7XG5cblx0cmV0dXJuRm4gPSBwbHVyYWxHZW5lcmF0b3JGbiggcGx1cmFsICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIHBsdXJhbCBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvcGx1cmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvcGx1cmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCAyMDEwLCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiLi9udW1iZXJcIixcblx0XHRcdFwiLi9wbHVyYWxcIixcblx0XHRcdFwiY2xkci9ldmVudFwiLFxuXHRcdFx0XCJjbGRyL3N1cHBsZW1lbnRhbFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gRXh0ZW5kIGdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgZm9ybWF0TWVzc2FnZSA9IEdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSxcblx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlcjtcblxuXG4vKipcbiAqIGZvcm1hdCggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl0gVGhlIG51bWJlciB0byBmb3JtYXRcbiAqXG4gKiBAbnVtYmVyRm9ybWF0dGVyIFtTdHJpbmddIEEgbnVtYmVyRm9ybWF0dGVyIGZyb20gR2xvYmFsaXplLm51bWJlckZvcm1hdHRlclxuICpcbiAqIEBwbHVyYWxHZW5lcmF0b3IgW1N0cmluZ10gQSBwbHVyYWxHZW5lcmF0b3IgZnJvbSBHbG9iYWxpemUucGx1cmFsR2VuZXJhdG9yXG4gKlxuICogQHByb3BlcnRpZXMgW09iamVjdF0gY29udGFpbmluZyByZWxhdGl2ZSB0aW1lIHBsdXJhbCBtZXNzYWdlLlxuICpcbiAqIEZvcm1hdCByZWxhdGl2ZSB0aW1lLlxuICovXG52YXIgcmVsYXRpdmVUaW1lRm9ybWF0ID0gZnVuY3Rpb24oIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApIHtcblxuXHR2YXIgcmVsYXRpdmVUaW1lLFxuXHRcdG1lc3NhZ2UgPSBwcm9wZXJ0aWVzWyBcInJlbGF0aXZlLXR5cGUtXCIgKyB2YWx1ZSBdO1xuXG5cdGlmICggbWVzc2FnZSApIHtcblx0XHRyZXR1cm4gbWVzc2FnZTtcblx0fVxuXG5cdHJlbGF0aXZlVGltZSA9IHZhbHVlIDw9IDAgPyBwcm9wZXJ0aWVzWyBcInJlbGF0aXZlVGltZS10eXBlLXBhc3RcIiBdXG5cdFx0OiBwcm9wZXJ0aWVzWyBcInJlbGF0aXZlVGltZS10eXBlLWZ1dHVyZVwiIF07XG5cblx0dmFsdWUgPSBNYXRoLmFicyggdmFsdWUgKTtcblxuXHRtZXNzYWdlID0gcmVsYXRpdmVUaW1lWyBcInJlbGF0aXZlVGltZVBhdHRlcm4tY291bnQtXCIgKyBwbHVyYWxHZW5lcmF0b3IoIHZhbHVlICkgXTtcblx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIFsgbnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApIF0gKTtcbn07XG5cblxuXG5cbnZhciByZWxhdGl2ZVRpbWVGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIHJlbGF0aXZlVGltZUZvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0cmV0dXJuIHJlbGF0aXZlVGltZUZvcm1hdCggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICk7XG5cdH07XG5cbn07XG5cblxuXG5cbi8qKlxuICogcHJvcGVydGllcyggdW5pdCwgY2xkciwgb3B0aW9ucyApXG4gKlxuICogQHVuaXQgW1N0cmluZ10gZWcuIFwiZGF5XCIsIFwid2Vla1wiLCBcIm1vbnRoXCIsIGV0Yy5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF1cbiAqIC0gZm9ybTogW1N0cmluZ10gZWcuIFwic2hvcnRcIiBvciBcIm5hcnJvd1wiLiBPciBmYWxzeSBmb3IgZGVmYXVsdCBsb25nIGZvcm0uXG4gKlxuICogUmV0dXJuIHJlbGF0aXZlIHRpbWUgcHJvcGVydGllcy5cbiAqL1xudmFyIHJlbGF0aXZlVGltZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggdW5pdCwgY2xkciwgb3B0aW9ucyApIHtcblxuXHR2YXIgZm9ybSA9IG9wdGlvbnMuZm9ybSxcblx0XHRyYXcsIHByb3BlcnRpZXMsIGtleSwgbWF0Y2g7XG5cblx0aWYgKCBmb3JtICkge1xuXHRcdHVuaXQgPSB1bml0ICsgXCItXCIgKyBmb3JtO1xuXHR9XG5cblx0cmF3ID0gY2xkci5tYWluKCBbIFwiZGF0ZXNcIiwgXCJmaWVsZHNcIiwgdW5pdCBdICk7XG5cdHByb3BlcnRpZXMgPSB7XG5cdFx0XCJyZWxhdGl2ZVRpbWUtdHlwZS1mdXR1cmVcIjogcmF3WyBcInJlbGF0aXZlVGltZS10eXBlLWZ1dHVyZVwiIF0sXG5cdFx0XCJyZWxhdGl2ZVRpbWUtdHlwZS1wYXN0XCI6IHJhd1sgXCJyZWxhdGl2ZVRpbWUtdHlwZS1wYXN0XCIgXVxuXHR9O1xuXHRmb3IgKCBrZXkgaW4gcmF3ICkge1xuXHRcdGlmICggcmF3Lmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdG1hdGNoID0gL3JlbGF0aXZlLXR5cGUtKC0/WzAtOV0rKS8uZXhlYygga2V5ICk7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRwcm9wZXJ0aWVzWyBrZXkgXSA9IHJhd1sga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG5cblxuXG4vKipcbiAqIC5mb3JtYXRSZWxhdGl2ZVRpbWUoIHZhbHVlLCB1bml0IFssIG9wdGlvbnNdIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl0gVGhlIG51bWJlciBvZiB1bml0IHRvIGZvcm1hdC5cbiAqXG4gKiBAdW5pdCBbU3RyaW5nXSBzZWUgLnJlbGF0aXZlVGltZUZvcm1hdHRlcigpIGZvciBkZXRhaWxzLlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSAucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCkgZm9yIGRldGFpbHMuXG4gKlxuICogRm9ybWF0cyBhIHJlbGF0aXZlIHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB1bml0LCBvcHRpb25zLCBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZm9ybWF0UmVsYXRpdmVUaW1lID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0UmVsYXRpdmVUaW1lID0gZnVuY3Rpb24oIHZhbHVlLCB1bml0LCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLnJlbGF0aXZlVGltZUZvcm1hdHRlciggdW5pdCwgb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiAucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCB1bml0IFssIG9wdGlvbnMgXSlcbiAqXG4gKiBAdW5pdCBbU3RyaW5nXSBTdHJpbmcgdmFsdWUgaW5kaWNhdGluZyB0aGUgdW5pdCB0byBiZSBmb3JtYXR0ZWQuIGVnLiBcImRheVwiLCBcIndlZWtcIiwgXCJtb250aFwiLCBldGMuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF1cbiAqIC0gZm9ybTogW1N0cmluZ10gZWcuIFwic2hvcnRcIiBvciBcIm5hcnJvd1wiLiBPciBmYWxzeSBmb3IgZGVmYXVsdCBsb25nIGZvcm0uXG4gKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIHJlbGF0aXZlIHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB1bml0LCBvcHRpb25zLCBhbmQgdGhlXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLnJlbGF0aXZlVGltZUZvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLnJlbGF0aXZlVGltZUZvcm1hdHRlciA9IGZ1bmN0aW9uKCB1bml0LCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMsIHJldHVybkZuO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHVuaXQsIFwidW5pdFwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdW5pdCwgXCJ1bml0XCIgKTtcblxuXHRjbGRyID0gdGhpcy5jbGRyO1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRhcmdzID0gWyB1bml0LCBvcHRpb25zIF07XG5cblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cdHByb3BlcnRpZXMgPSByZWxhdGl2ZVRpbWVQcm9wZXJ0aWVzKCB1bml0LCBjbGRyLCBvcHRpb25zICk7XG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblxuXHRudW1iZXJGb3JtYXR0ZXIgPSB0aGlzLm51bWJlckZvcm1hdHRlciggb3B0aW9ucyApO1xuXHRwbHVyYWxHZW5lcmF0b3IgPSB0aGlzLnBsdXJhbEdlbmVyYXRvcigpO1xuXG5cdHJldHVybkZuID0gcmVsYXRpdmVUaW1lRm9ybWF0dGVyRm4oIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9yZWxhdGl2ZS10aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvcmVsYXRpdmUtdGltZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcIi4vbnVtYmVyXCIsXG5cdFx0XHRcIi4vcGx1cmFsXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBFeHRlbmQgZ2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBmb3JtYXRNZXNzYWdlID0gR2xvYmFsaXplLl9mb3JtYXRNZXNzYWdlLFxuXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nO1xuXG5cbi8qKlxuICogZm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHVuaXRQcm9wZXJpZXMgKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXVxuICpcbiAqIEBudW1iZXJGb3JtYXR0ZXIgW09iamVjdF06IEEgbnVtYmVyRm9ybWF0dGVyIGZyb20gR2xvYmFsaXplLm51bWJlckZvcm1hdHRlci5cbiAqXG4gKiBAcGx1cmFsR2VuZXJhdG9yIFtPYmplY3RdOiBBIHBsdXJhbEdlbmVyYXRvciBmcm9tIEdsb2JhbGl6ZS5wbHVyYWxHZW5lcmF0b3IuXG4gKlxuICogQHVuaXRQcm9wZXJpZXMgW09iamVjdF06IGxvY2FsaXplZCB1bml0IGRhdGEgZnJvbSBjbGRyLlxuICpcbiAqIEZvcm1hdCB1bml0cyBzdWNoIGFzIHNlY29uZHMsIG1pbnV0ZXMsIGRheXMsIHdlZWtzLCBldGMuXG4gKlxuICogT0JTOlxuICpcbiAqIFVuaXQgU2VxdWVuY2VzIGFyZSBub3QgaW1wbGVtZW50ZWQuXG4gKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTM1L3RyMzUtZ2VuZXJhbC5odG1sI1VuaXRfU2VxdWVuY2VzXG4gKlxuICogRHVyYXRpb24gVW5pdCAoZm9yIGNvbXBvc2VkIHRpbWUgdW5pdCBkdXJhdGlvbnMpIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzUvdHIzNS1nZW5lcmFsLmh0bWwjZHVyYXRpb25Vbml0XG4gKi9cbnZhciB1bml0Rm9ybWF0ID0gZnVuY3Rpb24oIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgdW5pdFByb3BlcnRpZXMgKSB7XG5cdHZhciBjb21wb3VuZFVuaXRQYXR0ZXJuID0gdW5pdFByb3BlcnRpZXMuY29tcG91bmRVbml0UGF0dGVybiwgZGl2aWRlbmQsIGRpdmlkZW5kUHJvcGVydGllcyxcblx0XHRmb3JtYXR0ZWRWYWx1ZSwgZGl2aXNvciwgZGl2aXNvclByb3BlcnRpZXMsIG1lc3NhZ2UsIHBsdXJhbFZhbHVlO1xuXG5cdHVuaXRQcm9wZXJ0aWVzID0gdW5pdFByb3BlcnRpZXMudW5pdFByb3BlcnRpZXM7XG5cdGZvcm1hdHRlZFZhbHVlID0gbnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApO1xuXHRwbHVyYWxWYWx1ZSA9IHBsdXJhbEdlbmVyYXRvciggdmFsdWUgKTtcblxuXHQvLyBjb21wdXRlZCBjb21wb3VuZCB1bml0LCBlZy4gXCJtZWdhYnl0ZS1wZXItc2Vjb25kXCIuXG5cdGlmICggdW5pdFByb3BlcnRpZXMgaW5zdGFuY2VvZiBBcnJheSApIHtcblx0XHRkaXZpZGVuZFByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllc1sgMCBdO1xuXHRcdGRpdmlzb3JQcm9wZXJ0aWVzID0gdW5pdFByb3BlcnRpZXNbIDEgXTtcblxuXHRcdGRpdmlkZW5kID0gZm9ybWF0TWVzc2FnZSggZGl2aWRlbmRQcm9wZXJ0aWVzWyBwbHVyYWxWYWx1ZSBdLCBbIHZhbHVlIF0gKTtcblx0XHRkaXZpc29yID0gZm9ybWF0TWVzc2FnZSggZGl2aXNvclByb3BlcnRpZXMub25lLCBbIFwiXCIgXSApLnRyaW0oKTtcblxuXHRcdHJldHVybiBmb3JtYXRNZXNzYWdlKCBjb21wb3VuZFVuaXRQYXR0ZXJuLCBbIGRpdmlkZW5kLCBkaXZpc29yIF0gKTtcblx0fVxuXG5cdG1lc3NhZ2UgPSB1bml0UHJvcGVydGllc1sgcGx1cmFsVmFsdWUgXTtcblxuXHRyZXR1cm4gZm9ybWF0TWVzc2FnZSggbWVzc2FnZSwgWyBmb3JtYXR0ZWRWYWx1ZSBdICk7XG59O1xuXG5cblxuXG52YXIgdW5pdEZvcm1hdHRlckZuID0gZnVuY3Rpb24oIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCB1bml0UHJvcGVydGllcyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIHVuaXRGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHJldHVybiB1bml0Rm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHVuaXRQcm9wZXJ0aWVzICk7XG5cdH07XG5cbn07XG5cblxuXG5cbi8qKlxuICogY2F0ZWdvcmllcygpXG4gKlxuICogUmV0dXJuIGFsbCB1bml0IGNhdGVnb3JpZXMuXG4gKi9cbnZhciB1bml0Q2F0ZWdvcmllcyA9IFsgXCJhY2NlbGVyYXRpb25cIiwgXCJhbmdsZVwiLCBcImFyZWFcIiwgXCJkaWdpdGFsXCIsIFwiZHVyYXRpb25cIiwgXCJsZW5ndGhcIiwgXCJtYXNzXCIsIFwicG93ZXJcIixcblwicHJlc3N1cmVcIiwgXCJzcGVlZFwiLCBcInRlbXBlcmF0dXJlXCIsIFwidm9sdW1lXCIgXTtcblxuXG5cblxuZnVuY3Rpb24gc3RyaXBQbHVyYWxHYXJiYWdlKCBkYXRhICkge1xuXHR2YXIgYXV4LCBwbHVyYWxDb3VudDtcblxuXHRpZiAoIGRhdGEgKSB7XG5cdFx0YXV4ID0ge307XG5cdFx0Zm9yICggcGx1cmFsQ291bnQgaW4gZGF0YSApIHtcblx0XHRcdGF1eFsgcGx1cmFsQ291bnQucmVwbGFjZSggL3VuaXRQYXR0ZXJuLWNvdW50LS8sIFwiXCIgKSBdID0gZGF0YVsgcGx1cmFsQ291bnQgXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYXV4O1xufVxuXG4vKipcbiAqIGdldCggdW5pdCwgZm9ybSwgY2xkciApXG4gKlxuICogQHVuaXQgW1N0cmluZ10gVGhlIGZ1bGwgdHlwZS11bml0IG5hbWUgKGVnLiBkdXJhdGlvbi1zZWNvbmQpLCBvciB0aGUgc2hvcnQgdW5pdCBuYW1lXG4gKiAoZWcuIHNlY29uZCkuXG4gKlxuICogQGZvcm0gW1N0cmluZ10gQSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZm9ybSBvZiB0aGUgdW5pdCByZXByZXNlbnRhdGlvbiAoZWcuIGxvbmcsXG4gKiBzaG9ydCwgbmFycm93KS5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHRoZSBwbHVyYWwgbWFwIG9mIGEgdW5pdCwgZWc6IFwic2Vjb25kXCJcbiAqIHsgXCJvbmVcIjogXCJ7MH0gc2Vjb25kXCIsXG4gKiAgIFwib3RoZXJcIjogXCJ7MH0gc2Vjb25kc1wiIH1cbiAqIH1cbiAqXG4gKiBPciB0aGUgQXJyYXkgb2YgcGx1cmFsIG1hcHMgb2YgYSBjb21wb3VuZC11bml0LCBlZzogXCJmb290LXBlci1zZWNvbmRcIlxuICogWyB7IFwib25lXCI6IFwiezB9IGZvb3RcIixcbiAqICAgICBcIm90aGVyXCI6IFwiezB9IGZlZXRcIiB9LFxuICogICB7IFwib25lXCI6IFwiezB9IHNlY29uZFwiLFxuICogICAgIFwib3RoZXJcIjogXCJ7MH0gc2Vjb25kc1wiIH0gXVxuICpcbiAqIFVzZXMgdGhlIHByZWNvbXB1dGVkIGZvcm0gb2YgYSBjb21wb3VuZC11bml0IGlmIGF2YWlsYWJsZSwgZWc6IFwibWlsZS1wZXItaG91clwiXG4gKiB7IFwiZGlzcGxheU5hbWVcIjogXCJtaWxlcyBwZXIgaG91clwiLFxuICogICAgXCJ1bml0UGF0dGVybi1jb3VudC1vbmVcIjogXCJ7MH0gbWlsZSBwZXIgaG91clwiLFxuICogICAgXCJ1bml0UGF0dGVybi1jb3VudC1vdGhlclwiOiBcInswfSBtaWxlcyBwZXIgaG91clwiXG4gKiB9LFxuICpcbiAqIEFsc28gc3VwcG9ydHMgXCIvXCIgaW5zdGVhZCBvZiBcIi1wZXItXCIsIGVnLiBcImZvb3Qvc2Vjb25kXCIsIHVzaW5nIHRoZSBwcmVjb21wdXRlZCBmb3JtIGlmXG4gKiBhdmFpbGFibGUuXG4gKlxuICogT3IgdGhlIEFycmF5IG9mIHBsdXJhbCBtYXBzIG9mIGEgY29tcG91bmQtdW5pdCwgZWc6IFwiZm9vdC1wZXItc2Vjb25kXCJcbiAqIFsgeyBcIm9uZVwiOiBcInswfSBmb290XCIsXG4gKiAgICAgXCJvdGhlclwiOiBcInswfSBmZWV0XCIgfSxcbiAqICAgeyBcIm9uZVwiOiBcInswfSBzZWNvbmRcIixcbiAqICAgICBcIm90aGVyXCI6IFwiezB9IHNlY29uZHNcIiB9IF1cbiAqXG4gKiBPciB1bmRlZmluZWQgaW4gY2FzZSB0aGUgdW5pdCAob3IgYSB1bml0IG9mIHRoZSBjb21wb3VuZC11bml0KSBkb2Vzbid0IGV4aXN0LlxuICovXG52YXIgZ2V0ID0gZnVuY3Rpb24oIHVuaXQsIGZvcm0sIGNsZHIgKSB7XG5cdHZhciByZXQ7XG5cblx0Ly8gRW5zdXJlIHRoYXQgd2UgZ2V0IHRoZSAncHJlY29tcHV0ZWQnIGZvcm0sIGlmIHByZXNlbnQuXG5cdHVuaXQgPSB1bml0LnJlcGxhY2UoIC9cXC8vLCBcIi1wZXItXCIgKTtcblxuXHQvLyBHZXQgdW5pdCBvciA8Y2F0ZWdvcnk+LXVuaXQgKGVnLiBcImR1cmF0aW9uLXNlY29uZFwiKS5cblx0WyBcIlwiIF0uY29uY2F0KCB1bml0Q2F0ZWdvcmllcyApLnNvbWUoZnVuY3Rpb24oIGNhdGVnb3J5ICkge1xuXHRcdHJldHVybiByZXQgPSBjbGRyLm1haW4oW1xuXHRcdFx0XCJ1bml0c1wiLFxuXHRcdFx0Zm9ybSxcblx0XHRcdGNhdGVnb3J5Lmxlbmd0aCA/IGNhdGVnb3J5ICsgXCItXCIgKyB1bml0IDogdW5pdFxuXHRcdF0pO1xuXHR9KTtcblxuXHQvLyBSZW5hbWUga2V5cyBzL3VuaXRQYXR0ZXJuLWNvdW50LS8vZy5cblx0cmV0ID0gc3RyaXBQbHVyYWxHYXJiYWdlKCByZXQgKTtcblxuXHQvLyBDb21wb3VuZCBVbml0LCBlZy4gXCJmb290LXBlci1zZWNvbmRcIiBvciBcImZvb3Qvc2Vjb25kXCIuXG5cdGlmICggIXJldCAmJiAoIC8tcGVyLS8gKS50ZXN0KCB1bml0ICkgKSB7XG5cblx0XHQvLyBcIlNvbWUgdW5pdHMgYWxyZWFkeSBoYXZlICdwcmVjb21wdXRlZCcgZm9ybXMsIHN1Y2ggYXMga2lsb21ldGVyLXBlci1ob3VyO1xuXHRcdC8vIHdoZXJlIHN1Y2ggdW5pdHMgZXhpc3QsIHRoZXkgc2hvdWxkIGJlIHVzZWQgaW4gcHJlZmVyZW5jZVwiIFVUUyMzNS5cblx0XHQvLyBOb3RlIHRoYXQgcHJlY29tcHV0ZWQgZm9ybSBoYXMgYWxyZWFkeSBiZWVuIGhhbmRsZWQgYWJvdmUgKCFyZXQpLlxuXG5cdFx0Ly8gR2V0IGJvdGggcmVjdXJzaXZlbHkuXG5cdFx0dW5pdCA9IHVuaXQuc3BsaXQoIFwiLXBlci1cIiApO1xuXHRcdHJldCA9IHVuaXQubWFwKGZ1bmN0aW9uKCB1bml0ICkge1xuXHRcdFx0cmV0dXJuIGdldCggdW5pdCwgZm9ybSwgY2xkciApO1xuXHRcdH0pO1xuXHRcdGlmICggIXJldFsgMCBdIHx8ICFyZXRbIDEgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxudmFyIHVuaXRHZXQgPSBnZXQ7XG5cblxuXG5cbi8qKlxuICogcHJvcGVydGllcyggdW5pdCwgZm9ybSwgY2xkciApXG4gKlxuICogQHVuaXQgW1N0cmluZ10gVGhlIGZ1bGwgdHlwZS11bml0IG5hbWUgKGVnLiBkdXJhdGlvbi1zZWNvbmQpLCBvciB0aGUgc2hvcnQgdW5pdCBuYW1lXG4gKiAoZWcuIHNlY29uZCkuXG4gKlxuICogQGZvcm0gW1N0cmluZ10gQSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZm9ybSBvZiB0aGUgdW5pdCByZXByZXNlbnRhdGlvbiAoZWcuIGxvbmcsXG4gKiBzaG9ydCwgbmFycm93KS5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKi9cbnZhciB1bml0UHJvcGVydGllcyA9IGZ1bmN0aW9uKCB1bml0LCBmb3JtLCBjbGRyICkge1xuXHR2YXIgY29tcG91bmRVbml0UGF0dGVybiwgdW5pdFByb3BlcnRpZXM7XG5cblx0Y29tcG91bmRVbml0UGF0dGVybiA9IGNsZHIubWFpbiggWyBcInVuaXRzXCIsIGZvcm0sIFwicGVyL2NvbXBvdW5kVW5pdFBhdHRlcm5cIiBdICk7XG5cdHVuaXRQcm9wZXJ0aWVzID0gdW5pdEdldCggdW5pdCwgZm9ybSwgY2xkciApO1xuXG5cdHJldHVybiB7XG5cdFx0Y29tcG91bmRVbml0UGF0dGVybjogY29tcG91bmRVbml0UGF0dGVybixcblx0XHR1bml0UHJvcGVydGllczogdW5pdFByb3BlcnRpZXNcblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogR2xvYmFsaXplLmZvcm1hdFVuaXQoIHZhbHVlLCB1bml0LCBvcHRpb25zIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl1cbiAqXG4gKiBAdW5pdCBbU3RyaW5nXTogVGhlIHVuaXQgKGUuZyBcInNlY29uZFwiLCBcImRheVwiLCBcInllYXJcIilcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XVxuICogLSBmb3JtOiBbU3RyaW5nXSBcImxvbmdcIiwgXCJzaG9ydFwiIChkZWZhdWx0KSwgb3IgXCJuYXJyb3dcIi5cbiAqXG4gKiBGb3JtYXQgdW5pdHMgc3VjaCBhcyBzZWNvbmRzLCBtaW51dGVzLCBkYXlzLCB3ZWVrcywgZXRjLlxuICovXG5HbG9iYWxpemUuZm9ybWF0VW5pdCA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdFVuaXQgPSBmdW5jdGlvbiggdmFsdWUsIHVuaXQsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMudW5pdEZvcm1hdHRlciggdW5pdCwgb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiBHbG9iYWxpemUudW5pdEZvcm1hdHRlciggdW5pdCwgb3B0aW9ucyApXG4gKlxuICogQHVuaXQgW1N0cmluZ106IFRoZSB1bml0IChlLmcgXCJzZWNvbmRcIiwgXCJkYXlcIiwgXCJ5ZWFyXCIpXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF1cbiAqIC0gZm9ybTogW1N0cmluZ10gXCJsb25nXCIsIFwic2hvcnRcIiAoZGVmYXVsdCksIG9yIFwibmFycm93XCIuXG4gKlxuICogLSBudW1iZXJGb3JtYXR0ZXI6IFtGdW5jdGlvbl0gYSBudW1iZXIgZm9ybWF0dGVyIGZ1bmN0aW9uLiBEZWZhdWx0cyB0byBHbG9iYWxpemVcbiAqICAgYC5udW1iZXJGb3JtYXR0ZXIoKWAgZm9yIHRoZSBjdXJyZW50IGxvY2FsZSB1c2luZyB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICovXG5HbG9iYWxpemUudW5pdEZvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLnVuaXRGb3JtYXR0ZXIgPSBmdW5jdGlvbiggdW5pdCwgb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGZvcm0sIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCByZXR1cm5GbiwgcHJvcGVydGllcztcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB1bml0LCBcInVuaXRcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHVuaXQsIFwidW5pdFwiICk7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0YXJncyA9IFsgdW5pdCwgb3B0aW9ucyBdO1xuXHRmb3JtID0gb3B0aW9ucy5mb3JtIHx8IFwibG9uZ1wiO1xuXHRwcm9wZXJ0aWVzID0gdW5pdFByb3BlcnRpZXMoIHVuaXQsIGZvcm0sIHRoaXMuY2xkciApO1xuXG5cdG51bWJlckZvcm1hdHRlciA9IG9wdGlvbnMubnVtYmVyRm9ybWF0dGVyIHx8IHRoaXMubnVtYmVyRm9ybWF0dGVyKCk7XG5cdHBsdXJhbEdlbmVyYXRvciA9IHRoaXMucGx1cmFsR2VuZXJhdG9yKCk7XG5cdHJldHVybkZuID0gdW5pdEZvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCB0aGlzLmNsZHIsIHJldHVybkZuLCBbIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS91bml0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvdW5pdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuXG4vLyBDb3JlXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoIFwiLi9nbG9iYWxpemVcIiApO1xuXG4vLyBFeHRlbnQgY29yZSB3aXRoIHRoZSBmb2xsb3dpbmcgbW9kdWxlc1xucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS9tZXNzYWdlXCIgKTtcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvbnVtYmVyXCIgKTtcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvcGx1cmFsXCIgKTtcblxuLy8gTG9hZCBhZnRlciBnbG9iYWxpemUvbnVtYmVyXG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL2N1cnJlbmN5XCIgKTtcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvZGF0ZVwiICk7XG5cbi8vIExvYWQgYWZ0ZXIgZ2xvYmFsaXplL251bWJlciBhbmQgZ2xvYmFsaXplL3BsdXJhbFxucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS9yZWxhdGl2ZS10aW1lXCIgKTtcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvdW5pdFwiICk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L25vZGUtbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3Qvbm9kZS1tYWluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1laWRhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChvW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9OyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2goZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxuXHRcdGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJpbXBvcnQgKiBhcyBjc3MgZnJvbSAnLi9hcHAubS5jc3MnO1xuXG5jb25zdCBBcHAgPSBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc3QgRm9vID0gYXdhaXQgaW1wb3J0KCcuL0ZvbycpO1xuXHRyZXR1cm4gRm9vLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBCYXIgPSBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc3QgQmFyID0gYXdhaXQgaW1wb3J0KCcuL0JhcicpO1xuXHRyZXR1cm4gQmFyLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBCYXogPSBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc3QgQmF6ID0gYXdhaXQgaW1wb3J0KCcuL0JheicpO1xuXHRyZXR1cm4gQmF6LmRlZmF1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coY3NzKTtcblx0Y29uc3QgYmFyID0gYXdhaXQgQmFyKCk7XG5cdGNvbnN0IGJheiA9IGF3YWl0IEJheigpO1xuXHRiYXIoKTtcblx0YmF6KCk7XG5cdHJldHVybiBBcHAoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvY3NzLW1vZHVsZS1kdHMtbG9hZGVyP3R5cGU9dHMmaW5zdGFuY2VOYW1lPTBfZG9qbyEuL3NyYy9BcHAudHMiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCIgX2tleVwiOlwiYXBwXCIsXCJyb290XCI6XCJhcHAtbV9fcm9vdF9fWXh0dFAgdGhlbWUtbV9fcm9vdF9fM3gxU0dcIn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwLm0uY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3NyYy9hcHAubS5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluLmNzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvbWFpbi5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5pbXBvcnQgKiBhcyBjc3MgZnJvbSAnLi9hcHAubS5jc3MnO1xuaW1wb3J0IGhhcyBmcm9tICdAZG9qby9oYXMvaGFzJztcbichaGFzKFwiYmFyXCIpJztcbmltcG9ydCAnLi9CYXInO1xuXG5pZiAoaGFzKCdmb28nKSkge1xuXHRjb25zb2xlLmxvZygnZm9vJyk7XG59XG5cbkFwcCgpLnRoZW4ocmVzdWx0ID0+IHtcblx0Y29uc29sZS5sb2cocmVzdWx0KCkpO1xuXHRjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZGl2LmlubmVySFRNTCA9ICdoZWxsbywgd29ybGQnO1xuXHRkaXYuY2xhc3NMaXN0LmFkZCguLi5jc3Mucm9vdC5zcGxpdCgnICcpKTtcblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2Nzcy1tb2R1bGUtZHRzLWxvYWRlcj90eXBlPXRzJmluc3RhbmNlTmFtZT0wX2Rvam8hLi9zcmMvbWFpbi50cyJdLCJzb3VyY2VSb290IjoiIn0=