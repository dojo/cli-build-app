/*!
 * 
 * [Dojo](https://dojo.io/)
 * Copyright [JS Foundation](https://js.foundation/) & contributors
 * [New BSD license](https://github.com/dojo/meta/blob/master/LICENSE)
 * All rights reserved
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("main", [], factory);
	else if(typeof exports === 'object')
		exports["main"] = factory();
	else
		root["main"] = factory();
})(this, function() {
return dojoWebpackJsonptest_app(["main"],{

/***/ "./node_modules/@dojo/core/Destroyable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Promise_1 = __webpack_require__("./node_modules/@dojo/shim/Promise.js");
/**
 * No operation function to replace own once instance is destoryed
 */
function noop() {
    return Promise_1.default.resolve(false);
}
/**
 * No op function used to replace own, once instance has been destoryed
 */
function destroyed() {
    throw new Error('Call made to destroyed method');
}
var Destroyable = (function () {
    /**
     * @constructor
     */
    function Destroyable() {
        this.handles = [];
    }
    /**
     * Register handles for the instance that will be destroyed when `this.destroy` is called
     *
     * @param {Handle} handle The handle to add for the instance
     * @returns {Handle} a handle for the handle, removes the handle for the instance and calls destroy
     */
    Destroyable.prototype.own = function (handle) {
        var handles = this.handles;
        handles.push(handle);
        return {
            destroy: function () {
                handles.splice(handles.indexOf(handle));
                handle.destroy();
            }
        };
    };
    /**
     * Destrpys all handers registered for the instance
     *
     * @returns {Promise<any} a promise that resolves once all handles have been destroyed
     */
    Destroyable.prototype.destroy = function () {
        var _this = this;
        return new Promise_1.default(function (resolve) {
            _this.handles.forEach(function (handle) {
                handle && handle.destroy && handle.destroy();
            });
            _this.destroy = noop;
            _this.own = destroyed;
            resolve(true);
        });
    };
    return Destroyable;
}());
exports.Destroyable = Destroyable;
exports.default = Destroyable;


/***/ }),

/***/ "./node_modules/@dojo/core/Evented.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var Map_1 = __webpack_require__("./node_modules/@dojo/shim/Map.js");
var aspect_1 = __webpack_require__("./node_modules/@dojo/core/aspect.js");
var Destroyable_1 = __webpack_require__("./node_modules/@dojo/core/Destroyable.js");
/**
 * Determines is the value is Actionable (has a `.do` function)
 *
 * @param value the value to check
 * @returns boolean indicating is the value is Actionable
 */
function isActionable(value) {
    return Boolean(value && typeof value.do === 'function');
}
/**
 * Resolve listeners.
 */
function resolveListener(listener) {
    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;
}
/**
 * Handles an array of handles
 *
 * @param handles an array of handles
 * @returns a single Handle for handles passed
 */
function handlesArraytoHandle(handles) {
    return {
        destroy: function () {
            handles.forEach(function (handle) { return handle.destroy(); });
        }
    };
}
/**
 * Map of computed regular expressions, keyed by string
 */
var regexMap = new Map_1.default();
/**
 * Determines is the event type glob has been matched
 *
 * @returns boolean that indicates if the glob is matched
 */
function isGlobMatch(globString, targetString) {
    if (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {
        var regex = void 0;
        if (regexMap.has(globString)) {
            regex = regexMap.get(globString);
        }
        else {
            regex = new RegExp("^" + globString.replace(/\*/g, '.*') + "$");
            regexMap.set(globString, regex);
        }
        return regex.test(targetString);
    }
    else {
        return globString === targetString;
    }
}
exports.isGlobMatch = isGlobMatch;
/**
 * Event Class
 */
var Evented = (function (_super) {
    tslib_1.__extends(Evented, _super);
    /**
     * @constructor
     * @param options The constructor argurments
     */
    function Evented(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        /**
         * map of listeners keyed by event type
         */
        _this.listenersMap = new Map_1.default();
        /**
         * Catch all handler for various call signatures. The signatures are defined in
         * `BaseEventedEvents`.  You can add your own event type -> handler types by extending
         * `BaseEventedEvents`.  See example for details.
         *
         * @param args
         *
         * @example
         *
         * interface WidgetBaseEvents extends BaseEventedEvents {
         *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;
         * }
         * class WidgetBase extends Evented {
         *    on: WidgetBaseEvents;
         * }
         *
         * @return {any}
         */
        _this.on = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 2) {
                var _a = tslib_1.__read(args, 2), type_1 = _a[0], listeners = _a[1];
                if (Array.isArray(listeners)) {
                    var handles = listeners.map(function (listener) { return aspect_1.on(_this.listenersMap, type_1, resolveListener(listener)); });
                    return handlesArraytoHandle(handles);
                }
                else {
                    return aspect_1.on(this.listenersMap, type_1, resolveListener(listeners));
                }
            }
            else if (args.length === 1) {
                var _b = tslib_1.__read(args, 1), listenerMapArg_1 = _b[0];
                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });
                return handlesArraytoHandle(handles);
            }
            else {
                throw new TypeError('Invalid arguments');
            }
        };
        var listeners = options.listeners;
        if (listeners) {
            _this.own(_this.on(listeners));
        }
        return _this;
    }
    /**
     * Emits the event objet for the specified type
     *
     * @param event the event to emit
     */
    Evented.prototype.emit = function (event) {
        var _this = this;
        this.listenersMap.forEach(function (method, type) {
            if (isGlobMatch(type, event.type)) {
                method.call(_this, event);
            }
        });
    };
    return Evented;
}(Destroyable_1.Destroyable));
exports.Evented = Evented;
exports.default = Evented;


/***/ }),

/***/ "./node_modules/@dojo/core/aspect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var WeakMap_1 = __webpack_require__("./node_modules/@dojo/shim/WeakMap.js");
var lang_1 = __webpack_require__("./node_modules/@dojo/core/lang.js");
/**
 * An internal type guard that determines if an value is MapLike or not
 *
 * @param value The value to guard against
 */
function isMapLike(value) {
    return value && typeof value.get === 'function' && typeof value.set === 'function';
}
/**
 * A weak map of dispatchers used to apply the advice
 */
var dispatchAdviceMap = new WeakMap_1.default();
/**
 * A UID for tracking advice ordering
 */
var nextId = 0;
/**
 * Internal function that advises a join point
 *
 * @param dispatcher The current advice dispatcher
 * @param type The type of before or after advice to apply
 * @param advice The advice to apply
 * @param receiveArguments If true, the advice will receive the arguments passed to the join point
 * @return The handle that will remove the advice
 */
function adviseObject(dispatcher, type, advice, receiveArguments) {
    var previous = dispatcher && dispatcher[type];
    var advised = {
        id: nextId++,
        advice: advice,
        receiveArguments: receiveArguments
    };
    if (previous) {
        if (type === 'after') {
            // add the listener to the end of the list
            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
            while (previous.next && (previous = previous.next)) { }
            previous.next = advised;
            advised.previous = previous;
        }
        else {
            // add to the beginning
            if (dispatcher) {
                dispatcher.before = advised;
            }
            advised.next = previous;
            previous.previous = advised;
        }
    }
    else {
        dispatcher && (dispatcher[type] = advised);
    }
    advice = previous = undefined;
    return lang_1.createHandle(function () {
        var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;
        if (dispatcher && !previous && !next) {
            dispatcher[type] = undefined;
        }
        else {
            if (previous) {
                previous.next = next;
            }
            else {
                dispatcher && (dispatcher[type] = next);
            }
            if (next) {
                next.previous = previous;
            }
        }
        if (advised) {
            delete advised.advice;
        }
        dispatcher = advised = undefined;
    });
}
/**
 * Advise a join point (function) with supplied advice
 *
 * @param joinPoint The function to be advised
 * @param type The type of advice to be applied
 * @param advice The advice to apply
 */
function adviseJoinPoint(joinPoint, type, advice) {
    var dispatcher;
    if (type === 'around') {
        dispatcher = getJoinPointDispatcher(advice.apply(this, [joinPoint]));
    }
    else {
        dispatcher = getJoinPointDispatcher(joinPoint);
        // cannot have undefined in map due to code logic, using !
        var adviceMap = dispatchAdviceMap.get(dispatcher);
        if (type === 'before') {
            (adviceMap.before || (adviceMap.before = [])).unshift(advice);
        }
        else {
            (adviceMap.after || (adviceMap.after = [])).push(advice);
        }
    }
    return dispatcher;
}
/**
 * An internal function that resolves or creates the dispatcher for a given join point
 *
 * @param target The target object or map
 * @param methodName The name of the method that the dispatcher should be resolved for
 * @return The dispatcher
 */
function getDispatcherObject(target, methodName) {
    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];
    var dispatcher;
    if (!existing || existing.target !== target) {
        /* There is no existing dispatcher, therefore we will create one */
        dispatcher = function () {
            var executionId = nextId;
            var args = arguments;
            var results;
            var before = dispatcher.before;
            while (before) {
                if (before.advice) {
                    args = before.advice.apply(this, args) || args;
                }
                before = before.next;
            }
            if (dispatcher.around && dispatcher.around.advice) {
                results = dispatcher.around.advice(this, args);
            }
            var after = dispatcher.after;
            while (after && after.id !== undefined && after.id < executionId) {
                if (after.advice) {
                    if (after.receiveArguments) {
                        var newResults = after.advice.apply(this, args);
                        results = newResults === undefined ? results : newResults;
                    }
                    else {
                        results = after.advice.call(this, results, args);
                    }
                }
                after = after.next;
            }
            return results;
        };
        if (isMapLike(target)) {
            target.set(methodName, dispatcher);
        }
        else {
            target && (target[methodName] = dispatcher);
        }
        if (existing) {
            dispatcher.around = {
                advice: function (target, args) {
                    return existing.apply(target, args);
                }
            };
        }
        dispatcher.target = target;
    }
    else {
        dispatcher = existing;
    }
    return dispatcher;
}
/**
 * Returns the dispatcher function for a given joinPoint (method/function)
 *
 * @param joinPoint The function that is to be advised
 */
function getJoinPointDispatcher(joinPoint) {
    function dispatcher() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // cannot have undefined in map due to code logic, using !
        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;
        if (before) {
            args = before.reduce(function (previousArgs, advice) {
                var currentArgs = advice.apply(_this, previousArgs);
                return currentArgs || previousArgs;
            }, args);
        }
        var result = joinPoint.apply(this, args);
        if (after) {
            result = after.reduce(function (previousResult, advice) {
                return advice.apply(_this, [previousResult].concat(args));
            }, result);
        }
        return result;
    }
    /* We want to "clone" the advice that has been applied already, if this
     * joinPoint is already advised */
    if (dispatchAdviceMap.has(joinPoint)) {
        // cannot have undefined in map due to code logic, using !
        var adviceMap = dispatchAdviceMap.get(joinPoint);
        var before_1 = adviceMap.before, after_1 = adviceMap.after;
        if (before_1) {
            before_1 = before_1.slice(0);
        }
        if (after_1) {
            after_1 = after_1.slice(0);
        }
        dispatchAdviceMap.set(dispatcher, {
            joinPoint: adviceMap.joinPoint,
            before: before_1,
            after: after_1
        });
    }
    else {
        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });
    }
    return dispatcher;
}
/**
 * Apply advice *after* the supplied joinPoint (function)
 *
 * @param joinPoint A function that should have advice applied to
 * @param advice The after advice
 */
function afterJoinPoint(joinPoint, advice) {
    return adviseJoinPoint(joinPoint, 'after', advice);
}
/**
 * Attaches "after" advice to be executed after the original method.
 * The advising function will receive the original method's return value and arguments object.
 * The value it returns will be returned from the method when it is called (even if the return value is undefined).
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the original method's return value and arguments object
 * @return A handle which will remove the aspect when destroy is called
 */
function afterObject(target, methodName, advice) {
    return adviseObject(getDispatcherObject(target, methodName), 'after', advice);
}
function after(joinPointOrTarget, methodNameOrAdvice, objectAdvice) {
    if (typeof joinPointOrTarget === 'function') {
        return afterJoinPoint(joinPointOrTarget, methodNameOrAdvice);
    }
    else {
        return afterObject(joinPointOrTarget, methodNameOrAdvice, objectAdvice);
    }
}
exports.after = after;
/**
 * Apply advice *around* the supplied joinPoint (function)
 *
 * @param joinPoint A function that should have advice applied to
 * @param advice The around advice
 */
function aroundJoinPoint(joinPoint, advice) {
    return adviseJoinPoint(joinPoint, 'around', advice);
}
exports.aroundJoinPoint = aroundJoinPoint;
/**
 * Attaches "around" advice around the original method.
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the original function
 * @return A handle which will remove the aspect when destroy is called
 */
function aroundObject(target, methodName, advice) {
    var dispatcher = getDispatcherObject(target, methodName);
    var previous = dispatcher.around;
    var advised;
    if (advice) {
        advised = advice(function () {
            if (previous && previous.advice) {
                return previous.advice(this, arguments);
            }
        });
    }
    dispatcher.around = {
        advice: function (target, args) {
            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);
        }
    };
    return lang_1.createHandle(function () {
        advised = dispatcher = undefined;
    });
}
exports.aroundObject = aroundObject;
function around(joinPointOrTarget, methodNameOrAdvice, objectAdvice) {
    if (typeof joinPointOrTarget === 'function') {
        return aroundJoinPoint(joinPointOrTarget, methodNameOrAdvice);
    }
    else {
        return aroundObject(joinPointOrTarget, methodNameOrAdvice, objectAdvice);
    }
}
exports.around = around;
/**
 * Apply advice *before* the supplied joinPoint (function)
 *
 * @param joinPoint A function that should have advice applied to
 * @param advice The before advice
 */
function beforeJoinPoint(joinPoint, advice) {
    return adviseJoinPoint(joinPoint, 'before', advice);
}
exports.beforeJoinPoint = beforeJoinPoint;
/**
 * Attaches "before" advice to be executed before the original method.
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the same arguments as the original, and may return new arguments
 * @return A handle which will remove the aspect when destroy is called
 */
function beforeObject(target, methodName, advice) {
    return adviseObject(getDispatcherObject(target, methodName), 'before', advice);
}
exports.beforeObject = beforeObject;
function before(joinPointOrTarget, methodNameOrAdvice, objectAdvice) {
    if (typeof joinPointOrTarget === 'function') {
        return beforeJoinPoint(joinPointOrTarget, methodNameOrAdvice);
    }
    else {
        return beforeObject(joinPointOrTarget, methodNameOrAdvice, objectAdvice);
    }
}
exports.before = before;
/**
 * Attaches advice to be executed after the original method.
 * The advising function will receive the same arguments as the original method.
 * The value it returns will be returned from the method when it is called *unless* its return value is undefined.
 *
 * @param target Object whose method will be aspected
 * @param methodName Name of method to aspect
 * @param advice Advising function which will receive the same arguments as the original method
 * @return A handle which will remove the aspect when destroy is called
 */
function on(target, methodName, advice) {
    return adviseObject(getDispatcherObject(target, methodName), 'after', advice, true);
}
exports.on = on;


/***/ }),

/***/ "./node_modules/@dojo/core/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
tslib_1.__exportStar(__webpack_require__("./node_modules/@dojo/shim/support/has.js"), exports);
exports.default = has_1.default;
has_1.add('object-assign', typeof global_1.default.Object.assign === 'function', true);
has_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined', true);
has_1.add('formdata', typeof global_1.default.FormData !== 'undefined', true);
has_1.add('filereader', typeof global_1.default.FileReader !== 'undefined', true);
has_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined', true);
has_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype, true);
has_1.add('blob', function () {
    if (!has_1.default('xhr2')) {
        return false;
    }
    var request = new global_1.default.XMLHttpRequest();
    request.open('GET', 'http://www.google.com', true);
    request.responseType = 'blob';
    request.abort();
    return request.responseType === 'blob';
}, true);
has_1.add('node-buffer', 'Buffer' in global_1.default && typeof global_1.default.Buffer === 'function', true);
has_1.add('fetch', 'fetch' in global_1.default && typeof global_1.default.fetch === 'function', true);
has_1.add('web-worker-xhr-upload', new Promise(function (resolve) {
    try {
        if (global_1.default.Worker !== undefined && global_1.default.URL && global_1.default.URL.createObjectURL) {
            var blob = new Blob(["(function () {\nself.addEventListener('message', function () {\n\tvar xhr = new XMLHttpRequest();\n\ttry {\n\t\txhr.upload;\n\t\tpostMessage('true');\n\t} catch (e) {\n\t\tpostMessage('false');\n\t}\n});\n\t\t})()"], { type: 'application/javascript' });
            var worker = new Worker(URL.createObjectURL(blob));
            worker.addEventListener('message', function (_a) {
                var result = _a.data;
                resolve(result === 'true');
            });
            worker.postMessage({});
        }
        else {
            resolve(false);
        }
    }
    catch (e) {
        // IE11 on Winodws 8.1 encounters a security error.
        resolve(false);
    }
}), true);


/***/ }),

/***/ "./node_modules/@dojo/core/lang.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var object_1 = __webpack_require__("./node_modules/@dojo/shim/object.js");
var object_2 = __webpack_require__("./node_modules/@dojo/shim/object.js");
exports.assign = object_2.assign;
var slice = Array.prototype.slice;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Type guard that ensures that the value can be coerced to Object
 * to weed out host objects that do not derive from Object.
 * This function is used to check if we want to deep copy an object or not.
 * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will
 * change the value returned by `toString`. This is a rare edge case that is difficult to handle,
 * so it is not handled here.
 * @param  value The value to check
 * @return       If the value is coercible into an Object
 */
function shouldDeepCopyObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
function copyArray(array, inherited) {
    return array.map(function (item) {
        if (Array.isArray(item)) {
            return copyArray(item, inherited);
        }
        return !shouldDeepCopyObject(item) ?
            item :
            _mixin({
                deep: true,
                inherited: inherited,
                sources: [item],
                target: {}
            });
    });
}
function _mixin(kwArgs) {
    var deep = kwArgs.deep;
    var inherited = kwArgs.inherited;
    var target = kwArgs.target;
    var copied = kwArgs.copied || [];
    var copiedClone = tslib_1.__spread(copied);
    for (var i = 0; i < kwArgs.sources.length; i++) {
        var source = kwArgs.sources[i];
        if (source === null || source === undefined) {
            continue;
        }
        for (var key in source) {
            if (inherited || hasOwnProperty.call(source, key)) {
                var value = source[key];
                if (copiedClone.indexOf(value) !== -1) {
                    continue;
                }
                if (deep) {
                    if (Array.isArray(value)) {
                        value = copyArray(value, inherited);
                    }
                    else if (shouldDeepCopyObject(value)) {
                        var targetValue = target[key] || {};
                        copied.push(source);
                        value = _mixin({
                            deep: true,
                            inherited: inherited,
                            sources: [value],
                            target: targetValue,
                            copied: copied
                        });
                    }
                }
                target[key] = value;
            }
        }
    }
    return target;
}
function create(prototype) {
    var mixins = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        mixins[_i - 1] = arguments[_i];
    }
    if (!mixins.length) {
        throw new RangeError('lang.create requires at least one mixin object.');
    }
    var args = mixins.slice();
    args.unshift(Object.create(prototype));
    return object_1.assign.apply(null, args);
}
exports.create = create;
function deepAssign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: true,
        inherited: false,
        sources: sources,
        target: target
    });
}
exports.deepAssign = deepAssign;
function deepMixin(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: true,
        inherited: true,
        sources: sources,
        target: target
    });
}
exports.deepMixin = deepMixin;
/**
 * Creates a new object using the provided source's prototype as the prototype for the new object, and then
 * deep copies the provided source's values into the new target.
 *
 * @param source The object to duplicate
 * @return The new object
 */
function duplicate(source) {
    var target = Object.create(Object.getPrototypeOf(source));
    return deepMixin(target, source);
}
exports.duplicate = duplicate;
/**
 * Determines whether two values are the same value.
 *
 * @param a First value to compare
 * @param b Second value to compare
 * @return true if the values are the same; false otherwise
 */
function isIdentical(a, b) {
    return a === b ||
        /* both values are NaN */
        (a !== a && b !== b);
}
exports.isIdentical = isIdentical;
/**
 * Returns a function that binds a method to the specified object at runtime. This is similar to
 * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.
 * As a result, the function returned by `lateBind` will always call the function currently assigned to
 * the specified property on the object as of the moment the function it returns is called.
 *
 * @param instance The context object
 * @param method The name of the method on the context object to bind to itself
 * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list
 * @return The bound function
 */
function lateBind(instance, method) {
    var suppliedArgs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        suppliedArgs[_i - 2] = arguments[_i];
    }
    return suppliedArgs.length ?
        function () {
            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;
            // TS7017
            return instance[method].apply(instance, args);
        } :
        function () {
            // TS7017
            return instance[method].apply(instance, arguments);
        };
}
exports.lateBind = lateBind;
function mixin(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: false,
        inherited: true,
        sources: sources,
        target: target
    });
}
exports.mixin = mixin;
/**
 * Returns a function which invokes the given function with the given arguments prepended to its argument list.
 * Like `Function.prototype.bind`, but does not alter execution context.
 *
 * @param targetFunction The function that needs to be bound
 * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list
 * @return The bound function
 */
function partial(targetFunction) {
    var suppliedArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        suppliedArgs[_i - 1] = arguments[_i];
    }
    return function () {
        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;
        return targetFunction.apply(this, args);
    };
}
exports.partial = partial;
/**
 * Returns an object with a destroy method that, when called, calls the passed-in destructor.
 * This is intended to provide a unified interface for creating "remove" / "destroy" handlers for
 * event listeners, timers, etc.
 *
 * @param destructor A function that will be called when the handle's `destroy` method is invoked
 * @return The handle object
 */
function createHandle(destructor) {
    return {
        destroy: function () {
            this.destroy = function () { };
            destructor.call(this);
        }
    };
}
exports.createHandle = createHandle;
/**
 * Returns a single handle that can be used to destroy multiple handles simultaneously.
 *
 * @param handles An array of handles with `destroy` methods
 * @return The handle object
 */
function createCompositeHandle() {
    var handles = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        handles[_i] = arguments[_i];
    }
    return createHandle(function () {
        for (var i = 0; i < handles.length; i++) {
            handles[i].destroy();
        }
    });
}
exports.createCompositeHandle = createCompositeHandle;


/***/ }),

/***/ "./node_modules/@dojo/core/load/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
function isPlugin(value) {
    return Boolean(value) && typeof value.load === 'function';
}
exports.isPlugin = isPlugin;
function useDefault(modules) {
    if (iterator_1.isArrayLike(modules)) {
        var processedModules = [];
        for (var i = 0; i < modules.length; i++) {
            var module_1 = modules[i];
            processedModules.push((module_1.__esModule && module_1.default) ? module_1.default : module_1);
        }
        return processedModules;
    }
    else if (iterator_1.isIterable(modules)) {
        var processedModules = [];
        try {
            for (var modules_1 = tslib_1.__values(modules), modules_1_1 = modules_1.next(); !modules_1_1.done; modules_1_1 = modules_1.next()) {
                var module_2 = modules_1_1.value;
                processedModules.push((module_2.__esModule && module_2.default) ? module_2.default : module_2);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (modules_1_1 && !modules_1_1.done && (_a = modules_1.return)) _a.call(modules_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return processedModules;
    }
    else {
        return (modules.__esModule && modules.default) ? modules.default : modules;
    }
    var e_1, _a;
}
exports.useDefault = useDefault;


/***/ }),

/***/ "./node_modules/@dojo/core/uuid.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a v4 compliant UUID.
 *
 * @returns {string}
 */
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
exports.default = uuid;


/***/ }),

/***/ "./node_modules/@dojo/has/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {
Object.defineProperty(exports, "__esModule", { value: true });
function isFeatureTestThenable(value) {
    return value && value.then;
}
/**
 * A cache of results of feature tests
 */
exports.testCache = {};
/**
 * A cache of the un-resolved feature tests
 */
exports.testFunctions = {};
/**
 * A cache of unresolved thenables (probably promises)
 * @type {{}}
 */
var testThenables = {};
/**
 * A reference to the global scope (`window` in a browser, `global` in NodeJS)
 */
var globalScope = (function () {
    /* istanbul ignore else */
    if (typeof window !== 'undefined') {
        // Browsers
        return window;
    }
    else if (typeof global !== 'undefined') {
        // Node
        return global;
    }
    else if (typeof self !== 'undefined') {
        // Web workers
        return self;
    }
    /* istanbul ignore next */
    return {};
})();
/* Grab the staticFeatures if there are available */
var staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;
/* Cleaning up the DojoHasEnviornment */
if ('DojoHasEnvironment' in globalScope) {
    delete globalScope.DojoHasEnvironment;
}
/**
 * Custom type guard to narrow the `staticFeatures` to either a map or a function that
 * returns a map.
 *
 * @param value The value to guard for
 */
function isStaticFeatureFunction(value) {
    return typeof value === 'function';
}
/**
 * The cache of asserted features that were available in the global scope when the
 * module loaded
 */
var staticCache = staticFeatures
    ? isStaticFeatureFunction(staticFeatures)
        ? staticFeatures.apply(globalScope)
        : staticFeatures
    : {};/* Providing an empty cache, if none was in the environment

/**
* AMD plugin function.
*
* Conditional loads modules based on a has feature test value.
*
* @param resourceId Gives the resolved module id to load.
* @param require The loader require function with respect to the module that contained the plugin resource in its
*                dependency list.
* @param load Callback to loader that consumes result of plugin demand.
*/
function load(resourceId, require, load, config) {
    resourceId ? require([resourceId], load) : load();
}
exports.load = load;
/**
 * AMD plugin function.
 *
 * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test
 * value(s).
 *
 * @param resourceId The id of the module
 * @param normalize Resolves a relative module id into an absolute module id
 */
function normalize(resourceId, normalize) {
    var tokens = resourceId.match(/[\?:]|[^:\?]*/g) || [];
    var i = 0;
    function get(skip) {
        var term = tokens[i++];
        if (term === ':') {
            // empty string module name, resolves to null
            return null;
        }
        else {
            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
            if (tokens[i++] === '?') {
                if (!skip && has(term)) {
                    // matched the feature, get the first value from the options
                    return get();
                }
                else {
                    // did not match, get the second value, passing over the first
                    get(true);
                    return get(skip);
                }
            }
            // a module
            return term;
        }
    }
    var id = get();
    return id && normalize(id);
}
exports.normalize = normalize;
/**
 * Check if a feature has already been registered
 *
 * @param feature the name of the feature
 */
function exists(feature) {
    var normalizedFeature = feature.toLowerCase();
    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);
}
exports.exists = exists;
/**
 * Register a new test for a named feature.
 *
 * @example
 * has.add('dom-addeventlistener', !!document.addEventListener);
 *
 * @example
 * has.add('touch-events', function () {
 *    return 'ontouchstart' in document
 * });
 *
 * @param feature the name of the feature
 * @param value the value reported of the feature, or a function that will be executed once on first test
 * @param overwrite if an existing value should be overwritten. Defaults to false.
 */
function add(feature, value, overwrite) {
    if (overwrite === void 0) { overwrite = false; }
    var normalizedFeature = feature.toLowerCase();
    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {
        throw new TypeError("Feature \"" + feature + "\" exists and overwrite not true.");
    }
    if (typeof value === 'function') {
        exports.testFunctions[normalizedFeature] = value;
    }
    else if (isFeatureTestThenable(value)) {
        testThenables[feature] = value.then(function (resolvedValue) {
            exports.testCache[feature] = resolvedValue;
            delete testThenables[feature];
        }, function () {
            delete testThenables[feature];
        });
    }
    else {
        exports.testCache[normalizedFeature] = value;
        delete exports.testFunctions[normalizedFeature];
    }
}
exports.add = add;
/**
 * Return the current value of a named feature.
 *
 * @param feature The name (if a string) or identifier (if an integer) of the feature to test.
 */
function has(feature) {
    var result;
    var normalizedFeature = feature.toLowerCase();
    if (normalizedFeature in staticCache) {
        result = staticCache[normalizedFeature];
    }
    else if (exports.testFunctions[normalizedFeature]) {
        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);
        delete exports.testFunctions[normalizedFeature];
    }
    else if (normalizedFeature in exports.testCache) {
        result = exports.testCache[normalizedFeature];
    }
    else if (feature in testThenables) {
        return false;
    }
    else {
        throw new TypeError("Attempt to detect unregistered has feature \"" + feature + "\"");
    }
    return result;
}
exports.default = has;
/*
 * Out of the box feature tests
 */
/* Environments */
/* Used as a value to provide a debug only code path */
add('debug', true);
/* Detects if the environment is "browser like" */
add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');
/* Detects if the environment appears to be NodeJS */
add('host-node', function () {
    if (typeof process === 'object' && process.versions && process.versions.node) {
        return process.versions.node;
    }
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@dojo/i18n/cldr/load.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// required for Globalize/Cldr to properly resolve locales in the browser.
__webpack_require__("./node_modules/cldrjs/dist/cldr/unresolved.js");
var Promise_1 = __webpack_require__("./node_modules/@dojo/shim/Promise.js");
var Globalize = __webpack_require__("./node_modules/globalize/dist/node-main.js");
var locales_1 = __webpack_require__("./node_modules/@dojo/i18n/cldr/locales.js");
var main_1 = __webpack_require__("./node_modules/@dojo/i18n/util/main.js");
/**
 * A list of all required CLDR packages for an individual locale.
 */
exports.mainPackages = Object.freeze([
    'dates/calendars/gregorian',
    'dates/fields',
    'dates/timeZoneNames',
    'numbers',
    'numbers/currencies',
    'units'
]);
/**
 * A list of all required CLDR supplement packages.
 */
exports.supplementalPackages = Object.freeze([
    'currencyData',
    'likelySubtags',
    'numberingSystems',
    'plurals-type-cardinal',
    'plurals-type-ordinal',
    'timeData',
    'weekData'
]);
/**
 * @private
 * A simple map containing boolean flags indicating whether a particular CLDR package has been loaded.
 */
var loadCache = {
    main: Object.create(null),
    supplemental: generateSupplementalCache()
};
/**
 * @private
 * Generate the locale-specific data cache from a list of keys. Nested objects will be generated from
 * slash-separated strings.
 *
 * @param cache
 * An empty locale cache object.
 *
 * @param keys
 * The list of keys.
 */
function generateLocaleCache(cache, keys) {
    return keys.reduce(function (tree, key) {
        var parts = key.split('/');
        if (parts.length === 1) {
            tree[key] = false;
            return tree;
        }
        parts.reduce(function (tree, key, i) {
            if (typeof tree[key] !== 'object') {
                tree[key] = i === parts.length - 1 ? false : Object.create(null);
            }
            return tree[key];
        }, tree);
        return tree;
    }, cache);
}
/**
 * @private
 * Generate the supplemental data cache.
 */
function generateSupplementalCache() {
    return exports.supplementalPackages.reduce(function (map, key) {
        map[key] = false;
        return map;
    }, Object.create(null));
}
/**
 * @private
 * Recursively determine whether a list of packages have been loaded for the specified CLDR group.
 *
 * @param group
 * The CLDR group object (e.g., the supplemental data, or a specific locale group)
 *
 * @param args
 * A list of keys to recursively check from left to right. For example, if [ "en", "numbers" ],
 * then `group.en.numbers` must exist for the test to pass.
 *
 * @return
 * `true` if the deepest value exists; `false` otherwise.
 */
function isLoadedForGroup(group, args) {
    return args.every(function (arg) {
        var next = group[arg];
        group = next;
        return Boolean(next);
    });
}
/**
 * @private
 * Recursively flag as loaded all recognized keys on the provided CLDR data object.
 *
 * @param cache
 * The load cache (either the entire object, or a nested segment of it).
 *
 * @param localeData
 * The CLDR data object being loaded (either the entire object, or a nested segment of it).
 */
function registerLocaleData(cache, localeData) {
    Object.keys(localeData).forEach(function (key) {
        if (key in cache) {
            var value = cache[key];
            if (typeof value === 'boolean') {
                cache[key] = true;
            }
            else {
                registerLocaleData(value, localeData[key]);
            }
        }
    });
}
/**
 * @private
 * Flag all supplied CLDR packages for a specific locale as loaded.
 *
 * @param data
 * The `main` locale data.
 */
function registerMain(data) {
    if (!data) {
        return;
    }
    Object.keys(data).forEach(function (locale) {
        if (locales_1.default.indexOf(locale) < 0) {
            return;
        }
        var loadedData = loadCache.main[locale];
        if (!loadedData) {
            loadedData = loadCache.main[locale] = generateLocaleCache(Object.create(null), exports.mainPackages);
        }
        registerLocaleData(loadedData, data[locale]);
    });
}
/**
 * @private
 * Flag all supplied CLDR supplemental packages as loaded.
 *
 * @param data
 * The supplemental data.
 */
function registerSupplemental(data) {
    if (!data) {
        return;
    }
    var supplemental = loadCache.supplemental;
    Object.keys(data).forEach(function (key) {
        if (key in supplemental) {
            supplemental[key] = true;
        }
    });
}
/**
 * Determine whether a particular CLDR package has been loaded.
 *
 * Example: to check that `supplemental.likelySubtags` has been loaded, `isLoaded` would be called as
 * `isLoaded('supplemental', 'likelySubtags')`.
 *
 * @param groupName
 * The group to check; either "main" or "supplemental".
 *
 * @param ...args
 * Any remaining keys in the path to the desired package.
 *
 * @return
 * `true` if the deepest value exists; `false` otherwise.
 */
function isLoaded(groupName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var group = loadCache[groupName];
    if (groupName === 'main' && args.length > 0) {
        var locale = args[0];
        if (!main_1.validateLocale(locale)) {
            return false;
        }
        args = args.slice(1);
        return main_1.generateLocales(locale).some(function (locale) {
            var next = group[locale];
            return next ? isLoadedForGroup(next, args) : false;
        });
    }
    return isLoadedForGroup(group, args);
}
exports.isLoaded = isLoaded;
/**
 * Load the specified CLDR data with the i18n ecosystem.
 *
 * @param data
 * A data object containing `main` and/or `supplemental` objects with CLDR data.
 */
function loadCldrData(data) {
    registerMain(data.main);
    registerSupplemental(data.supplemental);
    Globalize.load(data);
    return Promise_1.default.resolve();
}
exports.default = loadCldrData;
/**
 * Clear the load cache, either the entire cache for the specified group. After calling this method,
 * `isLoaded` will return false for keys within the specified group(s).
 *
 * @param group
 * An optional group name. If not provided, then both the "main" and "supplemental" caches will be cleared.
 */
function reset(group) {
    if (group !== 'supplemental') {
        loadCache.main = Object.create(null);
    }
    if (group !== 'main') {
        loadCache.supplemental = generateSupplementalCache();
    }
}
exports.reset = reset;


/***/ }),

/***/ "./node_modules/@dojo/i18n/cldr/locales.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A list of `cldr-data/main` directories used to load the correct CLDR data for a given locale.
 */
var localesList = [
    'af-NA',
    'af',
    'agq',
    'ak',
    'am',
    'ar-AE',
    'ar-BH',
    'ar-DJ',
    'ar-DZ',
    'ar-EG',
    'ar-EH',
    'ar-ER',
    'ar-IL',
    'ar-IQ',
    'ar-JO',
    'ar-KM',
    'ar-KW',
    'ar-LB',
    'ar-LY',
    'ar-MA',
    'ar-MR',
    'ar-OM',
    'ar-PS',
    'ar-QA',
    'ar-SA',
    'ar-SD',
    'ar-SO',
    'ar-SS',
    'ar-SY',
    'ar-TD',
    'ar-TN',
    'ar-YE',
    'ar',
    'as',
    'asa',
    'ast',
    'az-Cyrl',
    'az-Latn',
    'az',
    'bas',
    'be',
    'bem',
    'bez',
    'bg',
    'bm',
    'bn-IN',
    'bn',
    'bo-IN',
    'bo',
    'br',
    'brx',
    'bs-Cyrl',
    'bs-Latn',
    'bs',
    'ca-AD',
    'ca-ES-VALENCIA',
    'ca-FR',
    'ca-IT',
    'ca',
    'ce',
    'cgg',
    'chr',
    'ckb-IR',
    'ckb',
    'cs',
    'cu',
    'cy',
    'da-GL',
    'da',
    'dav',
    'de-AT',
    'de-BE',
    'de-CH',
    'de-IT',
    'de-LI',
    'de-LU',
    'de',
    'dje',
    'dsb',
    'dua',
    'dyo',
    'dz',
    'ebu',
    'ee-TG',
    'ee',
    'el-CY',
    'el',
    'en-001',
    'en-150',
    'en-AG',
    'en-AI',
    'en-AS',
    'en-AT',
    'en-AU',
    'en-BB',
    'en-BE',
    'en-BI',
    'en-BM',
    'en-BS',
    'en-BW',
    'en-BZ',
    'en-CA',
    'en-CC',
    'en-CH',
    'en-CK',
    'en-CM',
    'en-CX',
    'en-CY',
    'en-DE',
    'en-DG',
    'en-DK',
    'en-DM',
    'en-ER',
    'en-FI',
    'en-FJ',
    'en-FK',
    'en-FM',
    'en-GB',
    'en-GD',
    'en-GG',
    'en-GH',
    'en-GI',
    'en-GM',
    'en-GU',
    'en-GY',
    'en-HK',
    'en-IE',
    'en-IL',
    'en-IM',
    'en-IN',
    'en-IO',
    'en-JE',
    'en-JM',
    'en-KE',
    'en-KI',
    'en-KN',
    'en-KY',
    'en-LC',
    'en-LR',
    'en-LS',
    'en-MG',
    'en-MH',
    'en-MO',
    'en-MP',
    'en-MS',
    'en-MT',
    'en-MU',
    'en-MW',
    'en-MY',
    'en-NA',
    'en-NF',
    'en-NG',
    'en-NL',
    'en-NR',
    'en-NU',
    'en-NZ',
    'en-PG',
    'en-PH',
    'en-PK',
    'en-PN',
    'en-PR',
    'en-PW',
    'en-RW',
    'en-SB',
    'en-SC',
    'en-SD',
    'en-SE',
    'en-SG',
    'en-SH',
    'en-SI',
    'en-SL',
    'en-SS',
    'en-SX',
    'en-SZ',
    'en-TC',
    'en-TK',
    'en-TO',
    'en-TT',
    'en-TV',
    'en-TZ',
    'en-UG',
    'en-UM',
    'en-US-POSIX',
    'en-VC',
    'en-VG',
    'en-VI',
    'en-VU',
    'en-WS',
    'en-ZA',
    'en-ZM',
    'en-ZW',
    'en',
    'eo',
    'es-419',
    'es-AR',
    'es-BO',
    'es-BR',
    'es-CL',
    'es-CO',
    'es-CR',
    'es-CU',
    'es-DO',
    'es-EA',
    'es-EC',
    'es-GQ',
    'es-GT',
    'es-HN',
    'es-IC',
    'es-MX',
    'es-NI',
    'es-PA',
    'es-PE',
    'es-PH',
    'es-PR',
    'es-PY',
    'es-SV',
    'es-US',
    'es-UY',
    'es-VE',
    'es',
    'et',
    'eu',
    'ewo',
    'fa-AF',
    'fa',
    'ff-CM',
    'ff-GN',
    'ff-MR',
    'ff',
    'fi',
    'fil',
    'fo-DK',
    'fo',
    'fr-BE',
    'fr-BF',
    'fr-BI',
    'fr-BJ',
    'fr-BL',
    'fr-CA',
    'fr-CD',
    'fr-CF',
    'fr-CG',
    'fr-CH',
    'fr-CI',
    'fr-CM',
    'fr-DJ',
    'fr-DZ',
    'fr-GA',
    'fr-GF',
    'fr-GN',
    'fr-GP',
    'fr-GQ',
    'fr-HT',
    'fr-KM',
    'fr-LU',
    'fr-MA',
    'fr-MC',
    'fr-MF',
    'fr-MG',
    'fr-ML',
    'fr-MQ',
    'fr-MR',
    'fr-MU',
    'fr-NC',
    'fr-NE',
    'fr-PF',
    'fr-PM',
    'fr-RE',
    'fr-RW',
    'fr-SC',
    'fr-SN',
    'fr-SY',
    'fr-TD',
    'fr-TG',
    'fr-TN',
    'fr-VU',
    'fr-WF',
    'fr-YT',
    'fr',
    'fur',
    'fy',
    'ga',
    'gd',
    'gl',
    'gsw-FR',
    'gsw-LI',
    'gsw',
    'gu',
    'guz',
    'gv',
    'ha-GH',
    'ha-NE',
    'ha',
    'haw',
    'he',
    'hi',
    'hr-BA',
    'hr',
    'hsb',
    'hu',
    'hy',
    'id',
    'ig',
    'ii',
    'is',
    'it-CH',
    'it-SM',
    'it',
    'ja',
    'jgo',
    'jmc',
    'ka',
    'kab',
    'kam',
    'kde',
    'kea',
    'khq',
    'ki',
    'kk',
    'kkj',
    'kl',
    'kln',
    'km',
    'kn',
    'ko-KP',
    'ko',
    'kok',
    'ks',
    'ksb',
    'ksf',
    'ksh',
    'kw',
    'ky',
    'lag',
    'lb',
    'lg',
    'lkt',
    'ln-AO',
    'ln-CF',
    'ln-CG',
    'ln',
    'lo',
    'lrc-IQ',
    'lrc',
    'lt',
    'lu',
    'luo',
    'luy',
    'lv',
    'mas-TZ',
    'mas',
    'mer',
    'mfe',
    'mg',
    'mgh',
    'mgo',
    'mk',
    'ml',
    'mn',
    'mr',
    'ms-BN',
    'ms-SG',
    'ms',
    'mt',
    'mua',
    'my',
    'mzn',
    'naq',
    'nb-SJ',
    'nb',
    'nd',
    'nds-NL',
    'nds',
    'ne-IN',
    'ne',
    'nl-AW',
    'nl-BE',
    'nl-BQ',
    'nl-CW',
    'nl-SR',
    'nl-SX',
    'nl',
    'nmg',
    'nn',
    'nnh',
    'nus',
    'nyn',
    'om-KE',
    'om',
    'or',
    'os-RU',
    'os',
    'pa-Arab',
    'pa-Guru',
    'pa',
    'pl',
    'prg',
    'ps',
    'pt-AO',
    'pt-CH',
    'pt-CV',
    'pt-GQ',
    'pt-GW',
    'pt-LU',
    'pt-MO',
    'pt-MZ',
    'pt-PT',
    'pt-ST',
    'pt-TL',
    'pt',
    'qu-BO',
    'qu-EC',
    'qu',
    'rm',
    'rn',
    'ro-MD',
    'ro',
    'rof',
    'root',
    'ru-BY',
    'ru-KG',
    'ru-KZ',
    'ru-MD',
    'ru-UA',
    'ru',
    'rw',
    'rwk',
    'sah',
    'saq',
    'sbp',
    'se-FI',
    'se-SE',
    'se',
    'seh',
    'ses',
    'sg',
    'shi-Latn',
    'shi-Tfng',
    'shi',
    'si',
    'sk',
    'sl',
    'smn',
    'sn',
    'so-DJ',
    'so-ET',
    'so-KE',
    'so',
    'sq-MK',
    'sq-XK',
    'sq',
    'sr-Cyrl-BA',
    'sr-Cyrl-ME',
    'sr-Cyrl-XK',
    'sr-Cyrl',
    'sr-Latn-BA',
    'sr-Latn-ME',
    'sr-Latn-XK',
    'sr-Latn',
    'sr',
    'sv-AX',
    'sv-FI',
    'sv',
    'sw-CD',
    'sw-KE',
    'sw-UG',
    'sw',
    'ta-LK',
    'ta-MY',
    'ta-SG',
    'ta',
    'te',
    'teo-KE',
    'teo',
    'th',
    'ti-ER',
    'ti',
    'tk',
    'to',
    'tr-CY',
    'tr',
    'twq',
    'tzm',
    'ug',
    'uk',
    'ur-IN',
    'ur',
    'uz-Arab',
    'uz-Cyrl',
    'uz-Latn',
    'uz',
    'vai-Latn',
    'vai-Vaii',
    'vai',
    'vi',
    'vo',
    'vun',
    'wae',
    'xog',
    'yav',
    'yi',
    'yo-BJ',
    'yo',
    'yue',
    'zgh',
    'zh-Hans-HK',
    'zh-Hans-MO',
    'zh-Hans-SG',
    'zh-Hans',
    'zh-Hant-HK',
    'zh-Hant-MO',
    'zh-Hant',
    'zh',
    'zu'
];
exports.default = localesList;


/***/ }),

/***/ "./node_modules/@dojo/i18n/i18n.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
/* tslint:disable:interface-name */
__webpack_require__("./node_modules/@dojo/shim/Promise.js"); // ensure Promise.all exists
var Evented_1 = __webpack_require__("./node_modules/@dojo/core/Evented.js");
var has_1 = __webpack_require__("./node_modules/@dojo/core/has.js");
var lang_1 = __webpack_require__("./node_modules/@dojo/core/lang.js");
var util_1 = __webpack_require__("./node_modules/@dojo/core/load/util.js");
var uuid_1 = __webpack_require__("./node_modules/@dojo/core/uuid.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var Map_1 = __webpack_require__("./node_modules/@dojo/shim/Map.js");
var Observable_1 = __webpack_require__("./node_modules/@dojo/shim/Observable.js");
var Globalize = __webpack_require__("./node_modules/globalize/dist/globalize/message.js");
var load_1 = __webpack_require__("./node_modules/@dojo/i18n/cldr/load.js");
var main_1 = __webpack_require__("./node_modules/@dojo/i18n/util/main.js");
var TOKEN_PATTERN = /\{([a-z0-9_]+)\}/gi;
var bundleMap = new Map_1.default();
var formatterMap = new Map_1.default();
var localeProducer = new Evented_1.default();
var rootLocale;
/**
 * Return the bundle's unique identifier, creating one if it does not already exist.
 *
 * @param bundle A message bundle
 * @return The bundle's unique identifier
 */
function getBundleId(bundle) {
    if (bundle.id) {
        return bundle.id;
    }
    var id = uuid_1.default();
    Object.defineProperty(bundle, 'id', {
        value: id
    });
    return id;
}
/**
 * @private
 * Return a function that formats an ICU-style message, and takes an optional value for token replacement.
 *
 * Usage:
 * const formatter = getMessageFormatter(bundle, 'guestInfo', 'fr');
 * const message = formatter({
 *   host: 'Miles',
 *   gender: 'male',
 *   guest: 'Oscar',
 *   guestCount: '15'
 * });
 *
 * @param id
 * The message's bundle id.
 *
 * @param key
 * The message's key.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The message formatter.
 */
function getIcuMessageFormatter(id, key, locale) {
    locale = main_1.normalizeLocale(locale || getRootLocale());
    var formatterKey = locale + ":" + id + ":" + key;
    var formatter = formatterMap.get(formatterKey);
    if (formatter) {
        return formatter;
    }
    var globalize = locale !== getRootLocale() ? new Globalize(main_1.normalizeLocale(locale)) : Globalize;
    formatter = globalize.messageFormatter(id + "/" + key);
    var cached = bundleMap.get(id);
    if (cached && cached.get(locale)) {
        formatterMap.set(formatterKey, formatter);
    }
    return formatter;
}
/**
 * @private
 * Load the specified locale-specific bundles, mapping the default exports to simple `Messages` objects.
 */
function loadLocaleBundles(locales, supported) {
    return Promise.all(supported.map(function (locale) { return locales[locale](); })).then(function (bundles) {
        return bundles.map(function (bundle) { return util_1.useDefault(bundle); });
    });
}
/**
 * @private
 * Return the root locale. Defaults to the system locale.
 */
function getRootLocale() {
    return rootLocale || exports.systemLocale;
}
/**
 * @private
 * Retrieve a list of supported locales that can provide messages for the specified locale.
 *
 * @param locale
 * The target locale.
 *
 * @param supported
 * The locales that are supported by the bundle.
 *
 * @return
 * A list of supported locales that match the target locale.
 */
function getSupportedLocales(locale, supported) {
    if (supported === void 0) { supported = []; }
    return main_1.generateLocales(locale).filter(function (locale) { return supported.indexOf(locale) > -1; });
}
/**
 * @private
 * Inject messages for the specified locale into the i18n system.
 *
 * @param id
 * The bundle's unique identifier
 *
 * @param messages
 * The messages to inject
 *
 * @param locale
 * An optional locale. If not specified, then it is assumed that the messages are the defaults for the given
 * bundle path.
 */
function loadMessages(id, messages, locale) {
    if (locale === void 0) { locale = 'root'; }
    var cached = bundleMap.get(id);
    if (!cached) {
        cached = new Map_1.default();
        bundleMap.set(id, cached);
    }
    cached.set(locale, messages);
    Globalize.loadMessages((_a = {},
        _a[locale] = (_b = {},
            _b[id] = messages,
            _b),
        _a));
    var _a, _b;
}
/**
 * Return a formatted message.
 *
 * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
 * the ICU message format is supported. Otherwise, a simple token-replacement mechanism is used.
 *
 * Usage:
 * formatMessage(bundle, 'guestInfo', {
 *   host: 'Bill',
 *   guest: 'John'
 * }, 'fr');
 *
 * @param bundle
 * The bundle containing the target message.
 *
 * @param key
 * The message's key.
 *
 * @param options
 * An optional value used by the formatter to replace tokens with values.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The formatted message.
 */
function formatMessage(bundle, key, options, locale) {
    return getMessageFormatter(bundle, key, locale)(options);
}
exports.formatMessage = formatMessage;
/**
 * Return the cached messages for the specified bundle and locale. If messages have not been previously loaded for the
 * specified locale, no value will be returned.
 *
 * @param bundle
 * The default bundle that is used to determine where the locale-specific bundles are located.
 *
 * @param locale
 * The locale of the desired messages.
 *
 * @return The cached messages object, if it exists.
 */
function getCachedMessages(bundle, locale) {
    var _a = bundle.id, id = _a === void 0 ? getBundleId(bundle) : _a, locales = bundle.locales, messages = bundle.messages;
    var cached = bundleMap.get(id);
    if (!cached) {
        loadMessages(id, messages);
    }
    else {
        var localeMessages = cached.get(locale);
        if (localeMessages) {
            return localeMessages;
        }
    }
    var supportedLocales = getSupportedLocales(locale, locales && Object.keys(locales));
    if (!supportedLocales.length) {
        return messages;
    }
    if (cached) {
        return cached.get(supportedLocales[supportedLocales.length - 1]);
    }
}
exports.getCachedMessages = getCachedMessages;
/**
 * Return a function that formats a specific message, and takes an optional value for token replacement.
 *
 * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
 * the returned function will have ICU message format support. Otherwise, the returned function will perform a simple
 * token replacement on the message string.
 *
 * Usage:
 * const formatter = getMessageFormatter(bundle, 'guestInfo', 'fr');
 * const message = formatter({
 *   host: 'Miles',
 *   gender: 'male',
 *   guest: 'Oscar',
 *   guestCount: '15'
 * });
 *
 * @param bundle
 * The bundle containing the target message.
 *
 * @param key
 * The message's key.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The message formatter.
 */
function getMessageFormatter(bundle, key, locale) {
    var _a = bundle.id, id = _a === void 0 ? getBundleId(bundle) : _a;
    if (load_1.isLoaded('supplemental', 'likelySubtags') && load_1.isLoaded('supplemental', 'plurals-type-cardinal')) {
        return getIcuMessageFormatter(id, key, locale);
    }
    var cached = bundleMap.get(id);
    var messages = cached ? cached.get(locale || getRootLocale()) || cached.get('root') : null;
    if (!messages) {
        throw new Error("The bundle has not been registered.");
    }
    return function (options) {
        if (options === void 0) { options = Object.create(null); }
        return messages[key].replace(TOKEN_PATTERN, function (token, property) {
            var value = options[property];
            if (typeof value === 'undefined') {
                throw new Error("Missing property " + property);
            }
            return value;
        });
    };
}
exports.getMessageFormatter = getMessageFormatter;
/**
 * Load locale-specific messages for the specified bundle and locale.
 *
 * @param bundle
 * The default bundle that is used to determine where the locale-specific bundles are located.
 *
 * @param locale
 * An optional locale. If no locale is provided, then the current locale is assumed.
 *
 * @return A promise to the locale-specific messages.
 */
function i18n(bundle, locale) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var currentLocale, cachedMessages, locales, supportedLocales, bundles;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentLocale = locale ? main_1.normalizeLocale(locale) : getRootLocale();
                    cachedMessages = getCachedMessages(bundle, currentLocale);
                    if (cachedMessages) {
                        return [2 /*return*/, cachedMessages];
                    }
                    locales = bundle.locales;
                    supportedLocales = getSupportedLocales(currentLocale, Object.keys(locales));
                    return [4 /*yield*/, loadLocaleBundles(locales, supportedLocales)];
                case 1:
                    bundles = _a.sent();
                    return [2 /*return*/, bundles.reduce(function (previous, partial) {
                            var localeMessages = lang_1.assign({}, previous, partial);
                            loadMessages(getBundleId(bundle), Object.freeze(localeMessages), currentLocale);
                            return localeMessages;
                        }, bundle.messages)];
            }
        });
    });
}
Object.defineProperty(i18n, 'locale', {
    get: getRootLocale
});
exports.default = i18n;
/**
 * Invalidate the cache for a particular bundle, or invalidate the entire cache. Note that cached messages for all
 * locales for a given bundle will be cleared.
 *
 * @param bundle
 * An optional bundle to invalidate. If no bundle is provided, then the cache is cleared for all bundles.
 */
function invalidate(bundle) {
    if (bundle) {
        bundle.id && bundleMap.delete(bundle.id);
    }
    else {
        bundleMap.clear();
    }
}
exports.invalidate = invalidate;
/**
 * Register an observer to be notified when the root locale changes.
 *
 * @param observer
 * The observer whose `next` method will receive the locale string on updates, and whose `error` method will receive
 * an Error object if the locale switch fails.
 *
 * @return
 * A subscription object that can be used to unsubscribe from updates.
 */
exports.observeLocale = (function () {
    var localeSource = new Observable_1.default(function (observer) {
        var handles = [
            localeProducer.on('change', function (event) {
                observer.next(event.target);
            })
        ];
        return function () {
            handles.forEach(function (handle) {
                handle.destroy();
            });
        };
    });
    return function (observer) {
        return localeSource.subscribe(observer);
    };
})();
/**
 * Pre-load locale-specific messages into the i18n system.
 *
 * @param bundle
 * The default bundle that is used to merge locale-specific messages with the default messages.
 *
 * @param messages
 * The messages to cache.
 *
 * @param locale
 * The locale for the messages
 */
function setLocaleMessages(bundle, localeMessages, locale) {
    var messages = lang_1.assign({}, bundle.messages, localeMessages);
    loadMessages(getBundleId(bundle), Object.freeze(messages), locale);
}
exports.setLocaleMessages = setLocaleMessages;
/**
 * Change the root locale, and notify any registered observers.
 *
 * @param locale
 * The new locale.
 */
function switchLocale(locale) {
    var previous = rootLocale;
    rootLocale = locale ? main_1.normalizeLocale(locale) : '';
    if (previous !== rootLocale) {
        if (load_1.isLoaded('supplemental', 'likelySubtags')) {
            Globalize.load({
                main: (_a = {},
                    _a[rootLocale] = {},
                    _a)
            });
            Globalize.locale(rootLocale);
        }
        localeProducer.emit({ type: 'change', target: rootLocale });
    }
    var _a;
}
exports.switchLocale = switchLocale;
/**
 * The default environment locale.
 *
 * It should be noted that while the system locale will be normalized to a single
 * format when loading message bundles, this value represents the unaltered
 * locale returned directly by the environment.
 */
exports.systemLocale = (function () {
    var systemLocale = 'en';
    if (has_1.default('host-browser')) {
        var navigator_1 = global_1.default.navigator;
        systemLocale = navigator_1.language || navigator_1.userLanguage;
    }
    else if (has_1.default('host-node')) {
        systemLocale = process.env.LANG || systemLocale;
    }
    return main_1.normalizeLocale(systemLocale);
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@dojo/i18n/util/main.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Matches an ISO 639.1/639.2 compatible language, followed by optional subtags.
var VALID_LOCALE_PATTERN = /^[a-z]{2,3}(-[a-z0-9\-\_]+)?$/i;
/**
 * Retrieve a list of locales that can provide substitute for the specified locale
 * (including itself).
 *
 * For example, if 'fr-CA' is specified, then `[ 'fr', 'fr-CA' ]` is returned.
 *
 * @param locale
 * The target locale.
 *
 * @return
 * A list of locales that match the target locale.
 */
function generateLocales(locale) {
    var normalized = exports.normalizeLocale(locale);
    var parts = normalized.split('-');
    var current = parts[0];
    var result = [current];
    for (var i = 0; i < parts.length - 1; i += 1) {
        current += '-' + parts[i + 1];
        result.push(current);
    }
    return result;
}
exports.generateLocales = generateLocales;
/**
 * Normalize a locale so that it can be converted to a bundle path.
 *
 * @param locale
 * The target locale.
 *
 * @return The normalized locale.
 */
exports.normalizeLocale = (function () {
    function removeTrailingSeparator(value) {
        return value.replace(/(\-|_)$/, '');
    }
    function normalize(locale) {
        if (locale.indexOf('.') === -1) {
            return removeTrailingSeparator(locale);
        }
        return locale
            .split('.')
            .slice(0, -1)
            .map(function (part) {
            return removeTrailingSeparator(part).replace(/_/g, '-');
        })
            .join('-');
    }
    return function (locale) {
        var normalized = normalize(locale);
        if (!validateLocale(normalized)) {
            throw new Error(normalized + " is not a valid locale.");
        }
        return normalized;
    };
})();
/**
 * Validates that the provided locale at least begins with a ISO 639.1/639.2 comptabile language subtag,
 * and that any additional subtags contain only valid characters.
 *
 * While locales should adhere to the guidelines set forth by RFC 5646 (https://tools.ietf.org/html/rfc5646),
 * only the language subtag is strictly enforced.
 *
 * @param locale
 * The locale to validate.
 *
 * @return
 * `true` if the locale is valid; `false` otherwise.
 */
function validateLocale(locale) {
    return VALID_LOCALE_PATTERN.test(locale);
}
exports.validateLocale = validateLocale;


/***/ }),

/***/ "./node_modules/@dojo/shim/Map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var object_1 = __webpack_require__("./node_modules/@dojo/shim/object.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.Map = global_1.default.Map;
if (!has_1.default('es6-map')) {
    exports.Map = (_a = /** @class */ (function () {
            function Map(iterable) {
                this._keys = [];
                this._values = [];
                this[Symbol.toStringTag] = 'Map';
                if (iterable) {
                    if (iterator_1.isArrayLike(iterable)) {
                        for (var i = 0; i < iterable.length; i++) {
                            var value = iterable[i];
                            this.set(value[0], value[1]);
                        }
                    }
                    else {
                        try {
                            for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                                var value = iterable_1_1.value;
                                this.set(value[0], value[1]);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                }
                var e_1, _a;
            }
            /**
             * An alternative to Array.prototype.indexOf using Object.is
             * to check for equality. See http://mzl.la/1zuKO2V
             */
            Map.prototype._indexOfKey = function (keys, key) {
                for (var i = 0, length_1 = keys.length; i < length_1; i++) {
                    if (object_1.is(keys[i], key)) {
                        return i;
                    }
                }
                return -1;
            };
            Object.defineProperty(Map.prototype, "size", {
                get: function () {
                    return this._keys.length;
                },
                enumerable: true,
                configurable: true
            });
            Map.prototype.clear = function () {
                this._keys.length = this._values.length = 0;
            };
            Map.prototype.delete = function (key) {
                var index = this._indexOfKey(this._keys, key);
                if (index < 0) {
                    return false;
                }
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
                return true;
            };
            Map.prototype.entries = function () {
                var _this = this;
                var values = this._keys.map(function (key, i) {
                    return [key, _this._values[i]];
                });
                return new iterator_1.ShimIterator(values);
            };
            Map.prototype.forEach = function (callback, context) {
                var keys = this._keys;
                var values = this._values;
                for (var i = 0, length_2 = keys.length; i < length_2; i++) {
                    callback.call(context, values[i], keys[i], this);
                }
            };
            Map.prototype.get = function (key) {
                var index = this._indexOfKey(this._keys, key);
                return index < 0 ? undefined : this._values[index];
            };
            Map.prototype.has = function (key) {
                return this._indexOfKey(this._keys, key) > -1;
            };
            Map.prototype.keys = function () {
                return new iterator_1.ShimIterator(this._keys);
            };
            Map.prototype.set = function (key, value) {
                var index = this._indexOfKey(this._keys, key);
                index = index < 0 ? this._keys.length : index;
                this._keys[index] = key;
                this._values[index] = value;
                return this;
            };
            Map.prototype.values = function () {
                return new iterator_1.ShimIterator(this._values);
            };
            Map.prototype[Symbol.iterator] = function () {
                return this.entries();
            };
            return Map;
        }()),
        _a[Symbol.species] = _a,
        _a);
}
exports.default = exports.Map;
var _a;


/***/ }),

/***/ "./node_modules/@dojo/shim/Observable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.Observable = global_1.default.Observable;
if (!has_1.default('es-observable')) {
    /*
     * Create a subscription observer for a given observer, and return the subscription.  The "logic" for Observerables
     * is in here!
     */
    var startSubscription_1 = function startSubscription(executor, observer) {
        var closed = false;
        var cleanUp;
        function unsubscribe() {
            if (!closed) {
                closed = true;
                if (cleanUp) {
                    cleanUp();
                }
            }
        }
        function start(subscriptionObserver) {
            if (observer.start) {
                observer.start(subscription);
            }
            if (closed) {
                return;
            }
            try {
                var result = executor(subscriptionObserver);
                if (typeof result === 'function') {
                    cleanUp = result;
                }
                else if (result && 'unsubscribe' in result) {
                    cleanUp = result.unsubscribe;
                }
                else if (result !== undefined && result !== null) {
                    throw new TypeError('Subscriber must return a callable or subscription');
                }
                if (closed) {
                    if (cleanUp) {
                        cleanUp();
                    }
                }
            }
            catch (e) {
                error(e);
            }
        }
        function next(value) {
            if (closed) {
                return;
            }
            var next = observer.next;
            try {
                if (typeof next === 'function') {
                    return next(value);
                }
                else if (next !== undefined && next !== null) {
                    throw new TypeError('Observer.next is not a function');
                }
            }
            catch (e) {
                error(e);
            }
        }
        function error(errorValue) {
            if (!closed) {
                var cleanUpError = undefined;
                try {
                    unsubscribe();
                }
                catch (e) {
                    cleanUpError = e;
                }
                var observerError = observer.error;
                if (observerError !== undefined && observerError !== null) {
                    if (typeof observerError === 'function') {
                        var errorResult = observerError(errorValue);
                        if (cleanUpError !== undefined) {
                            throw cleanUpError;
                        }
                        return errorResult;
                    }
                    else {
                        throw new TypeError('Observer.error is not a function');
                    }
                }
                else if (observer.complete) {
                    return observer.complete(errorValue);
                }
                else {
                    throw errorValue;
                }
            }
            else {
                throw errorValue;
            }
        }
        function complete(completeValue) {
            if (!closed) {
                var cleanUpError = undefined;
                try {
                    unsubscribe();
                }
                catch (e) {
                    cleanUpError = e;
                }
                var observerComplete = observer.complete;
                if (observerComplete !== undefined && observerComplete !== null) {
                    if (typeof observerComplete === 'function') {
                        var completeResult = observerComplete(completeValue);
                        if (cleanUpError !== undefined) {
                            throw cleanUpError;
                        }
                        return completeResult;
                    }
                    else {
                        throw new TypeError('Observer.complete is not a function');
                    }
                }
                else if (cleanUpError) {
                    throw cleanUpError;
                }
            }
        }
        var subscription = Object.create(Object.create({}, {
            closed: {
                enumerable: false,
                configurable: true,
                get: function () {
                    return closed;
                }
            },
            unsubscribe: {
                enumerable: false,
                configurable: true,
                writable: true,
                value: unsubscribe
            }
        }));
        var prototype = Object.create({}, {
            next: {
                enumerable: false,
                writable: true,
                value: next,
                configurable: true
            },
            error: {
                enumerable: false,
                writable: true,
                value: error,
                configurable: true
            },
            complete: {
                enumerable: false,
                writable: true,
                value: complete,
                configurable: true
            },
            closed: {
                enumerable: false,
                configurable: true,
                get: function () {
                    return closed;
                }
            }
        });
        // create the SubscriptionObserver and kick things off
        start(Object.create(prototype));
        // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber
        return subscription;
    };
    exports.Observable = (function () {
        function nonEnumerable(target, key, descriptor) {
            descriptor.enumerable = false;
        }
        var Observable = /** @class */ (function () {
            function Observable(subscriber) {
                if (typeof subscriber !== 'function') {
                    throw new TypeError('subscriber is not a function');
                }
                this._executor = subscriber;
            }
            Observable.prototype[_a = Symbol.observable] = function () {
                return this;
            };
            Observable.prototype.subscribe = function (observerOrNext) {
                var listeners = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    listeners[_i - 1] = arguments[_i];
                }
                var _a = tslib_1.__read(tslib_1.__spread(listeners), 2), onError = _a[0], onComplete = _a[1];
                if (!observerOrNext ||
                    typeof observerOrNext === 'number' ||
                    typeof observerOrNext === 'string' ||
                    typeof observerOrNext === 'boolean') {
                    throw new TypeError('parameter must be a function or an observer');
                }
                var observer;
                if (typeof observerOrNext === 'function') {
                    observer = {
                        next: observerOrNext
                    };
                    if (typeof onError === 'function') {
                        observer.error = onError;
                    }
                    if (typeof onComplete === 'function') {
                        observer.complete = onComplete;
                    }
                }
                else {
                    observer = observerOrNext;
                }
                return startSubscription_1(this._executor, observer);
            };
            Observable.of = function () {
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                var constructor;
                if (typeof this !== 'function') {
                    constructor = Observable;
                }
                else {
                    constructor = this;
                }
                return new constructor(function (observer) {
                    try {
                        for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                            var o = items_1_1.value;
                            observer.next(o);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    observer.complete();
                    var e_1, _a;
                });
            };
            Observable.from = function (item) {
                if (item === null || item === undefined) {
                    throw new TypeError('item cannot be null or undefined');
                }
                var constructor;
                if (typeof this !== 'function') {
                    constructor = Observable;
                }
                else {
                    constructor = this;
                }
                var observableSymbol = item[Symbol.observable];
                if (observableSymbol !== undefined) {
                    if (typeof observableSymbol !== 'function') {
                        throw new TypeError('Symbol.observable must be a function');
                    }
                    var result = observableSymbol.call(item);
                    if (result === undefined ||
                        result === null ||
                        typeof result === 'number' ||
                        typeof result === 'boolean' ||
                        typeof result === 'string') {
                        throw new TypeError('Return value of Symbol.observable must be object');
                    }
                    if ((result.constructor && result.constructor === this) || result instanceof Observable) {
                        return result;
                    }
                    else if (result.subscribe) {
                        return new constructor(result.subscribe);
                    }
                    else {
                        if (constructor.of) {
                            return constructor.of(result);
                        }
                        else {
                            return Observable.of(result);
                        }
                    }
                }
                else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {
                    return new constructor(function (observer) {
                        if (iterator_1.isArrayLike(item)) {
                            for (var i = 0; i < item.length; i++) {
                                observer.next(item[i]);
                            }
                        }
                        else {
                            try {
                                for (var item_1 = tslib_1.__values(item), item_1_1 = item_1.next(); !item_1_1.done; item_1_1 = item_1.next()) {
                                    var o = item_1_1.value;
                                    observer.next(o);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (item_1_1 && !item_1_1.done && (_a = item_1.return)) _a.call(item_1);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        observer.complete();
                        var e_2, _a;
                    });
                }
                else {
                    throw new TypeError('Parameter is neither Observable nor Iterable');
                }
            };
            tslib_1.__decorate([
                nonEnumerable
            ], Observable.prototype, _a, null);
            tslib_1.__decorate([
                nonEnumerable
            ], Observable.prototype, "subscribe", null);
            tslib_1.__decorate([
                nonEnumerable
            ], Observable, "of", null);
            tslib_1.__decorate([
                nonEnumerable
            ], Observable, "from", null);
            return Observable;
            var _a;
        }());
        return Observable;
    })();
}
exports.default = exports.Observable;


/***/ }),

/***/ "./node_modules/@dojo/shim/Promise.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var queue_1 = __webpack_require__("./node_modules/@dojo/shim/support/queue.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
exports.ShimPromise = global_1.default.Promise;
exports.isThenable = function isThenable(value) {
    return value && typeof value.then === 'function';
};
if (!has_1.default('es6-promise')) {
    global_1.default.Promise = exports.ShimPromise = (_a = /** @class */ (function () {
            /**
             * Creates a new Promise.
             *
             * @constructor
             *
             * @param executor
             * The executor function is called immediately when the Promise is instantiated. It is responsible for
             * starting the asynchronous operation when it is invoked.
             *
             * The executor must call either the passed `resolve` function when the asynchronous operation has completed
             * successfully, or the `reject` function when the operation fails.
             */
            function Promise(executor) {
                var _this = this;
                /**
                 * The current state of this promise.
                 */
                this.state = 1 /* Pending */;
                this[Symbol.toStringTag] = 'Promise';
                /**
                 * If true, the resolution of this promise is chained ("locked in") to another promise.
                 */
                var isChained = false;
                /**
                 * Whether or not this promise is in a resolved state.
                 */
                var isResolved = function () {
                    return _this.state !== 1 /* Pending */ || isChained;
                };
                /**
                 * Callbacks that should be invoked once the asynchronous operation has completed.
                 */
                var callbacks = [];
                /**
                 * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,
                 * enqueues callbacks for execution on the next event loop turn.
                 */
                var whenFinished = function (callback) {
                    if (callbacks) {
                        callbacks.push(callback);
                    }
                };
                /**
                 * Settles this promise.
                 *
                 * @param newState The resolved state for this promise.
                 * @param {T|any} value The resolved value for this promise.
                 */
                var settle = function (newState, value) {
                    // A promise can only be settled once.
                    if (_this.state !== 1 /* Pending */) {
                        return;
                    }
                    _this.state = newState;
                    _this.resolvedValue = value;
                    whenFinished = queue_1.queueMicroTask;
                    // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to
                    // wait an extra turn.
                    if (callbacks && callbacks.length > 0) {
                        queue_1.queueMicroTask(function () {
                            if (callbacks) {
                                var count = callbacks.length;
                                for (var i = 0; i < count; ++i) {
                                    callbacks[i].call(null);
                                }
                                callbacks = null;
                            }
                        });
                    }
                };
                /**
                 * Resolves this promise.
                 *
                 * @param newState The resolved state for this promise.
                 * @param {T|any} value The resolved value for this promise.
                 */
                var resolve = function (newState, value) {
                    if (isResolved()) {
                        return;
                    }
                    if (exports.isThenable(value)) {
                        value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));
                        isChained = true;
                    }
                    else {
                        settle(newState, value);
                    }
                };
                this.then = function (onFulfilled, onRejected) {
                    return new Promise(function (resolve, reject) {
                        // whenFinished initially queues up callbacks for execution after the promise has settled. Once the
                        // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the
                        // event loop.
                        whenFinished(function () {
                            var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;
                            if (typeof callback === 'function') {
                                try {
                                    resolve(callback(_this.resolvedValue));
                                }
                                catch (error) {
                                    reject(error);
                                }
                            }
                            else if (_this.state === 2 /* Rejected */) {
                                reject(_this.resolvedValue);
                            }
                            else {
                                resolve(_this.resolvedValue);
                            }
                        });
                    });
                };
                try {
                    executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));
                }
                catch (error) {
                    settle(2 /* Rejected */, error);
                }
            }
            Promise.all = function (iterable) {
                return new this(function (resolve, reject) {
                    var values = [];
                    var complete = 0;
                    var total = 0;
                    var populating = true;
                    function fulfill(index, value) {
                        values[index] = value;
                        ++complete;
                        finish();
                    }
                    function finish() {
                        if (populating || complete < total) {
                            return;
                        }
                        resolve(values);
                    }
                    function processItem(index, item) {
                        ++total;
                        if (exports.isThenable(item)) {
                            // If an item Promise rejects, this Promise is immediately rejected with the item
                            // Promise's rejection error.
                            item.then(fulfill.bind(null, index), reject);
                        }
                        else {
                            Promise.resolve(item).then(fulfill.bind(null, index));
                        }
                    }
                    var i = 0;
                    try {
                        for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                            var value = iterable_1_1.value;
                            processItem(i, value);
                            i++;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    populating = false;
                    finish();
                    var e_1, _a;
                });
            };
            Promise.race = function (iterable) {
                return new this(function (resolve, reject) {
                    try {
                        for (var iterable_2 = tslib_1.__values(iterable), iterable_2_1 = iterable_2.next(); !iterable_2_1.done; iterable_2_1 = iterable_2.next()) {
                            var item = iterable_2_1.value;
                            if (item instanceof Promise) {
                                // If a Promise item rejects, this Promise is immediately rejected with the item
                                // Promise's rejection error.
                                item.then(resolve, reject);
                            }
                            else {
                                Promise.resolve(item).then(resolve);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) _a.call(iterable_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    var e_2, _a;
                });
            };
            Promise.reject = function (reason) {
                return new this(function (resolve, reject) {
                    reject(reason);
                });
            };
            Promise.resolve = function (value) {
                return new this(function (resolve) {
                    resolve(value);
                });
            };
            Promise.prototype.catch = function (onRejected) {
                return this.then(undefined, onRejected);
            };
            return Promise;
        }()),
        _a[Symbol.species] = exports.ShimPromise,
        _a);
}
exports.default = exports.ShimPromise;
var _a;


/***/ }),

/***/ "./node_modules/@dojo/shim/Symbol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var util_1 = __webpack_require__("./node_modules/@dojo/shim/support/util.js");
exports.Symbol = global_1.default.Symbol;
if (!has_1.default('es6-symbol')) {
    /**
     * Throws if the value is not a symbol, used internally within the Shim
     * @param  {any}    value The value to check
     * @return {symbol}       Returns the symbol or throws
     */
    var validateSymbol_1 = function validateSymbol(value) {
        if (!isSymbol(value)) {
            throw new TypeError(value + ' is not a symbol');
        }
        return value;
    };
    var defineProperties_1 = Object.defineProperties;
    var defineProperty_1 = Object.defineProperty;
    var create_1 = Object.create;
    var objPrototype_1 = Object.prototype;
    var globalSymbols_1 = {};
    var getSymbolName_1 = (function () {
        var created = create_1(null);
        return function (desc) {
            var postfix = 0;
            var name;
            while (created[String(desc) + (postfix || '')]) {
                ++postfix;
            }
            desc += String(postfix || '');
            created[desc] = true;
            name = '@@' + desc;
            // FIXME: Temporary guard until the duplicate execution when testing can be
            // pinned down.
            if (!Object.getOwnPropertyDescriptor(objPrototype_1, name)) {
                defineProperty_1(objPrototype_1, name, {
                    set: function (value) {
                        defineProperty_1(this, name, util_1.getValueDescriptor(value));
                    }
                });
            }
            return name;
        };
    })();
    var InternalSymbol_1 = function Symbol(description) {
        if (this instanceof InternalSymbol_1) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        return Symbol(description);
    };
    exports.Symbol = global_1.default.Symbol = function Symbol(description) {
        if (this instanceof Symbol) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        var sym = Object.create(InternalSymbol_1.prototype);
        description = description === undefined ? '' : String(description);
        return defineProperties_1(sym, {
            __description__: util_1.getValueDescriptor(description),
            __name__: util_1.getValueDescriptor(getSymbolName_1(description))
        });
    };
    /* Decorate the Symbol function with the appropriate properties */
    defineProperty_1(exports.Symbol, 'for', util_1.getValueDescriptor(function (key) {
        if (globalSymbols_1[key]) {
            return globalSymbols_1[key];
        }
        return (globalSymbols_1[key] = exports.Symbol(String(key)));
    }));
    defineProperties_1(exports.Symbol, {
        keyFor: util_1.getValueDescriptor(function (sym) {
            var key;
            validateSymbol_1(sym);
            for (key in globalSymbols_1) {
                if (globalSymbols_1[key] === sym) {
                    return key;
                }
            }
        }),
        hasInstance: util_1.getValueDescriptor(exports.Symbol.for('hasInstance'), false, false),
        isConcatSpreadable: util_1.getValueDescriptor(exports.Symbol.for('isConcatSpreadable'), false, false),
        iterator: util_1.getValueDescriptor(exports.Symbol.for('iterator'), false, false),
        match: util_1.getValueDescriptor(exports.Symbol.for('match'), false, false),
        observable: util_1.getValueDescriptor(exports.Symbol.for('observable'), false, false),
        replace: util_1.getValueDescriptor(exports.Symbol.for('replace'), false, false),
        search: util_1.getValueDescriptor(exports.Symbol.for('search'), false, false),
        species: util_1.getValueDescriptor(exports.Symbol.for('species'), false, false),
        split: util_1.getValueDescriptor(exports.Symbol.for('split'), false, false),
        toPrimitive: util_1.getValueDescriptor(exports.Symbol.for('toPrimitive'), false, false),
        toStringTag: util_1.getValueDescriptor(exports.Symbol.for('toStringTag'), false, false),
        unscopables: util_1.getValueDescriptor(exports.Symbol.for('unscopables'), false, false)
    });
    /* Decorate the InternalSymbol object */
    defineProperties_1(InternalSymbol_1.prototype, {
        constructor: util_1.getValueDescriptor(exports.Symbol),
        toString: util_1.getValueDescriptor(function () {
            return this.__name__;
        }, false, false)
    });
    /* Decorate the Symbol.prototype */
    defineProperties_1(exports.Symbol.prototype, {
        toString: util_1.getValueDescriptor(function () {
            return 'Symbol (' + validateSymbol_1(this).__description__ + ')';
        }),
        valueOf: util_1.getValueDescriptor(function () {
            return validateSymbol_1(this);
        })
    });
    defineProperty_1(exports.Symbol.prototype, exports.Symbol.toPrimitive, util_1.getValueDescriptor(function () {
        return validateSymbol_1(this);
    }));
    defineProperty_1(exports.Symbol.prototype, exports.Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));
    defineProperty_1(InternalSymbol_1.prototype, exports.Symbol.toPrimitive, util_1.getValueDescriptor(exports.Symbol.prototype[exports.Symbol.toPrimitive], false, false, true));
    defineProperty_1(InternalSymbol_1.prototype, exports.Symbol.toStringTag, util_1.getValueDescriptor(exports.Symbol.prototype[exports.Symbol.toStringTag], false, false, true));
}
/**
 * A custom guard function that determines if an object is a symbol or not
 * @param  {any}       value The value to check to see if it is a symbol or not
 * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)
 */
function isSymbol(value) {
    return (value && (typeof value === 'symbol' || value['@@toStringTag'] === 'Symbol')) || false;
}
exports.isSymbol = isSymbol;
/**
 * Fill any missing well known symbols if the native Symbol is missing them
 */
[
    'hasInstance',
    'isConcatSpreadable',
    'iterator',
    'species',
    'replace',
    'search',
    'split',
    'match',
    'toPrimitive',
    'toStringTag',
    'unscopables',
    'observable'
].forEach(function (wellKnown) {
    if (!exports.Symbol[wellKnown]) {
        Object.defineProperty(exports.Symbol, wellKnown, util_1.getValueDescriptor(exports.Symbol.for(wellKnown), false, false));
    }
});
exports.default = exports.Symbol;


/***/ }),

/***/ "./node_modules/@dojo/shim/WeakMap.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.WeakMap = global_1.default.WeakMap;
if (!has_1.default('es6-weakmap')) {
    var DELETED_1 = {};
    var getUID_1 = function getUID() {
        return Math.floor(Math.random() * 100000000);
    };
    var generateName_1 = (function () {
        var startId = Math.floor(Date.now() % 100000000);
        return function generateName() {
            return '__wm' + getUID_1() + (startId++ + '__');
        };
    })();
    exports.WeakMap = /** @class */ (function () {
        function WeakMap(iterable) {
            this[Symbol.toStringTag] = 'WeakMap';
            Object.defineProperty(this, '_name', {
                value: generateName_1()
            });
            this._frozenEntries = [];
            if (iterable) {
                if (iterator_1.isArrayLike(iterable)) {
                    for (var i = 0; i < iterable.length; i++) {
                        var item = iterable[i];
                        this.set(item[0], item[1]);
                    }
                }
                else {
                    try {
                        for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                            var _a = tslib_1.__read(iterable_1_1.value, 2), key = _a[0], value = _a[1];
                            this.set(key, value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (iterable_1_1 && !iterable_1_1.done && (_b = iterable_1.return)) _b.call(iterable_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            var e_1, _b;
        }
        WeakMap.prototype._getFrozenEntryIndex = function (key) {
            for (var i = 0; i < this._frozenEntries.length; i++) {
                if (this._frozenEntries[i].key === key) {
                    return i;
                }
            }
            return -1;
        };
        WeakMap.prototype.delete = function (key) {
            if (key === undefined || key === null) {
                return false;
            }
            var entry = key[this._name];
            if (entry && entry.key === key && entry.value !== DELETED_1) {
                entry.value = DELETED_1;
                return true;
            }
            var frozenIndex = this._getFrozenEntryIndex(key);
            if (frozenIndex >= 0) {
                this._frozenEntries.splice(frozenIndex, 1);
                return true;
            }
            return false;
        };
        WeakMap.prototype.get = function (key) {
            if (key === undefined || key === null) {
                return undefined;
            }
            var entry = key[this._name];
            if (entry && entry.key === key && entry.value !== DELETED_1) {
                return entry.value;
            }
            var frozenIndex = this._getFrozenEntryIndex(key);
            if (frozenIndex >= 0) {
                return this._frozenEntries[frozenIndex].value;
            }
        };
        WeakMap.prototype.has = function (key) {
            if (key === undefined || key === null) {
                return false;
            }
            var entry = key[this._name];
            if (Boolean(entry && entry.key === key && entry.value !== DELETED_1)) {
                return true;
            }
            var frozenIndex = this._getFrozenEntryIndex(key);
            if (frozenIndex >= 0) {
                return true;
            }
            return false;
        };
        WeakMap.prototype.set = function (key, value) {
            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {
                throw new TypeError('Invalid value used as weak map key');
            }
            var entry = key[this._name];
            if (!entry || entry.key !== key) {
                entry = Object.create(null, {
                    key: { value: key }
                });
                if (Object.isFrozen(key)) {
                    this._frozenEntries.push(entry);
                }
                else {
                    Object.defineProperty(key, this._name, {
                        value: entry
                    });
                }
            }
            entry.value = value;
            return this;
        };
        return WeakMap;
    }());
}
exports.default = exports.WeakMap;


/***/ }),

/***/ "./node_modules/@dojo/shim/global.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var globalObject = (function () {
    if (typeof global !== 'undefined') {
        // global spec defines a reference to the global object called 'global'
        // https://github.com/tc39/proposal-global
        // `global` is also defined in NodeJS
        return global;
    }
    else if (typeof window !== 'undefined') {
        // window is defined in browsers
        return window;
    }
    else if (typeof self !== 'undefined') {
        // self is defined in WebWorkers
        return self;
    }
})();
exports.default = globalObject;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@dojo/shim/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
var string_1 = __webpack_require__("./node_modules/@dojo/shim/string.js");
var staticDone = { done: true, value: undefined };
/**
 * A class that _shims_ an iterator interface on array like objects.
 */
var ShimIterator = /** @class */ (function () {
    function ShimIterator(list) {
        this._nextIndex = -1;
        if (isIterable(list)) {
            this._nativeIterator = list[Symbol.iterator]();
        }
        else {
            this._list = list;
        }
    }
    /**
     * Return the next iteration result for the Iterator
     */
    ShimIterator.prototype.next = function () {
        if (this._nativeIterator) {
            return this._nativeIterator.next();
        }
        if (!this._list) {
            return staticDone;
        }
        if (++this._nextIndex < this._list.length) {
            return {
                done: false,
                value: this._list[this._nextIndex]
            };
        }
        return staticDone;
    };
    ShimIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    return ShimIterator;
}());
exports.ShimIterator = ShimIterator;
/**
 * A type guard for checking if something has an Iterable interface
 *
 * @param value The value to type guard against
 */
function isIterable(value) {
    return value && typeof value[Symbol.iterator] === 'function';
}
exports.isIterable = isIterable;
/**
 * A type guard for checking if something is ArrayLike
 *
 * @param value The value to type guard against
 */
function isArrayLike(value) {
    return value && typeof value.length === 'number';
}
exports.isArrayLike = isArrayLike;
/**
 * Returns the iterator for an object
 *
 * @param iterable The iterable object to return the iterator for
 */
function get(iterable) {
    if (isIterable(iterable)) {
        return iterable[Symbol.iterator]();
    }
    else if (isArrayLike(iterable)) {
        return new ShimIterator(iterable);
    }
}
exports.get = get;
/**
 * Shims the functionality of `for ... of` blocks
 *
 * @param iterable The object the provides an interator interface
 * @param callback The callback which will be called for each item of the iterable
 * @param thisArg Optional scope to pass the callback
 */
function forOf(iterable, callback, thisArg) {
    var broken = false;
    function doBreak() {
        broken = true;
    }
    /* We need to handle iteration of double byte strings properly */
    if (isArrayLike(iterable) && typeof iterable === 'string') {
        var l = iterable.length;
        for (var i = 0; i < l; ++i) {
            var char = iterable[i];
            if (i + 1 < l) {
                var code = char.charCodeAt(0);
                if (code >= string_1.HIGH_SURROGATE_MIN && code <= string_1.HIGH_SURROGATE_MAX) {
                    char += iterable[++i];
                }
            }
            callback.call(thisArg, char, iterable, doBreak);
            if (broken) {
                return;
            }
        }
    }
    else {
        var iterator = get(iterable);
        if (iterator) {
            var result = iterator.next();
            while (!result.done) {
                callback.call(thisArg, result.value, iterable, doBreak);
                if (broken) {
                    return;
                }
                result = iterator.next();
            }
        }
    }
}
exports.forOf = forOf;


/***/ }),

/***/ "./node_modules/@dojo/shim/object.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var Symbol_1 = __webpack_require__("./node_modules/@dojo/shim/Symbol.js");
if (has_1.default('es6-object')) {
    var globalObject = global_1.default.Object;
    exports.assign = globalObject.assign;
    exports.getOwnPropertyDescriptor = globalObject.getOwnPropertyDescriptor;
    exports.getOwnPropertyNames = globalObject.getOwnPropertyNames;
    exports.getOwnPropertySymbols = globalObject.getOwnPropertySymbols;
    exports.is = globalObject.is;
    exports.keys = globalObject.keys;
}
else {
    exports.keys = function symbolAwareKeys(o) {
        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });
    };
    exports.assign = function assign(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        if (target == null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(target);
        sources.forEach(function (nextSource) {
            if (nextSource) {
                // Skip over if undefined or null
                exports.keys(nextSource).forEach(function (nextKey) {
                    to[nextKey] = nextSource[nextKey];
                });
            }
        });
        return to;
    };
    exports.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(o, prop) {
        if (Symbol_1.isSymbol(prop)) {
            return Object.getOwnPropertyDescriptor(o, prop);
        }
        else {
            return Object.getOwnPropertyDescriptor(o, prop);
        }
    };
    exports.getOwnPropertyNames = function getOwnPropertyNames(o) {
        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });
    };
    exports.getOwnPropertySymbols = function getOwnPropertySymbols(o) {
        return Object.getOwnPropertyNames(o)
            .filter(function (key) { return Boolean(key.match(/^@@.+/)); })
            .map(function (key) { return Symbol.for(key.substring(2)); });
    };
    exports.is = function is(value1, value2) {
        if (value1 === value2) {
            return value1 !== 0 || 1 / value1 === 1 / value2; // -0
        }
        return value1 !== value1 && value2 !== value2; // NaN
    };
}
if (has_1.default('es2017-object')) {
    var globalObject = global_1.default.Object;
    exports.getOwnPropertyDescriptors = globalObject.getOwnPropertyDescriptors;
    exports.entries = globalObject.entries;
    exports.values = globalObject.values;
}
else {
    exports.getOwnPropertyDescriptors = function getOwnPropertyDescriptors(o) {
        return exports.getOwnPropertyNames(o).reduce(function (previous, key) {
            previous[key] = exports.getOwnPropertyDescriptor(o, key);
            return previous;
        }, {});
    };
    exports.entries = function entries(o) {
        return exports.keys(o).map(function (key) { return [key, o[key]]; });
    };
    exports.values = function values(o) {
        return exports.keys(o).map(function (key) { return o[key]; });
    };
}


/***/ }),

/***/ "./node_modules/@dojo/shim/string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var util_1 = __webpack_require__("./node_modules/@dojo/shim/support/util.js");
/**
 * The minimum location of high surrogates
 */
exports.HIGH_SURROGATE_MIN = 0xd800;
/**
 * The maximum location of high surrogates
 */
exports.HIGH_SURROGATE_MAX = 0xdbff;
/**
 * The minimum location of low surrogates
 */
exports.LOW_SURROGATE_MIN = 0xdc00;
/**
 * The maximum location of low surrogates
 */
exports.LOW_SURROGATE_MAX = 0xdfff;
if (has_1.default('es6-string') && has_1.default('es6-string-raw')) {
    exports.fromCodePoint = global_1.default.String.fromCodePoint;
    exports.raw = global_1.default.String.raw;
    exports.codePointAt = util_1.wrapNative(global_1.default.String.prototype.codePointAt);
    exports.endsWith = util_1.wrapNative(global_1.default.String.prototype.endsWith);
    exports.includes = util_1.wrapNative(global_1.default.String.prototype.includes);
    exports.normalize = util_1.wrapNative(global_1.default.String.prototype.normalize);
    exports.repeat = util_1.wrapNative(global_1.default.String.prototype.repeat);
    exports.startsWith = util_1.wrapNative(global_1.default.String.prototype.startsWith);
}
else {
    /**
     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).
     * Used by startsWith, includes, and endsWith.
     *
     * @return Normalized position.
     */
    var normalizeSubstringArgs_1 = function (name, text, search, position, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        if (text == null) {
            throw new TypeError('string.' + name + ' requires a valid string to search against.');
        }
        var length = text.length;
        position = position !== position ? (isEnd ? length : 0) : position;
        return [text, String(search), Math.min(Math.max(position, 0), length)];
    };
    exports.fromCodePoint = function fromCodePoint() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
        }
        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint
        var length = arguments.length;
        if (!length) {
            return '';
        }
        var fromCharCode = String.fromCharCode;
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var index = -1;
        var result = '';
        while (++index < length) {
            var codePoint = Number(arguments[index]);
            // Code points must be finite integers within the valid range
            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint && codePoint >= 0 && codePoint <= 0x10ffff;
            if (!isValid) {
                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);
            }
            if (codePoint <= 0xffff) {
                // BMP code point
                codeUnits.push(codePoint);
            }
            else {
                // Astral code point; split in surrogate halves
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;
                var lowSurrogate = codePoint % 0x400 + exports.LOW_SURROGATE_MIN;
                codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
    exports.raw = function raw(callSite) {
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        var rawStrings = callSite.raw;
        var result = '';
        var numSubstitutions = substitutions.length;
        if (callSite == null || callSite.raw == null) {
            throw new TypeError('string.raw requires a valid callSite object with a raw value');
        }
        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {
            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');
        }
        return result;
    };
    exports.codePointAt = function codePointAt(text, position) {
        if (position === void 0) { position = 0; }
        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt
        if (text == null) {
            throw new TypeError('string.codePointAt requries a valid string.');
        }
        var length = text.length;
        if (position !== position) {
            position = 0;
        }
        if (position < 0 || position >= length) {
            return undefined;
        }
        // Get the first code unit
        var first = text.charCodeAt(position);
        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {
            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            var second = text.charCodeAt(position + 1);
            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {
                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;
            }
        }
        return first;
    };
    exports.endsWith = function endsWith(text, search, endPosition) {
        if (endPosition == null) {
            endPosition = text.length;
        }
        _a = tslib_1.__read(normalizeSubstringArgs_1('endsWith', text, search, endPosition, true), 3), text = _a[0], search = _a[1], endPosition = _a[2];
        var start = endPosition - search.length;
        if (start < 0) {
            return false;
        }
        return text.slice(start, endPosition) === search;
        var _a;
    };
    exports.includes = function includes(text, search, position) {
        if (position === void 0) { position = 0; }
        _a = tslib_1.__read(normalizeSubstringArgs_1('includes', text, search, position), 3), text = _a[0], search = _a[1], position = _a[2];
        return text.indexOf(search, position) !== -1;
        var _a;
    };
    exports.repeat = function repeat(text, count) {
        if (count === void 0) { count = 0; }
        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat
        if (text == null) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (count !== count) {
            count = 0;
        }
        if (count < 0 || count === Infinity) {
            throw new RangeError('string.repeat requires a non-negative finite count.');
        }
        var result = '';
        while (count) {
            if (count % 2) {
                result += text;
            }
            if (count > 1) {
                text += text;
            }
            count >>= 1;
        }
        return result;
    };
    exports.startsWith = function startsWith(text, search, position) {
        if (position === void 0) { position = 0; }
        search = String(search);
        _a = tslib_1.__read(normalizeSubstringArgs_1('startsWith', text, search, position), 3), text = _a[0], search = _a[1], position = _a[2];
        var end = position + search.length;
        if (end > text.length) {
            return false;
        }
        return text.slice(position, end) === search;
        var _a;
    };
}
if (has_1.default('es2017-string')) {
    exports.padEnd = util_1.wrapNative(global_1.default.String.prototype.padEnd);
    exports.padStart = util_1.wrapNative(global_1.default.String.prototype.padStart);
}
else {
    exports.padEnd = function padEnd(text, maxLength, fillString) {
        if (fillString === void 0) { fillString = ' '; }
        if (text === null || text === undefined) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (maxLength === Infinity) {
            throw new RangeError('string.padEnd requires a non-negative finite count.');
        }
        if (maxLength === null || maxLength === undefined || maxLength < 0) {
            maxLength = 0;
        }
        var strText = String(text);
        var padding = maxLength - strText.length;
        if (padding > 0) {
            strText +=
                exports.repeat(fillString, Math.floor(padding / fillString.length)) +
                    fillString.slice(0, padding % fillString.length);
        }
        return strText;
    };
    exports.padStart = function padStart(text, maxLength, fillString) {
        if (fillString === void 0) { fillString = ' '; }
        if (text === null || text === undefined) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (maxLength === Infinity) {
            throw new RangeError('string.padStart requires a non-negative finite count.');
        }
        if (maxLength === null || maxLength === undefined || maxLength < 0) {
            maxLength = 0;
        }
        var strText = String(text);
        var padding = maxLength - strText.length;
        if (padding > 0) {
            strText =
                exports.repeat(fillString, Math.floor(padding / fillString.length)) +
                    fillString.slice(0, padding % fillString.length) +
                    strText;
        }
        return strText;
    };
}


/***/ }),

/***/ "./node_modules/@dojo/shim/support/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var has_1 = __webpack_require__("./node_modules/@dojo/has/has.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
exports.default = has_1.default;
tslib_1.__exportStar(__webpack_require__("./node_modules/@dojo/has/has.js"), exports);
/* ECMAScript 6 and 7 Features */
/* Array */
has_1.add('es6-array', function () {
    return (['from', 'of'].every(function (key) { return key in global_1.default.Array; }) &&
        ['findIndex', 'find', 'copyWithin'].every(function (key) { return key in global_1.default.Array.prototype; }));
}, true);
has_1.add('es6-array-fill', function () {
    if ('fill' in global_1.default.Array.prototype) {
        /* Some versions of Safari do not properly implement this */
        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;
    }
    return false;
}, true);
has_1.add('es7-array', function () { return 'includes' in global_1.default.Array.prototype; }, true);
/* Map */
has_1.add('es6-map', function () {
    if (typeof global_1.default.Map === 'function') {
        /*
    IE11 and older versions of Safari are missing critical ES6 Map functionality
    We wrap this in a try/catch because sometimes the Map constructor exists, but does not
    take arguments (iOS 8.4)
     */
        try {
            var map = new global_1.default.Map([[0, 1]]);
            return (map.has(0) &&
                typeof map.keys === 'function' &&
                has_1.default('es6-symbol') &&
                typeof map.values === 'function' &&
                typeof map.entries === 'function');
        }
        catch (e) {
            /* istanbul ignore next: not testing on iOS at the moment */
            return false;
        }
    }
    return false;
}, true);
/* Math */
has_1.add('es6-math', function () {
    return [
        'clz32',
        'sign',
        'log10',
        'log2',
        'log1p',
        'expm1',
        'cosh',
        'sinh',
        'tanh',
        'acosh',
        'asinh',
        'atanh',
        'trunc',
        'fround',
        'cbrt',
        'hypot'
    ].every(function (name) { return typeof global_1.default.Math[name] === 'function'; });
}, true);
has_1.add('es6-math-imul', function () {
    if ('imul' in global_1.default.Math) {
        /* Some versions of Safari on ios do not properly implement this */
        return Math.imul(0xffffffff, 5) === -5;
    }
    return false;
}, true);
/* Object */
has_1.add('es6-object', function () {
    return (has_1.default('es6-symbol') &&
        ['assign', 'is', 'getOwnPropertySymbols', 'setPrototypeOf'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; }));
}, true);
has_1.add('es2017-object', function () {
    return ['values', 'entries', 'getOwnPropertyDescriptors'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; });
}, true);
/* Observable */
has_1.add('es-observable', function () { return typeof global_1.default.Observable !== 'undefined'; }, true);
/* Promise */
has_1.add('es6-promise', function () { return typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'); }, true);
/* Set */
has_1.add('es6-set', function () {
    if (typeof global_1.default.Set === 'function') {
        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */
        var set = new global_1.default.Set([1]);
        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');
    }
    return false;
}, true);
/* String */
has_1.add('es6-string', function () {
    return ([
        /* static methods */
        'fromCodePoint'
    ].every(function (key) { return typeof global_1.default.String[key] === 'function'; }) &&
        [
            /* instance methods */
            'codePointAt',
            'normalize',
            'repeat',
            'startsWith',
            'endsWith',
            'includes'
        ].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; }));
}, true);
has_1.add('es6-string-raw', function () {
    function getCallSite(callSite) {
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        var result = tslib_1.__spread(callSite);
        result.raw = callSite.raw;
        return result;
    }
    if ('raw' in global_1.default.String) {
        var b = 1;
        var callSite = getCallSite(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["a\n", ""], ["a\\n", ""])), b);
        callSite.raw = ['a\\n'];
        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\n';
        return supportsTrunc;
    }
    return false;
}, true);
has_1.add('es2017-string', function () {
    return ['padStart', 'padEnd'].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; });
}, true);
/* Symbol */
has_1.add('es6-symbol', function () { return typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol'; }, true);
/* WeakMap */
has_1.add('es6-weakmap', function () {
    if (typeof global_1.default.WeakMap !== 'undefined') {
        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */
        var key1 = {};
        var key2 = {};
        var map = new global_1.default.WeakMap([[key1, 1]]);
        Object.freeze(key1);
        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');
    }
    return false;
}, true);
/* Miscellaneous features */
has_1.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); }, true);
has_1.add('postmessage', function () {
    // If window is undefined, and we have postMessage, it probably means we're in a web worker. Web workers have
    // post message but it doesn't work how we expect it to, so it's best just to pretend it doesn't exist.
    return typeof global_1.default.window !== 'undefined' && typeof global_1.default.postMessage === 'function';
}, true);
has_1.add('raf', function () { return typeof global_1.default.requestAnimationFrame === 'function'; }, true);
has_1.add('setimmediate', function () { return typeof global_1.default.setImmediate !== 'undefined'; }, true);
/* DOM Features */
has_1.add('dom-mutationobserver', function () {
    if (has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver)) {
        // IE11 has an unreliable MutationObserver implementation where setProperty() does not
        // generate a mutation event, observers can crash, and the queue does not drain
        // reliably. The following feature test was adapted from
        // https://gist.github.com/t10ko/4aceb8c71681fdb275e33efe5e576b14
        var example = document.createElement('div');
        /* tslint:disable-next-line:variable-name */
        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
        var observer = new HostMutationObserver(function () { });
        observer.observe(example, { attributes: true });
        example.style.setProperty('display', 'block');
        return Boolean(observer.takeRecords().length);
    }
    return false;
}, true);
var templateObject_1;


/***/ }),

/***/ "./node_modules/@dojo/shim/support/queue.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
function executeTask(item) {
    if (item && item.isActive && item.callback) {
        item.callback();
    }
}
function getQueueHandle(item, destructor) {
    return {
        destroy: function () {
            this.destroy = function () { };
            item.isActive = false;
            item.callback = null;
            if (destructor) {
                destructor();
            }
        }
    };
}
var checkMicroTaskQueue;
var microTasks;
/**
 * Schedules a callback to the macrotask queue.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueTask = (function () {
    var destructor;
    var enqueue;
    // Since the IE implementation of `setImmediate` is not flawless, we will test for `postMessage` first.
    if (has_1.default('postmessage')) {
        var queue_1 = [];
        global_1.default.addEventListener('message', function (event) {
            // Confirm that the event was triggered by the current window and by this particular implementation.
            if (event.source === global_1.default && event.data === 'dojo-queue-message') {
                event.stopPropagation();
                if (queue_1.length) {
                    executeTask(queue_1.shift());
                }
            }
        });
        enqueue = function (item) {
            queue_1.push(item);
            global_1.default.postMessage('dojo-queue-message', '*');
        };
    }
    else if (has_1.default('setimmediate')) {
        destructor = global_1.default.clearImmediate;
        enqueue = function (item) {
            return setImmediate(executeTask.bind(null, item));
        };
    }
    else {
        destructor = global_1.default.clearTimeout;
        enqueue = function (item) {
            return setTimeout(executeTask.bind(null, item), 0);
        };
    }
    function queueTask(callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        var id = enqueue(item);
        return getQueueHandle(item, destructor &&
            function () {
                destructor(id);
            });
    }
    // TODO: Use aspect.before when it is available.
    return has_1.default('microtasks')
        ? queueTask
        : function (callback) {
            checkMicroTaskQueue();
            return queueTask(callback);
        };
})();
// When no mechanism for registering microtasks is exposed by the environment, microtasks will
// be queued and then executed in a single macrotask before the other macrotasks are executed.
if (!has_1.default('microtasks')) {
    var isMicroTaskQueued_1 = false;
    microTasks = [];
    checkMicroTaskQueue = function () {
        if (!isMicroTaskQueued_1) {
            isMicroTaskQueued_1 = true;
            exports.queueTask(function () {
                isMicroTaskQueued_1 = false;
                if (microTasks.length) {
                    var item = void 0;
                    while ((item = microTasks.shift())) {
                        executeTask(item);
                    }
                }
            });
        }
    };
}
/**
 * Schedules an animation task with `window.requestAnimationFrame` if it exists, or with `queueTask` otherwise.
 *
 * Since requestAnimationFrame's behavior does not match that expected from `queueTask`, it is not used there.
 * However, at times it makes more sense to delegate to requestAnimationFrame; hence the following method.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueAnimationTask = (function () {
    if (!has_1.default('raf')) {
        return exports.queueTask;
    }
    function queueAnimationTask(callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        var rafId = requestAnimationFrame(executeTask.bind(null, item));
        return getQueueHandle(item, function () {
            cancelAnimationFrame(rafId);
        });
    }
    // TODO: Use aspect.before when it is available.
    return has_1.default('microtasks')
        ? queueAnimationTask
        : function (callback) {
            checkMicroTaskQueue();
            return queueAnimationTask(callback);
        };
})();
/**
 * Schedules a callback to the microtask queue.
 *
 * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native
 * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask
 * registered with `queueTask` or `queueAnimationTask`.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueMicroTask = (function () {
    var enqueue;
    if (has_1.default('host-node')) {
        enqueue = function (item) {
            global_1.default.process.nextTick(executeTask.bind(null, item));
        };
    }
    else if (has_1.default('es6-promise')) {
        enqueue = function (item) {
            global_1.default.Promise.resolve(item).then(executeTask);
        };
    }
    else if (has_1.default('dom-mutationobserver')) {
        /* tslint:disable-next-line:variable-name */
        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
        var node_1 = document.createElement('div');
        var queue_2 = [];
        var observer = new HostMutationObserver(function () {
            while (queue_2.length > 0) {
                var item = queue_2.shift();
                if (item && item.isActive && item.callback) {
                    item.callback();
                }
            }
        });
        observer.observe(node_1, { attributes: true });
        enqueue = function (item) {
            queue_2.push(item);
            node_1.setAttribute('queueStatus', '1');
        };
    }
    else {
        enqueue = function (item) {
            checkMicroTaskQueue();
            microTasks.push(item);
        };
    }
    return function (callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        enqueue(item);
        return getQueueHandle(item);
    };
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@dojo/shim/support/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper function to generate a value property descriptor
 *
 * @param value        The value the property descriptor should be set to
 * @param enumerable   If the property should be enumberable, defaults to false
 * @param writable     If the property should be writable, defaults to true
 * @param configurable If the property should be configurable, defaults to true
 * @return             The property descriptor object
 */
function getValueDescriptor(value, enumerable, writable, configurable) {
    if (enumerable === void 0) { enumerable = false; }
    if (writable === void 0) { writable = true; }
    if (configurable === void 0) { configurable = true; }
    return {
        value: value,
        enumerable: enumerable,
        writable: writable,
        configurable: configurable
    };
}
exports.getValueDescriptor = getValueDescriptor;
function wrapNative(nativeFunction) {
    return function (target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return nativeFunction.apply(target, args);
    };
}
exports.wrapNative = wrapNative;


/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const i18n = __webpack_require__("./node_modules/@dojo/i18n/i18n.js");
const loadCldrData = __webpack_require__("./node_modules/@dojo/i18n/cldr/load.js").default;
const systemLocale = i18n.systemLocale;
const userLocale = systemLocale.replace(/^([a-z]{2}).*/i, '$1');
const isUserLocaleSupported = userLocale === 'en' ||
    ["es"].some(function (locale) {
        return locale === systemLocale || locale === userLocale;
    });
loadCldrData({});
i18n.switchLocale(isUserLocaleSupported ? systemLocale : 'en');


/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,src/Foo!./src/Foo.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("src/Foo").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Foo.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Bar.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("widgets").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Bar.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Baz.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("widgets").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Baz.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( root, factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory();
	} else {
		// Global
		root.Cldr = factory();
	}

}( this, function() {


	var arrayIsArray = Array.isArray || function( obj ) {
		return Object.prototype.toString.call( obj ) === "[object Array]";
	};




	var pathNormalize = function( path, attributes ) {
		if ( arrayIsArray( path ) ) {
			path = path.join( "/" );
		}
		if ( typeof path !== "string" ) {
			throw new Error( "invalid path \"" + path + "\"" );
		}
		// 1: Ignore leading slash `/`
		// 2: Ignore leading `cldr/`
		path = path
			.replace( /^\// , "" ) /* 1 */
			.replace( /^cldr\// , "" ); /* 2 */

		// Replace {attribute}'s
		path = path.replace( /{[a-zA-Z]+}/g, function( name ) {
			name = name.replace( /^{([^}]*)}$/, "$1" );
			return attributes[ name ];
		});

		return path.split( "/" );
	};




	var arraySome = function( array, callback ) {
		var i, length;
		if ( array.some ) {
			return array.some( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			if ( callback( array[ i ], i, array ) ) {
				return true;
			}
		}
		return false;
	};




	/**
	 * Return the maximized language id as defined in
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. Canonicalize.
	 * 1.1 Make sure the input locale is in canonical form: uses the right
	 * separator, and has the right casing.
	 * TODO Right casing? What df? It seems languages are lowercase, scripts are
	 * Capitalized, territory is uppercase. I am leaving this as an exercise to
	 * the user.
	 *
	 * 1.2 Replace any deprecated subtags with their canonical values using the
	 * <alias> data in supplemental metadata. Use the first value in the
	 * replacement list, if it exists. Language tag replacements may have multiple
	 * parts, such as "sh"  "sr_Latn" or mo"  "ro_MD". In such a case, the
	 * original script and/or region are retained if there is one. Thus
	 * "sh_Arab_AQ"  "sr_Arab_AQ", not "sr_Latn_AQ".
	 * TODO What <alias> data?
	 *
	 * 1.3 If the tag is grandfathered (see <variable id="$grandfathered"
	 * type="choice"> in the supplemental data), then return it.
	 * TODO grandfathered?
	 *
	 * 1.4 Remove the script code 'Zzzz' and the region code 'ZZ' if they occur.
	 * 1.5 Get the components of the cleaned-up source tag (languages, scripts,
	 * and regions), plus any variants and extensions.
	 * 2. Lookup. Lookup each of the following in order, and stop on the first
	 * match:
	 * 2.1 languages_scripts_regions
	 * 2.2 languages_regions
	 * 2.3 languages_scripts
	 * 2.4 languages
	 * 2.5 und_scripts
	 * 3. Return
	 * 3.1 If there is no match, either return an error value, or the match for
	 * "und" (in APIs where a valid language tag is required).
	 * 3.2 Otherwise there is a match = languagem_scriptm_regionm
	 * 3.3 Let xr = xs if xs is not empty, and xm otherwise.
	 * 3.4 Return the language tag composed of languager _ scriptr _ regionr +
	 * variants + extensions.
	 *
	 * @subtags [Array] normalized language id subtags tuple (see init.js).
	 */
	var coreLikelySubtags = function( Cldr, cldr, subtags, options ) {
		var match, matchFound,
			language = subtags[ 0 ],
			script = subtags[ 1 ],
			sep = Cldr.localeSep,
			territory = subtags[ 2 ],
			variants = subtags.slice( 3, 4 );
		options = options || {};

		// Skip if (language, script, territory) is not empty [3.3]
		if ( language !== "und" && script !== "Zzzz" && territory !== "ZZ" ) {
			return [ language, script, territory ].concat( variants );
		}

		// Skip if no supplemental likelySubtags data is present
		if ( typeof cldr.get( "supplemental/likelySubtags" ) === "undefined" ) {
			return;
		}

		// [2]
		matchFound = arraySome([
			[ language, script, territory ],
			[ language, territory ],
			[ language, script ],
			[ language ],
			[ "und", script ]
		], function( test ) {
			return match = !(/\b(Zzzz|ZZ)\b/).test( test.join( sep ) ) /* [1.4] */ && cldr.get( [ "supplemental/likelySubtags", test.join( sep ) ] );
		});

		// [3]
		if ( matchFound ) {
			// [3.2 .. 3.4]
			match = match.split( sep );
			return [
				language !== "und" ? language : match[ 0 ],
				script !== "Zzzz" ? script : match[ 1 ],
				territory !== "ZZ" ? territory : match[ 2 ]
			].concat( variants );
		} else if ( options.force ) {
			// [3.1.2]
			return cldr.get( "supplemental/likelySubtags/und" ).split( sep );
		} else {
			// [3.1.1]
			return;
		}
	};



	/**
	 * Given a locale, remove any fields that Add Likely Subtags would add.
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. First get max = AddLikelySubtags(inputLocale). If an error is signaled,
	 * return it.
	 * 2. Remove the variants from max.
	 * 3. Then for trial in {language, language _ region, language _ script}. If
	 * AddLikelySubtags(trial) = max, then return trial + variants.
	 * 4. If you do not get a match, return max + variants.
	 * 
	 * @maxLanguageId [Array] maxLanguageId tuple (see init.js).
	 */
	var coreRemoveLikelySubtags = function( Cldr, cldr, maxLanguageId ) {
		var match, matchFound,
			language = maxLanguageId[ 0 ],
			script = maxLanguageId[ 1 ],
			territory = maxLanguageId[ 2 ],
			variants = maxLanguageId[ 3 ];

		// [3]
		matchFound = arraySome([
			[ [ language, "Zzzz", "ZZ" ], [ language ] ],
			[ [ language, "Zzzz", territory ], [ language, territory ] ],
			[ [ language, script, "ZZ" ], [ language, script ] ]
		], function( test ) {
			var result = coreLikelySubtags( Cldr, cldr, test[ 0 ] );
			match = test[ 1 ];
			return result && result[ 0 ] === maxLanguageId[ 0 ] &&
				result[ 1 ] === maxLanguageId[ 1 ] &&
				result[ 2 ] === maxLanguageId[ 2 ];
		});

		if ( matchFound ) {
			if ( variants ) {
				match.push( variants );
			}
			return match;
		}

		// [4]
		return maxLanguageId;
	};




	/**
	 * subtags( locale )
	 *
	 * @locale [String]
	 */
	var coreSubtags = function( locale ) {
		var aux, unicodeLanguageId,
			subtags = [];

		locale = locale.replace( /_/, "-" );

		// Unicode locale extensions.
		aux = locale.split( "-u-" );
		if ( aux[ 1 ] ) {
			aux[ 1 ] = aux[ 1 ].split( "-t-" );
			locale = aux[ 0 ] + ( aux[ 1 ][ 1 ] ? "-t-" + aux[ 1 ][ 1 ] : "");
			subtags[ 4 /* unicodeLocaleExtensions */ ] = aux[ 1 ][ 0 ];
		}

		// TODO normalize transformed extensions. Currently, skipped.
		// subtags[ x ] = locale.split( "-t-" )[ 1 ];
		unicodeLanguageId = locale.split( "-t-" )[ 0 ];

		// unicode_language_id = "root"
		//   | unicode_language_subtag         
		//     (sep unicode_script_subtag)? 
		//     (sep unicode_region_subtag)?
		//     (sep unicode_variant_subtag)* ;
		//
		// Although unicode_language_subtag = alpha{2,8}, I'm using alpha{2,3}. Because, there's no language on CLDR lengthier than 3.
		aux = unicodeLanguageId.match( /^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/ );
		if ( aux === null ) {
			return [ "und", "Zzzz", "ZZ" ];
		}
		subtags[ 0 /* language */ ] = aux[ 10 ] /* root */ || aux[ 2 ] || "und";
		subtags[ 1 /* script */ ] = aux[ 4 ] || "Zzzz";
		subtags[ 2 /* territory */ ] = aux[ 6 ] || "ZZ";
		if ( aux[ 7 ] && aux[ 7 ].length ) {
			subtags[ 3 /* variant */ ] = aux[ 7 ].slice( 1 ) /* remove leading "-" */;
		}

		// 0: language
		// 1: script
		// 2: territory (aka region)
		// 3: variant
		// 4: unicodeLocaleExtensions
		return subtags;
	};




	var arrayForEach = function( array, callback ) {
		var i, length;
		if ( array.forEach ) {
			return array.forEach( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			callback( array[ i ], i, array );
		}
	};




	/**
	 * bundleLookup( minLanguageId )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @cldr [Cldr instance]
	 *
	 * @minLanguageId [String] requested languageId after applied remove likely subtags.
	 */
	var bundleLookup = function( Cldr, cldr, minLanguageId ) {
		var availableBundleMap = Cldr._availableBundleMap,
			availableBundleMapQueue = Cldr._availableBundleMapQueue;

		if ( availableBundleMapQueue.length ) {
			arrayForEach( availableBundleMapQueue, function( bundle ) {
				var existing, maxBundle, minBundle, subtags;
				subtags = coreSubtags( bundle );
				maxBundle = coreLikelySubtags( Cldr, cldr, subtags );
				minBundle = coreRemoveLikelySubtags( Cldr, cldr, maxBundle );
				minBundle = minBundle.join( Cldr.localeSep );
				existing = availableBundleMapQueue[ minBundle ];
				if ( existing && existing.length < bundle.length ) {
					return;
				}
				availableBundleMap[ minBundle ] = bundle;
			});
			Cldr._availableBundleMapQueue = [];
		}

		return availableBundleMap[ minLanguageId ] || null;
	};




	var objectKeys = function( object ) {
		var i,
			result = [];

		if ( Object.keys ) {
			return Object.keys( object );
		}

		for ( i in object ) {
			result.push( i );
		}

		return result;
	};




	var createError = function( code, attributes ) {
		var error, message;

		message = code + ( attributes && JSON ? ": " + JSON.stringify( attributes ) : "" );
		error = new Error( message );
		error.code = code;

		// extend( error, attributes );
		arrayForEach( objectKeys( attributes ), function( attribute ) {
			error[ attribute ] = attributes[ attribute ];
		});

		return error;
	};




	var validate = function( code, check, attributes ) {
		if ( !check ) {
			throw createError( code, attributes );
		}
	};




	var validatePresence = function( value, name ) {
		validate( "E_MISSING_PARAMETER", typeof value !== "undefined", {
			name: name
		});
	};




	var validateType = function( value, name, check, expected ) {
		validate( "E_INVALID_PAR_TYPE", check, {
			expected: expected,
			name: name,
			value: value
		});
	};




	var validateTypePath = function( value, name ) {
		validateType( value, name, typeof value === "string" || arrayIsArray( value ), "String or Array" );
	};




	/**
	 * Function inspired by jQuery Core, but reduced to our use case.
	 */
	var isPlainObject = function( obj ) {
		return obj !== null && "" + obj === "[object Object]";
	};




	var validateTypePlainObject = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || isPlainObject( value ), "Plain Object" );
	};




	var validateTypeString = function( value, name ) {
		validateType( value, name, typeof value === "string", "a string" );
	};




	// @path: normalized path
	var resourceGet = function( data, path ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			node = node[ path[ i ] ];
			if ( !node ) {
				return undefined;
			}
		}
		return node[ path[ i ] ];
	};




	/**
	 * setAvailableBundles( Cldr, json )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @json resolved/unresolved cldr data.
	 *
	 * Set available bundles queue based on passed json CLDR data. Considers a bundle as any String at /main/{bundle}.
	 */
	var coreSetAvailableBundles = function( Cldr, json ) {
		var bundle,
			availableBundleMapQueue = Cldr._availableBundleMapQueue,
			main = resourceGet( json, [ "main" ] );

		if ( main ) {
			for ( bundle in main ) {
				if ( main.hasOwnProperty( bundle ) && bundle !== "root" &&
							availableBundleMapQueue.indexOf( bundle ) === -1 ) {
					availableBundleMapQueue.push( bundle );
				}
			}
		}
	};



	var alwaysArray = function( somethingOrArray ) {
		return arrayIsArray( somethingOrArray ) ?  somethingOrArray : [ somethingOrArray ];
	};


	var jsonMerge = (function() {

	// Returns new deeply merged JSON.
	//
	// Eg.
	// merge( { a: { b: 1, c: 2 } }, { a: { b: 3, d: 4 } } )
	// -> { a: { b: 3, c: 2, d: 4 } }
	//
	// @arguments JSON's
	// 
	var merge = function() {
		var destination = {},
			sources = [].slice.call( arguments, 0 );
		arrayForEach( sources, function( source ) {
			var prop;
			for ( prop in source ) {
				if ( prop in destination && typeof destination[ prop ] === "object" && !arrayIsArray( destination[ prop ] ) ) {

					// Merge Objects
					destination[ prop ] = merge( destination[ prop ], source[ prop ] );

				} else {

					// Set new values
					destination[ prop ] = source[ prop ];

				}
			}
		});
		return destination;
	};

	return merge;

}());


	/**
	 * load( Cldr, source, jsons )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @source [Object]
	 *
	 * @jsons [arguments]
	 */
	var coreLoad = function( Cldr, source, jsons ) {
		var i, j, json;

		validatePresence( jsons[ 0 ], "json" );

		// Support arbitrary parameters, e.g., `Cldr.load({...}, {...})`.
		for ( i = 0; i < jsons.length; i++ ) {

			// Support array parameters, e.g., `Cldr.load([{...}, {...}])`.
			json = alwaysArray( jsons[ i ] );

			for ( j = 0; j < json.length; j++ ) {
				validateTypePlainObject( json[ j ], "json" );
				source = jsonMerge( source, json[ j ] );
				coreSetAvailableBundles( Cldr, json[ j ] );
			}
		}

		return source;
	};



	var itemGetResolved = function( Cldr, path, attributes ) {
		// Resolve path
		var normalizedPath = pathNormalize( path, attributes );

		return resourceGet( Cldr._resolved, normalizedPath );
	};




	/**
	 * new Cldr()
	 */
	var Cldr = function( locale ) {
		this.init( locale );
	};

	// Build optimization hack to avoid duplicating functions across modules.
	Cldr._alwaysArray = alwaysArray;
	Cldr._coreLoad = coreLoad;
	Cldr._createError = createError;
	Cldr._itemGetResolved = itemGetResolved;
	Cldr._jsonMerge = jsonMerge;
	Cldr._pathNormalize = pathNormalize;
	Cldr._resourceGet = resourceGet;
	Cldr._validatePresence = validatePresence;
	Cldr._validateType = validateType;
	Cldr._validateTypePath = validateTypePath;
	Cldr._validateTypePlainObject = validateTypePlainObject;

	Cldr._availableBundleMap = {};
	Cldr._availableBundleMapQueue = [];
	Cldr._resolved = {};

	// Allow user to override locale separator "-" (default) | "_". According to http://www.unicode.org/reports/tr35/#Unicode_language_identifier, both "-" and "_" are valid locale separators (eg. "en_GB", "en-GB"). According to http://unicode.org/cldr/trac/ticket/6786 its usage must be consistent throughout the data set.
	Cldr.localeSep = "-";

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved cldr data.
	 */
	Cldr.load = function() {
		Cldr._resolved = coreLoad( Cldr, Cldr._resolved, arguments );
	};

	/**
	 * .init() automatically run on instantiation/construction.
	 */
	Cldr.prototype.init = function( locale ) {
		var attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant,
			sep = Cldr.localeSep,
			unicodeLocaleExtensionsRaw = "";

		validatePresence( locale, "locale" );
		validateTypeString( locale, "locale" );

		subtags = coreSubtags( locale );

		if ( subtags.length === 5 ) {
			unicodeLocaleExtensions = subtags.pop();
			unicodeLocaleExtensionsRaw = sep + "u" + sep + unicodeLocaleExtensions;
			// Remove trailing null when there is unicodeLocaleExtensions but no variants.
			if ( !subtags[ 3 ] ) {
				subtags.pop();
			}
		}
		variant = subtags[ 3 ];

		// Normalize locale code.
		// Get (or deduce) the "triple subtags": language, territory (also aliased as region), and script subtags.
		// Get the variant subtags (calendar, collation, currency, etc).
		// refs:
		// - http://www.unicode.org/reports/tr35/#Field_Definitions
		// - http://www.unicode.org/reports/tr35/#Language_and_Locale_IDs
		// - http://www.unicode.org/reports/tr35/#Unicode_locale_identifier

		// When a locale id does not specify a language, or territory (region), or script, they are obtained by Likely Subtags.
		maxLanguageId = coreLikelySubtags( Cldr, this, subtags, { force: true } ) || subtags;
		language = maxLanguageId[ 0 ];
		script = maxLanguageId[ 1 ];
		territory = maxLanguageId[ 2 ];

		minLanguageId = coreRemoveLikelySubtags( Cldr, this, maxLanguageId ).join( sep );

		// Set attributes
		this.attributes = attributes = {
			bundle: bundleLookup( Cldr, this, minLanguageId ),

			// Unicode Language Id
			minLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,
			maxLanguageId: maxLanguageId.join( sep ) + unicodeLocaleExtensionsRaw,

			// Unicode Language Id Subtabs
			language: language,
			script: script,
			territory: territory,
			region: territory, /* alias */
			variant: variant
		};

		// Unicode locale extensions.
		unicodeLocaleExtensions && ( "-" + unicodeLocaleExtensions ).replace( /-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function( attribute, key, type ) {

			if ( key ) {

				// Extension is in the `keyword` form.
				attributes[ "u" + key ] = type;
			} else {

				// Extension is in the `attribute` form.
				attributes[ "u" + attribute ] = true;
			}
		});

		this.locale = locale;
	};

	/**
	 * .get()
	 */
	Cldr.prototype.get = function( path ) {

		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		return itemGetResolved( Cldr, path, this.attributes );
	};

	/**
	 * .main()
	 */
	Cldr.prototype.main = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		validate( "E_MISSING_BUNDLE", this.attributes.bundle !== null, {
			locale: this.locale
		});

		path = alwaysArray( path );
		return this.get( [ "main/{bundle}" ].concat( path ) );
	};

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/event.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var pathNormalize = Cldr._pathNormalize,
		validatePresence = Cldr._validatePresence,
		validateType = Cldr._validateType;

/*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

var EventEmitter;
/* jshint ignore:start */
EventEmitter = (function () {


	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (evt instanceof RegExp) {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (evt instanceof RegExp) {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	return EventEmitter;
}());
/* jshint ignore:end */



	var validateTypeFunction = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || typeof value === "function", "Function" );
	};




	var superGet, superInit,
		globalEe = new EventEmitter();

	function validateTypeEvent( value, name ) {
		validateType( value, name, typeof value === "string" || value instanceof RegExp, "String or RegExp" );
	}

	function validateThenCall( method, self ) {
		return function( event, listener ) {
			validatePresence( event, "event" );
			validateTypeEvent( event, "event" );

			validatePresence( listener, "listener" );
			validateTypeFunction( listener, "listener" );

			return self[ method ].apply( self, arguments );
		};
	}

	function off( self ) {
		return validateThenCall( "off", self );
	}

	function on( self ) {
		return validateThenCall( "on", self );
	}

	function once( self ) {
		return validateThenCall( "once", self );
	}

	Cldr.off = off( globalEe );
	Cldr.on = on( globalEe );
	Cldr.once = once( globalEe );

	/**
	 * Overload Cldr.prototype.init().
	 */
	superInit = Cldr.prototype.init;
	Cldr.prototype.init = function() {
		var ee;
		this.ee = ee = new EventEmitter();
		this.off = off( ee );
		this.on = on( ee );
		this.once = once( ee );
		superInit.apply( this, arguments );
	};

	/**
	 * getOverload is encapsulated, because of cldr/unresolved. If it's loaded
	 * after cldr/event (and note it overwrites .get), it can trigger this
	 * overload again.
	 */
	function getOverload() {

		/**
		 * Overload Cldr.prototype.get().
		 */
		superGet = Cldr.prototype.get;
		Cldr.prototype.get = function( path ) {
			var value = superGet.apply( this, arguments );
			path = pathNormalize( path, this.attributes ).join( "/" );
			globalEe.trigger( "get", [ path, value ] );
			this.ee.trigger( "get", [ path, value ] );
			return value;
		};
	}

	Cldr._eventInit = getOverload;
	getOverload();

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/supplemental.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var alwaysArray = Cldr._alwaysArray;



	var supplementalMain = function( cldr ) {

		var prepend, supplemental;
		
		prepend = function( prepend ) {
			return function( path ) {
				path = alwaysArray( path );
				return cldr.get( [ prepend ].concat( path ) );
			};
		};

		supplemental = prepend( "supplemental" );

		// Week Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Week_Data
		supplemental.weekData = prepend( "supplemental/weekData" );

		supplemental.weekData.firstDay = function() {
			return cldr.get( "supplemental/weekData/firstDay/{territory}" ) ||
				cldr.get( "supplemental/weekData/firstDay/001" );
		};

		supplemental.weekData.minDays = function() {
			var minDays = cldr.get( "supplemental/weekData/minDays/{territory}" ) ||
				cldr.get( "supplemental/weekData/minDays/001" );
			return parseInt( minDays, 10 );
		};

		// Time Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
		supplemental.timeData = prepend( "supplemental/timeData" );

		supplemental.timeData.allowed = function() {
			return cldr.get( "supplemental/timeData/{territory}/_allowed" ) ||
				cldr.get( "supplemental/timeData/001/_allowed" );
		};

		supplemental.timeData.preferred = function() {
			return cldr.get( "supplemental/timeData/{territory}/_preferred" ) ||
				cldr.get( "supplemental/timeData/001/_preferred" );
		};

		return supplemental;

	};




	var initSuper = Cldr.prototype.init;

	/**
	 * .init() automatically ran on construction.
	 *
	 * Overload .init().
	 */
	Cldr.prototype.init = function() {
		initSuper.apply( this, arguments );
		this.supplemental = supplementalMain( this );
	};

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/unresolved.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var coreLoad = Cldr._coreLoad;
	var jsonMerge = Cldr._jsonMerge;
	var pathNormalize = Cldr._pathNormalize;
	var resourceGet = Cldr._resourceGet;
	var validatePresence = Cldr._validatePresence;
	var validateTypePath = Cldr._validateTypePath;



	var bundleParentLookup = function( Cldr, locale ) {
		var normalizedPath, parent;

		if ( locale === "root" ) {
			return;
		}

		// First, try to find parent on supplemental data.
		normalizedPath = pathNormalize( [ "supplemental/parentLocales/parentLocale", locale ] );
		parent = resourceGet( Cldr._resolved, normalizedPath ) || resourceGet( Cldr._raw, normalizedPath );
		if ( parent ) {
			return parent;
		}

		// Or truncate locale.
		parent = locale.substr( 0, locale.lastIndexOf( Cldr.localeSep ) );
		if ( !parent ) {
			return "root";
		}

		return parent;
	};




	// @path: normalized path
	var resourceSet = function( data, path, value ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			if ( !node[ path[ i ] ] ) {
				node[ path[ i ] ] = {};
			}
			node = node[ path[ i ] ];
		}
		node[ path[ i ] ] = value;
	};


	var itemLookup = (function() {

	var lookup;

	lookup = function( Cldr, locale, path, attributes, childLocale ) {
		var normalizedPath, parent, value;

		// 1: Finish recursion
		// 2: Avoid infinite loop
		if ( typeof locale === "undefined" /* 1 */ || locale === childLocale /* 2 */ ) {
			return;
		}

		// Resolve path
		normalizedPath = pathNormalize( path, attributes );

		// Check resolved (cached) data first
		// 1: Due to #16, never use the cached resolved non-leaf nodes. It may not
		//    represent its leafs in its entirety.
		value = resourceGet( Cldr._resolved, normalizedPath );
		if ( value && typeof value !== "object" /* 1 */ ) {
			return value;
		}

		// Check raw data
		value = resourceGet( Cldr._raw, normalizedPath );

		if ( !value ) {
			// Or, lookup at parent locale
			parent = bundleParentLookup( Cldr, locale );
			value = lookup( Cldr, parent, path, jsonMerge( attributes, { bundle: parent }), locale );
		}

		if ( value ) {
			// Set resolved (cached)
			resourceSet( Cldr._resolved, normalizedPath, value );
		}

		return value;
	};

	return lookup;

}());


	Cldr._raw = {};

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved or unresolved cldr data.
	 * Overwrite Cldr.load().
	 */
	Cldr.load = function() {
		Cldr._raw = coreLoad( Cldr, Cldr._raw, arguments );
	};

	/**
	 * Overwrite Cldr.prototype.get().
	 */
	Cldr.prototype.get = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		// 1: use bundle as locale on item lookup for simplification purposes, because no other extended subtag is used anyway on bundle parent lookup.
		// 2: during init(), this method is called, but bundle is yet not defined. Use "" as a workaround in this very specific scenario.
		return itemLookup( Cldr, this.attributes && this.attributes.bundle /* 1 */ || "" /* 2 */, path, this.attributes );
	};

	// In case cldr/unresolved is loaded after cldr/event, we trigger its overloads again. Because, .get is overwritten in here.
	if ( Cldr._eventInit ) {
		Cldr._eventInit();
	}

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/node_main.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */

// Cldr
module.exports = __webpack_require__( "./node_modules/cldrjs/dist/cldr.js" );

// Extent Cldr with the following modules
__webpack_require__( "./node_modules/cldrjs/dist/cldr/event.js" );
__webpack_require__( "./node_modules/cldrjs/dist/cldr/supplemental.js" );
__webpack_require__( "./node_modules/cldrjs/dist/cldr/unresolved.js" );


/***/ }),

/***/ "./node_modules/globalize/dist/globalize.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"cldr/event"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ) );
	} else {

		// Global
		root.Globalize = factory( root.Cldr );
	}
}( this, function( Cldr ) {


/**
 * A toString method that outputs meaningful values for objects or arrays and
 * still performs as fast as a plain string in case variable is string, or as
 * fast as `"" + number` in case variable is a number.
 * Ref: http://jsperf.com/my-stringify
 */
var toString = function( variable ) {
	return typeof variable === "string" ? variable : ( typeof variable === "number" ? "" +
		variable : JSON.stringify( variable ) );
};




/**
 * formatMessage( message, data )
 *
 * @message [String] A message with optional {vars} to be replaced.
 *
 * @data [Array or JSON] Object with replacing-variables content.
 *
 * Return the formatted message. For example:
 *
 * - formatMessage( "{0} second", [ 1 ] ); // 1 second
 *
 * - formatMessage( "{0}/{1}", ["m", "s"] ); // m/s
 *
 * - formatMessage( "{name} <{email}>", {
 *     name: "Foo",
 *     email: "bar@baz.qux"
 *   }); // Foo <bar@baz.qux>
 */
var formatMessage = function( message, data ) {

	// Replace {attribute}'s
	message = message.replace( /{[0-9a-zA-Z-_. ]+}/g, function( name ) {
		name = name.replace( /^{([^}]*)}$/, "$1" );
		return toString( data[ name ] );
	});

	return message;
};




var objectExtend = function() {
	var destination = arguments[ 0 ],
		sources = [].slice.call( arguments, 1 );

	sources.forEach(function( source ) {
		var prop;
		for ( prop in source ) {
			destination[ prop ] = source[ prop ];
		}
	});

	return destination;
};




var createError = function( code, message, attributes ) {
	var error;

	message = code + ( message ? ": " + formatMessage( message, attributes ) : "" );
	error = new Error( message );
	error.code = code;

	objectExtend( error, attributes );

	return error;
};




// Based on http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
var stringHash = function( str ) {
	return [].reduce.call( str, function( hash, i ) {
		var chr = i.charCodeAt( 0 );
		hash = ( ( hash << 5 ) - hash ) + chr;
		return hash | 0;
	}, 0 );
};




var runtimeKey = function( fnName, locale, args, argsStr ) {
	var hash;
	argsStr = argsStr || JSON.stringify( args );
	hash = stringHash( fnName + locale + argsStr );
	return hash > 0 ? "a" + hash : "b" + Math.abs( hash );
};




var functionName = function( fn ) {
	if ( fn.name !== undefined ) {
		return fn.name;
	}

	// fn.name is not supported by IE.
	var matches = /^function\s+([\w\$]+)\s*\(/.exec( fn.toString() );

	if ( matches && matches.length > 0 ) {
		return matches[ 1 ];
	}
};




var runtimeBind = function( args, cldr, fn, runtimeArgs ) {

	var argsStr = JSON.stringify( args ),
		fnName = functionName( fn ),
		locale = cldr.locale;

	// If name of the function is not available, this is most likely due to uglification,
	// which most likely means we are in production, and runtimeBind here is not necessary.
	if ( !fnName ) {
		return fn;
	}

	fn.runtimeKey = runtimeKey( fnName, locale, null, argsStr );

	fn.generatorString = function() {
		return "Globalize(\"" + locale + "\")." + fnName + "(" + argsStr.slice( 1, -1 ) + ")";
	};

	fn.runtimeArgs = runtimeArgs;

	return fn;
};




var validate = function( code, message, check, attributes ) {
	if ( !check ) {
		throw createError( code, message, attributes );
	}
};




var alwaysArray = function( stringOrArray ) {
	return Array.isArray( stringOrArray ) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];
};




var validateCldr = function( path, value, options ) {
	var skipBoolean;
	options = options || {};

	skipBoolean = alwaysArray( options.skip ).some(function( pathRe ) {
		return pathRe.test( path );
	});

	validate( "E_MISSING_CLDR", "Missing required CLDR content `{path}`.", value || skipBoolean, {
		path: path
	});
};




var validateDefaultLocale = function( value ) {
	validate( "E_DEFAULT_LOCALE_NOT_DEFINED", "Default locale has not been defined.",
		value !== undefined, {} );
};




var validateParameterPresence = function( value, name ) {
	validate( "E_MISSING_PARAMETER", "Missing required parameter `{name}`.",
		value !== undefined, { name: name });
};




/**
 * range( value, name, minimum, maximum )
 *
 * @value [Number].
 *
 * @name [String] name of variable.
 *
 * @minimum [Number]. The lowest valid value, inclusive.
 *
 * @maximum [Number]. The greatest valid value, inclusive.
 */
var validateParameterRange = function( value, name, minimum, maximum ) {
	validate(
		"E_PAR_OUT_OF_RANGE",
		"Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].",
		value === undefined || value >= minimum && value <= maximum,
		{
			maximum: maximum,
			minimum: minimum,
			name: name,
			value: value
		}
	);
};




var validateParameterType = function( value, name, check, expected ) {
	validate(
		"E_INVALID_PAR_TYPE",
		"Invalid `{name}` parameter ({value}). {expected} expected.",
		check,
		{
			expected: expected,
			name: name,
			value: value
		}
	);
};




var validateParameterTypeLocale = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" || value instanceof Cldr,
		"String or Cldr instance"
	);
};




/**
 * Function inspired by jQuery Core, but reduced to our use case.
 */
var isPlainObject = function( obj ) {
	return obj !== null && "" + obj === "[object Object]";
};




var validateParameterTypePlainObject = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ),
		"Plain Object"
	);
};




var alwaysCldr = function( localeOrCldr ) {
	return localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr( localeOrCldr );
};




// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
var regexpEscape = function( string ) {
	return string.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1" );
};




var stringPad = function( str, count, right ) {
	var length;
	if ( typeof str !== "string" ) {
		str = String( str );
	}
	for ( length = str.length; length < count; length += 1 ) {
		str = ( right ? ( str + "0" ) : ( "0" + str ) );
	}
	return str;
};




function validateLikelySubtags( cldr ) {
	cldr.once( "get", validateCldr );
	cldr.get( "supplemental/likelySubtags" );
}

/**
 * [new] Globalize( locale|cldr )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Create a Globalize instance.
 */
function Globalize( locale ) {
	if ( !( this instanceof Globalize ) ) {
		return new Globalize( locale );
	}

	validateParameterPresence( locale, "locale" );
	validateParameterTypeLocale( locale, "locale" );

	this.cldr = alwaysCldr( locale );

	validateLikelySubtags( this.cldr );
}

/**
 * Globalize.load( json, ... )
 *
 * @json [JSON]
 *
 * Load resolved or unresolved cldr data.
 * Somewhat equivalent to previous Globalize.addCultureInfo(...).
 */
Globalize.load = function() {

	// validations are delegated to Cldr.load().
	Cldr.load.apply( Cldr, arguments );
};

/**
 * Globalize.locale( [locale|cldr] )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Set default Cldr instance if locale or cldr argument is passed.
 *
 * Return the default Cldr instance.
 */
Globalize.locale = function( locale ) {
	validateParameterTypeLocale( locale, "locale" );

	if ( arguments.length ) {
		this.cldr = alwaysCldr( locale );
		validateLikelySubtags( this.cldr );
	}
	return this.cldr;
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._alwaysArray = alwaysArray;
Globalize._createError = createError;
Globalize._formatMessage = formatMessage;
Globalize._isPlainObject = isPlainObject;
Globalize._objectExtend = objectExtend;
Globalize._regexpEscape = regexpEscape;
Globalize._runtimeBind = runtimeBind;
Globalize._stringPad = stringPad;
Globalize._validate = validate;
Globalize._validateCldr = validateCldr;
Globalize._validateDefaultLocale = validateDefaultLocale;
Globalize._validateParameterPresence = validateParameterPresence;
Globalize._validateParameterRange = validateParameterRange;
Globalize._validateParameterTypePlainObject = validateParameterTypePlainObject;
Globalize._validateParameterType = validateParameterType;

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/currency.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/*!
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	formatMessage = Globalize._formatMessage,
	numberNumberingSystem = Globalize._numberNumberingSystem,
	numberPattern = Globalize._numberPattern,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var validateParameterTypeCurrency = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" && ( /^[A-Za-z]{3}$/ ).test( value ),
		"3-letter currency code string as defined by ISO 4217"
	);
};




/**
 * supplementalOverride( currency, pattern, cldr )
 *
 * Return pattern with fraction digits overriden by supplemental currency data.
 */
var currencySupplementalOverride = function( currency, pattern, cldr ) {
	var digits,
		fraction = "",
		fractionData = cldr.supplemental([ "currencyData/fractions", currency ]) ||
			cldr.supplemental( "currencyData/fractions/DEFAULT" );

	digits = +fractionData._digits;

	if ( digits ) {
		fraction = "." + stringPad( "0", digits ).slice( 0, -1 ) + fractionData._rounding;
	}

	return pattern.replace( /\.(#+|0*[0-9]|0+[0-9]?)/g, fraction );
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




var currencyUnitPatterns = function( cldr ) {
	return objectFilter( cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr )
	]), /^unitPattern/ );
};




/**
 * codeProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyCodeProperties = function( currency, cldr ) {
	var pattern = numberPattern( "decimal", cldr );

	// The number of decimal places and the rounding for each currency is not locale-specific. Those
	// values overridden by Supplemental Currency Data.
	pattern = currencySupplementalOverride( currency, pattern, cldr );

	return {
		currency: currency,
		pattern: pattern,
		unitPatterns: currencyUnitPatterns( cldr )
	};
};




/**
 * nameFormat( formattedNumber, pluralForm, properties )
 *
 * Return the appropriate name form currency format.
 */
var currencyNameFormat = function( formattedNumber, pluralForm, properties ) {
	var displayName, unitPattern,
		displayNames = properties.displayNames || {},
		unitPatterns = properties.unitPatterns;

	displayName = displayNames[ "displayName-count-" + pluralForm ] ||
		displayNames[ "displayName-count-other" ] ||
		displayNames.displayName ||
		properties.currency;
	unitPattern = unitPatterns[ "unitPattern-count-" + pluralForm ] ||
		unitPatterns[ "unitPattern-count-other" ];

	return formatMessage( unitPattern, [ formattedNumber, displayName ]);
};




var currencyFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	var fn;

	// Return formatter when style is "code" or "name".
	if ( pluralGenerator && properties ) {
		fn = function currencyFormatter( value ) {
			validateParameterPresence( value, "value" );
			validateParameterTypeNumber( value, "value" );
			return currencyNameFormat(
				numberFormatter( value ),
				pluralGenerator( value ),
				properties
			);
		};

	// Return formatter when style is "symbol" or "accounting".
	} else {
		fn = function currencyFormatter( value ) {
			return numberFormatter( value );
		};
	}

	return fn;
};




/**
 * nameProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyNameProperties = function( currency, cldr ) {
	var properties = currencyCodeProperties( currency, cldr );

	properties.displayNames = objectFilter( cldr.main([
		"numbers/currencies",
		currency
	]), /^displayName/ );

	return properties;
};




/**
 * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and
 * box-drawing characters.
 *
 * Generated by:
 *
 * regenerate()
 *   .addRange( 0x0, 0x10FFFF )
 *   .remove( require( "unicode-7.0.0/categories/S/symbols" ) ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-7.0.0
 */
var regexpNotS = /[\0-#%-\*,-;\?-\]_a-\{\}\x7F-\xA1\xA7\xAA\xAB\xAD\xB2\xB3\xB5-\xB7\xB9-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376-\u0383\u0386-\u03F5\u03F7-\u0481\u0483-\u058C\u0590-\u0605\u0609\u060A\u060C\u060D\u0610-\u06DD\u06DF-\u06E8\u06EA-\u06FC\u06FF-\u07F5\u07F7-\u09F1\u09F4-\u09F9\u09FC-\u0AF0\u0AF2-\u0B6F\u0B71-\u0BF2\u0BFB-\u0C7E\u0C80-\u0D78\u0D7A-\u0E3E\u0E40-\u0F00\u0F04-\u0F12\u0F14\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39-\u0FBD\u0FC6\u0FCD\u0FD0-\u0FD4\u0FD9-\u109D\u10A0-\u138F\u139A-\u17DA\u17DC-\u193F\u1941-\u19DD\u1A00-\u1B60\u1B6B-\u1B73\u1B7D-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDC\u1FE0-\u1FEC\u1FF0-\u1FFC\u1FFF-\u2043\u2045-\u2051\u2053-\u2079\u207D-\u2089\u208D-\u209F\u20BE-\u20FF\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u218F\u2308-\u230B\u2329\u232A\u23FB-\u23FF\u2427-\u243F\u244B-\u249B\u24EA-\u24FF\u2768-\u2793\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2CE4\u2CEB-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u3003\u3005-\u3011\u3014-\u301F\u3021-\u3035\u3038-\u303D\u3040-\u309A\u309D-\u318F\u3192-\u3195\u31A0-\u31BF\u31E4-\u31FF\u321F-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u32FF\u3400-\u4DBF\u4E00-\uA48F\uA4C7-\uA6FF\uA717-\uA71F\uA722-\uA788\uA78B-\uA827\uA82C-\uA835\uA83A-\uAA76\uAA7A-\uAB5A\uAB5C-\uD7FF\uDC00-\uFB28\uFB2A-\uFBB1\uFBC2-\uFDFB\uFDFE-\uFE61\uFE63\uFE67\uFE68\uFE6A-\uFF03\uFF05-\uFF0A\uFF0C-\uFF1B\uFF1F-\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5F-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]|\uD800[\uDC00-\uDD36\uDD40-\uDD78\uDD8A\uDD8B\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFD-\uDFFF]|[\uD801\uD803-\uD819\uD81B-\uD82E\uD830-\uD833\uD836-\uD83A\uD83F-\uDBFF][\uDC00-\uDFFF]|\uD802[\uDC00-\uDC76\uDC79-\uDEC7\uDEC9-\uDFFF]|\uD81A[\uDC00-\uDF3B\uDF40-\uDF44\uDF46-\uDFFF]|\uD82F[\uDC00-\uDC9B\uDC9D-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD65-\uDD69\uDD6D-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDDDE-\uDDFF\uDE42-\uDE44\uDE46-\uDEFF\uDF57-\uDFFF]|\uD835[\uDC00-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFFF]|\uD83B[\uDC00-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF\uDF2D-\uDF2F\uDF7E\uDF7F\uDFCF-\uDFD3\uDFF8-\uDFFF]|\uD83D[\uDCFF\uDD4B-\uDD4F\uDD7A\uDDA4\uDE43\uDE44\uDED0-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDFFF]|[\uD800-\uDBFF]/;




/**
 * symbolProperties( currency, cldr )
 *
 * Return pattern replacing `` with the appropriate currency symbol literal.
 */
var currencySymbolProperties = function( currency, cldr, options ) {
	var currencySpacing, pattern,
		regexp = {
			"[:digit:]": /\d/,
			"[:^S:]": regexpNotS
		},
		symbol = cldr.main([
			"numbers/currencies",
			currency,
			"symbol"
		]);

	currencySpacing = [ "beforeCurrency", "afterCurrency" ].map(function( position ) {
		return cldr.main([
			"numbers",
			"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
			"currencySpacing",
			position
		]);
	});

	pattern = cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
		options.style === "accounting" ? "accounting" : "standard"
	]);

	pattern =

		// The number of decimal places and the rounding for each currency is not locale-specific.
		// Those values are overridden by Supplemental Currency Data.
		currencySupplementalOverride( currency, pattern, cldr )

		// Replace "" (\u00A4) with the appropriate symbol literal.
		.split( ";" ).map(function( pattern ) {

			return pattern.split( "\u00A4" ).map(function( part, i ) {
				var currencyMatch = regexp[ currencySpacing[ i ].currencyMatch ],
					surroundingMatch = regexp[ currencySpacing[ i ].surroundingMatch ],
					insertBetween = "";

				// For currencyMatch and surroundingMatch definitions, read [1].
				// When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.
				// 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies
				currencyMatch = currencyMatch.test( symbol.charAt( i ? symbol.length - 1 : 0 ) );
				surroundingMatch = surroundingMatch.test(
					part.charAt( i ? 0 : part.length - 1 ).replace( /[#@,.]/g, "0" )
				);

				if ( currencyMatch && part && surroundingMatch ) {
					insertBetween = currencySpacing[ i ].insertBetween;
				}

				return ( i ? insertBetween : "" ) + part + ( i ? "" : insertBetween );
			}).join( "'" + symbol + "'" );
		}).join( ";" );

	return {
		pattern: pattern
	};
};




/**
 * objectOmit( object, keys )
 *
 * Return a copy of the object, filtered to omit the blacklisted key or array of keys.
 */
var objectOmit = function( object, keys ) {
	var key,
		copy = {};

	keys = alwaysArray( keys );

	for ( key in object ) {
		if ( keys.indexOf( key ) === -1 ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [ /supplemental\/currencyData\/fractions\/[A-Za-z]{3}$/ ]
	});
}

/**
 * .currencyFormatter( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]:
 * - style: [String] "symbol" (default), "accounting", "code" or "name".
 * - see also number/format options.
 *
 * Return a function that formats a currency according to the given options and default/instance
 * locale.
 */
Globalize.currencyFormatter =
Globalize.prototype.currencyFormatter = function( currency, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn, style;

	validateParameterPresence( currency, "currency" );
	validateParameterTypeCurrency( currency, "currency" );

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};

	args = [ currency, options ];
	style = options.style || "symbol";

	validateDefaultLocale( cldr );

	// Get properties given style ("symbol" default, "code" or "name").
	cldr.on( "get", validateRequiredCldr );
	properties = ({
		accounting: currencySymbolProperties,
		code: currencyCodeProperties,
		name: currencyNameProperties,
		symbol: currencySymbolProperties
	}[ style ] )( currency, cldr, options );
	cldr.off( "get", validateRequiredCldr );

	// options = options minus style, plus raw pattern.
	options = objectOmit( options, "style" );
	options.raw = properties.pattern;

	// Return formatter when style is "symbol" or "accounting".
	if ( style === "symbol" || style === "accounting" ) {
		numberFormatter = this.numberFormatter( options );

		returnFn = currencyFormatterFn( numberFormatter );

		runtimeBind( args, cldr, returnFn, [ numberFormatter ] );

	// Return formatter when style is "code" or "name".
	} else {
		numberFormatter = this.numberFormatter( options );
		pluralGenerator = this.pluralGenerator();

		returnFn = currencyFormatterFn( numberFormatter, pluralGenerator, properties );

		runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );
	}

	return returnFn;
};

/**
 * .currencyParser( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Return the currency parser according to the given options and the default/instance locale.
 */
Globalize.currencyParser =
Globalize.prototype.currencyParser = function( /* currency, options */ ) {

	// TODO implement parser.

};

/**
 * .formatCurrency( value, currency [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Format a currency according to the given options and the default/instance locale.
 */
Globalize.formatCurrency =
Globalize.prototype.formatCurrency = function( value, currency, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.currencyFormatter( currency, options )( value );
};

/**
 * .parseCurrency( value, currency [, options] )
 *
 * @value [String]
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]: See currencyFormatter.
 *
 * Return the parsed currency or NaN when value is invalid.
 */
Globalize.parseCurrency =
Globalize.prototype.parseCurrency = function( /* value, currency, options */ ) {
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/date.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,
	formatMessage = Globalize._formatMessage,
	isPlainObject = Globalize._isPlainObject,
	looseMatching = Globalize._looseMatching,
	numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,
	numberSymbol = Globalize._numberSymbol,
	regexpEscape = Globalize._regexpEscape,
	removeLiteralQuotes = Globalize._removeLiteralQuotes,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validate = Globalize._validate,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeString = Globalize._validateParameterTypeString;


var validateParameterTypeDate = function( value, name ) {
	validateParameterType( value, name, value === undefined || value instanceof Date, "Date" );
};




var createErrorInvalidParameterValue = function( name, value ) {
	return createError( "E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", {
		name: name,
		value: value
	});
};




/**
 * Create a map between the skeleton fields and their positions, e.g.,
 * {
 *   G: 0
 *   y: 1
 *   ...
 * }
 */
var validateSkeletonFieldsPosMap = "GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx".split( "" ).reduce(function( memo, item, i ) {
	memo[ item ] = i;
	return memo;
}, {});




/**
 * validateSkeleton( skeleton )
 *
 * skeleton: Assume `j` has already been converted into a localized hour field.
 */
var validateSkeleton = function validateSkeleton( skeleton ) {
	var last,

		// Using easier to read variable.
		fieldsPosMap = validateSkeletonFieldsPosMap;

	// "The fields are from the Date Field Symbol Table in Date Format Patterns"
	// Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
	// I.e., check for invalid characters.
	skeleton.replace( /[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function( field ) {
		throw createError(
			"E_INVALID_OPTIONS", "Invalid field `{invalidField}` of skeleton `{value}`",
			{
				invalidField: field,
				type: "skeleton",
				value: skeleton
			}
		);
	});

	// "The canonical order is from top to bottom in that table; that is, yM not My".
	// http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
	// I.e., check for invalid order.
	skeleton.split( "" ).every(function( field ) {
		if ( fieldsPosMap[ field ] < last ) {
			throw createError(
				"E_INVALID_OPTIONS", "Invalid order `{invalidField}` of skeleton `{value}`",
				{
					invalidField: field,
					type: "skeleton",
					value: skeleton
				}
			);
		}
		last = fieldsPosMap[ field ];
		return true;
	});
};




/**
 * Returns a new object created by using `object`'s values as keys, and the keys as values.
 */
var objectInvert = function( object, fn ) {
	fn = fn || function( object, key, value ) {
		object[ value ] = key;
		return object;
	};
	return Object.keys( object ).reduce(function( newObject, key ) {
		return fn( newObject, key, object[ key ] );
	}, {});
};




// Invert key and values, e.g., {"e": "eEc"} ==> {"e": "e", "E": "e", "c": "e"}.
var dateExpandPatternSimilarFieldsMap = objectInvert({
	"e": "eEc",
	"L": "ML"
}, function( object, key, value ) {
	value.split( "" ).forEach(function( field ) {
		object[ field ] = key;
	});
	return object;
});




var dateExpandPatternNormalizePatternType = function( character ) {
	return dateExpandPatternSimilarFieldsMap[ character ] || character;
};




var datePatternRe = ( /([a-z])\1*|'([^']|'')+'|''|./ig );




var stringRepeat = function( str, count ) {
	var i, result = "";
	for ( i = 0; i < count; i++ ) {
		result = result + str;
	}
	return result;
};




var dateExpandPatternAugmentFormat = function( requestedSkeleton, bestMatchFormat ) {
	var i, j, matchedType, matchedLength, requestedType, requestedLength,

		// Using an easier to read variable.
		normalizePatternType = dateExpandPatternNormalizePatternType;

	requestedSkeleton = requestedSkeleton.match( datePatternRe );
	bestMatchFormat = bestMatchFormat.match( datePatternRe );

	for ( i = 0; i < bestMatchFormat.length; i++ ) {
		matchedType = bestMatchFormat[i].charAt( 0 );
		matchedLength = bestMatchFormat[i].length;
		for ( j = 0; j < requestedSkeleton.length; j++ ) {
			requestedType = requestedSkeleton[j].charAt( 0 );
			requestedLength = requestedSkeleton[j].length;
			if ( normalizePatternType( matchedType ) === normalizePatternType( requestedType ) &&
				matchedLength < requestedLength
			) {
				bestMatchFormat[i] = stringRepeat( matchedType, requestedLength );
			}
		}
	}

	return bestMatchFormat.join( "" );
};




var dateExpandPatternCompareFormats = function( formatA, formatB ) {
	var a, b, distance, lenA, lenB, typeA, typeB, i, j,

		// Using easier to read variables.
		normalizePatternType = dateExpandPatternNormalizePatternType;

	if ( formatA === formatB ) {
		return 0;
	}

	formatA = formatA.match( datePatternRe );
	formatB = formatB.match( datePatternRe );

	if ( formatA.length !== formatB.length ) {
		return -1;
	}

	distance = 1;
	for ( i = 0; i < formatA.length; i++ ) {
		a = formatA[ i ].charAt( 0 );
		typeA = normalizePatternType( a );
		typeB = null;
		for ( j = 0; j < formatB.length; j++ ) {
			b = formatB[ j ].charAt( 0 );
			typeB = normalizePatternType( b );
			if ( typeA === typeB ) {
				break;
			} else {
				typeB = null;
			}
		}
		if ( typeB === null ) {
			return -1;
		}
		lenA = formatA[ i ].length;
		lenB = formatB[ j ].length;
		distance = distance + Math.abs( lenA - lenB );

		// Most symbols have a small distance from each other, e.g., M  L; E  c; a  b  B;
		// H  k  h  K; ...
		if ( a !== b ) {
			distance += 1;
		}

		// Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.
		if ( ( lenA < 3 && lenB >= 3 ) || ( lenA >= 3 && lenB < 3 ) ) {
			distance += 20;
		}
	}
	return distance;
};




var dateExpandPatternGetBestMatchPattern = function( cldr, askedSkeleton ) {
	var availableFormats, pattern, ratedFormats, skeleton,
		path = "dates/calendars/gregorian/dateTimeFormats/availableFormats",

		// Using easier to read variables.
		augmentFormat = dateExpandPatternAugmentFormat,
		compareFormats = dateExpandPatternCompareFormats;

	pattern = cldr.main([ path, askedSkeleton ]);

	if ( askedSkeleton && !pattern ) {
		availableFormats = cldr.main([ path ]);
		ratedFormats = [];

		for ( skeleton in availableFormats ) {
			ratedFormats.push({
				skeleton: skeleton,
				pattern: availableFormats[ skeleton ],
				rate: compareFormats( askedSkeleton, skeleton )
			});
		}

		ratedFormats = ratedFormats
			.filter( function( format ) {
				return format.rate > -1;
			} )
			.sort( function( formatA, formatB ) {
				return formatA.rate - formatB.rate;
			});

		if ( ratedFormats.length ) {
			pattern = augmentFormat( askedSkeleton, ratedFormats[0].pattern );
		}
	}

	return pattern;
};




/**
 * expandPattern( options, cldr )
 *
 * @options [Object] if String, it's considered a skeleton. Object accepts:
 * - skeleton: [String] lookup availableFormat;
 * - date: [String] ( "full" | "long" | "medium" | "short" );
 * - time: [String] ( "full" | "long" | "medium" | "short" );
 * - datetime: [String] ( "full" | "long" | "medium" | "short" );
 * - raw: [String] For more info see datetime/format.js.
 *
 * @cldr [Cldr instance].
 *
 * Return the corresponding pattern.
 * Eg for "en":
 * - "GyMMMd" returns "MMM d, y G";
 * - { skeleton: "GyMMMd" } returns "MMM d, y G";
 * - { date: "full" } returns "EEEE, MMMM d, y";
 * - { time: "full" } returns "h:mm:ss a zzzz";
 * - { datetime: "full" } returns "EEEE, MMMM d, y 'at' h:mm:ss a zzzz";
 * - { raw: "dd/mm" } returns "dd/mm";
 */
var dateExpandPattern = function( options, cldr ) {
	var dateSkeleton, result, skeleton, timeSkeleton, type,

		// Using easier to read variables.
		getBestMatchPattern = dateExpandPatternGetBestMatchPattern;

	function combineDateTime( type, datePattern, timePattern ) {
		return formatMessage(
			cldr.main([
				"dates/calendars/gregorian/dateTimeFormats",
				type
			]),
			[ timePattern, datePattern ]
		);
	}

	switch ( true ) {
		case "skeleton" in options:
			skeleton = options.skeleton;

			// Preferred hour (j).
			skeleton = skeleton.replace( /j/g, function() {
				return cldr.supplemental.timeData.preferred();
			});

			validateSkeleton( skeleton );

			// Try direct map (note that getBestMatchPattern handles it).
			// ... or, try to "best match" the whole skeleton.
			result = getBestMatchPattern(
				cldr,
				skeleton
			);
			if ( result ) {
				break;
			}

			// ... or, try to "best match" the date and time parts individually.
			timeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];
			dateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];
			dateSkeleton = getBestMatchPattern(
				cldr,
				dateSkeleton
			);
			timeSkeleton = getBestMatchPattern(
				cldr,
				timeSkeleton
			);

			if ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {
				type = "full";
			} else if ( /MMMM|LLLL/.test( dateSkeleton ) ) {
				type = "long";
			} else if ( /MMM|LLL/.test( dateSkeleton ) ) {
				type = "medium";
			} else {
				type = "short";
			}

			if ( dateSkeleton && timeSkeleton ) {
				result = combineDateTime( type, dateSkeleton, timeSkeleton );
			} else {
				result = dateSkeleton || timeSkeleton;
			}

			break;

		case "date" in options:
		case "time" in options:
			result = cldr.main([
				"dates/calendars/gregorian",
				"date" in options ? "dateFormats" : "timeFormats",
				( options.date || options.time )
			]);
			break;

		case "datetime" in options:
			result = combineDateTime( options.datetime,
				cldr.main([ "dates/calendars/gregorian/dateFormats", options.datetime ]),
				cldr.main([ "dates/calendars/gregorian/timeFormats", options.datetime ])
			);
			break;

		case "raw" in options:
			result = options.raw;
			break;

		default:
			throw createErrorInvalidParameterValue({
				name: "options",
				value: options
			});
	}

	return result;
};




var dateWeekDays = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];




/**
 * firstDayOfWeek
 */
var dateFirstDayOfWeek = function( cldr ) {
	return dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );
};




/**
 * getTimeZoneName( length, type )
 */
var dateGetTimeZoneName = function( length, type, timeZone, cldr ) {
	var metaZone, result;

	if ( !timeZone ) {
		return;
	}

	result = cldr.main([
		"dates/timeZoneNames/zone",
		timeZone,
		length < 4 ? "short" : "long",
		type
	]);

	if ( result ) {
		return result;
	}

	// The latest metazone data of the metazone array.
	// TODO expand to support the historic metazones based on the given date.
	metaZone = cldr.supplemental([
		"metaZones/metazoneInfo/timezone", timeZone, 0,
		"usesMetazone/_mzone"
	]);

	return cldr.main([
		"dates/timeZoneNames/metazone",
		metaZone,
		length < 4 ? "short" : "long",
		type
	]);
};




/**
 * timezoneHourFormatShortH( hourFormat )
 *
 * @hourFormat [String]
 *
 * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.
 * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
 *
 * Example:
 * - "+HH.mm;-HH.mm" => "+H;-H"
 * - "+HH:mm;-HH:mm" => "+H;-H"
 * - "+HH:mm;HH:mm" => "+H;H" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+H:-H"
 */
var dateTimezoneHourFormatH = function( hourFormat ) {
	return hourFormat
		.split( ";" )
		.map(function( format ) {
			return format.slice( 0, format.indexOf( "H" ) + 1 );
		})
		.join( ";" );
};




/**
 * timezoneHourFormatLongHm( hourFormat )
 *
 * @hourFormat [String]
 *
 * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.
 * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
 *
 * Example (hFormat === "H"): (used for short Hm)
 * - "+HH.mm;-HH.mm" => "+H.mm;-H.mm"
 * - "+HH:mm;-HH:mm" => "+H:mm;-H:mm"
 * - "+HH:mm;HH:mm" => "+H:mm;H:mm" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+Hmm:-Hmm"
 *
 * Example (hFormat === "HH": (used for long Hm)
 * - "+HH.mm;-HH.mm" => "+HH.mm;-HH.mm"
 * - "+HH:mm;-HH:mm" => "+HH:mm;-HH:mm"
 * - "+H:mm;-H:mm"   => "+HH:mm;-HH:mm"
 * - "+HH:mm;HH:mm" => "+HH:mm;HH:mm" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+HHmm:-HHmm"
 */
var dateTimezoneHourFormatHm = function( hourFormat, hFormat ) {
	return hourFormat
		.split( ";" )
		.map(function( format ) {
			var parts = format.split( /H+/ );
			parts.splice( 1, 0, hFormat );
			return parts.join( "" );
		})
		.join( ";" );
};




var runtimeCacheDataBind = function( key, data ) {
	var fn = function() {
		return data;
	};
	fn.dataCacheKey = key;
	return fn;
};




/**
 * properties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 *
 * @cldr [Cldr instance].
 *
 * Return the properties given the pattern and cldr.
 *
 * TODO Support other calendar types.
 */
var dateFormatProperties = function( pattern, cldr, timeZone ) {
	var properties = {
			numberFormatters: {},
			pattern: pattern,
			timeSeparator: numberSymbol( "timeSeparator", cldr )
		},
		widths = [ "abbreviated", "wide", "narrow" ];

	function setNumberFormatterPattern( pad ) {
		properties.numberFormatters[ pad ] = stringPad( "", pad );
	}

	if ( timeZone ) {
		properties.timeZoneData = runtimeCacheDataBind( "iana/" + timeZone, {
			offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
			untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
			isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
		});
	}

	pattern.replace( datePatternRe, function( current ) {
		var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;

		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			properties.preferredTime = chr = cldr.supplemental.timeData.preferred();
		}

		// ZZZZ: same as "OOOO".
		if ( chr === "Z" && length === 4 ) {
			chr = "O";
			length = 4;
		}

		// z...zzz: "{shortRegion}", eg. "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "z" ) {
			standardTzName = dateGetTimeZoneName( length, "standard", timeZone, cldr );
			daylightTzName = dateGetTimeZoneName( length, "daylight", timeZone, cldr );
			if ( standardTzName ) {
				properties.standardTzName = standardTzName;
			}
			if ( daylightTzName ) {
				properties.daylightTzName = daylightTzName;
			}

			// Fall through the "O" format in case one name is missing.
			if ( !standardTzName || !daylightTzName ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			genericTzName = dateGetTimeZoneName( length, "generic", timeZone, cldr );

			// Fall back to "V" format.
			if ( !genericTzName ) {
				chr = "V";
				length = 4;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				properties.eras = cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":

				// Plain year.
				formatNumber = true;
				break;

			case "Y":

				// Year in "Week of Year"
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					if ( !properties.quarters ) {
						properties.quarters = {};
					}
					if ( !properties.quarters[ chr ] ) {
						properties.quarters[ chr ] = {};
					}
					properties.quarters[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Month
			case "M":
			case "L":
				if ( length > 2 ) {
					if ( !properties.months ) {
						properties.months = {};
					}
					if ( !properties.months[ chr ] ) {
						properties.months[ chr ] = {};
					}
					properties.months[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Week - Week of Year (w) or Week of Month (W).
			case "w":
			case "W":
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			// Day
			case "d":
			case "D":
			case "F":
				formatNumber = true;
				break;

			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {
					properties.firstDay = dateFirstDayOfWeek( cldr );
					formatNumber = true;
					break;
				}

			/* falls through */
			case "E":
				if ( !properties.days ) {
					properties.days = {};
				}
				if ( !properties.days[ chr ] ) {
					properties.days[ chr ] = {};
				}
				if ( length === 6 ) {

					// If short day names are not explicitly specified, abbreviated day names are
					// used instead.
					// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					// http://unicode.org/cldr/trac/ticket/6790
					properties.days[ chr ][ length ] = cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"short"
						]) || cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"abbreviated"
						]);
				} else {
					properties.days[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/days",
						chr === "c" ? "stand-alone" : "format",
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				properties.dayPeriods = {
					am: cldr.main(
						"dates/calendars/gregorian/dayPeriods/format/wide/am"
					),
					pm: cldr.main(
						"dates/calendars/gregorian/dayPeriods/format/wide/pm"
					)
				};
				break;

			// Hour
			case "h": // 1-12
			case "H": // 0-23
			case "K": // 0-11
			case "k": // 1-24

			// Minute
			case "m":

			// Second
			case "s":
			case "S":
			case "A":
				formatNumber = true;
				break;

			// Zone
			case "v":
				if ( length !== 1 && length !== 4 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}
				properties.genericTzName = genericTzName;
				break;

			case "V":

				if ( length === 1 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}

				if ( timeZone ) {
					if ( length === 2 ) {
						properties.timeZoneName = timeZone;
						break;
					}

					var timeZoneName,
						exemplarCity = cldr.main([
							"dates/timeZoneNames/zone", timeZone, "exemplarCity"
						]);

					if ( length === 3 ) {
						if ( !exemplarCity ) {
							exemplarCity = cldr.main([
								"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity"
							]);
						}
						timeZoneName = exemplarCity;
					}

					if ( exemplarCity && length === 4 ) {
						timeZoneName = formatMessage(
							cldr.main(
								"dates/timeZoneNames/regionFormat"
							),
							[ exemplarCity ]
						);
					}

					if ( timeZoneName ) {
						properties.timeZoneName = timeZoneName;
						break;
					}
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				properties.gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				properties.gmtZeroFormat = cldr.main( "dates/timeZoneNames/gmtZeroFormat" );

				// Unofficial deduction of the hourFormat variations.
				// Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
				aux = cldr.main( "dates/timeZoneNames/hourFormat" );
				properties.hourFormat = length < 4 ?
					[ dateTimezoneHourFormatH( aux ), dateTimezoneHourFormatHm( aux, "H" ) ] :
					dateTimezoneHourFormatHm( aux, "HH" );

			/* falls through */
			case "Z":
			case "X":
			case "x":
				setNumberFormatterPattern( 1 );
				setNumberFormatterPattern( 2 );
				break;
		}

		if ( formatNumber ) {
			setNumberFormatterPattern( length );
		}
	});

	return properties;
};




var dateFormatterFn = function( dateToPartsFormatter ) {
	return function dateFormatter( value ) {
		return dateToPartsFormatter( value ).map( function( part ) {
			return part.value;
		}).join( "" );
	};
};




/**
 * parseProperties( cldr )
 *
 * @cldr [Cldr instance].
 *
 * @timeZone [String] FIXME.
 *
 * Return parser properties.
 */
var dateParseProperties = function( cldr, timeZone ) {
	var properties = {
		preferredTimeData: cldr.supplemental.timeData.preferred()
	};

	if ( timeZone ) {
		properties.timeZoneData = runtimeCacheDataBind( "iana/" + timeZone, {
			offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
			untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
			isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
		});
	}

	return properties;
};


var ZonedDateTime = (function() {
function definePrivateProperty(object, property, value) {
  Object.defineProperty(object, property, {
    value: value
  });
}

function getUntilsIndex(original, untils) {
  var index = 0;
  var originalTime = original.getTime();

  // TODO Should we do binary search for improved performance?
  while (index < untils.length - 1 && originalTime >= untils[index]) {
    index++;
  }
  return index;
}

function setWrap(fn) {
  var offset1 = this.getTimezoneOffset();
  var ret = fn();
  this.original.setTime(new Date(this.getTime()));
  var offset2 = this.getTimezoneOffset();
  if (offset2 - offset1) {
    this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);
  }
  return ret;
}

var ZonedDateTime = function(date, timeZoneData) {
  definePrivateProperty(this, "original", new Date(date.getTime()));
  definePrivateProperty(this, "local", new Date(date.getTime()));
  definePrivateProperty(this, "timeZoneData", timeZoneData);
  definePrivateProperty(this, "setWrap", setWrap);
  if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {
    throw new Error("Invalid IANA data");
  }
  this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);
};

ZonedDateTime.prototype.clone = function() {
  return new ZonedDateTime(this.original, this.timeZoneData);
};

// Date field getters.
["getFullYear", "getMonth", "getDate", "getDay", "getHours", "getMinutes",
"getSeconds", "getMilliseconds"].forEach(function(method) {
  // Corresponding UTC method, e.g., "getUTCFullYear" if method === "getFullYear".
  var utcMethod = "getUTC" + method.substr(3);
  ZonedDateTime.prototype[method] = function() {
    return this.local[utcMethod]();
  };
});

// Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.
ZonedDateTime.prototype.valueOf =
ZonedDateTime.prototype.getTime = function() {
  return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;
};

ZonedDateTime.prototype.getTimezoneOffset = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  return this.timeZoneData.offsets[index];
};

// Date field setters.
["setFullYear", "setMonth", "setDate", "setHours", "setMinutes", "setSeconds", "setMilliseconds"].forEach(function(method) {
  // Corresponding UTC method, e.g., "setUTCFullYear" if method === "setFullYear".
  var utcMethod = "setUTC" + method.substr(3);
  ZonedDateTime.prototype[method] = function(value) {
    var local = this.local;
    // Note setWrap is needed for seconds and milliseconds just because
    // abs(value) could be >= a minute.
    return this.setWrap(function() {
      return local[utcMethod](value);
    });
  };
});

ZonedDateTime.prototype.setTime = function(time) {
  return this.local.setTime(time);
};

ZonedDateTime.prototype.isDST = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  return Boolean(this.timeZoneData.isdsts[index]);
};

ZonedDateTime.prototype.inspect = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  var abbrs = this.timeZoneData.abbrs;
  return this.local.toISOString().replace(/Z$/, "") + " " +
    (abbrs && abbrs[index] + " " || (this.getTimezoneOffset() * -1) + " ") +
    (this.isDST() ? "(daylight savings)" : "");
};

ZonedDateTime.prototype.toDate = function() {
  return new Date(this.getTime());
};

// Type cast getters.
["toISOString", "toJSON", "toUTCString"].forEach(function(method) {
  ZonedDateTime.prototype[method] = function() {
    return this.toDate()[method]();
  };
});

return ZonedDateTime;
}());


/**
 * isLeapYear( year )
 *
 * @year [Number]
 *
 * Returns an indication whether the specified year is a leap year.
 */
var dateIsLeapYear = function( year ) {
	return new Date( year, 1, 29 ).getMonth() === 1;
};




/**
 * lastDayOfMonth( date )
 *
 * @date [Date]
 *
 * Return the last day of the given date's month
 */
var dateLastDayOfMonth = function( date ) {
	return new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();
};




/**
 * startOf changes the input to the beginning of the given unit.
 *
 * For example, starting at the start of a day, resets hours, minutes
 * seconds and milliseconds to 0. Starting at the month does the same, but
 * also sets the date to 1.
 *
 * Returns the modified date
 */
var dateStartOf = function( date, unit ) {
	date = date instanceof ZonedDateTime ? date.clone() : new Date( date.getTime() );
	switch ( unit ) {
		case "year":
			date.setMonth( 0 );
		/* falls through */
		case "month":
			date.setDate( 1 );
		/* falls through */
		case "day":
			date.setHours( 0 );
		/* falls through */
		case "hour":
			date.setMinutes( 0 );
		/* falls through */
		case "minute":
			date.setSeconds( 0 );
		/* falls through */
		case "second":
			date.setMilliseconds( 0 );
	}
	return date;
};




/**
 * Differently from native date.setDate(), this function returns a date whose
 * day remains inside the month boundaries. For example:
 *
 * setDate( FebDate, 31 ): a "Feb 28" date.
 * setDate( SepDate, 31 ): a "Sep 30" date.
 */
var dateSetDate = function( date, day ) {
	var lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();

	date.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );
};




/**
 * Differently from native date.setMonth(), this function adjusts date if
 * needed, so final month is always the one set.
 *
 * setMonth( Jan31Date, 1 ): a "Feb 28" date.
 * setDate( Jan31Date, 8 ): a "Sep 30" date.
 */
var dateSetMonth = function( date, month ) {
	var originalDate = date.getDate();

	date.setDate( 1 );
	date.setMonth( month );
	dateSetDate( date, originalDate );
};




var outOfRange = function( value, low, high ) {
	return value < low || value > high;
};




/**
 * parse( value, tokens, properties )
 *
 * @value [String] string date.
 *
 * @tokens [Object] tokens returned by date/tokenizer.
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 */
var dateParse = function( value, tokens, properties ) {
	var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,
		YEAR = 0,
		MONTH = 1,
		DAY = 2,
		HOUR = 3,
		MINUTE = 4,
		SECOND = 5,
		MILLISECONDS = 6,
		date = new Date(),
		truncateAt = [],
		units = [ "year", "month", "day", "hour", "minute", "second", "milliseconds" ];

	// Create globalize date with given timezone data.
	if ( properties.timeZoneData ) {
		date = new ZonedDateTime( date, properties.timeZoneData() );
	}

	if ( !tokens.length ) {
		return null;
	}

	valid = tokens.every(function( token ) {
		var century, chr, value, length;

		if ( token.type === "literal" ) {

			// continue
			return true;
		}

		chr = token.type.charAt( 0 );
		length = token.type.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTimeData;
		}

		switch ( chr ) {

			// Era
			case "G":
				truncateAt.push( YEAR );
				era = +token.value;
				break;

			// Year
			case "y":
				value = token.value;
				if ( length === 2 ) {
					if ( outOfRange( value, 0, 99 ) ) {
						return false;
					}

					// mimic dojo/date/locale: choose century to apply, according to a sliding
					// window of 80 years before and 20 years after present year.
					century = Math.floor( date.getFullYear() / 100 ) * 100;
					value += century;
					if ( value > date.getFullYear() + 20 ) {
						value -= 100;
					}
				}
				date.setFullYear( value );
				truncateAt.push( YEAR );
				break;

			case "Y": // Year in "Week of Year"
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter (skip)
			case "Q":
			case "q":
				break;

			// Month
			case "M":
			case "L":
				if ( length <= 2 ) {
					value = token.value;
				} else {
					value = +token.value;
				}
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}

				// Setting the month later so that we have the correct year and can determine
				// the correct last day of February in case of leap year.
				month = value;
				truncateAt.push( MONTH );
				break;

			// Week (skip)
			case "w": // Week of Year.
			case "W": // Week of Month.
				break;

			// Day
			case "d":
				day = token.value;
				truncateAt.push( DAY );
				break;

			case "D":
				daysOfYear = token.value;
				truncateAt.push( DAY );
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				// Skip
				break;

			// Week day
			case "e":
			case "c":
			case "E":

				// Skip.
				// value = arrayIndexOf( dateWeekDays, token.value );
				break;

			// Period (AM or PM)
			case "a":
				amPm = token.value;
				break;

			// Hour
			case "h": // 1-12
				value = token.value;
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value === 12 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "K": // 0-11
				value = token.value;
				if ( outOfRange( value, 0, 11 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			case "k": // 1-24
				value = token.value;
				if ( outOfRange( value, 1, 24 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value === 24 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "H": // 0-23
				value = token.value;
				if ( outOfRange( value, 0, 23 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			// Minute
			case "m":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setMinutes( value );
				truncateAt.push( MINUTE );
				break;

			// Second
			case "s":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setSeconds( value );
				truncateAt.push( SECOND );
				break;

			case "A":
				date.setHours( 0 );
				date.setMinutes( 0 );
				date.setSeconds( 0 );

			/* falls through */
			case "S":
				value = Math.round( token.value * Math.pow( 10, 3 - length ) );
				date.setMilliseconds( value );
				truncateAt.push( MILLISECONDS );
				break;

			// Zone
			case "z":
			case "Z":
			case "O":
			case "v":
			case "V":
			case "X":
			case "x":
				if ( typeof token.value === "number" ) {
					timezoneOffset = token.value;
				}
				break;
		}

		return true;
	});

	if ( !valid ) {
		return null;
	}

	// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null
	// if amPm && !hour12 || !amPm && hour12.
	if ( hour && !( !amPm ^ hour12 ) ) {
		return null;
	}

	if ( era === 0 ) {

		// 1 BC = year 0
		date.setFullYear( date.getFullYear() * -1 + 1 );
	}

	if ( month !== undefined ) {
		dateSetMonth( date, month - 1 );
	}

	if ( day !== undefined ) {
		if ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {
			return null;
		}
		date.setDate( day );
	} else if ( daysOfYear !== undefined ) {
		if ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {
			return null;
		}
		date.setMonth( 0 );
		date.setDate( daysOfYear );
	}

	if ( hour12 && amPm === "pm" ) {
		date.setHours( date.getHours() + 12 );
	}

	if ( timezoneOffset !== undefined ) {
		date.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );
	}

	// Truncate date at the most precise unit defined. Eg.
	// If value is "12/31", and pattern is "MM/dd":
	// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );
	truncateAt = Math.max.apply( null, truncateAt );
	date = dateStartOf( date, units[ truncateAt ] );

	// Get date back from globalize date.
	if ( date instanceof ZonedDateTime ) {
		date = date.toDate();
	}

	return date;
};




/**
 * tokenizer( value, numberParser, properties )
 *
 * @value [String] string date.
 *
 * @numberParser [Function]
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * Returns an Array of tokens, eg. value "5 o'clock PM", pattern "h 'o''clock' a":
 * [{
 *   type: "h",
 *   lexeme: "5"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "literal",
 *   lexeme: "o'clock"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "a",
 *   lexeme: "PM",
 *   value: "pm"
 * }]
 *
 * OBS: lexeme's are always String and may return invalid ranges depending of the token type.
 * Eg. "99" for month number.
 *
 * Return an empty Array when not successfully parsed.
 */
var dateTokenizer = function( value, numberParser, properties ) {
	var digitsRe, valid,
		tokens = [],
		widths = [ "abbreviated", "wide", "narrow" ];

	digitsRe = properties.digitsRe;
	value = looseMatching( value );

	valid = properties.pattern.match( datePatternRe ).every(function( current ) {
		var aux, chr, length, numeric, tokenRe,
			token = {};

		function hourFormatParse( tokenRe, numberParser ) {
			var aux, isPositive,
				match = value.match( tokenRe );
			numberParser = numberParser || function( value ) {
				return +value;
			};

			if ( !match ) {
				return false;
			}

			isPositive = match[ 1 ];

			// hourFormat containing H only, e.g., `+H;-H`
			if ( match.length < 6 ) {
				aux = isPositive ? 1 : 3;
				token.value = numberParser( match[ aux ] ) * 60;

			// hourFormat containing H and m, e.g., `+HHmm;-HHmm`
			} else if ( match.length < 10 ) {
				aux = isPositive ? [ 1, 3 ] : [ 5, 7 ];
				token.value = numberParser( match[ aux[ 0 ] ] ) * 60 +
					numberParser( match[ aux[ 1 ] ] );

			// hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`
			} else {
				aux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];
				token.value = numberParser( match[ aux[ 0 ] ] ) * 60 +
					numberParser( match[ aux[ 1 ] ] ) +
					numberParser( match[ aux[ 2 ] ] ) / 60;
			}

			if ( isPositive ) {
				token.value *= -1;
			}

			return true;
		}

		function oneDigitIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d/
				numeric = true;
				return tokenRe = digitsRe;
			}
		}

		function oneOrTwoDigitsIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
			}
		}

		function oneOrTwoDigitsIfLengthOneOrTwo() {
			if ( length === 1 || length === 2 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
			}
		}

		function twoDigitsIfLengthTwo() {
			if ( length === 2 ) {

				// Unicode equivalent to /\d\d/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){2}" );
			}
		}

		// Brute-force test every locale entry in an attempt to match the given value.
		// Return the first found one (and set token accordingly), or null.
		function lookup( path ) {
			var array = properties[ path.join( "/" ) ];

			if ( !array ) {
				return null;
			}

			// array of pairs [key, value] sorted by desc value length.
			array.some(function( item ) {
				var valueRe = item[ 1 ];
				if ( valueRe.test( value ) ) {
					token.value = item[ 0 ];
					tokenRe = item[ 1 ];
					return true;
				}
			});
			return null;
		}

		token.type = current;
		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		if ( chr === "z" ) {
			if ( properties.standardOrDaylightTzName ) {
				token.value = null;
				tokenRe = properties.standardOrDaylightTzName;
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			if ( properties.genericTzName ) {
				token.value = null;
				tokenRe = properties.genericTzName;

			// Fall back to "V" format.
			} else {
				chr = "V";
				length = 4;
			}
		}

		if ( chr === "V" && properties.timeZoneName ) {
			token.value = length === 2 ? properties.timeZoneName : null;
			tokenRe = properties.timeZoneNameRe;
		}

		switch ( chr ) {

			// Era
			case "G":
				lookup([
					"gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":
			case "Y":
				numeric = true;

				// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...
				if ( length === 1 ) {

					// Unicode equivalent to /\d+/.
					tokenRe = new RegExp( "^(" + digitsRe.source + ")+" );
				} else if ( length === 2 ) {

					// Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits
					// year, so parser accepts both zero-padded and non-zero-padded for `yy`.
					//
					// Unicode equivalent to /\d\d?/
					tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
				} else {

					// Unicode equivalent to /\d{length,}/
					tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + ",}" );
				}
				break;

			// Quarter
			case "Q":
			case "q":

				// number l=1:{1}, l=2:{2}.
				// lookup l=3...
				oneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||
					lookup([
						"gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				//
				// Lenient parsing: skeleton "yMd" (i.e., one M) may include MM for the pattern,
				// therefore parser accepts both zero-padded and non-zero-padded for M and MM.
				// Similar for L.
				oneOrTwoDigitsIfLengthOneOrTwo() || lookup([
					"gregorian/months",
					chr === "M" ? "format" : "stand-alone",
					widths[ length - 3 ]
				]);
				break;

			// Day
			case "D":

				// number {l,3}.
				if ( length <= 3 ) {

					// Equivalent to /\d{length,3}/
					numeric = true;
					tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + ",3}" );
				}
				break;

			case "W":
			case "F":

				// number l=1:{1}.
				oneDigitIfLengthOne();
				break;

			// Week day
			case "e":
			case "c":

				// number l=1:{1}, l=2:{2}.
				// lookup for length >=3.
				if ( length <= 2 ) {
					oneDigitIfLengthOne() || twoDigitsIfLengthTwo();
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				lookup([
					"gregorian/dayPeriods/format/wide"
				]);
				break;

			// Week
			case "w":

				// number l1:{1,2}, l2:{2}.
				oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();
				break;

			// Day, Hour, Minute, or Second
			case "d":
			case "h":
			case "H":
			case "K":
			case "k":
			case "j":
			case "m":
			case "s":

				// number l1:{1,2}, l2:{2}.
				//
				// Lenient parsing:
				// - skeleton "hms" (i.e., one m) always includes mm for the pattern, i.e., it's
				//   impossible to use a different skeleton to parse non-zero-padded minutes,
				//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar
				//   for seconds s.
				// - skeleton "hms" (i.e., one h) may include h or hh for the pattern, i.e., it's
				//   impossible to use a different skeleton to parser non-zero-padded hours for some
				//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.
				//   Similar for d (in skeleton yMd).
				oneOrTwoDigitsIfLengthOneOrTwo();
				break;

			case "S":

				// number {l}.

				// Unicode equivalent to /\d{length}/
				numeric = true;
				tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + "}" );
				break;

			case "A":

				// number {l+5}.

				// Unicode equivalent to /\d{length+5}/
				numeric = true;
				tokenRe = new RegExp( "^(" + digitsRe.source + "){" + ( length + 5 ) + "}" );
				break;

			// Zone
			case "v":
			case "V":
			case "z":
				if ( tokenRe && tokenRe.test( value ) ) {
					break;
				}
				if ( chr === "V" && length === 2 ) {
					break;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( value === properties[ "timeZoneNames/gmtZeroFormat" ] ) {
					token.value = 0;
					tokenRe = properties[ "timeZoneNames/gmtZeroFormatRe" ];
				} else {
					aux = properties[ "timeZoneNames/hourFormat" ].some(function( hourFormatRe ) {
						if ( hourFormatParse( hourFormatRe, numberParser ) ) {
							tokenRe = hourFormatRe;
							return true;
						}
					});
					if ( !aux ) {
						return null;
					}
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( value === "Z" ) {
					token.value = 0;
					tokenRe = /^Z/;
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				aux = properties.x.some(function( hourFormatRe ) {
					if ( hourFormatParse( hourFormatRe ) ) {
						tokenRe = hourFormatRe;
						return true;
					}
				});
				if ( !aux ) {
					return null;
				}
				break;

			case "'":
				token.type = "literal";
				tokenRe = new RegExp( "^" + regexpEscape( removeLiteralQuotes( current ) ) );
				break;

			default:
				token.type = "literal";
				tokenRe = new RegExp( "^" + regexpEscape( current ) );
		}

		if ( !tokenRe ) {
			return false;
		}

		// Get lexeme and consume it.
		value = value.replace( tokenRe, function( lexeme ) {
			token.lexeme = lexeme;
			if ( numeric ) {
				token.value = numberParser( lexeme );
			}
			return "";
		});

		if ( !token.lexeme ) {
			return false;
		}

		if ( numeric && isNaN( token.value ) ) {
			return false;
		}

		tokens.push( token );
		return true;
	});

	if ( value !== "" ) {
		valid = false;
	}

	return valid ? tokens : [];
};




var dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {
	return function dateParser( value ) {
		var tokens;

		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		tokens = dateTokenizer( value, numberParser, tokenizerProperties );
		return dateParse( value, tokens, parseProperties ) || null;
	};
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




/**
 * tokenizerProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 *
 * @cldr [Cldr instance].
 *
 * Return Object with data that will be used by tokenizer.
 */
var dateTokenizerProperties = function( pattern, cldr, timeZone ) {
	var digitsReSource,
		properties = {
			pattern: looseMatching( pattern )
		},
		timeSeparator = numberSymbol( "timeSeparator", cldr ),
		widths = [ "abbreviated", "wide", "narrow" ];

	digitsReSource = numberNumberingSystemDigitsMap( cldr );
	digitsReSource = digitsReSource ? "[" + digitsReSource + "]" : "\\d";
	properties.digitsRe = new RegExp( digitsReSource );

	// Transform:
	// - "+H;-H" -> /\+(\d\d?)|-(\d\d?)/
	// - "+HH;-HH" -> /\+(\d\d)|-(\d\d)/
	// - "+HHmm;-HHmm" -> /\+(\d\d)(\d\d)|-(\d\d)(\d\d)/
	// - "+HH:mm;-HH:mm" -> /\+(\d\d):(\d\d)|-(\d\d):(\d\d)/
	//
	// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:
	// - "+H;-H" -> /GMT\+(\d\d?)|GMT-(\d\d?)/
	function hourFormatRe( hourFormat, gmtFormat, digitsReSource, timeSeparator ) {
		var re;

		if ( !digitsReSource ) {
			digitsReSource = "\\d";
		}
		if ( !gmtFormat ) {
			gmtFormat = "{0}";
		}

		re = hourFormat
			.replace( "+", "\\+" )

			// Unicode equivalent to (\\d\\d)
			.replace( /HH|mm|ss/g, "((" + digitsReSource + "){2})" )

			// Unicode equivalent to (\\d\\d?)
			.replace( /H|m/g, "((" + digitsReSource + "){1,2})" );

		if ( timeSeparator ) {
			re = re.replace( /:/g, timeSeparator );
		}

		re = re.split( ";" ).map(function( part ) {
			return gmtFormat.replace( "{0}", part );
		}).join( "|" );

		return new RegExp( "^" + re );
	}

	function populateProperties( path, value ) {

		// Skip
		var skipRe = /(timeZoneNames\/zone|supplemental\/metaZones|timeZoneNames\/metazone|timeZoneNames\/regionFormat|timeZoneNames\/gmtFormat)/;
		if ( skipRe.test( path ) ) {
			return;
		}

		if ( !value ) {
			return;
		}

		// The `dates` and `calendars` trim's purpose is to reduce properties' key size only.
		path = path.replace( /^.*\/dates\//, "" ).replace( /calendars\//, "" );

		// Specific filter for "gregorian/dayPeriods/format/wide".
		if ( path === "gregorian/dayPeriods/format/wide" ) {
			value = objectFilter( value, /^am|^pm/ );
		}

		// Transform object into array of pairs [key, /value/], sort by desc value length.
		if ( isPlainObject( value ) ) {
			value = Object.keys( value ).map(function( key ) {
				return [ key, new RegExp( "^" + regexpEscape( looseMatching( value[ key ] ) ) ) ];
			}).sort(function( a, b ) {
				return b[ 1 ].source.length - a[ 1 ].source.length;
			});

		// If typeof value === "string".
		} else {
			value = looseMatching( value );
		}
		properties[ path ] = value;
	}

	function regexpSourceSomeTerm( terms ) {
		return "(" + terms.filter(function( item ) {
			return item;
		}).reduce(function( memo, item ) {
			return memo + "|" + item;
		}) + ")";
	}

	cldr.on( "get", populateProperties );

	pattern.match( datePatternRe ).forEach(function( current ) {
		var aux, chr, daylightTzName, gmtFormat, length, standardTzName;

		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "Z" ) {
			if ( length < 5 ) {
				chr = "O";
				length = 4;
			} else {
				chr = "X";
				length = 5;
			}
		}

		// z...zzz: "{shortRegion}", eg. "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "z" ) {
			standardTzName = dateGetTimeZoneName( length, "standard", timeZone, cldr );
			daylightTzName = dateGetTimeZoneName( length, "daylight", timeZone, cldr );
			if ( standardTzName ) {
				standardTzName = regexpEscape( looseMatching( standardTzName ) );
			}
			if ( daylightTzName ) {
				daylightTzName = regexpEscape( looseMatching( daylightTzName ) );
			}
			if ( standardTzName || daylightTzName ) {
				properties.standardOrDaylightTzName = new RegExp(
					"^" + regexpSourceSomeTerm([ standardTzName, daylightTzName ])
				);
			}

			// Fall through the "O" format in case one name is missing.
			if ( !standardTzName || !daylightTzName ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			if ( length !== 1 && length !== 4 ) {
				throw createErrorUnsupportedFeature({
					feature: "timezone pattern `" + pattern + "`"
				});
			}
			var genericTzName = dateGetTimeZoneName( length, "generic", timeZone, cldr );
			if ( genericTzName ) {
				properties.genericTzName = new RegExp(
					"^" + regexpEscape( looseMatching( genericTzName ) )
				);
				chr = "O";

			// Fall back to "V" format.
			} else {
				chr = "V";
				length = 4;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Day
			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":

				// lookup for length >=3.
				if ( length <= 2 ) {
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				cldr.main(
					"dates/calendars/gregorian/dayPeriods/format/wide"
				);
				break;

			// Zone
			case "V":

				if ( length === 1 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}

				if ( timeZone ) {
					if ( length === 2 ) {

						// Skip looseMatching processing since timeZone is a canonical posix value.
						properties.timeZoneName = timeZone;
						properties.timeZoneNameRe = new RegExp( "^" + regexpEscape( timeZone ) );
						break;
					}

					var timeZoneName,
						exemplarCity = cldr.main([
							"dates/timeZoneNames/zone", timeZone, "exemplarCity"
						]);

					if ( length === 3 ) {
						if ( !exemplarCity ) {
							exemplarCity = cldr.main([
								"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity"
							]);
						}
						timeZoneName = exemplarCity;
					}

					if ( exemplarCity && length === 4 ) {
						timeZoneName = formatMessage(
							cldr.main(
								"dates/timeZoneNames/regionFormat"
							),
							[ exemplarCity ]
						);
					}

					if ( timeZoneName ) {
						timeZoneName = looseMatching( timeZoneName );
						properties.timeZoneName = timeZoneName;
						properties.timeZoneNameRe = new RegExp(
							"^" + regexpEscape( timeZoneName )
						);
					}
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "z":
			case "O":
				gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				cldr.main( "dates/timeZoneNames/gmtZeroFormat" );
				cldr.main( "dates/timeZoneNames/hourFormat" );
				properties[ "timeZoneNames/gmtZeroFormatRe" ] =
					new RegExp( "^" + regexpEscape( properties[ "timeZoneNames/gmtZeroFormat" ] ) );
				aux = properties[ "timeZoneNames/hourFormat" ];
				properties[ "timeZoneNames/hourFormat" ] = (
					length < 4 ?
						[ dateTimezoneHourFormatHm( aux, "H" ), dateTimezoneHourFormatH( aux ) ] :
						[ dateTimezoneHourFormatHm( aux, "HH" ) ]
				).map(function( hourFormat ) {
					return hourFormatRe(
						hourFormat,
						gmtFormat,
						digitsReSource,
						timeSeparator
					);
				});

			/* falls through */
			case "X":
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				properties.x = [
					[ "+HHmm;-HHmm", "+HH;-HH" ],
					[ "+HHmm;-HHmm" ],
					[ "+HH:mm;-HH:mm" ],
					[ "+HHmmss;-HHmmss", "+HHmm;-HHmm" ],
					[ "+HH:mm:ss;-HH:mm:ss", "+HH:mm;-HH:mm" ]
				][ length - 1 ].map(function( hourFormat ) {
					return hourFormatRe( hourFormat );
				});
		}
	});

	cldr.off( "get", populateProperties );

	return properties;
};




/**
 * dayOfWeek( date, firstDay )
 *
 * @date
 *
 * @firstDay the result of `dateFirstDayOfWeek( cldr )`
 *
 * Return the day of the week normalized by the territory's firstDay [0-6].
 * Eg for "mon":
 * - return 0 if territory is GB, or BR, or DE, or FR (week starts on "mon");
 * - return 1 if territory is US (week starts on "sun");
 * - return 2 if territory is EG (week starts on "sat");
 */
var dateDayOfWeek = function( date, firstDay ) {
	return ( date.getDay() - firstDay + 7 ) % 7;
};




/**
 * distanceInDays( from, to )
 *
 * Return the distance in days between from and to Dates.
 */
var dateDistanceInDays = function( from, to ) {
	var inDays = 864e5;
	return ( to.getTime() - from.getTime() ) / inDays;
};




/**
 * dayOfYear
 *
 * Return the distance in days of the date to the begin of the year [0-d].
 */
var dateDayOfYear = function( date ) {
	return Math.floor( dateDistanceInDays( dateStartOf( date, "year" ), date ) );
};




// Invert key and values, e.g., {"year": "yY"} ==> {"y": "year", "Y": "year"}
var dateFieldsMap = objectInvert({
	"era": "G",
	"year": "yY",
	"quarter": "qQ",
	"month": "ML",
	"week": "wW",
	"day": "dDF",
	"weekday": "ecE",
	"dayperiod": "a",
	"hour": "hHkK",
	"minute": "m",
	"second": "sSA",
	"zone": "zvVOxX"
}, function( object, key, value ) {
	value.split( "" ).forEach(function( symbol ) {
		object[ symbol ] = key;
	});
	return object;
});




/**
 * millisecondsInDay
 */
var dateMillisecondsInDay = function( date ) {

	// TODO Handle daylight savings discontinuities
	return date - dateStartOf( date, "day" );
};




/**
 * hourFormat( date, format, timeSeparator, formatNumber )
 *
 * Return date's timezone offset according to the format passed.
 * Eg for format when timezone offset is 180:
 * - "+H;-H": -3
 * - "+HHmm;-HHmm": -0300
 * - "+HH:mm;-HH:mm": -03:00
 * - "+HH:mm:ss;-HH:mm:ss": -03:00:00
 */
var dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {
	var absOffset,
		offset = date.getTimezoneOffset();

	absOffset = Math.abs( offset );
	formatNumber = formatNumber || {
		1: function( value ) {
			return stringPad( value, 1 );
		},
		2: function( value ) {
			return stringPad( value, 2 );
		}
	};

	return format

		// Pick the correct sign side (+ or -).
		.split( ";" )[ offset > 0 ? 1 : 0 ]

		// Localize time separator
		.replace( ":", timeSeparator )

		// Update hours offset.
		.replace( /HH?/, function( match ) {
			return formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );
		})

		// Update minutes offset and return.
		.replace( /mm/, function() {
			return formatNumber[ 2 ]( Math.floor( absOffset % 60 ) );
		})

		// Update minutes offset and return.
		.replace( /ss/, function() {
			return formatNumber[ 2 ]( Math.floor( absOffset % 1 * 60 ) );
		});
};




/**
 * format( date, properties )
 *
 * @date [Date instance].
 *
 * @properties
 *
 * TODO Support other calendar types.
 *
 * Disclosure: this function borrows excerpts of dojo/date/locale.
 */
var dateFormat = function( date, numberFormatters, properties ) {
	var parts = [];

	var timeSeparator = properties.timeSeparator;

	// create globalize date with given timezone data
	if ( properties.timeZoneData ) {
		date = new ZonedDateTime( date, properties.timeZoneData() );
	}

	properties.pattern.replace( datePatternRe, function( current ) {
		var aux, dateField, type, value,
			chr = current.charAt( 0 ),
			length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTime;
		}

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		// z...zzz: "{shortRegion}", e.g., "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		if ( chr === "z" ) {
			if ( date.isDST ) {
				value = date.isDST() ? properties.daylightTzName : properties.standardTzName;
			}

			// Fall back to "O" format.
			if ( !value ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				value = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];
				break;

			// Year
			case "y":

				// Plain year.
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				value = date.getFullYear();
				if ( length === 2 ) {
					value = String( value );
					value = +value.substr( value.length - 2 );
				}
				break;

			case "Y":

				// Year in "Week of Year"
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays
				value = new Date( date.getTime() );
				value.setDate(
					value.getDate() + 7 -
					dateDayOfWeek( date, properties.firstDay ) -
					properties.firstDay -
					properties.minDays
				);
				value = value.getFullYear();
				if ( length === 2 ) {
					value = String( value );
					value = +value.substr( value.length - 2 );
				}
				break;

			// Quarter
			case "Q":
			case "q":
				value = Math.ceil( ( date.getMonth() + 1 ) / 3 );
				if ( length > 2 ) {
					value = properties.quarters[ chr ][ length ][ value ];
				}
				break;

			// Month
			case "M":
			case "L":
				value = date.getMonth() + 1;
				if ( length > 2 ) {
					value = properties.months[ chr ][ length ][ value ];
				}
				break;

			// Week
			case "w":

				// Week of Year.
				// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.
				// TODO should pad on ww? Not documented, but I guess so.
				value = dateDayOfWeek( dateStartOf( date, "year" ), properties.firstDay );
				value = Math.ceil( ( dateDayOfYear( date ) + value ) / 7 ) -
					( 7 - value >= properties.minDays ? 0 : 1 );
				break;

			case "W":

				// Week of Month.
				// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.
				value = dateDayOfWeek( dateStartOf( date, "month" ), properties.firstDay );
				value = Math.ceil( ( date.getDate() + value ) / 7 ) -
					( 7 - value >= properties.minDays ? 0 : 1 );
				break;

			// Day
			case "d":
				value = date.getDate();
				break;

			case "D":
				value = dateDayOfYear( date ) + 1;
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				value = Math.floor( date.getDate() / 7 ) + 1;
				break;

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {

					// Range is [1-7] (deduced by example provided on documentation)
					// TODO Should pad with zeros (not specified in the docs)?
					value = dateDayOfWeek( date, properties.firstDay ) + 1;
					break;
				}

			/* falls through */
			case "E":
				value = dateWeekDays[ date.getDay() ];
				value = properties.days[ chr ][ length ][ value ];
				break;

			// Period (AM or PM)
			case "a":
				value = properties.dayPeriods[ date.getHours() < 12 ? "am" : "pm" ];
				break;

			// Hour
			case "h": // 1-12
				value = ( date.getHours() % 12 ) || 12;
				break;

			case "H": // 0-23
				value = date.getHours();
				break;

			case "K": // 0-11
				value = date.getHours() % 12;
				break;

			case "k": // 1-24
				value = date.getHours() || 24;
				break;

			// Minute
			case "m":
				value = date.getMinutes();
				break;

			// Second
			case "s":
				value = date.getSeconds();
				break;

			case "S":
				value = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );
				break;

			case "A":
				value = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );
				break;

			// Zone
			case "z":
				break;

			case "v":

				// v...vvv: "{shortRegion}", eg. "PT".
				// vvvv: "{regionName} {Time}",
				//       e.g., "Pacific Time".
				if ( properties.genericTzName ) {
					value = properties.genericTzName;
					break;
				}

			/* falls through */
			case "V":

				//VVVV: "{explarCity} {Time}", e.g., "Los Angeles Time"
				if ( properties.timeZoneName ) {
					value = properties.timeZoneName;
					break;
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( date.getTimezoneOffset() === 0 ) {
					value = properties.gmtZeroFormat;
				} else {

					// If O..OOO and timezone offset has non-zero minutes, show minutes.
					if ( length < 4 ) {
						aux = date.getTimezoneOffset();
						aux = properties.hourFormat[ aux % 60 - aux % 1 === 0 ? 0 : 1 ];
					} else {
						aux = properties.hourFormat;
					}

					value = dateTimezoneHourFormat(
						date,
						aux,
						timeSeparator,
						numberFormatters
					);
					value = properties.gmtFormat.replace( /\{0\}/, value );
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( date.getTimezoneOffset() === 0 ) {
					value = "Z";
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				aux = date.getTimezoneOffset();

				// If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).
				if ( length === 1 && aux % 60 - aux % 1 !== 0 ) {
					length += 1;
				}

				// If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx
				// respectively (i.e., don't show optional seconds).
				if ( ( length === 4 || length === 5 ) && aux % 1 === 0 ) {
					length -= 2;
				}

				value = [
					"+HH;-HH",
					"+HHmm;-HHmm",
					"+HH:mm;-HH:mm",
					"+HHmmss;-HHmmss",
					"+HH:mm:ss;-HH:mm:ss"
				][ length - 1 ];

				value = dateTimezoneHourFormat( date, value, ":" );
				break;

			// timeSeparator
			case ":":
				value = timeSeparator;
				break;

			// ' literals.
			case "'":
				value = removeLiteralQuotes( current );
				break;

			// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and
			// arabic characters.
			default:
				value = current;

		}
		if ( typeof value === "number" ) {
			value = numberFormatters[ length ]( value );
		}

		dateField = dateFieldsMap[ chr ];
		type = dateField ? dateField : "literal";

		// Concat two consecutive literals
		if ( type === "literal" && parts.length && parts[ parts.length - 1 ].type === "literal" ) {
			parts[ parts.length - 1 ].value += value;
			return;
		}

		parts.push( { type: type, value: value } );

	});

	return parts;

};




var dateToPartsFormatterFn = function( numberFormatters, properties ) {
	return function dateToPartsFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeDate( value, "value" );

		return dateFormat( value, numberFormatters, properties );
	};

};




function optionsHasStyle( options ) {
	return options.skeleton !== undefined ||
		options.date !== undefined ||
		options.time !== undefined ||
		options.datetime !== undefined ||
		options.raw !== undefined;
}

function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [
			/dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/,
			/dates\/calendars\/gregorian\/days\/.*\/short/,
			/dates\/timeZoneNames\/zone/,
			/dates\/timeZoneNames\/metazone/,
			/globalize-iana/,
			/supplemental\/metaZones/,
			/supplemental\/timeData\/(?!001)/,
			/supplemental\/weekData\/(?!001)/
		]
	});
}

function validateOptionsPreset( options ) {
	validateOptionsPresetEach( "date", options );
	validateOptionsPresetEach( "time", options );
	validateOptionsPresetEach( "datetime", options );
}

function validateOptionsPresetEach( type, options ) {
	var value = options[ type ];
	validate(
		"E_INVALID_OPTIONS",
		"Invalid `{{type}: \"{value}\"}`.",
		value === undefined || [ "short", "medium", "long", "full" ].indexOf( value ) !== -1,
		{ type: type, value: value }
	);
}

function validateOptionsSkeleton( pattern, skeleton ) {
	validate(
		"E_INVALID_OPTIONS",
		"Invalid `{skeleton: \"{value}\"}` based on provided CLDR.",
		skeleton === undefined || ( typeof pattern === "string" && pattern ),
		{ type: "skeleton", value: skeleton }
	);
}

function validateRequiredIana( timeZone ) {
	return function( path, value ) {

		if ( !/globalize-iana/.test( path ) ) {
			return;
		}

		validate(
			"E_MISSING_IANA_TZ",
			"Missing required IANA timezone content for `{timeZone}`: `{path}`.",
			value,
			{
				path: path.replace( /globalize-iana\//, "" ),
				timeZone: timeZone
			}
		);
	};
}

/**
 * .loadTimeZone( json )
 *
 * @json [JSON]
 *
 * Load IANA timezone data.
 */
Globalize.loadTimeZone = function( json ) {
	var customData = {
			"globalize-iana": json
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	Cldr.load( customData );
};

/**
 * .dateFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date according to the given `format` and the default/instance
 * locale.
 */
Globalize.dateFormatter =
Globalize.prototype.dateFormatter = function( options ) {
	var args, dateToPartsFormatter, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}
	args = [ options ];

	dateToPartsFormatter = this.dateToPartsFormatter( options );
	returnFn = dateFormatterFn( dateToPartsFormatter );
	runtimeBind( args, this.cldr, returnFn, [ dateToPartsFormatter ] );

	return returnFn;
};

/**
 * .dateToPartsFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date to parts according to the given `format`
 * and the default/instance
 * locale.
 */
Globalize.dateToPartsFormatter =
Globalize.prototype.dateToPartsFormatter = function( options ) {
	var args, cldr, numberFormatters, pad, pattern, properties, returnFn,
		timeZone;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}

	validateOptionsPreset( options );
	validateDefaultLocale( cldr );

	timeZone = options.timeZone;
	validateParameterTypeString( timeZone, "options.timeZone" );

	args = [ options ];

	cldr.on( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.on( "get", validateRequiredIana( timeZone ) );
	}
	pattern = dateExpandPattern( options, cldr );
	validateOptionsSkeleton( pattern, options.skeleton );
	properties = dateFormatProperties( pattern, cldr, timeZone );
	cldr.off( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.off( "get", validateRequiredIana( timeZone ) );
	}

	// Create needed number formatters.
	numberFormatters = properties.numberFormatters;
	delete properties.numberFormatters;
	for ( pad in numberFormatters ) {
		numberFormatters[ pad ] = this.numberFormatter({
			raw: numberFormatters[ pad ]
		});
	}

	returnFn = dateToPartsFormatterFn( numberFormatters, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );

	return returnFn;
};

/**
 * .dateParser( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a function that parses a string date according to the given `formats` and the
 * default/instance locale.
 */
Globalize.dateParser =
Globalize.prototype.dateParser = function( options ) {
	var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone,
		tokenizerProperties;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}

	validateOptionsPreset( options );
	validateDefaultLocale( cldr );

	timeZone = options.timeZone;
	validateParameterTypeString( timeZone, "options.timeZone" );

	args = [ options ];

	cldr.on( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.on( "get", validateRequiredIana( timeZone ) );
	}
	pattern = dateExpandPattern( options, cldr );
	validateOptionsSkeleton( pattern, options.skeleton );
	tokenizerProperties = dateTokenizerProperties( pattern, cldr, timeZone );
	parseProperties = dateParseProperties( cldr, timeZone );
	cldr.off( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.off( "get", validateRequiredIana( timeZone ) );
	}

	numberParser = this.numberParser({ raw: "0" });

	returnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );

	runtimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );

	return returnFn;
};

/**
 * .formatDate( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number according to the given options string and the default/instance locale.
 */
Globalize.formatDate =
Globalize.prototype.formatDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateFormatter( options )( value );
};

/**
 * .formatDateToParts( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number to parts according to the given options and the default/instance locale.
 */
Globalize.formatDateToParts =
Globalize.prototype.formatDateToParts = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateToPartsFormatter( options )( value );
};

/**
 * .parseDate( value, options )
 *
 * @value [String]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a Date instance or null.
 */
Globalize.parseDate =
Globalize.prototype.parseDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.dateParser( options )( value );
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/message.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	createError = Globalize._createError,
	isPlainObject = Globalize._isPlainObject,
	runtimeBind = Globalize._runtimeBind,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validate = Globalize._validate,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MessageFormat;
/* jshint ignore:start */
MessageFormat = (function() {
MessageFormat._parse = (function() {

  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function(st) {
              return { type: 'messageFormatPattern', statements: st };
            },
        peg$c2 = peg$FAILED,
        peg$c3 = "{",
        peg$c4 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c5 = null,
        peg$c6 = ",",
        peg$c7 = { type: "literal", value: ",", description: "\",\"" },
        peg$c8 = "}",
        peg$c9 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c10 = function(argIdx, efmt) {
              var res = {
                type: "messageFormatElement",
                argumentIndex: argIdx
              };
              if (efmt && efmt.length) {
                res.elementFormat = efmt[1];
              } else {
                res.output = true;
              }
              return res;
            },
        peg$c11 = "plural",
        peg$c12 = { type: "literal", value: "plural", description: "\"plural\"" },
        peg$c13 = function(t, s) {
              return { type: "elementFormat", key: t, val: s };
            },
        peg$c14 = "selectordinal",
        peg$c15 = { type: "literal", value: "selectordinal", description: "\"selectordinal\"" },
        peg$c16 = "select",
        peg$c17 = { type: "literal", value: "select", description: "\"select\"" },
        peg$c18 = function(t, p) {
              return { type: "elementFormat", key: t, val: p };
            },
        peg$c19 = function(op, pf) {
              return { type: "pluralFormatPattern", pluralForms: pf, offset: op || 0 };
            },
        peg$c20 = "offset",
        peg$c21 = { type: "literal", value: "offset", description: "\"offset\"" },
        peg$c22 = ":",
        peg$c23 = { type: "literal", value: ":", description: "\":\"" },
        peg$c24 = function(d) { return d; },
        peg$c25 = function(k, mfp) {
              return { key: k, val: mfp };
            },
        peg$c26 = function(i) { return i; },
        peg$c27 = "=",
        peg$c28 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c29 = function(pf) { return { type: "selectFormatPattern", pluralForms: pf }; },
        peg$c30 = function(p) { return p; },
        peg$c31 = "#",
        peg$c32 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c33 = function() { return {type: 'octothorpe'}; },
        peg$c34 = function(s) { return { type: "string", val: s.join('') }; },
        peg$c35 = { type: "other", description: "identifier" },
        peg$c36 = /^[0-9a-zA-Z$_]/,
        peg$c37 = { type: "class", value: "[0-9a-zA-Z$_]", description: "[0-9a-zA-Z$_]" },
        peg$c38 = /^[^ \t\n\r,.+={}]/,
        peg$c39 = { type: "class", value: "[^ \\t\\n\\r,.+={}]", description: "[^ \\t\\n\\r,.+={}]" },
        peg$c40 = function(s) { return s; },
        peg$c41 = function(chars) { return chars.join(''); },
        peg$c42 = /^[^{}#\\\0-\x1F \t\n\r]/,
        peg$c43 = { type: "class", value: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]", description: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]" },
        peg$c44 = function(x) { return x; },
        peg$c45 = "\\\\",
        peg$c46 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c47 = function() { return "\\"; },
        peg$c48 = "\\#",
        peg$c49 = { type: "literal", value: "\\#", description: "\"\\\\#\"" },
        peg$c50 = function() { return "#"; },
        peg$c51 = "\\{",
        peg$c52 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
        peg$c53 = function() { return "\u007B"; },
        peg$c54 = "\\}",
        peg$c55 = { type: "literal", value: "\\}", description: "\"\\\\}\"" },
        peg$c56 = function() { return "\u007D"; },
        peg$c57 = "\\u",
        peg$c58 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
        peg$c59 = function(h1, h2, h3, h4) {
              return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
            },
        peg$c60 = /^[0-9]/,
        peg$c61 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c62 = function(ds) {
            //the number might start with 0 but must not be interpreted as an octal number
            //Hence, the base is passed to parseInt explicitely
            return parseInt((ds.join('')), 10);
          },
        peg$c63 = /^[0-9a-fA-F]/,
        peg$c64 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c65 = { type: "other", description: "whitespace" },
        peg$c66 = function(w) { return w.join(''); },
        peg$c67 = /^[ \t\n\r]/,
        peg$c68 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsemessageFormatPattern();

      return s0;
    }

    function peg$parsemessageFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsemessageFormatElement();
      if (s2 === peg$FAILED) {
        s2 = peg$parsestring();
        if (s2 === peg$FAILED) {
          s2 = peg$parseoctothorpe();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsemessageFormatElement();
        if (s2 === peg$FAILED) {
          s2 = peg$parsestring();
          if (s2 === peg$FAILED) {
            s2 = peg$parseoctothorpe();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsemessageFormatElement() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c3;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseid();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c6;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseelementFormat();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c5;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c8;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c9); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c10(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseelementFormat() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c11) {
          s2 = peg$c11;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c6;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsepluralFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c13(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 13) === peg$c14) {
            s2 = peg$c14;
            peg$currPos += 13;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c6;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsepluralFormatPattern();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c13(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c16) {
              s2 = peg$c16;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c6;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c7); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseselectFormatPattern();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c13(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseid();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseargStylePattern();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseargStylePattern();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c18(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
      }

      return s0;
    }

    function peg$parsepluralFormatPattern() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseoffsetPattern();
      if (s1 === peg$FAILED) {
        s1 = peg$c5;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsepluralForm();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsepluralForm();
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c19(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoffsetPattern() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c20) {
          s2 = peg$c20;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c22;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsedigits();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c24(s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepluralKey();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralKey() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsedigits();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseselectFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseselectForm();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseselectForm();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c29(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseselectForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseid();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseargStylePattern() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseid();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c30(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoctothorpe() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c33();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechars();
      if (s2 === peg$FAILED) {
        s2 = peg$parsewhitespace();
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechars();
          if (s2 === peg$FAILED) {
            s2 = peg$parsewhitespace();
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseid() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c38.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c39); }
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c2;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c40(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }

      return s0;
    }

    function peg$parsechars() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechar();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c41(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (peg$c42.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c44(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c45) {
          s1 = peg$c45;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c48) {
            s1 = peg$c48;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c57) {
                  s1 = peg$c57;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c58); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsehexDigit();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsehexDigit();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parsehexDigit();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsehexDigit();
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c59(s2, s3, s4, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsedigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c62(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      if (peg$c63.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c66(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0;

      if (peg$c67.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
}()).parse;


/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript
 *  @author Alex Sexton - @SlexAxton
 *  @version 0.3.0-1
 *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors
 *  @license To use or fork, MIT. To contribute back, Dojo CLA  */


/** Utility function for quoting an Object's key value iff required
 *  @private  */
function propname(key, obj) {
  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {
    return obj ? obj + '.' + key : key;
  } else {
    var jkey = JSON.stringify(key);
    return obj ? obj + '[' + jkey + ']' : jkey;
  }
};


/** Create a new message formatter
 *
 *  @class
 *  @global
 *  @param {string|string[]} [locale="en"] - The locale to use, with fallbacks
 *  @param {function} [pluralFunc] - Optional custom pluralization function
 *  @param {function[]} [formatters] - Optional custom formatting functions  */
function MessageFormat(locale, pluralFunc, formatters) {
  this.lc = [locale];  
  this.runtime.pluralFuncs = {};
  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;
  this.runtime.fmt = {};
  if (formatters) for (var f in formatters) {
    this.runtime.fmt[f] = formatters[f];
  }
}




/** Parse an input string to its AST
 *
 *  Precompiled from `lib/messageformat-parser.pegjs` by
 *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object
 *  to enable testing.
 *
 *  @private  */



/** Pluralization functions from
 *  {@link http://github.com/eemeli/make-plural.js make-plural}
 *
 *  @memberof MessageFormat
 *  @type Object.<string,function>  */
MessageFormat.plurals = {};


/** Default number formatting functions in the style of ICU's
 *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}
 *  implemented using the
 *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}
 *  object defined by ECMA-402.
 *
 *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so
 *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.
 *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these
 *  functions to be available for inclusion in the output.
 *
 *  @see MessageFormat#setIntlSupport
 *
 *  @namespace
 *  @memberof MessageFormat
 *  @property {function} number - Represent a number as an integer, percent or currency value
 *  @property {function} date - Represent a date as a full/long/default/short string
 *  @property {function} time - Represent a time as a full/long/default/short string
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is 5.50."
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is 5.50."  */
MessageFormat.formatters = {};

/** Enable or disable support for the default formatters, which require the
 *  `Intl` object. Note that this can't be autodetected, as the environment
 *  in which the formatted text is compiled into Javascript functions is not
 *  necessarily the same environment in which they will get executed.
 *
 *  @see MessageFormat.formatters
 *
 *  @memberof MessageFormat
 *  @param {boolean} [enable=true]
 *  @returns {Object} The MessageFormat instance, to allow for chaining
 *  @example
 *  > var Intl = require('intl');
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > mf.compile("The total is {V,number,currency}.")({V:5.5});
 *  "The total is 5.50."  */



/** A set of utility functions that are called by the compiled Javascript
 *  functions, these are included locally in the output of {@link
 *  MessageFormat#compile compile()}.
 *
 *  @namespace
 *  @memberof MessageFormat  */
MessageFormat.prototype.runtime = {

  /** Utility function for `#` in plural rules
   *
   *  @param {number} value - The value to operate on
   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */
  number: function(value, offset) {
    if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
    return value - (offset || 0);
  },

  /** Utility function for `{N, plural|selectordinal, ...}`
   *
   *  @param {number} value - The key to use to find a pluralization rule
   *  @param {number} offset - An offset to apply to `value`
   *  @param {function} lcfunc - A locale function from `pluralFuncs`
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules
   *  @returns {string} The result of the pluralization  */
  plural: function(value, offset, lcfunc, data, isOrdinal) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    if (offset) value -= offset;
    var key = lcfunc(value, isOrdinal);
    if (key in data) return data[key]();
    return data.other();
  },

  /** Utility function for `{N, select, ...}`
   *
   *  @param {number} value - The key to use to find a selection
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @returns {string} The result of the select statement  */
  select: function(value, data) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    return data.other()
  },

  /** Pluralization functions included in compiled output
   *  @instance
   *  @type Object.<string,function>  */
  pluralFuncs: {},

  /** Custom formatting functions called by `{var, fn[, args]*}` syntax
   *
   *  For examples, see {@link MessageFormat.formatters}
   *
   *  @instance
   *  @see MessageFormat.formatters
   *  @type Object.<string,function>  */
  fmt: {},

  /** Custom stringifier to clean up browser inconsistencies
   *  @instance  */
  toString: function () {
    var _stringify = function(o, level) {
      if (typeof o != 'object') {
        var funcStr = o.toString().replace(/^(function )\w*/, '$1');
        var indent = /([ \t]*)\S.*$/.exec(funcStr);
        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;
      }
      var s = [];
      for (var i in o) if (i != 'toString') {
        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\n');
        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));
      }
      if (level == 0) return s.join('');
      if (s.length == 0) return '{}';
      var indent = '  '; while (--level) indent += '  ';
      return '{\n' + s.join(',\n').replace(/^/gm, indent) + '\n}';
    };
    return _stringify(this, 0);
  }
};


/** Recursively map an AST to its resulting string
 *
 *  @memberof MessageFormat
 *
 *  @param ast - the Ast node for which the JS code should be generated
 *
 *  @private  */
MessageFormat.prototype._precompile = function(ast, data) {
  data = data || { keys: {}, offset: {} };
  var r = [], i, tmp, args = [];

  switch ( ast.type ) {
    case 'messageFormatPattern':
      for ( i = 0; i < ast.statements.length; ++i ) {
        r.push(this._precompile( ast.statements[i], data ));
      }
      tmp = r.join(' + ') || '""';
      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';

    case 'messageFormatElement':
      data.pf_count = data.pf_count || 0;
      if ( ast.output ) {
        return propname(ast.argumentIndex, 'd');
      }
      else {
        data.keys[data.pf_count] = ast.argumentIndex;
        return this._precompile( ast.elementFormat, data );
      }
      return '';

    case 'elementFormat':
      args = [ propname(data.keys[data.pf_count], 'd') ];
      switch (ast.key) {
        case 'select':
          args.push(this._precompile(ast.val, data));
          return 'select(' + args.join(', ') + ')';
        case 'selectordinal':
          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);
          return 'plural(' + args.join(', ') + ')';
        case 'plural':
          data.offset[data.pf_count || 0] = ast.val.offset || 0;
          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);
          return 'plural(' + args.join(', ') + ')';
        default:
          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {
            tmp = MessageFormat.formatters[ast.key];
            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;
          }
          args.push(JSON.stringify(this.lc));
          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));
          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';
      }

    case 'pluralFormatPattern':
    case 'selectFormatPattern':
      data.pf_count = data.pf_count || 0;
      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;
      var needOther = true;
      for (i = 0; i < ast.pluralForms.length; ++i) {
        var key = ast.pluralForms[i].key;
        if (key === 'other') needOther = false;
        var data_copy = JSON.parse(JSON.stringify(data));
        data_copy.pf_count++;
        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');
      }
      if (needOther) throw new Error("No 'other' form found in " + ast.type + " " + data.pf_count);
      return '{ ' + r.join(', ') + ' }';

    case 'string':
      return JSON.stringify(ast.val || "");

    case 'octothorpe':
      if (!data.pf_count) return '"#"';
      args = [ propname(data.keys[data.pf_count-1], 'd') ];
      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);
      return 'number(' + args.join(', ') + ')';

    default:
      throw new Error( 'Bad AST type: ' + ast.type );
  }
};

/** Compile messages into an executable function with clean string
 *  representation.
 *
 *  If `messages` is a single string including ICU MessageFormat declarations,
 *  `opt` is ignored and the returned function takes a single Object parameter
 *  `d` representing each of the input's defined variables. The returned
 *  function will be defined in a local scope that includes all the required
 *  runtime variables.
 *
 *  If `messages` is a map of keys to strings, or a map of namespace keys to
 *  such key/string maps, the returned function will fill the specified global
 *  with javascript functions matching the structure of the input. In such use,
 *  the output of `compile()` is expected to be serialized using `.toString()`,
 *  and will include definitions of the runtime functions. If `opt.global` is
 *  null, calling the output function will return the object itself.
 *
 *  Together, the input parameters should match the following patterns:
 *  ```js
 *  messages = "string" || { key0: "string0", key1: "string1", ... } || {
 *    ns0: { key0: "string0", key1: "string1", ...  },
 *    ns1: { key0: "string0", key1: "string1", ...  },
 *    ...
 *  }
 *
 *  opt = null || {
 *    locale: null || {
 *      ns0: "lc0" || [ "lc0", ... ],
 *      ns1: "lc1" || [ "lc1", ... ],
 *      ...
 *    },
 *    global: null || "module.exports" || "exports" || "i18n" || ...
 *  }
 *  ```
 *
 *  @memberof MessageFormat
 *  @param {string|Object}
 *      messages - The input message(s) to be compiled, in ICU MessageFormat
 *  @param {Object} [opt={}] - Options controlling output for non-simple intput
 *  @param {Object} [opt.locale] - The locales to use for the messages, with a
 *      structure matching that of `messages`
 *  @param {string} [opt.global=""] - The global variable that the output
 *      function should use, or a null string for none. "exports" and
 *      "module.exports" are recognised as special cases.
 *  @returns {function} The first match found for the given locale(s)
 *
 *  @example
 * > var MessageFormat = require('messageformat'),
 * ...   mf = new MessageFormat('en'),
 * ...   mfunc0 = mf.compile('A {TYPE} example.');
 * > mfunc0({TYPE:'simple'})
 * 'A simple example.'
 * > mfunc0.toString()
 * 'function (d) { return "A " + d.TYPE + " example."; }'
 *
 *  @example
 * > var msgSet = { a: 'A {TYPE} example.',
 * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },
 * ...   mfuncSet = mf.compile(msgSet);
 * > mfuncSet().a({TYPE:'more complex'})
 * 'A more complex example.'
 * > mfuncSet().b({COUNT:2})
 * 'This has 2 members.'
 *
 * > console.log(mfuncSet.toString())
 * function anonymous() {
 * var number = function (value, offset) {
 *   if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
 *   return value - (offset || 0);
 * };
 * var plural = function (value, offset, lcfunc, data, isOrdinal) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   if (offset) value -= offset;
 *   var key = lcfunc(value, isOrdinal);
 *   if (key in data) return data[key]();
 *   return data.other();
 * };
 * var select = function (value, data) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   return data.other()
 * };
 * var pluralFuncs = {
 *   en: function (n, ord) {
 *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
 *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
 *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'
 *         : (n10 == 2 && n100 != 12) ? 'two'
 *         : (n10 == 3 && n100 != 13) ? 'few'
 *         : 'other';
 *     return (n == 1 && v0) ? 'one' : 'other';
 *   }
 * };
 * var fmt = {};
 *
 * return {
 *   a: function(d) { return "A " + d.TYPE + " example."; },
 *   b: function(d) { return "This has " + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return "one member";}, other: function() { return number(d.COUNT)+" members";} }) + "."; }
 * }
 * }
 *
 *  @example
 * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;
 * > var multiSet = { en: { a: 'A {TYPE} example.',
 * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },
 * ...                fi: { a: '{TYPE} esimerkki.',
 * ...                      b: 'Tm on {COUNT, selectordinal, other{#.}} esimerkki.' } },
 * ...   multiSetLocales = { en: 'en', fi: 'fi' },
 * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });
 * > mfuncSet(this);
 * > i18n.en.b({COUNT:3})
 * 'This is the 3rd example.'
 * > i18n.fi.b({COUNT:3})
 * 'Tm on 3. esimerkki.'  */
MessageFormat.prototype.compile = function ( messages, opt ) {
  var r = {}, lc0 = this.lc,
      compileMsg = function(self, msg) {
        try {
          var ast = MessageFormat._parse(msg);
          return self._precompile(ast);
        } catch (e) {
          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());
        }
      },
      stringify = function(r, level) {
        if (!level) level = 0;
        if (typeof r != 'object') return r;
        var o = [], indent = '';
        for (var i = 0; i < level; ++i) indent += '  ';
        for (var k in r) o.push('\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));
        return '{' + o.join(',') + '\n' + indent + '}';
      };

  if (typeof messages == 'string') {
    var f = new Function(
        'number, plural, select, pluralFuncs, fmt',
        'return ' + compileMsg(this, messages));
    return f(this.runtime.number, this.runtime.plural, this.runtime.select,
        this.runtime.pluralFuncs, this.runtime.fmt);
  }

  opt = opt || {};

  for (var ns in messages) {
    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;
    if (typeof messages[ns] == 'string') {
      try { r[ns] = compileMsg(this, messages[ns]); }
      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }
    } else {
      r[ns] = {};
      for (var key in messages[ns]) {
        try { r[ns][key] = compileMsg(this, messages[ns][key]); }
        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }
      }
    }
  }

  this.lc = lc0;
  var s = this.runtime.toString() + '\n';
  switch (opt.global || '') {
    case 'exports':
      var o = [];
      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));
      return new Function(s + o.join(';\n'));
    case 'module.exports':
      return new Function(s + 'module.exports = ' + stringify(r));
    case '':
      return new Function(s + 'return ' + stringify(r));
    default:
      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));
  }
};


return MessageFormat;
}());
/* jshint ignore:end */


var createErrorPluralModulePresence = function() {
	return createError( "E_MISSING_PLURAL_MODULE", "Plural module not loaded." );
};




var validateMessageBundle = function( cldr ) {
	validate(
		"E_MISSING_MESSAGE_BUNDLE",
		"Missing message bundle for locale `{locale}`.",
		cldr.attributes.bundle && cldr.get( "globalize-messages/{bundle}" ) !== undefined,
		{
			locale: cldr.locale
		}
	);
};




var validateMessagePresence = function( path, value ) {
	path = path.join( "/" );
	validate( "E_MISSING_MESSAGE", "Missing required message content `{path}`.",
		value !== undefined, { path: path } );
};




var validateMessageType = function( path, value ) {
	path = path.join( "/" );
	validate(
		"E_INVALID_MESSAGE",
		"Invalid message content `{path}`. {expected} expected.",
		typeof value === "string",
		{
			expected: "a string",
			path: path
		}
	);
};




var validateParameterTypeMessageVariables = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ) || Array.isArray( value ),
		"Array or Plain Object"
	);
};




var messageFormatterFn = function( formatter ) {
	return function messageFormatter( variables ) {
		if ( typeof variables === "number" || typeof variables === "string" ) {
			variables = [].slice.call( arguments, 0 );
		}
		validateParameterTypeMessageVariables( variables, "variables" );
		return formatter( variables );
	};
};




var messageFormatterRuntimeBind = function( cldr, messageformatter ) {
	var locale = cldr.locale,
		origToString = messageformatter.toString;

	messageformatter.toString = function() {
		var argNames, argValues, output,
			args = {};

		// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:
		output = origToString.call( messageformatter );

		if ( /number\(/.test( output ) ) {
			args.number = "messageFormat.number";
		}

		if ( /plural\(/.test( output ) ) {
			args.plural = "messageFormat.plural";
		}

		if ( /select\(/.test( output ) ) {
			args.select = "messageFormat.select";
		}

		output.replace( /pluralFuncs(\[([^\]]+)\]|\.([a-zA-Z]+))/, function( match ) {
			args.pluralFuncs = "{" +
				"\"" + locale + "\": Globalize(\"" + locale + "\").pluralGenerator()" +
				"}";
			return match;
		});

		argNames = Object.keys( args ).join( ", " );
		argValues = Object.keys( args ).map(function( key ) {
			return args[ key ];
		}).join( ", " );

		return "(function( " + argNames + " ) {\n" +
			"  return " + output + "\n" +
			"})(" + argValues + ")";
	};

	return messageformatter;
};




var slice = [].slice;

/**
 * .loadMessages( json )
 *
 * @json [JSON]
 *
 * Load translation data.
 */
Globalize.loadMessages = function( json ) {
	var locale,
		customData = {
			"globalize-messages": json,
			"main": {}
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	// Set available bundles by populating customData main dataset.
	for ( locale in json ) {
		if ( json.hasOwnProperty( locale ) ) {
			customData.main[ locale ] = {};
		}
	}

	Cldr.load( customData );
};

/**
 * .messageFormatter( path )
 *
 * @path [String or Array]
 *
 * Format a message given its path.
 */
Globalize.messageFormatter =
Globalize.prototype.messageFormatter = function( path ) {
	var cldr, formatter, message, pluralGenerator, returnFn,
		args = slice.call( arguments, 0 );

	validateParameterPresence( path, "path" );
	validateParameterType( path, "path", typeof path === "string" || Array.isArray( path ),
		"a String nor an Array" );

	path = alwaysArray( path );
	cldr = this.cldr;

	validateDefaultLocale( cldr );
	validateMessageBundle( cldr );

	message = cldr.get( [ "globalize-messages/{bundle}" ].concat( path ) );
	validateMessagePresence( path, message );

	// If message is an Array, concatenate it.
	if ( Array.isArray( message ) ) {
		message = message.join( " " );
	}
	validateMessageType( path, message );

	// Is plural module present? Yes, use its generator. Nope, use an error generator.
	pluralGenerator = this.plural !== undefined ?
		this.pluralGenerator() :
		createErrorPluralModulePresence;

	formatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );

	returnFn = messageFormatterFn( formatter );

	runtimeBind( args, cldr, returnFn,
		[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );

	return returnFn;
};

/**
 * .formatMessage( path [, variables] )
 *
 * @path [String or Array]
 *
 * @variables [Number, String, Array or Object]
 *
 * Format a message given its path.
 */
Globalize.formatMessage =
Globalize.prototype.formatMessage = function( path /* , variables */ ) {
	return this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/number.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	regexpEscape = Globalize._regexpEscape,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterRange = Globalize._validateParameterRange,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var createErrorUnsupportedFeature = function( feature ) {
	return createError( "E_UNSUPPORTED", "Unsupported {feature}.", {
		feature: feature
	});
};




var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypeString = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string",
		"a string"
	);
};




/**
 * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )
 *
 * @number [Number].
 *
 * @primaryGroupingSize [Number]
 *
 * @secondaryGroupingSize [Number]
 *
 * Return the formatted number with group separator.
 */
var numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {
	var index,
		currentGroupingSize = primaryGroupingSize,
		ret = "",
		sep = ",",
		switchToSecondary = secondaryGroupingSize ? true : false;

	number = String( number ).split( "." );
	index = number[ 0 ].length;

	while ( index > currentGroupingSize ) {
		ret = number[ 0 ].slice( index - currentGroupingSize, index ) +
			( ret.length ? sep : "" ) + ret;
		index -= currentGroupingSize;
		if ( switchToSecondary ) {
			currentGroupingSize = secondaryGroupingSize;
			switchToSecondary = false;
		}
	}

	number[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : "" ) + ret;
	return number.join( "." );
};




/**
 * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,
 * maximumFractionDigits, round, roundIncrement )
 *
 * @number [Number]
 *
 * @minimumIntegerDigits [Number]
 *
 * @minimumFractionDigits [Number]
 *
 * @maximumFractionDigits [Number]
 *
 * @round [Function]
 *
 * @roundIncrement [Function]
 *
 * Return the formatted integer and fraction digits.
 */
var numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,
	roundIncrement ) {

	// Fraction
	if ( maximumFractionDigits ) {

		// Rounding
		if ( roundIncrement ) {
			number = round( number, roundIncrement );

		// Maximum fraction digits
		} else {
			number = round( number, { exponent: -maximumFractionDigits } );
		}

	} else {
		number = round( number );
	}

	number = String( number );

	// Maximum integer digits (post string phase)
	if ( maximumFractionDigits && /e-/.test( number ) ) {

		// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are
		// displayed using plain digits instead of scientific notation.
		// 1: Remove leading decimal zeros.
		// 2: Remove leading decimal separator.
		// Note: String() is still preferred so it doesn't mess up with a number precision
		// unnecessarily, e.g., (123456789.123).toFixed(10) === "123456789.1229999959",
		// String(123456789.123) === "123456789.123".
		number = ( +number ).toFixed( maximumFractionDigits )
			.replace( /0+$/, "" ) /* 1 */
			.replace( /\.$/, "" ) /* 2 */;
	}

	// Minimum fraction digits (post string phase)
	if ( minimumFractionDigits ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumFractionDigits, true );
		number = number.join( "." );
	}

	// Minimum integer digits
	if ( minimumIntegerDigits ) {
		number = number.split( "." );
		number[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );
		number = number.join( "." );
	}

	return number;
};




/**
 * toPrecision( number, precision, round )
 *
 * @number (Number)
 *
 * @precision (Number) significant figures precision (not decimal precision).
 *
 * @round (Function)
 *
 * Return number.toPrecision( precision ) using the given round function.
 */
var numberToPrecision = function( number, precision, round ) {
	var roundOrder;

	// Get number at two extra significant figure precision.
	number = number.toPrecision( precision + 2 );

	// Then, round it to the required significant figure precision.
	roundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );
	roundOrder -= precision;

	return round( number, { exponent: roundOrder } );
};




/**
 * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )
 *
 * @number [Number]
 *
 * @minimumSignificantDigits [Number]
 *
 * @maximumSignificantDigits [Number]
 *
 * @round [Function]
 *
 * Return the formatted significant digits number.
 */
var numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {
	var atMinimum, atMaximum;

	// Sanity check.
	if ( minimumSignificantDigits > maximumSignificantDigits ) {
		maximumSignificantDigits = minimumSignificantDigits;
	}

	atMinimum = numberToPrecision( number, minimumSignificantDigits, round );
	atMaximum = numberToPrecision( number, maximumSignificantDigits, round );

	// Use atMaximum only if it has more significant digits than atMinimum.
	number = +atMinimum === +atMaximum ? atMinimum : atMaximum;

	// Expand integer numbers, eg. 123e5 to 12300.
	number = ( +number ).toString( 10 );

	if ( ( /e/ ).test( number ) ) {
		throw createErrorUnsupportedFeature({
			feature: "integers out of (1e21, 1e-7)"
		});
	}

	// Add trailing zeros if necessary.
	if ( minimumSignificantDigits - number.replace( /^0+|\./g, "" ).length > 0 ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumSignificantDigits - number[ 0 ].replace( /^0+/, "" ).length, true );
		number = number.join( "." );
	}

	return number;
};




/**
 * removeLiteralQuotes( string )
 *
 * Return:
 * - `` if input string is `''`.
 * - `o'clock` if input string is `'o''clock'`.
 * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted
 *   string.
 */
var removeLiteralQuotes = function( string ) {
	if ( string[ 0 ] + string[ string.length - 1 ] !== "''" ) {
		return string;
	}
	if ( string === "''" ) {
		return "";
	}
	return string.replace( /''/g, "'" ).slice( 1, -1 );
};




/**
 * format( number, properties )
 *
 * @number [Number].
 *
 * @properties [Object] Output of number/format-properties.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormat = function( number, properties ) {
	var infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
	minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix,
	primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix,
	symbolMap;

	padding = properties[ 1 ];
	minimumIntegerDigits = properties[ 2 ];
	minimumFractionDigits = properties[ 3 ];
	maximumFractionDigits = properties[ 4 ];
	minimumSignificantDigits = properties[ 5 ];
	maximumSignificantDigits = properties[ 6 ];
	roundIncrement = properties[ 7 ];
	primaryGroupingSize = properties[ 8 ];
	secondaryGroupingSize = properties[ 9 ];
	round = properties[ 15 ];
	infinitySymbol = properties[ 16 ];
	nanSymbol = properties[ 17 ];
	symbolMap = properties[ 18 ];
	nuDigitsMap = properties[ 19 ];

	// NaN
	if ( isNaN( number ) ) {
		return nanSymbol;
	}

	if ( number < 0 ) {
		pattern = properties[ 12 ];
		prefix = properties[ 13 ];
		suffix = properties[ 14 ];
	} else {
		pattern = properties[ 11 ];
		prefix = properties[ 0 ];
		suffix = properties[ 10 ];
	}

	// Infinity
	if ( !isFinite( number ) ) {
		return prefix + infinitySymbol + suffix;
	}

	ret = prefix;

	// Percent
	if ( pattern.indexOf( "%" ) !== -1 ) {
		number *= 100;

	// Per mille
	} else if ( pattern.indexOf( "\u2030" ) !== -1 ) {
		number *= 1000;
	}

	// Significant digit format
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		number = numberFormatSignificantDigits( number, minimumSignificantDigits,
			maximumSignificantDigits, round );

	// Integer and fractional format
	} else {
		number = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,
			minimumFractionDigits, maximumFractionDigits, round, roundIncrement );
	}

	// Remove the possible number minus sign
	number = number.replace( /^-/, "" );

	// Grouping separators
	if ( primaryGroupingSize ) {
		number = numberFormatGroupingSeparator( number, primaryGroupingSize,
			secondaryGroupingSize );
	}

	ret += number;

	// Scientific notation
	// TODO implement here

	// Padding/'([^']|'')+'|''|[.,\-+E%\u2030]/g
	// TODO implement here

	ret += suffix;

	return ret.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

		// Literals
		if ( literal ) {
			return removeLiteralQuotes( literal );
		}

		// Symbols
		character = character.replace( /[.,\-+E%\u2030]/, function( symbol ) {
			return symbolMap[ symbol ];
		});

		// Numbering system
		if ( nuDigitsMap ) {
			character = character.replace( /[0-9]/, function( digit ) {
				return nuDigitsMap[ +digit ];
			});
		}

		return character;
	});
};




var numberFormatterFn = function( properties ) {
	return function numberFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return numberFormat( value, properties );
	};
};




/**
 * NumberingSystem( cldr )
 *
 * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems
 * - http://cldr.unicode.org/index/bcp47-extension
 * - http://www.unicode.org/reports/tr35/#u_Extension
 */
var numberNumberingSystem = function( cldr ) {
	var nu = cldr.attributes[ "u-nu" ];

	if ( nu ) {
		if ( nu === "traditio" ) {
			nu = "traditional";
		}
		if ( [ "native", "traditional", "finance" ].indexOf( nu ) !== -1 ) {

			// Unicode locale extension `u-nu` is set using either (native, traditional or
			// finance). So, lookup the respective locale's numberingSystem and return it.
			return cldr.main([ "numbers/otherNumberingSystems", nu ]);
		}

		// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.
		return nu;
	}

	// Return the default numberingSystem.
	return cldr.main( "numbers/defaultNumberingSystem" );
};




/**
 * nuMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return digits map if numbering system is different than `latn`.
 */
var numberNumberingSystemDigitsMap = function( cldr ) {
	var aux,
		nu = numberNumberingSystem( cldr );

	if ( nu === "latn" ) {
		return;
	}

	aux = cldr.supplemental([ "numberingSystems", nu ]);

	if ( aux._type !== "numeric" ) {
		throw createErrorUnsupportedFeature( "`" + aux._type + "` numbering system" );
	}

	return aux._digits;
};




/**
 * EBNF representation:
 *
 * number_pattern_re =        prefix?
 *                            padding?
 *                            (integer_fraction_pattern | significant_pattern)
 *                            scientific_notation?
 *                            suffix?
 *
 * prefix =                   non_number_stuff
 *
 * padding =                  "*" regexp(.)
 *
 * integer_fraction_pattern = integer_pattern
 *                            fraction_pattern?
 *
 * integer_pattern =          regexp([#,]*[0,]*0+)
 *
 * fraction_pattern =         "." regexp(0*[0-9]*#*)
 *
 * significant_pattern =      regexp([#,]*@+#*)
 *
 * scientific_notation =      regexp(E\+?0+)
 *
 * suffix =                   non_number_stuff
 *
 * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)
 *
 *
 * Regexp groups:
 *
 *  0: number_pattern_re
 *  1: prefix
 *  2: -
 *  3: -
 *  4: padding
 *  5: (integer_fraction_pattern | significant_pattern)
 *  6: integer_fraction_pattern
 *  7: integer_pattern
 *  8: fraction_pattern
 *  9: significant_pattern
 * 10: scientific_notation
 * 11: suffix
 * 12: -
 */
var numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );




/**
 * format( number, pattern )
 *
 * @number [Number].
 *
 * @pattern [String] raw pattern for numbers.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberPatternProperties = function( pattern ) {
	var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,
		maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
		minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,
		roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;

	pattern = pattern.match( numberPatternRe );
	if ( !pattern ) {
		throw new Error( "Invalid pattern: " + pattern );
	}

	prefix = pattern[ 1 ];
	padding = pattern[ 4 ];
	integerFractionOrSignificantPattern = pattern[ 5 ];
	significantPattern = pattern[ 9 ];
	scientificNotation = pattern[ 10 ];
	suffix = pattern[ 11 ];

	// Significant digit format
	if ( significantPattern ) {
		significantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {
			minimumSignificantDigits = minimumSignificantDigitsMatch.length;
			maximumSignificantDigits = minimumSignificantDigits +
				maximumSignificantDigitsMatch.length;
		});

	// Integer and fractional format
	} else {
		fractionPattern = pattern[ 8 ];
		integerPattern = pattern[ 7 ];

		if ( fractionPattern ) {

			// Minimum fraction digits, and rounding.
			fractionPattern.replace( /[0-9]+/, function( match ) {
				minimumFractionDigits = match;
			});
			if ( minimumFractionDigits ) {
				roundIncrement = +( "0." + minimumFractionDigits );
				minimumFractionDigits = minimumFractionDigits.length;
			} else {
				minimumFractionDigits = 0;
			}

			// Maximum fraction digits
			// 1: ignore decimal character
			maximumFractionDigits = fractionPattern.length - 1 /* 1 */;
		}

		// Minimum integer digits
		integerPattern.replace( /0+$/, function( match ) {
			minimumIntegerDigits = match.length;
		});
	}

	// Scientific notation
	if ( scientificNotation ) {
		throw createErrorUnsupportedFeature({
			feature: "scientific notation (not implemented)"
		});
	}

	// Padding
	if ( padding ) {
		throw createErrorUnsupportedFeature({
			feature: "padding (not implemented)"
		});
	}

	// Grouping
	if ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( "," ) ) !== -1 ) {

		// Primary grouping size is the interval between the last group separator and the end of
		// the integer (or the end of the significant pattern).
		aux2 = integerFractionOrSignificantPattern.split( "." )[ 0 ];
		primaryGroupingSize = aux2.length - aux1 - 1;

		// Secondary grouping size is the interval between the last two group separators.
		if ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( ",", aux1 - 1 ) ) !== -1 ) {
			secondaryGroupingSize = aux1 - 1 - aux2;
		}
	}

	// Return:
	//  0: @prefix String
	//  1: @padding Array [ <character>, <count> ] TODO
	//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer
	//        digits to be used. Numbers will be padded with leading zeroes if necessary.
	//  3: @minimumFractionDigits and
	//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and
	//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing
	//        zeroes if necessary.
	//  5: @minimumSignificantDigits and
	//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and
	//        maximum fraction digits to be shown. Either none or both of these properties are
	//        present; if they are, they override minimum and maximum integer and fraction digits
	//         the formatter uses however many integer and fraction digits are required to display
	//        the specified number of significant digits.
	//  7: @roundIncrement Decimal round increment or null
	//  8: @primaryGroupingSize
	//  9: @secondaryGroupingSize
	// 10: @suffix String
	return [
		prefix,
		padding,
		minimumIntegerDigits,
		minimumFractionDigits,
		maximumFractionDigits,
		minimumSignificantDigits,
		maximumSignificantDigits,
		roundIncrement,
		primaryGroupingSize,
		secondaryGroupingSize,
		suffix
	];
};




/**
 * Symbol( name, cldr )
 *
 * @name [String] Symbol name.
 *
 * @cldr [Cldr instance].
 *
 * Return the localized symbol given its name.
 */
var numberSymbol = function( name, cldr ) {
	return cldr.main([
		"numbers/symbols-numberSystem-" + numberNumberingSystem( cldr ),
		name
	]);
};




var numberSymbolName = {
	".": "decimal",
	",": "group",
	"%": "percentSign",
	"+": "plusSign",
	"-": "minusSign",
	"E": "exponential",
	"\u2030": "perMille"
};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   ".": "",
 *   ",": "",
 *   "%": "",
 *   ...
 * };
 */
var numberSymbolMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );
	}

	return symbolMap;
};




var numberTruncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};




/**
 * round( method )
 *
 * @method [String] with either "round", "ceil", "floor", or "truncate".
 *
 * Return function( value, incrementOrExp ):
 *
 *   @value [Number] eg. 123.45.
 *
 *   @incrementOrExp [Number] optional, eg. 0.1; or
 *     [Object] Either { increment: <value> } or { exponent: <value> }
 *
 *   Return the rounded number, eg:
 *   - round( "round" )( 123.45 ): 123;
 *   - round( "ceil" )( 123.45 ): 124;
 *   - round( "floor" )( 123.45 ): 123;
 *   - round( "truncate" )( 123.45 ): 123;
 *   - round( "round" )( 123.45, 0.1 ): 123.5;
 *   - round( "round" )( 123.45, 10 ): 120;
 *
 *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
 *   Ref: #376
 */
var numberRound = function( method ) {
	method = method || "round";
	method = method === "truncate" ? numberTruncate : Math[ method ];

	return function( value, incrementOrExp ) {
		var exp, increment;

		value = +value;

		// If the value is not a number, return NaN.
		if ( isNaN( value ) ) {
			return NaN;
		}

		// Exponent given.
		if ( typeof incrementOrExp === "object" && incrementOrExp.exponent ) {
			exp = +incrementOrExp.exponent;
			increment = 1;

			if ( exp === 0 ) {
				return method( value );
			}

			// If the exp is not an integer, return NaN.
			if ( !( typeof exp === "number" && exp % 1 === 0 ) ) {
				return NaN;
			}

		// Increment given.
		} else {
			increment = +incrementOrExp || 1;

			if ( increment === 1 ) {
				return method( value );
			}

			// If the increment is not a number, return NaN.
			if ( isNaN( increment ) ) {
				return NaN;
			}

			increment = increment.toExponential().split( "e" );
			exp = +increment[ 1 ];
			increment = +increment[ 0 ];
		}

		// Shift & Round
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] / increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;
		value = method( +( value[ 0 ] + "e" + value[ 1 ] ) );

		// Shift back
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] * increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;
		return +( value[ 0 ] + "e" + value[ 1 ] );
	};
};




/**
 * formatProperties( pattern, cldr [, options] )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]:
 * - minimumIntegerDigits [Number]
 * - minimumFractionDigits, maximumFractionDigits [Number]
 * - minimumSignificantDigits, maximumSignificantDigits [Number]
 * - round [String] "ceil", "floor", "round" (default), or "truncate".
 * - useGrouping [Boolean] default true.
 *
 * Return the processed properties that will be used in number/format.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormatProperties = function( pattern, cldr, options ) {
	var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,
		roundFn, properties;

	function getOptions( attribute, propertyIndex ) {
		if ( attribute in options ) {
			properties[ propertyIndex ] = options[ attribute ];
		}
	}

	options = options || {};
	pattern = pattern.split( ";" );

	positivePattern = pattern[ 0 ];

	negativePattern = pattern[ 1 ] || "-" + positivePattern;
	negativeProperties = numberPatternProperties( negativePattern );
	negativePrefix = negativeProperties[ 0 ];
	negativeSuffix = negativeProperties[ 10 ];

	// Have runtime code to refer to numberRound() instead of including it explicitly.
	roundFn = numberRound( options.round );
	roundFn.generatorString = function() {
		return "numberRound(" + ( options.round ? "\"" + options.round + "\"" : "" ) + ")";
	};

	properties = numberPatternProperties( positivePattern ).concat([
		positivePattern,
		negativePrefix + positivePattern + negativeSuffix,
		negativePrefix,
		negativeSuffix,
		roundFn,
		numberSymbol( "infinity", cldr ),
		numberSymbol( "nan", cldr ),
		numberSymbolMap( cldr ),
		numberNumberingSystemDigitsMap( cldr )
	]);

	getOptions( "minimumIntegerDigits", 2 );
	getOptions( "minimumFractionDigits", 3 );
	getOptions( "maximumFractionDigits", 4 );
	getOptions( "minimumSignificantDigits", 5 );
	getOptions( "maximumSignificantDigits", 6 );

	// Grouping separators
	if ( options.useGrouping === false ) {
		properties[ 8 ] = null;
	}

	// Normalize number of digits if only one of either minimumFractionDigits or
	// maximumFractionDigits is passed in as an option
	if ( "minimumFractionDigits" in options && !( "maximumFractionDigits" in options ) ) {

		// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );
		properties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );
	} else if ( !( "minimumFractionDigits" in options ) &&
			"maximumFractionDigits" in options ) {

		// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );
		properties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );
	}

	// Return:
	// 0-10: see number/pattern-properties.
	// 11: @positivePattern [String] Positive pattern.
	// 12: @negativePattern [String] Negative pattern.
	// 13: @negativePrefix [String] Negative prefix.
	// 14: @negativeSuffix [String] Negative suffix.
	// 15: @round [Function] Round function.
	// 16: @infinitySymbol [String] Infinity symbol.
	// 17: @nanSymbol [String] NaN symbol.
	// 18: @symbolMap [Object] A bunch of other symbols.
	// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.
	return properties;
};




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var formatSymbols = require( * "unicode-8.0.0/General_Category/Format/symbols" );
 * regenerate().add( formatSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 */
var regexpCfG = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/g;




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var dashSymbols = require( * "unicode-8.0.0/General_Category/Dash_Punctuation/symbols" );
 * regenerate().add( dashSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 *
 * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.
 */
var regexpDashG = /[\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u2212]/g;




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var spaceSeparatorSymbols = require( "unicode-8.0.0/General_Category/Space_Separator/symbols" );
 * regenerate().add( spaceSeparatorSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 */
var regexpZsG = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/g;




/**
 * Loose Matching:
 * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI
 *   formatting.
 * - Map all characters in [:Zs:] to U+0020 SPACE;
 * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;
 */
var looseMatching = function( value ) {
	return value
		.replace( regexpCfG, "" )
		.replace( regexpDashG, "-" )
		.replace( regexpZsG, " " );
};




/**
 * parse( value, properties )
 *
 * @value [String].
 *
 * @properties [Object] Parser properties is a reduced pre-processed cldr
 * data set returned by numberParserProperties().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberParse = function( value, properties ) {
	var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,
		suffix, tokenizer, valid;

	// Grammar:
	// - Value <=           NaN | PositiveNumber | NegativeNumber
	// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix
	// - NegativeNumber <=  NegativePrefix NumberOrInf
	// - NumberOrInf <=     Number | Inf
	grammar = [
		[ "nan" ],
		[ "prefix", "infinity", "suffix" ],
		[ "prefix", "number", "suffix" ],
		[ "negativePrefix", "infinity", "negativeSuffix" ],
		[ "negativePrefix", "number", "negativeSuffix" ]
	];

	invertedSymbolMap = properties[ 0 ];
	invertedNuDigitsMap = properties[ 1 ] || {};
	tokenizer = properties[ 2 ];

	value = looseMatching( value );

	function parse( type ) {
		return function( lexeme ) {

			// Reverse localized symbols and numbering system.
			lexeme = lexeme.split( "" ).map(function( character ) {
				return invertedSymbolMap[ character ] ||
					invertedNuDigitsMap[ character ] ||
					character;
			}).join( "" );

			switch ( type ) {
				case "infinity":
					number = Infinity;
					break;

				case "nan":
					number = NaN;
					break;

				case "number":

					// Remove grouping separators.
					lexeme = lexeme.replace( /,/g, "" );

					number = +lexeme;
					break;

				case "prefix":
				case "negativePrefix":
					prefix = lexeme;
					break;

				case "suffix":
					suffix = lexeme;
					break;

				case "negativeSuffix":
					suffix = lexeme;
					negative = true;
					break;

				// This should never be reached.
				default:
					throw new Error( "Internal error" );
			}
			return "";
		};
	}

	function tokenizeNParse( _value, grammar ) {
		return grammar.some(function( statement ) {
			var value = _value;

			// The whole grammar statement should be used (i.e., .every() return true) and value be
			// entirely consumed (i.e., !value.length).
			return statement.every(function( type ) {
				if ( value.match( tokenizer[ type ] ) === null ) {
					return false;
				}

				// Consume and parse it.
				value = value.replace( tokenizer[ type ], parse( type ) );
				return true;
			}) && !value.length;
		});
	}

	valid = tokenizeNParse( value, grammar );

	// NaN
	if ( !valid || isNaN( number ) ) {
		return NaN;
	}

	prefixNSuffix = "" + prefix + suffix;

	// Percent
	if ( prefixNSuffix.indexOf( "%" ) !== -1 ) {
		number /= 100;

	// Per mille
	} else if ( prefixNSuffix.indexOf( "\u2030" ) !== -1 ) {
		number /= 1000;
	}

	// Negative number
	if ( negative ) {
		number *= -1;
	}

	return number;
};




var numberParserFn = function( properties ) {
	return function numberParser( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		return numberParse( value, properties );
	};

};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   "": ".",
 *   "": ",",
 *   "": "%",
 *   ...
 * };
 */
var numberSymbolInvertedMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;
	}

	return symbolMap;
};




/**
 * objectMap( object, fn)
 *
 * - object
 *
 * - fn( pair ) => pair
 */
var objectMap = function( object, fn ) {
	return Object.keys( object ).map(function( key ) {
		return fn([ key, object[ key ] ]);
	}).reduce(function( object, pair ) {
		object[ pair[ 0 ] ] = pair[ 1 ];
		return object;
	}, {});
};




/**
 * parseProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * Return parser properties, used to feed parser function.
 *
 * TODO:
 * - Scientific_notation;
 * - Padding;
 */
var numberParseProperties = function( pattern, cldr, options ) {
	var aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,
		invertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,
		minimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,
		numberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,
		formatProperties = numberFormatProperties( pattern, cldr, options );

	prefix = looseMatching( formatProperties[ 0 ] );
	maximumFractionDigits = formatProperties[ 4 ];
	minimumSignificantDigits = formatProperties[ 5 ];
	maximumSignificantDigits = formatProperties[ 6 ];
	primaryGroupingSize = formatProperties[ 8 ];
	secondaryGroupingSize = formatProperties[ 9 ];
	suffix = looseMatching( formatProperties[ 10 ] );
	negativePrefix = looseMatching( formatProperties[ 13 ] );
	negativeSuffix = looseMatching( formatProperties[ 14 ] );
	infinitySymbol = looseMatching( formatProperties[ 16 ] );
	nanSymbol = looseMatching( formatProperties[ 17 ] );
	symbolMap = objectMap( formatProperties[ 18 ], function( pair ) {
		return [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];
	});
	nuDigitsMap = formatProperties[ 19 ];

	invertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {
		return [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];
	});

	digitsRe = nuDigitsMap ? "[" + nuDigitsMap + "]" : "\\d";
	groupingSeparatorRe = regexpEscape( symbolMap[ "," ] );
	decimalSymbolRe = regexpEscape( symbolMap[ "." ] );

	if ( nuDigitsMap ) {
		invertedNuDigitsMap = nuDigitsMap.split( "" ).reduce(function( object, localizedDigit, i ) {
			object[ localizedDigit ] = String( i );
			return object;
		}, {} );
	}

	aux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {
		return value.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

			// Literals
			if ( literal ) {
				return removeLiteralQuotes( literal );
			}

			// Symbols
			character = character.replace( /[\-+E%\u2030]/, function( symbol ) {
				return symbolMap[ symbol ];
			});

			return character;
		});
	});

	prefix = aux[ 0 ];
	suffix = aux[ 1 ];
	negativePrefix = aux[ 2 ];
	negativeSuffix = aux[ 3 ];

	// Number
	//
	// number_re =                       integer fraction?
	//
	// integer =                         digits | digits_using_grouping_separators
	//
	// fraction =                        regexp((.\d+)?)
	//
	// digits =                          regexp(\d+)
	//
	// digits_w_grouping_separators =    digits_w_1_grouping_separators |
	//                                   digits_w_2_grouping_separators
	//
	// digits_w_1_grouping_separators =  regexp(\d{1,3}(,\d{3})+)
	//
	// digits_w_2_grouping_separators =  regexp(\d{1,2}((,\d{2})*(,\d{3})))

	// Integer part
	numberTokenizer = digitsRe + "+";

	// Grouping separators
	if ( primaryGroupingSize ) {
		if ( secondaryGroupingSize ) {
			aux = digitsRe + "{1," + secondaryGroupingSize + "}((" + groupingSeparatorRe +
				digitsRe + "{" + secondaryGroupingSize + "})*(" + groupingSeparatorRe +
				digitsRe + "{" + primaryGroupingSize + "}))";
		} else {
			aux = digitsRe + "{1," + primaryGroupingSize + "}(" + groupingSeparatorRe +
				digitsRe + "{" + primaryGroupingSize + "})+";
		}
		numberTokenizer = "(" + aux + "|" + numberTokenizer + ")";
	}

	// Fraction part? Only included if 1 or 2.
	// 1: Using significant digit format.
	// 2: Using integer and fractional format && it has a maximumFractionDigits.
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */
				maximumFractionDigits /* 2 */ ) {

		// 1: Handle trailing decimal separator, e.g., `"1." => `1``.
		aux = decimalSymbolRe + digitsRe + "+";
		numberTokenizer = numberTokenizer + "(" + aux + "|" + decimalSymbolRe /* 1 */ + ")?" +

			// Handle non-padded decimals, e.g., `".12"` => `0.12` by making the integer part
			// optional.
			"|(" + numberTokenizer + ")?" + aux;

		numberTokenizer = "(" + numberTokenizer + ")";
	}

	// 0: @invertedSymbolMap [Object] Inverted symbol map.
	// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than
	//    `latn`.
	// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.
	return [
		invertedSymbolMap,
		invertedNuDigitsMap,
		{
			infinity: new RegExp( "^" + regexpEscape( infinitySymbol ) ),
			nan:  new RegExp( "^" + regexpEscape( nanSymbol ) ),
			negativePrefix: new RegExp( "^" + regexpEscape( negativePrefix ) ),
			negativeSuffix: new RegExp( "^" + regexpEscape( negativeSuffix ) ),
			number: new RegExp( "^" + numberTokenizer ),
			prefix: new RegExp( "^" + regexpEscape( prefix ) ),
			suffix: new RegExp( "^" + regexpEscape( suffix ) )
		}
	];

};




/**
 * Pattern( style )
 *
 * @style [String] "decimal" (default) or "percent".
 *
 * @cldr [Cldr instance].
 */
var numberPattern = function( style, cldr ) {
	if ( style !== "decimal" && style !== "percent" ) {
		throw new Error( "Invalid style" );
	}

	return cldr.main([
		"numbers",
		style + "Formats-numberSystem-" + numberNumberingSystem( cldr ),
		"standard"
	]);
};




function validateDigits( properties ) {
	var minimumIntegerDigits = properties[ 2 ],
		minimumFractionDigits = properties[ 3 ],
		maximumFractionDigits = properties[ 4 ],
		minimumSignificantDigits = properties[ 5 ],
		maximumSignificantDigits = properties[ 6 ];

	// Validate significant digit format properties
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		validateParameterRange( minimumSignificantDigits, "minimumSignificantDigits", 1, 21 );
		validateParameterRange( maximumSignificantDigits, "maximumSignificantDigits",
			minimumSignificantDigits, 21 );

	} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {
		throw new Error( "Neither or both the minimum and maximum significant digits must be " +
			"present" );

	// Validate integer and fractional format
	} else {
		validateParameterRange( minimumIntegerDigits, "minimumIntegerDigits", 1, 21 );
		validateParameterRange( minimumFractionDigits, "minimumFractionDigits", 0, 20 );
		validateParameterRange( maximumFractionDigits, "maximumFractionDigits",
			minimumFractionDigits, 20 );
	}
}

/**
 * .numberFormatter( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 * - see also number/format options.
 *
 * Return a function that formats a number according to the given options and default/instance
 * locale.
 */
Globalize.numberFormatter =
Globalize.prototype.numberFormatter = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberFormatProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	validateDigits( properties );

	returnFn = numberFormatterFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .numberParser( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 *
 * Return the number parser according to the default/instance locale.
 */
Globalize.numberParser =
Globalize.prototype.numberParser = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberParseProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	returnFn = numberParserFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .formatNumber( value [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @options [Object]: see number/format-properties.
 *
 * Format a number according to the given options and default/instance locale.
 */
Globalize.formatNumber =
Globalize.prototype.formatNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.numberFormatter( options )( value );
};

/**
 * .parseNumber( value [, options] )
 *
 * @value [String]
 *
 * @options [Object]: See numberParser().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 */
Globalize.parseNumber =
Globalize.prototype.parseNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.numberParser( options )( value );
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;
Globalize._numberNumberingSystem = numberNumberingSystem;
Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;
Globalize._numberPattern = numberPattern;
Globalize._numberSymbol = numberSymbol;
Globalize._looseMatching = looseMatching;
Globalize._removeLiteralQuotes = removeLiteralQuotes;
Globalize._stringPad = stringPad;
Globalize._validateParameterTypeNumber = validateParameterTypeNumber;
Globalize._validateParameterTypeString = validateParameterTypeString;

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/plural.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var runtimeBind = Globalize._runtimeBind,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MakePlural;
/* jshint ignore:start */
MakePlural = (function() {
'use strict';

var _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();


/**
 * make-plural.js -- https://github.com/eemeli/make-plural.js/
 * Copyright (c) 2014-2015 by Eemeli Aro <eemeli@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * The software is provided "as is" and the author disclaims all warranties
 * with regard to this software including all implied warranties of
 * merchantability and fitness. In no event shall the author be liable for
 * any special, direct, indirect, or consequential damages or any damages
 * whatsoever resulting from loss of use, data or profits, whether in an
 * action of contract, negligence or other tortious action, arising out of
 * or in connection with the use or performance of this software.
 */

var Parser = (function () {
    function Parser() {
        _classCallCheck(this, Parser);
    }

    _createClass(Parser, [{
        key: 'parse',
        value: function parse(cond) {
            var _this = this;

            if (cond === 'i = 0 or n = 1') {
                return 'n >= 0 && n <= 1';
            }if (cond === 'i = 0,1') {
                return 'n >= 0 && n < 2';
            }if (cond === 'i = 1 and v = 0') {
                this.v0 = 1;
                return 'n == 1 && v0';
            }
            return cond.replace(/([tv]) (!?)= 0/g, function (m, sym, noteq) {
                var sn = sym + '0';
                _this[sn] = 1;
                return noteq ? '!' + sn : sn;
            }).replace(/\b[fintv]\b/g, function (m) {
                _this[m] = 1;
                return m;
            }).replace(/([fin]) % (10+)/g, function (m, sym, num) {
                var sn = sym + num;
                _this[sn] = 1;
                return sn;
            }).replace(/n10+ = 0/g, 't0 && $&').replace(/(\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (m, se, noteq, x) {
                if (m === 'n = 0,1') return '(n == 0 || n == 1)';
                if (noteq) return se + x.split(',').join(' && ' + se);
                return '(' + se + x.split(',').join(' || ' + se) + ')';
            }).replace(/(\w+) (!?)= ([0-9]+)\.\.([0-9]+)/g, function (m, sym, noteq, x0, x1) {
                if (Number(x0) + 1 === Number(x1)) {
                    if (noteq) return '' + sym + ' != ' + x0 + ' && ' + sym + ' != ' + x1;
                    return '(' + sym + ' == ' + x0 + ' || ' + sym + ' == ' + x1 + ')';
                }
                if (noteq) return '(' + sym + ' < ' + x0 + ' || ' + sym + ' > ' + x1 + ')';
                if (sym === 'n') {
                    _this.t0 = 1;return '(t0 && n >= ' + x0 + ' && n <= ' + x1 + ')';
                }
                return '(' + sym + ' >= ' + x0 + ' && ' + sym + ' <= ' + x1 + ')';
            }).replace(/ and /g, ' && ').replace(/ or /g, ' || ').replace(/ = /g, ' == ');
        }
    }, {
        key: 'vars',
        value: (function (_vars) {
            function vars() {
                return _vars.apply(this, arguments);
            }

            vars.toString = function () {
                return _vars.toString();
            };

            return vars;
        })(function () {
            var vars = [];
            if (this.i) vars.push('i = s[0]');
            if (this.f || this.v) vars.push('f = s[1] || \'\'');
            if (this.t) vars.push('t = (s[1] || \'\').replace(/0+$/, \'\')');
            if (this.v) vars.push('v = f.length');
            if (this.v0) vars.push('v0 = !s[1]');
            if (this.t0 || this.n10 || this.n100) vars.push('t0 = Number(s[0]) == n');
            for (var k in this) {
                if (/^.10+$/.test(k)) {
                    var k0 = k[0] === 'n' ? 't0 && s[0]' : k[0];
                    vars.push('' + k + ' = ' + k0 + '.slice(-' + k.substr(2).length + ')');
                }
            }if (!vars.length) return '';
            return 'var ' + ['s = String(n).split(\'.\')'].concat(vars).join(', ');
        })
    }]);

    return Parser;
})();



var MakePlural = (function () {
    function MakePlural(lc) {
        var _ref = arguments[1] === undefined ? MakePlural : arguments[1];

        var cardinals = _ref.cardinals;
        var ordinals = _ref.ordinals;

        _classCallCheck(this, MakePlural);

        if (!cardinals && !ordinals) throw new Error('At least one type of plural is required');
        this.lc = lc;
        this.categories = { cardinal: [], ordinal: [] };
        this.parser = new Parser();
        
        this.fn = this.buildFunction(cardinals, ordinals);
        this.fn._obj = this;
        this.fn.categories = this.categories;
        
        this.fn.toString = this.fnToString.bind(this);
        return this.fn;
    }

    _createClass(MakePlural, [{
        key: 'compile',
        value: function compile(type, req) {
            var cases = [];
            var rules = MakePlural.rules[type][this.lc];
            if (!rules) {
                if (req) throw new Error('Locale "' + this.lc + '" ' + type + ' rules not found');
                this.categories[type] = ['other'];
                return '\'other\'';
            }
            for (var r in rules) {
                var _rules$r$trim$split = rules[r].trim().split(/\s*@\w*/);

                var _rules$r$trim$split2 = _toArray(_rules$r$trim$split);

                var cond = _rules$r$trim$split2[0];
                var examples = _rules$r$trim$split2.slice(1);
                var cat = r.replace('pluralRule-count-', '');
                if (cond) cases.push([this.parser.parse(cond), cat]);
                
            }
            this.categories[type] = cases.map(function (c) {
                return c[1];
            }).concat('other');
            if (cases.length === 1) {
                return '(' + cases[0][0] + ') ? \'' + cases[0][1] + '\' : \'other\'';
            } else {
                return [].concat(_toConsumableArray(cases.map(function (c) {
                    return '(' + c[0] + ') ? \'' + c[1] + '\'';
                })), ['\'other\'']).join('\n      : ');
            }
        }
    }, {
        key: 'buildFunction',
        value: function buildFunction(cardinals, ordinals) {
            var _this3 = this;

            var compile = function compile(c) {
                return c ? (c[1] ? 'return ' : 'if (ord) return ') + _this3.compile.apply(_this3, _toConsumableArray(c)) : '';
            },
                fold = { vars: function vars(str) {
                    return ('  ' + str + ';').replace(/(.{1,78})(,|$) ?/g, '$1$2\n      ');
                },
                cond: function cond(str) {
                    return ('  ' + str + ';').replace(/(.{1,78}) (\|\| |$) ?/gm, '$1\n          $2');
                } },
                cond = [ordinals && ['ordinal', !cardinals], cardinals && ['cardinal', true]].map(compile).map(fold.cond),
                body = [fold.vars(this.parser.vars())].concat(_toConsumableArray(cond)).join('\n').replace(/\s+$/gm, '').replace(/^[\s;]*[\r\n]+/gm, ''),
                args = ordinals && cardinals ? 'n, ord' : 'n';
            return new Function(args, body);
        }
    }, {
        key: 'fnToString',
        value: function fnToString(name) {
            return Function.prototype.toString.call(this.fn).replace(/^function( \w+)?/, name ? 'function ' + name : 'function').replace('\n/**/', '');
        }
    }], [{
        key: 'load',
        value: function load() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            args.forEach(function (cldr) {
                var data = cldr && cldr.supplemental || null;
                if (!data) throw new Error('Data does not appear to be CLDR data');
                MakePlural.rules = {
                    cardinal: data['plurals-type-cardinal'] || MakePlural.rules.cardinal,
                    ordinal: data['plurals-type-ordinal'] || MakePlural.rules.ordinal
                };
            });
            return MakePlural;
        }
    }]);

    return MakePlural;
})();



MakePlural.cardinals = true;
MakePlural.ordinals = false;
MakePlural.rules = { cardinal: {}, ordinal: {} };


return MakePlural;
}());
/* jshint ignore:end */


var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypePluralType = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || value === "cardinal" || value === "ordinal",
		"String \"cardinal\" or \"ordinal\""
	);
};




var pluralGeneratorFn = function( plural ) {
	return function pluralGenerator( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return plural( value );
	};
};




/**
 * .plural( value )
 *
 * @value [Number]
 *
 * Return the corresponding form (zero | one | two | few | many | other) of a
 * value given locale.
 */
Globalize.plural =
Globalize.prototype.plural = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );
	return this.pluralGenerator( options )( value );
};

/**
 * .pluralGenerator( [options] )
 *
 * Return a plural function (of the form below).
 *
 * fn( value )
 *
 * @value [Number]
 *
 * Return the corresponding form (zero | one | two | few | many | other) of a value given the
 * default/instance locale.
 */
Globalize.pluralGenerator =
Globalize.prototype.pluralGenerator = function( options ) {
	var args, cldr, isOrdinal, plural, returnFn, type;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];
	type = options.type || "cardinal";

	validateParameterTypePluralType( options.type, "options.type" );

	validateDefaultLocale( cldr );

	isOrdinal = type === "ordinal";

	cldr.on( "get", validateCldr );
	cldr.supplemental([ "plurals-type-" + type, "{language}" ]);
	cldr.off( "get", validateCldr );

	MakePlural.rules = {};
	MakePlural.rules[ type ] = cldr.supplemental( "plurals-type-" + type );

	plural = new MakePlural( cldr.attributes.language, {
		"ordinals": isOrdinal,
		"cardinals": !isOrdinal
	});

	returnFn = pluralGeneratorFn( plural );

	runtimeBind( args, cldr, returnFn, [ plural ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/relative-time.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"./plural",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var formatMessage = Globalize._formatMessage,
	runtimeBind = Globalize._runtimeBind,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterTypeString = Globalize._validateParameterTypeString,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber;


/**
 * format( value, numberFormatter, pluralGenerator, properties )
 *
 * @value [Number] The number to format
 *
 * @numberFormatter [String] A numberFormatter from Globalize.numberFormatter
 *
 * @pluralGenerator [String] A pluralGenerator from Globalize.pluralGenerator
 *
 * @properties [Object] containing relative time plural message.
 *
 * Format relative time.
 */
var relativeTimeFormat = function( value, numberFormatter, pluralGenerator, properties ) {

	var relativeTime,
		message = properties[ "relative-type-" + value ];

	if ( message ) {
		return message;
	}

	relativeTime = value <= 0 ? properties[ "relativeTime-type-past" ]
		: properties[ "relativeTime-type-future" ];

	value = Math.abs( value );

	message = relativeTime[ "relativeTimePattern-count-" + pluralGenerator( value ) ];
	return formatMessage( message, [ numberFormatter( value ) ] );
};




var relativeTimeFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	return function relativeTimeFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return relativeTimeFormat( value, numberFormatter, pluralGenerator, properties );
	};

};




/**
 * properties( unit, cldr, options )
 *
 * @unit [String] eg. "day", "week", "month", etc.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]
 * - form: [String] eg. "short" or "narrow". Or falsy for default long form.
 *
 * Return relative time properties.
 */
var relativeTimeProperties = function( unit, cldr, options ) {

	var form = options.form,
		raw, properties, key, match;

	if ( form ) {
		unit = unit + "-" + form;
	}

	raw = cldr.main( [ "dates", "fields", unit ] );
	properties = {
		"relativeTime-type-future": raw[ "relativeTime-type-future" ],
		"relativeTime-type-past": raw[ "relativeTime-type-past" ]
	};
	for ( key in raw ) {
		if ( raw.hasOwnProperty( key ) ) {
			match = /relative-type-(-?[0-9]+)/.exec( key );
			if ( match ) {
				properties[ key ] = raw[ key ];
			}
		}
	}

	return properties;
};




/**
 * .formatRelativeTime( value, unit [, options] )
 *
 * @value [Number] The number of unit to format.
 *
 * @unit [String] see .relativeTimeFormatter() for details.
 *
 * @options [Object] see .relativeTimeFormatter() for details.
 *
 * Formats a relative time according to the given unit, options, and the default/instance locale.
 */
Globalize.formatRelativeTime =
Globalize.prototype.formatRelativeTime = function( value, unit, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.relativeTimeFormatter( unit, options )( value );
};

/**
 * .relativeTimeFormatter( unit [, options ])
 *
 * @unit [String] String value indicating the unit to be formatted. eg. "day", "week", "month", etc.
 *
 * @options [Object]
 * - form: [String] eg. "short" or "narrow". Or falsy for default long form.
 *
 * Returns a function that formats a relative time according to the given unit, options, and the
 * default/instance locale.
 */
Globalize.relativeTimeFormatter =
Globalize.prototype.relativeTimeFormatter = function( unit, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn;

	validateParameterPresence( unit, "unit" );
	validateParameterTypeString( unit, "unit" );

	cldr = this.cldr;
	options = options || {};

	args = [ unit, options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );
	properties = relativeTimeProperties( unit, cldr, options );
	cldr.off( "get", validateCldr );

	numberFormatter = this.numberFormatter( options );
	pluralGenerator = this.pluralGenerator();

	returnFn = relativeTimeFormatterFn( numberFormatter, pluralGenerator, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/unit.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"./plural"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var formatMessage = Globalize._formatMessage,
	runtimeBind = Globalize._runtimeBind,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypeString = Globalize._validateParameterTypeString;


/**
 * format( value, numberFormatter, pluralGenerator, unitProperies )
 *
 * @value [Number]
 *
 * @numberFormatter [Object]: A numberFormatter from Globalize.numberFormatter.
 *
 * @pluralGenerator [Object]: A pluralGenerator from Globalize.pluralGenerator.
 *
 * @unitProperies [Object]: localized unit data from cldr.
 *
 * Format units such as seconds, minutes, days, weeks, etc.
 *
 * OBS:
 *
 * Unit Sequences are not implemented.
 * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#Unit_Sequences
 *
 * Duration Unit (for composed time unit durations) is not implemented.
 * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#durationUnit
 */
var unitFormat = function( value, numberFormatter, pluralGenerator, unitProperties ) {
	var compoundUnitPattern = unitProperties.compoundUnitPattern, dividend, dividendProperties,
		formattedValue, divisor, divisorProperties, message, pluralValue;

	unitProperties = unitProperties.unitProperties;
	formattedValue = numberFormatter( value );
	pluralValue = pluralGenerator( value );

	// computed compound unit, eg. "megabyte-per-second".
	if ( unitProperties instanceof Array ) {
		dividendProperties = unitProperties[ 0 ];
		divisorProperties = unitProperties[ 1 ];

		dividend = formatMessage( dividendProperties[ pluralValue ], [ value ] );
		divisor = formatMessage( divisorProperties.one, [ "" ] ).trim();

		return formatMessage( compoundUnitPattern, [ dividend, divisor ] );
	}

	message = unitProperties[ pluralValue ];

	return formatMessage( message, [ formattedValue ] );
};




var unitFormatterFn = function( numberFormatter, pluralGenerator, unitProperties ) {
	return function unitFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return unitFormat( value, numberFormatter, pluralGenerator, unitProperties );
	};

};




/**
 * categories()
 *
 * Return all unit categories.
 */
var unitCategories = [ "acceleration", "angle", "area", "digital", "duration", "length", "mass", "power",
"pressure", "speed", "temperature", "volume" ];




function stripPluralGarbage( data ) {
	var aux, pluralCount;

	if ( data ) {
		aux = {};
		for ( pluralCount in data ) {
			aux[ pluralCount.replace( /unitPattern-count-/, "" ) ] = data[ pluralCount ];
		}
	}

	return aux;
}

/**
 * get( unit, form, cldr )
 *
 * @unit [String] The full type-unit name (eg. duration-second), or the short unit name
 * (eg. second).
 *
 * @form [String] A string describing the form of the unit representation (eg. long,
 * short, narrow).
 *
 * @cldr [Cldr instance].
 *
 * Return the plural map of a unit, eg: "second"
 * { "one": "{0} second",
 *   "other": "{0} seconds" }
 * }
 *
 * Or the Array of plural maps of a compound-unit, eg: "foot-per-second"
 * [ { "one": "{0} foot",
 *     "other": "{0} feet" },
 *   { "one": "{0} second",
 *     "other": "{0} seconds" } ]
 *
 * Uses the precomputed form of a compound-unit if available, eg: "mile-per-hour"
 * { "displayName": "miles per hour",
 *    "unitPattern-count-one": "{0} mile per hour",
 *    "unitPattern-count-other": "{0} miles per hour"
 * },
 *
 * Also supports "/" instead of "-per-", eg. "foot/second", using the precomputed form if
 * available.
 *
 * Or the Array of plural maps of a compound-unit, eg: "foot-per-second"
 * [ { "one": "{0} foot",
 *     "other": "{0} feet" },
 *   { "one": "{0} second",
 *     "other": "{0} seconds" } ]
 *
 * Or undefined in case the unit (or a unit of the compound-unit) doesn't exist.
 */
var get = function( unit, form, cldr ) {
	var ret;

	// Ensure that we get the 'precomputed' form, if present.
	unit = unit.replace( /\//, "-per-" );

	// Get unit or <category>-unit (eg. "duration-second").
	[ "" ].concat( unitCategories ).some(function( category ) {
		return ret = cldr.main([
			"units",
			form,
			category.length ? category + "-" + unit : unit
		]);
	});

	// Rename keys s/unitPattern-count-//g.
	ret = stripPluralGarbage( ret );

	// Compound Unit, eg. "foot-per-second" or "foot/second".
	if ( !ret && ( /-per-/ ).test( unit ) ) {

		// "Some units already have 'precomputed' forms, such as kilometer-per-hour;
		// where such units exist, they should be used in preference" UTS#35.
		// Note that precomputed form has already been handled above (!ret).

		// Get both recursively.
		unit = unit.split( "-per-" );
		ret = unit.map(function( unit ) {
			return get( unit, form, cldr );
		});
		if ( !ret[ 0 ] || !ret[ 1 ] ) {
			return;
		}
	}

	return ret;
};

var unitGet = get;




/**
 * properties( unit, form, cldr )
 *
 * @unit [String] The full type-unit name (eg. duration-second), or the short unit name
 * (eg. second).
 *
 * @form [String] A string describing the form of the unit representation (eg. long,
 * short, narrow).
 *
 * @cldr [Cldr instance].
 */
var unitProperties = function( unit, form, cldr ) {
	var compoundUnitPattern, unitProperties;

	compoundUnitPattern = cldr.main( [ "units", form, "per/compoundUnitPattern" ] );
	unitProperties = unitGet( unit, form, cldr );

	return {
		compoundUnitPattern: compoundUnitPattern,
		unitProperties: unitProperties
	};
};




/**
 * Globalize.formatUnit( value, unit, options )
 *
 * @value [Number]
 *
 * @unit [String]: The unit (e.g "second", "day", "year")
 *
 * @options [Object]
 * - form: [String] "long", "short" (default), or "narrow".
 *
 * Format units such as seconds, minutes, days, weeks, etc.
 */
Globalize.formatUnit =
Globalize.prototype.formatUnit = function( value, unit, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.unitFormatter( unit, options )( value );
};

/**
 * Globalize.unitFormatter( unit, options )
 *
 * @unit [String]: The unit (e.g "second", "day", "year")
 *
 * @options [Object]
 * - form: [String] "long", "short" (default), or "narrow".
 *
 * - numberFormatter: [Function] a number formatter function. Defaults to Globalize
 *   `.numberFormatter()` for the current locale using the default options.
 */
Globalize.unitFormatter =
Globalize.prototype.unitFormatter = function( unit, options ) {
	var args, form, numberFormatter, pluralGenerator, returnFn, properties;

	validateParameterPresence( unit, "unit" );
	validateParameterTypeString( unit, "unit" );

	validateParameterTypePlainObject( options, "options" );

	options = options || {};

	args = [ unit, options ];
	form = options.form || "long";
	properties = unitProperties( unit, form, this.cldr );

	numberFormatter = options.numberFormatter || this.numberFormatter();
	pluralGenerator = this.pluralGenerator();
	returnFn = unitFormatterFn( numberFormatter, pluralGenerator, properties );

	runtimeBind( args, this.cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/node-main.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/*!
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */

// Core
module.exports = __webpack_require__( "./node_modules/globalize/dist/globalize.js" );

// Extent core with the following modules
__webpack_require__( "./node_modules/globalize/dist/globalize/message.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/number.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/plural.js" );

// Load after globalize/number
__webpack_require__( "./node_modules/globalize/dist/globalize/currency.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/date.js" );

// Load after globalize/number and globalize/plural
__webpack_require__( "./node_modules/globalize/dist/globalize/relative-time.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/unit.js" );



/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmeidate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/App.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __syncRequire = typeof module === "object" && typeof module.exports === "object";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var css = __webpack_require__("./src/app.m.css");
var App = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Foo;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,src/Foo!./src/Foo.ts")(); }) : false];
                case 1:
                    Foo = _a.sent();
                    return [2 /*return*/, Foo.default];
            }
        });
    });
};
var Bar = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Bar;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Bar.ts")(); }) : false];
                case 1:
                    Bar = _a.sent();
                    return [2 /*return*/, Bar.default];
            }
        });
    });
};
var Baz = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Baz;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Baz.ts")(); }) : false];
                case 1:
                    Baz = _a.sent();
                    return [2 /*return*/, Baz.default];
            }
        });
    });
};
function default_1() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var bar, baz;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log(css);
                    return [4 /*yield*/, Bar()];
                case 1:
                    bar = _a.sent();
                    return [4 /*yield*/, Baz()];
                case 2:
                    baz = _a.sent();
                    bar();
                    baz();
                    return [2 /*return*/, App()];
            }
        });
    });
}
exports.default = default_1;


/***/ }),

/***/ "./src/app.m.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {" _key":"app","root":"YxttPEx-"};

/***/ }),

/***/ "./src/main.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {" _key":"main.css","app":"QHEFgSeI"};

/***/ }),

/***/ "./src/main.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("./node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.js");

Object.defineProperty(exports, "__esModule", { value: true });
var App_1 = __webpack_require__("./src/App.ts");
var css = __webpack_require__("./src/app.m.css");
var has_1 = __webpack_require__("./node_modules/@dojo/has/has.js");
// !has('bar')
// elided: import './Bar'
if (true) {
    console.log('foo');
}
App_1.default().then(function (result) {
    console.log(result());
    var div = document.createElement('div');
    div.classList.add(css.root);
    document.body.appendChild(div);
});


/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./src/main.css");
module.exports = __webpack_require__("./src/main.ts");


/***/ })

},[0]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy9EZXN0cm95YWJsZS50cyIsIndlYnBhY2s6Ly8vRXZlbnRlZC50cyIsIndlYnBhY2s6Ly8vYXNwZWN0LnRzIiwid2VicGFjazovLy9oYXMudHMiLCJ3ZWJwYWNrOi8vL2xhbmcudHMiLCJ3ZWJwYWNrOi8vL3V0aWwudHMiLCJ3ZWJwYWNrOi8vL3V1aWQudHMiLCJ3ZWJwYWNrOi8vL2xvYWQudHMiLCJ3ZWJwYWNrOi8vL2xvY2FsZXMudHMiLCJ3ZWJwYWNrOi8vL2kxOG4udHMiLCJ3ZWJwYWNrOi8vL21haW4udHMiLCJ3ZWJwYWNrOi8vL01hcC50cyIsIndlYnBhY2s6Ly8vT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vUHJvbWlzZS50cyIsIndlYnBhY2s6Ly8vU3ltYm9sLnRzIiwid2VicGFjazovLy9XZWFrTWFwLnRzIiwid2VicGFjazovLy9nbG9iYWwudHMiLCJ3ZWJwYWNrOi8vL2l0ZXJhdG9yLnRzIiwid2VicGFjazovLy9vYmplY3QudHMiLCJ3ZWJwYWNrOi8vL3N0cmluZy50cyIsIndlYnBhY2s6Ly8vcXVldWUudHMiLCJ3ZWJwYWNrOi8vL3NldExvY2FsZURhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Zvby50cz83ZGNlIiwid2VicGFjazovLy8uL3NyYy9CYXIudHM/ODg3OSIsIndlYnBhY2s6Ly8vLi9zcmMvQmF6LnRzP2JmZGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvc3VwcGxlbWVudGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L25vZGVfbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvY3VycmVuY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9kYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3BsdXJhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS91bml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9ub2RlLW1haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLm0uY3NzPzZjMTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uY3NzPzUxYzUiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7QUNUQTtBQUVBOzs7QUFHQTtJQUNDLE9BQU8saUJBQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO0FBQzlCO0FBRUE7OztBQUdBO0lBQ0MsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQztBQUNqRDtBQUVBO0lBTUM7OztJQUdBO1FBQ0MsSUFBSSxDQUFDLFFBQU8sRUFBRyxFQUFFO0lBQ2xCO0lBRUE7Ozs7OztJQU1BLDBCQUFHLEVBQUgsVUFBSSxNQUFjO1FBQ1QsMEJBQU87UUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNwQixPQUFPO1lBQ04sT0FBTztnQkFDTixPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3ZDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDakI7U0FDQTtJQUNGLENBQUM7SUFFRDs7Ozs7SUFLQSw4QkFBTyxFQUFQO1FBQUE7UUFDQyxPQUFPLElBQUksaUJBQU8sQ0FBQyxVQUFDLE9BQU87WUFDMUIsS0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxNQUFNO2dCQUMzQixPQUFNLEdBQUksTUFBTSxDQUFDLFFBQU8sR0FBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQzdDLENBQUMsQ0FBQztZQUNGLEtBQUksQ0FBQyxRQUFPLEVBQUcsSUFBSTtZQUNuQixLQUFJLENBQUMsSUFBRyxFQUFHLFNBQVM7WUFDcEIsT0FBTyxDQUFDLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQztJQUNILENBQUM7SUFDRixrQkFBQztBQUFELENBN0NBO0FBQWE7QUErQ2Isa0JBQWUsV0FBVzs7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LE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLFNBQVM7SUFDVCxTQUFTO0lBQ1QsSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osS0FBSztJQUNMLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLE9BQU87SUFDUCxJQUFJO0lBQ0osT0FBTztJQUNQLElBQUk7SUFDSixJQUFJO0lBQ0osS0FBSztJQUNMLFNBQVM7SUFDVCxTQUFTO0lBQ1QsSUFBSTtJQUNKLE9BQU87SUFDUCxnQkFBZ0I7SUFDaEIsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsUUFBUTtJQUNSLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixPQUFPO0lBQ1AsSUFBSTtJQUNKLEtBQUs7SUFDTCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsT0FBTztJQUNQLElBQUk7SUFDSixPQUFPO0lBQ1AsSUFBSTtJQUNKLFFBQVE7SUFDUixRQUFRO0lBQ1IsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsYUFBYTtJQUNiLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixRQUFRO0lBQ1IsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxPQUFPO0lBQ1AsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixJQUFJO0lBQ0osS0FBSztJQUNMLE9BQU87SUFDUCxJQUFJO0lBQ0osT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osUUFBUTtJQUNSLFFBQVE7SUFDUixLQUFLO0lBQ0wsSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixJQUFJO0lBQ0osT0FBTztJQUNQLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLE9BQU87SUFDUCxJQUFJO0lBQ0osS0FBSztJQUNMLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLFFBQVE7SUFDUixLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixRQUFRO0lBQ1IsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsT0FBTztJQUNQLElBQUk7SUFDSixJQUFJO0lBQ0osUUFBUTtJQUNSLEtBQUs7SUFDTCxPQUFPO0lBQ1AsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLE9BQU87SUFDUCxJQUFJO0lBQ0osU0FBUztJQUNULFNBQVM7SUFDVCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixPQUFPO0lBQ1AsSUFBSTtJQUNKLEtBQUs7SUFDTCxNQUFNO0lBQ04sT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixVQUFVO0lBQ1YsVUFBVTtJQUNWLEtBQUs7SUFDTCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsSUFBSTtJQUNKLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixPQUFPO0lBQ1AsT0FBTztJQUNQLElBQUk7SUFDSixZQUFZO0lBQ1osWUFBWTtJQUNaLFlBQVk7SUFDWixTQUFTO0lBQ1QsWUFBWTtJQUNaLFlBQVk7SUFDWixZQUFZO0lBQ1osU0FBUztJQUNULElBQUk7SUFDSixPQUFPO0lBQ1AsT0FBTztJ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QUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUErQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUksa0JBQWtCLElB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QTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7QUNwR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQSxDQUFDOzs7Ozs7Ozs7QUN2YUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsRUFBRTs7Ozs7QUFLMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSixHQUFHLFVBQVU7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBLDJEQUEyRCxFQUFFO0FBQzdELEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDemJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsdURBQXVELEtBQUssVUFBVSxNQUFNO0FBQzVFO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7Ozs7QUFLTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYSxnQkFBZ0IsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWEsZ0JBQWdCLE1BQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047Ozs7O0FBS0EsaUNBQWlDLFdBQVcsTUFBTSw2QkFBNkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRSxPQUFPO0FBQzVFLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQixNQUFNLGVBQWU7QUFDckIsTUFBTSxlQUFlO0FBQ3JCLE1BQU0sbUJBQW1CO0FBQ3pCLE1BQU0sZUFBZTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsZUFBZTtBQUM1QixhQUFhLGVBQWU7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1CO0FBQ2hDLFlBQVksb0JBQW9CO0FBQ2hDLGFBQWEsbUJBQW1CO0FBQ2hDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLFdBQVcsRUFBRSxjQUFjLE9BQU8sV0FBVyxFQUFFLGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEsV0FBVyxFQUFFLEtBQUssT0FBTyxXQUFXLEVBQUUsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLFVBQVUsSUFBSSxVQUFVLFNBQVMsY0FBYztBQUMzRCxlQUFlLFdBQVcsV0FBVyxPQUFPLGNBQWM7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUIsZUFBZSxXQUFXLEVBQUUsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXLEVBQUUsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLFVBQVUsSUFBSSxVQUFVLFNBQVMsY0FBYztBQUMzRCxlQUFlLFdBQVcsV0FBVyxPQUFPLGNBQWM7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsMkJBQTJCOztBQUUxQyxFQUFFOztBQUVGOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssS0FBSyxNQUFNLEdBQUc7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWEsTUFBTSxHQUFHO0FBQ25DO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTLEtBQUssS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxXQUFXOztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7OztBQzloRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILDRCQUE0QixtQ0FBbUM7QUFDL0Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsd0JBQXdCLHFCQUFxQixLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUksS0FBSyxFQUFFO0FBQzNEO0FBQ0EsZ0RBQWdELElBQUksTUFBTSxFQUFFLE9BQU8sRUFBRTs7QUFFckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3RELGlC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YTs7O0FBRzlDO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7OztBQ3ZYRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7OztBQzNNRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFVBQVUsRUFBRTtBQUNoQixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVUsRUFBRTtBQUNsQixrQkFBa0IsRUFBRSxRQUFRO0FBQzVCLE1BQU0sVUFBVSxFQUFFO0FBQ2xCLGtCQUFrQixFQUFFLFdBQVc7QUFDL0I7QUFDQTtBQUNBLElBQUk7QUFDSixpQ0FBaUMsRUFBRTtBQUNuQyxtQ0FBbUMsRUFBRTtBQUNyQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSxFQUFFO0FBQ2xCLGtCQUFrQixFQUFFLFFBQVE7QUFDNUIsTUFBTSxVQUFVLEVBQUU7QUFDbEIsa0JBQWtCLEVBQUUsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7OztBQzlTRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM3QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7QUN2THRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFHLEVBQUcsU0FBcUI7b0JBQ2pDLHNCQUFPLEdBQUcsQ0FBQyxPQUFPOzs7O0NBQ2xCO0FBRUQ7Ozs7OztvQkFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztvQkFDSixxQkFBTSxHQUFHLEVBQUU7O29CQUFqQixJQUFHLEVBQUcsU0FBVztvQkFDWCxxQkFBTSxHQUFHLEVBQUU7O29CQUFqQixJQUFHLEVBQUcsU0FBVztvQkFDdkIsR0FBRyxFQUFFO29CQUNMLEdBQUcsRUFBRTtvQkFDTCxzQkFBTyxHQUFHLEVBQUU7Ozs7O0FBTmI7Ozs7Ozs7O0FDakJBO0FBQ0Esa0JBQWtCLGlDOzs7Ozs7O0FDRGxCO0FBQ0Esa0JBQWtCLHFDOzs7Ozs7Ozs7OztBQ0RsQjtBQUNBO0FBQ0E7OztVQUlnQjtJQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ25CO0FBRUEsYUFBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFNO0lBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDckIsSUFBTSxJQUFHLEVBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUM7SUFDekMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztJQUMzQixRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7QUFDL0IsQ0FBQyxDQUFDIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIm1haW5cIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibWFpblwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtYWluXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsImltcG9ydCB7IEhhbmRsZSB9IGZyb20gJ0Bkb2pvL2ludGVyZmFjZXMvY29yZSc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdAZG9qby9zaGltL1Byb21pc2UnO1xuXG4vKipcbiAqIE5vIG9wZXJhdGlvbiBmdW5jdGlvbiB0byByZXBsYWNlIG93biBvbmNlIGluc3RhbmNlIGlzIGRlc3RvcnllZFxuICovXG5mdW5jdGlvbiBub29wKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbn07XG5cbi8qKlxuICogTm8gb3AgZnVuY3Rpb24gdXNlZCB0byByZXBsYWNlIG93biwgb25jZSBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0b3J5ZWRcbiAqL1xuZnVuY3Rpb24gZGVzdHJveWVkKCk6IG5ldmVyIHtcblx0dGhyb3cgbmV3IEVycm9yKCdDYWxsIG1hZGUgdG8gZGVzdHJveWVkIG1ldGhvZCcpO1xufTtcblxuZXhwb3J0IGNsYXNzIERlc3Ryb3lhYmxlIHtcblx0LyoqXG5cdCAqIHJlZ2lzdGVyIGhhbmRsZXMgZm9yIHRoZSBpbnN0YW5jZVxuXHQgKi9cblx0cHJpdmF0ZSBoYW5kbGVzOiBIYW5kbGVbXTtcblxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmhhbmRsZXMgPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBoYW5kbGVzIGZvciB0aGUgaW5zdGFuY2UgdGhhdCB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIGB0aGlzLmRlc3Ryb3lgIGlzIGNhbGxlZFxuXHQgKlxuXHQgKiBAcGFyYW0ge0hhbmRsZX0gaGFuZGxlIFRoZSBoYW5kbGUgdG8gYWRkIGZvciB0aGUgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge0hhbmRsZX0gYSBoYW5kbGUgZm9yIHRoZSBoYW5kbGUsIHJlbW92ZXMgdGhlIGhhbmRsZSBmb3IgdGhlIGluc3RhbmNlIGFuZCBjYWxscyBkZXN0cm95XG5cdCAqL1xuXHRvd24oaGFuZGxlOiBIYW5kbGUpOiBIYW5kbGUge1xuXHRcdGNvbnN0IHsgaGFuZGxlcyB9ID0gdGhpcztcblx0XHRoYW5kbGVzLnB1c2goaGFuZGxlKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdHJveSgpIHtcblx0XHRcdFx0aGFuZGxlcy5zcGxpY2UoaGFuZGxlcy5pbmRleE9mKGhhbmRsZSkpO1xuXHRcdFx0XHRoYW5kbGUuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJweXMgYWxsIGhhbmRlcnMgcmVnaXN0ZXJlZCBmb3IgdGhlIGluc3RhbmNlXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPGFueX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgaGFuZGxlcyBoYXZlIGJlZW4gZGVzdHJveWVkXG5cdCAqL1xuXHRkZXN0cm95KCk6IFByb21pc2U8YW55PiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHR0aGlzLmhhbmRsZXMuZm9yRWFjaCgoaGFuZGxlKSA9PiB7XG5cdFx0XHRcdGhhbmRsZSAmJiBoYW5kbGUuZGVzdHJveSAmJiBoYW5kbGUuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRlc3Ryb3kgPSBub29wO1xuXHRcdFx0dGhpcy5vd24gPSBkZXN0cm95ZWQ7XG5cdFx0XHRyZXNvbHZlKHRydWUpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlc3Ryb3lhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIERlc3Ryb3lhYmxlLnRzIiwiaW1wb3J0IHsgQWN0aW9uYWJsZSB9IGZyb20gJ0Bkb2pvL2ludGVyZmFjZXMvYWJpbGl0aWVzJztcbmltcG9ydCB7IEV2ZW50ZWRMaXN0ZW5lciwgRXZlbnRlZExpc3RlbmVyT3JBcnJheSwgRXZlbnRlZExpc3RlbmVyc01hcCB9IGZyb20gJ0Bkb2pvL2ludGVyZmFjZXMvYmFzZXMnO1xuaW1wb3J0IHsgRXZlbnRUYXJnZXR0ZWRPYmplY3QsIEV2ZW50RXJyb3JPYmplY3QsIEhhbmRsZSB9IGZyb20gJ0Bkb2pvL2ludGVyZmFjZXMvY29yZSc7XG5pbXBvcnQgTWFwIGZyb20gJ0Bkb2pvL3NoaW0vTWFwJztcbmltcG9ydCB7IG9uIGFzIGFzcGVjdE9uIH0gZnJvbSAnLi9hc3BlY3QnO1xuaW1wb3J0IHsgRGVzdHJveWFibGUgfSBmcm9tICcuL0Rlc3Ryb3lhYmxlJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlzIHRoZSB2YWx1ZSBpcyBBY3Rpb25hYmxlIChoYXMgYSBgLmRvYCBmdW5jdGlvbilcbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaXMgdGhlIHZhbHVlIGlzIEFjdGlvbmFibGVcbiAqL1xuZnVuY3Rpb24gaXNBY3Rpb25hYmxlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBBY3Rpb25hYmxlPGFueSwgYW55PiB7XG5cdHJldHVybiBCb29sZWFuKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5kbyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBsaXN0ZW5lcnMuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVMaXN0ZW5lcjxULCBFIGV4dGVuZHMgRXZlbnRUYXJnZXR0ZWRPYmplY3Q8VD4+KGxpc3RlbmVyOiBFdmVudGVkTGlzdGVuZXI8VCwgRT4pOiBFdmVudGVkQ2FsbGJhY2s8RT4ge1xuXHRyZXR1cm4gaXNBY3Rpb25hYmxlKGxpc3RlbmVyKSA/IChldmVudDogRSkgPT4gbGlzdGVuZXIuZG8oeyBldmVudCB9KSA6IGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgYW4gYXJyYXkgb2YgaGFuZGxlc1xuICpcbiAqIEBwYXJhbSBoYW5kbGVzIGFuIGFycmF5IG9mIGhhbmRsZXNcbiAqIEByZXR1cm5zIGEgc2luZ2xlIEhhbmRsZSBmb3IgaGFuZGxlcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlc0FycmF5dG9IYW5kbGUoaGFuZGxlczogSGFuZGxlW10pOiBIYW5kbGUge1xuXHRyZXR1cm4ge1xuXHRcdGRlc3Ryb3koKSB7XG5cdFx0XHRoYW5kbGVzLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlLmRlc3Ryb3koKSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGV2ZW50IG9iamVjdCwgd2hpY2ggcHJvdmlkZXMgYSBgdHlwZWAgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudE9iamVjdCB7XG5cdC8qKlxuXHQgKiBUaGUgdHlwZSBvZiB0aGUgZXZlbnRcblx0ICovXG5cdHJlYWRvbmx5IHR5cGU6IHN0cmluZyB8IHN5bWJvbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudGVkQ2FsbGJhY2s8RSBleHRlbmRzIEV2ZW50T2JqZWN0PiB7XG5cdC8qKlxuXHQgKiBBIGNhbGxiYWNrIHRoYXQgdGFrZXMgYW4gYGV2ZW50YCBhcmd1bWVudFxuXHQgKlxuXHQgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdFxuXHQgKi9cblx0KGV2ZW50OiBFKTogYm9vbGVhbiB8IHZvaWQ7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBFdmVudGVkIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudGVkT3B0aW9ucyB7XG5cdC8qKlxuXHQgKiBPcHRpb25hbCBsaXN0ZW5lcnMgdG8gYWRkXG5cdCAqL1xuXHRsaXN0ZW5lcnM/OiBFdmVudGVkTGlzdGVuZXJzTWFwPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZUV2ZW50ZWRFdmVudHMge1xuXHQvKipcblx0ICogUmVnc2lzdGVyIGEgY2FsbGJhY2sgZm9yIGEgc3BlY2lmaWMgZXZlbnQgdHlwZVxuXHQgKlxuXHQgKiBAcGFyYW0gbGlzdGVuZXJzIG1hcCBvZiBsaXN0ZW5lcnNcblx0ICovXG5cdChsaXN0ZW5lcnM6IEV2ZW50ZWRMaXN0ZW5lcnNNYXA8RXZlbnRlZD4pOiBIYW5kbGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBldmVudFxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGF0dGFjaFxuXHQgKi9cblx0KHR5cGU6IHN0cmluZyB8IHN5bWJvbCwgbGlzdGVuZXI6IEV2ZW50ZWRMaXN0ZW5lck9yQXJyYXk8RXZlbnRlZCwgRXZlbnRUYXJnZXR0ZWRPYmplY3Q8RXZlbnRlZD4+KTogSGFuZGxlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBmb3IgYGVycm9yYFxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGF0dGFjaFxuXHQgKi9cblx0KHR5cGU6ICdlcnJvcicsIGxpc3RlbmVyOiBFdmVudGVkTGlzdGVuZXJPckFycmF5PEV2ZW50ZWQsIEV2ZW50RXJyb3JPYmplY3Q8RXZlbnRlZD4+KTogSGFuZGxlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50ZWQge1xuXHRvbjogQmFzZUV2ZW50ZWRFdmVudHM7XG59XG5cbi8qKlxuICogTWFwIG9mIGNvbXB1dGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGtleWVkIGJ5IHN0cmluZ1xuICovXG5jb25zdCByZWdleE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBSZWdFeHA+KCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpcyB0aGUgZXZlbnQgdHlwZSBnbG9iIGhhcyBiZWVuIG1hdGNoZWRcbiAqXG4gKiBAcmV0dXJucyBib29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBnbG9iIGlzIG1hdGNoZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzR2xvYk1hdGNoKGdsb2JTdHJpbmc6IHN0cmluZyB8IHN5bWJvbCwgdGFyZ2V0U3RyaW5nOiBzdHJpbmcgfCBzeW1ib2wpOiBib29sZWFuIHtcblx0aWYgKHR5cGVvZiB0YXJnZXRTdHJpbmcgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBnbG9iU3RyaW5nID09PSAnc3RyaW5nJyAmJiBnbG9iU3RyaW5nLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcblx0XHRsZXQgcmVnZXg6IFJlZ0V4cDtcblx0XHRpZiAocmVnZXhNYXAuaGFzKGdsb2JTdHJpbmcpKSB7XG5cdFx0XHRyZWdleCA9IHJlZ2V4TWFwLmdldChnbG9iU3RyaW5nKSE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVnZXggPSBuZXcgUmVnRXhwKGBeJHsgZ2xvYlN0cmluZy5yZXBsYWNlKC9cXCovZywgJy4qJykgfSRgKTtcblx0XHRcdHJlZ2V4TWFwLnNldChnbG9iU3RyaW5nLCByZWdleCk7XG5cdFx0fVxuXHRcdHJldHVybiByZWdleC50ZXN0KHRhcmdldFN0cmluZyk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZ2xvYlN0cmluZyA9PT0gdGFyZ2V0U3RyaW5nO1xuXHR9XG59XG5cbi8qKlxuICogRXZlbnQgQ2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50ZWQgZXh0ZW5kcyBEZXN0cm95YWJsZSBpbXBsZW1lbnRzIEV2ZW50ZWQge1xuXG5cdC8qKlxuXHQgKiBtYXAgb2YgbGlzdGVuZXJzIGtleWVkIGJ5IGV2ZW50IHR5cGVcblx0ICovXG5cdHByb3RlY3RlZCBsaXN0ZW5lcnNNYXA6IE1hcDxzdHJpbmcsIEV2ZW50ZWRDYWxsYmFjazxFdmVudE9iamVjdD4+ID0gbmV3IE1hcDxzdHJpbmcsIEV2ZW50ZWRDYWxsYmFjazxFdmVudE9iamVjdD4+KCk7XG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY29uc3RydWN0b3IgYXJndXJtZW50c1xuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9uczogRXZlbnRlZE9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0Y29uc3QgeyBsaXN0ZW5lcnMgfSA9IG9wdGlvbnM7XG5cdFx0aWYgKGxpc3RlbmVycykge1xuXHRcdFx0dGhpcy5vd24odGhpcy5vbihsaXN0ZW5lcnMpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW1pdHMgdGhlIGV2ZW50IG9iamV0IGZvciB0aGUgc3BlY2lmaWVkIHR5cGVcblx0ICpcblx0ICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCB0byBlbWl0XG5cdCAqL1xuXHRlbWl0PEUgZXh0ZW5kcyBFdmVudE9iamVjdD4oZXZlbnQ6IEUpOiB2b2lkIHtcblx0XHR0aGlzLmxpc3RlbmVyc01hcC5mb3JFYWNoKChtZXRob2QsIHR5cGUpID0+IHtcblx0XHRcdGlmIChpc0dsb2JNYXRjaCh0eXBlLCBldmVudC50eXBlKSkge1xuXHRcdFx0XHRtZXRob2QuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2F0Y2ggYWxsIGhhbmRsZXIgZm9yIHZhcmlvdXMgY2FsbCBzaWduYXR1cmVzLiBUaGUgc2lnbmF0dXJlcyBhcmUgZGVmaW5lZCBpblxuXHQgKiBgQmFzZUV2ZW50ZWRFdmVudHNgLiAgWW91IGNhbiBhZGQgeW91ciBvd24gZXZlbnQgdHlwZSAtPiBoYW5kbGVyIHR5cGVzIGJ5IGV4dGVuZGluZ1xuXHQgKiBgQmFzZUV2ZW50ZWRFdmVudHNgLiAgU2VlIGV4YW1wbGUgZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIEBwYXJhbSBhcmdzXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIGludGVyZmFjZSBXaWRnZXRCYXNlRXZlbnRzIGV4dGVuZHMgQmFzZUV2ZW50ZWRFdmVudHMge1xuXHQgKiAgICAgKHR5cGU6ICdwcm9wZXJ0aWVzOmNoYW5nZWQnLCBoYW5kbGVyOiBQcm9wZXJ0aWVzQ2hhbmdlZEhhbmRsZXIpOiBIYW5kbGU7XG5cdCAqIH1cblx0ICogY2xhc3MgV2lkZ2V0QmFzZSBleHRlbmRzIEV2ZW50ZWQge1xuXHQgKiAgICBvbjogV2lkZ2V0QmFzZUV2ZW50cztcblx0ICogfVxuXHQgKlxuXHQgKiBAcmV0dXJuIHthbnl9XG5cdCAqL1xuXHRvbjogQmFzZUV2ZW50ZWRFdmVudHMgPSBmdW5jdGlvbiAodGhpczogRXZlbnRlZCwgLi4uYXJnczogYW55W10pIHtcblx0XHRpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcblx0XHRcdGNvbnN0IFsgdHlwZSwgbGlzdGVuZXJzIF0gPSA8WyBzdHJpbmcsIEV2ZW50ZWRMaXN0ZW5lck9yQXJyYXk8YW55LCBFdmVudFRhcmdldHRlZE9iamVjdDxhbnk+Pl0+IGFyZ3M7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG5cdFx0XHRcdGNvbnN0IGhhbmRsZXMgPSBsaXN0ZW5lcnMubWFwKChsaXN0ZW5lcikgPT4gYXNwZWN0T24odGhpcy5saXN0ZW5lcnNNYXAsIHR5cGUsIHJlc29sdmVMaXN0ZW5lcihsaXN0ZW5lcikpKTtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZXNBcnJheXRvSGFuZGxlKGhhbmRsZXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBhc3BlY3RPbih0aGlzLmxpc3RlbmVyc01hcCwgdHlwZSwgcmVzb2x2ZUxpc3RlbmVyKGxpc3RlbmVycykpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0Y29uc3QgWyBsaXN0ZW5lck1hcEFyZyBdID0gPFtFdmVudGVkTGlzdGVuZXJzTWFwPGFueT5dPiBhcmdzO1xuXHRcdFx0Y29uc3QgaGFuZGxlcyA9IE9iamVjdC5rZXlzKGxpc3RlbmVyTWFwQXJnKS5tYXAoKHR5cGUpID0+IHRoaXMub24odHlwZSwgbGlzdGVuZXJNYXBBcmdbdHlwZV0pKTtcblx0XHRcdHJldHVybiBoYW5kbGVzQXJyYXl0b0hhbmRsZShoYW5kbGVzKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuXHRcdH1cblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRlZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBFdmVudGVkLnRzIiwiaW1wb3J0IHsgSGFuZGxlIH0gZnJvbSAnQGRvam8vaW50ZXJmYWNlcy9jb3JlJztcbmltcG9ydCBXZWFrTWFwIGZyb20gJ0Bkb2pvL3NoaW0vV2Vha01hcCc7XG5pbXBvcnQgeyBjcmVhdGVIYW5kbGUgfSBmcm9tICcuL2xhbmcnO1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIHRoZSBuZWNlc3NhcnkgQVBJcyB0byBiZSBNYXBMaWtlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFwTGlrZTxLLCBWPiB7XG5cdGdldChrZXk6IEspOiBWO1xuXHRzZXQoa2V5OiBLLCB2YWx1ZT86IFYpOiB0aGlzO1xufVxuXG4vKipcbiAqIEFuIGludGVybmFsIHR5cGUgZ3VhcmQgdGhhdCBkZXRlcm1pbmVzIGlmIGFuIHZhbHVlIGlzIE1hcExpa2Ugb3Igbm90XG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBndWFyZCBhZ2FpbnN0XG4gKi9cbmZ1bmN0aW9uIGlzTWFwTGlrZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgTWFwTGlrZTxhbnksIGFueT4ge1xuXHRyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuc2V0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4YWJsZSB7XG5cdFttZXRob2Q6IHN0cmluZ106IGFueTtcbn1cblxuLyoqXG4gKiBUaGUgdHlwZXMgb2Ygb2JqZWN0cyBvciBtYXBzIHdoZXJlIGFkdmljZSBjYW4gYmUgYXBwbGllZFxuICovXG5leHBvcnQgdHlwZSBUYXJnZXRhYmxlID0gTWFwTGlrZTxzdHJpbmcsIGFueT4gfCBJbmRleGFibGU7XG5cbnR5cGUgQWR2aWNlVHlwZSA9ICdiZWZvcmUnIHwgJ2FmdGVyJyB8ICdhcm91bmQnO1xuXG4vKipcbiAqIEEgbWV0YSBkYXRhIHN0cnVjdHVyZSB3aGVuIGFwcGx5aW5nIGFkdmljZVxuICovXG5pbnRlcmZhY2UgQWR2aXNlZCB7XG5cdHJlYWRvbmx5IGlkPzogbnVtYmVyO1xuXHRhZHZpY2U/OiBGdW5jdGlvbjtcblx0cHJldmlvdXM/OiBBZHZpc2VkO1xuXHRuZXh0PzogQWR2aXNlZDtcblx0cmVhZG9ubHkgcmVjZWl2ZUFyZ3VtZW50cz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgYWR2aWNlIHdoaWNoIGlzIGRlY29yYXRlZCB3aXRoIGFkZGl0aW9uYWxcbiAqIG1ldGEgZGF0YSBhYm91dCB0aGUgYWR2aWNlIHRvIGFwcGx5XG4gKi9cbmludGVyZmFjZSBEaXNwYXRjaGVyIHtcblx0WyB0eXBlOiBzdHJpbmcgXTogQWR2aXNlZCB8IHVuZGVmaW5lZDtcblx0KCk6IGFueTtcblx0dGFyZ2V0OiBhbnk7XG5cdGJlZm9yZT86IEFkdmlzZWQ7XG5cdGFyb3VuZD86IEFkdmlzZWQ7XG5cdGFmdGVyPzogQWR2aXNlZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2luUG9pbnREaXNwYXRjaEFkdmljZTxUPiB7XG5cdGJlZm9yZT86IEpvaW5Qb2ludEJlZm9yZUFkdmljZVtdO1xuXHRhZnRlcj86IEpvaW5Qb2ludEFmdGVyQWR2aWNlPFQ+W107XG5cdHJlYWRvbmx5IGpvaW5Qb2ludDogRnVuY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9pblBvaW50QWZ0ZXJBZHZpY2U8VD4ge1xuXHQvKipcblx0ICogQWR2aWNlIHdoaWNoIGlzIGFwcGxpZWQgKmFmdGVyKiwgcmVjZWl2aW5nIHRoZSByZXN1bHQgYW5kIGFyZ3VtZW50cyBmcm9tIHRoZSBqb2luIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gcmVzdWx0IFRoZSByZXN1bHQgZnJvbSB0aGUgZnVuY3Rpb24gYmVpbmcgYWR2aXNlZFxuXHQgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgd2VyZSBzdXBwbGllZCB0byB0aGUgYWR2aXNlZCBmdW5jdGlvblxuXHQgKiBAcmV0dXJucyBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgYWR2aWNlIGlzIHRoZW4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBtZXRob2Rcblx0ICovXG5cdChyZXN1bHQ6IFQsIC4uLmFyZ3M6IGFueVtdKTogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2luUG9pbnRBcm91bmRBZHZpY2U8VD4ge1xuXHQvKipcblx0ICogQWR2aWNlIHdoaWNoIGlzIGFwcGxpZWQgKmFyb3VuZCouICBUaGUgYWR2aXNpbmcgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGFuZFxuXHQgKiBuZWVkcyB0byByZXR1cm4gYSBuZXcgZnVuY3Rpb24gd2hpY2ggd2lsbCB0aGVuIGludm9rZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSBvcmlnRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIEEgbmV3IGZ1bmN0aW9uIHdoaWNoIHdpbGwgaW52b2tlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cblx0ICovXG5cdChvcmlnRm46IEdlbmVyaWNGdW5jdGlvbjxUPik6ICguLi5hcmdzOiBhbnlbXSkgPT4gVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2luUG9pbnRCZWZvcmVBZHZpY2Uge1xuXHQvKipcblx0ICogQWR2aWNlIHdoaWNoIGlzIGFwcGxpZWQgKmJlZm9yZSosIHJlY2VpdmluZyB0aGUgb3JpZ2luYWwgYXJndW1lbnRzLCBpZiB0aGUgYWR2aXNpbmdcblx0ICogZnVuY3Rpb24gcmV0dXJucyBhIHZhbHVlLCBpdCBpcyBwYXNzZWQgZnVydGhlciBhbG9uZyB0YWtpbmcgdGhlIHBsYWNlIG9mIHRoZSBvcmlnaW5hbFxuXHQgKiBhcmd1bWVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgdGhlIG1ldGhvZCB3YXMgY2FsbGVkIHdpdGhcblx0ICovXG5cdCguLi5hcmdzOiBhbnlbXSk6IGFueVtdIHwgdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmljRnVuY3Rpb248VD4ge1xuXHQoLi4uYXJnczogYW55W10pOiBUO1xufVxuXG4vKipcbiAqIEEgd2VhayBtYXAgb2YgZGlzcGF0Y2hlcnMgdXNlZCB0byBhcHBseSB0aGUgYWR2aWNlXG4gKi9cbmNvbnN0IGRpc3BhdGNoQWR2aWNlTWFwID0gbmV3IFdlYWtNYXA8RnVuY3Rpb24sIEpvaW5Qb2ludERpc3BhdGNoQWR2aWNlPGFueT4+KCk7XG5cbi8qKlxuICogQSBVSUQgZm9yIHRyYWNraW5nIGFkdmljZSBvcmRlcmluZ1xuICovXG5sZXQgbmV4dElkID0gMDtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGFkdmlzZXMgYSBqb2luIHBvaW50XG4gKlxuICogQHBhcmFtIGRpc3BhdGNoZXIgVGhlIGN1cnJlbnQgYWR2aWNlIGRpc3BhdGNoZXJcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGJlZm9yZSBvciBhZnRlciBhZHZpY2UgdG8gYXBwbHlcbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGFkdmljZSB0byBhcHBseVxuICogQHBhcmFtIHJlY2VpdmVBcmd1bWVudHMgSWYgdHJ1ZSwgdGhlIGFkdmljZSB3aWxsIHJlY2VpdmUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGpvaW4gcG9pbnRcbiAqIEByZXR1cm4gVGhlIGhhbmRsZSB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZHZpY2VcbiAqL1xuZnVuY3Rpb24gYWR2aXNlT2JqZWN0KFxuXHRkaXNwYXRjaGVyOiBEaXNwYXRjaGVyIHwgdW5kZWZpbmVkLFxuXHR0eXBlOiBBZHZpY2VUeXBlLFxuXHRhZHZpY2U6IEZ1bmN0aW9uIHwgdW5kZWZpbmVkLFxuXHRyZWNlaXZlQXJndW1lbnRzPzogYm9vbGVhblxuKTogSGFuZGxlIHtcblx0bGV0IHByZXZpb3VzID0gZGlzcGF0Y2hlciAmJiBkaXNwYXRjaGVyW3R5cGVdO1xuXHRsZXQgYWR2aXNlZDogQWR2aXNlZCB8IHVuZGVmaW5lZCA9IHtcblx0XHRpZDogbmV4dElkKyssXG5cdFx0YWR2aWNlOiBhZHZpY2UsXG5cdFx0cmVjZWl2ZUFyZ3VtZW50czogcmVjZWl2ZUFyZ3VtZW50c1xuXHR9O1xuXG5cdGlmIChwcmV2aW91cykge1xuXHRcdGlmICh0eXBlID09PSAnYWZ0ZXInKSB7XG5cdFx0XHQvLyBhZGQgdGhlIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3Rcblx0XHRcdC8vIG5vdGUgdGhhdCB3ZSBoYWQgdG8gY2hhbmdlIHRoaXMgbG9vcCBhIGxpdHRsZSBiaXQgdG8gd29ya2Fyb3VuZCBhIGJpemFycmUgSUUxMCBKSVQgYnVnXG5cdFx0XHR3aGlsZSAocHJldmlvdXMubmV4dCAmJiAocHJldmlvdXMgPSBwcmV2aW91cy5uZXh0KSkge31cblx0XHRcdHByZXZpb3VzLm5leHQgPSBhZHZpc2VkO1xuXHRcdFx0YWR2aXNlZC5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGFkZCB0byB0aGUgYmVnaW5uaW5nXG5cdFx0XHRpZiAoZGlzcGF0Y2hlcikge1xuXHRcdFx0XHRkaXNwYXRjaGVyLmJlZm9yZSA9IGFkdmlzZWQ7XG5cdFx0XHR9XG5cdFx0XHRhZHZpc2VkLm5leHQgPSBwcmV2aW91cztcblx0XHRcdHByZXZpb3VzLnByZXZpb3VzID0gYWR2aXNlZDtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZGlzcGF0Y2hlciAmJiAoZGlzcGF0Y2hlclt0eXBlXSA9IGFkdmlzZWQpO1xuXHR9XG5cblx0YWR2aWNlID0gcHJldmlvdXMgPSB1bmRlZmluZWQ7XG5cblx0cmV0dXJuIGNyZWF0ZUhhbmRsZShmdW5jdGlvbiAoKSB7XG5cdFx0bGV0IHsgcHJldmlvdXMgPSB1bmRlZmluZWQsIG5leHQgPSB1bmRlZmluZWQgfSA9IChhZHZpc2VkIHx8IHt9KTtcblxuXHRcdGlmIChkaXNwYXRjaGVyICYmICFwcmV2aW91cyAmJiAhbmV4dCkge1xuXHRcdFx0ZGlzcGF0Y2hlclt0eXBlXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAocHJldmlvdXMpIHtcblx0XHRcdFx0cHJldmlvdXMubmV4dCA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZGlzcGF0Y2hlciAmJiAoZGlzcGF0Y2hlclt0eXBlXSA9IG5leHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChhZHZpc2VkKSB7XG5cdFx0XHRkZWxldGUgYWR2aXNlZC5hZHZpY2U7XG5cdFx0fVxuXHRcdGRpc3BhdGNoZXIgPSBhZHZpc2VkID0gdW5kZWZpbmVkO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBBZHZpc2UgYSBqb2luIHBvaW50IChmdW5jdGlvbikgd2l0aCBzdXBwbGllZCBhZHZpY2VcbiAqXG4gKiBAcGFyYW0gam9pblBvaW50IFRoZSBmdW5jdGlvbiB0byBiZSBhZHZpc2VkXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBhZHZpY2UgdG8gYmUgYXBwbGllZFxuICogQHBhcmFtIGFkdmljZSBUaGUgYWR2aWNlIHRvIGFwcGx5XG4gKi9cbmZ1bmN0aW9uIGFkdmlzZUpvaW5Qb2ludDxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPih0aGlzOiBhbnksIGpvaW5Qb2ludDogRiwgdHlwZTogQWR2aWNlVHlwZSwgYWR2aWNlOiBKb2luUG9pbnRCZWZvcmVBZHZpY2UgfCBKb2luUG9pbnRBZnRlckFkdmljZTxUPiB8IEpvaW5Qb2ludEFyb3VuZEFkdmljZTxUPik6IEYge1xuXHRsZXQgZGlzcGF0Y2hlcjogRjtcblx0aWYgKHR5cGUgPT09ICdhcm91bmQnKSB7XG5cdFx0ZGlzcGF0Y2hlciA9IGdldEpvaW5Qb2ludERpc3BhdGNoZXIoYWR2aWNlLmFwcGx5KHRoaXMsIFsgam9pblBvaW50IF0pKTtcblx0fVxuXHRlbHNlIHtcblx0XHRkaXNwYXRjaGVyID0gZ2V0Sm9pblBvaW50RGlzcGF0Y2hlcihqb2luUG9pbnQpO1xuXHRcdC8vIGNhbm5vdCBoYXZlIHVuZGVmaW5lZCBpbiBtYXAgZHVlIHRvIGNvZGUgbG9naWMsIHVzaW5nICFcblx0XHRjb25zdCBhZHZpY2VNYXAgPSBkaXNwYXRjaEFkdmljZU1hcC5nZXQoZGlzcGF0Y2hlcikhO1xuXHRcdGlmICh0eXBlID09PSAnYmVmb3JlJykge1xuXHRcdFx0KGFkdmljZU1hcC5iZWZvcmUgfHwgKGFkdmljZU1hcC5iZWZvcmUgPSBbXSkpLnVuc2hpZnQoPEpvaW5Qb2ludEJlZm9yZUFkdmljZT4gYWR2aWNlKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQoYWR2aWNlTWFwLmFmdGVyIHx8IChhZHZpY2VNYXAuYWZ0ZXIgPSBbXSkpLnB1c2goYWR2aWNlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbi8qKlxuICogQW4gaW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBvciBjcmVhdGVzIHRoZSBkaXNwYXRjaGVyIGZvciBhIGdpdmVuIGpvaW4gcG9pbnRcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9yIG1hcFxuICogQHBhcmFtIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHRoZSBkaXNwYXRjaGVyIHNob3VsZCBiZSByZXNvbHZlZCBmb3JcbiAqIEByZXR1cm4gVGhlIGRpc3BhdGNoZXJcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzcGF0Y2hlck9iamVjdCh0YXJnZXQ6IFRhcmdldGFibGUsIG1ldGhvZE5hbWU6IHN0cmluZyk6IERpc3BhdGNoZXIge1xuXHRjb25zdCBleGlzdGluZyA9IGlzTWFwTGlrZSh0YXJnZXQpID8gdGFyZ2V0LmdldChtZXRob2ROYW1lKSA6IHRhcmdldCAmJiB0YXJnZXRbbWV0aG9kTmFtZV07XG5cdGxldCBkaXNwYXRjaGVyOiBEaXNwYXRjaGVyO1xuXG5cdGlmICghZXhpc3RpbmcgfHwgZXhpc3RpbmcudGFyZ2V0ICE9PSB0YXJnZXQpIHtcblx0XHQvKiBUaGVyZSBpcyBubyBleGlzdGluZyBkaXNwYXRjaGVyLCB0aGVyZWZvcmUgd2Ugd2lsbCBjcmVhdGUgb25lICovXG5cdFx0ZGlzcGF0Y2hlciA9IDxEaXNwYXRjaGVyPiBmdW5jdGlvbiAodGhpczogRGlzcGF0Y2hlcik6IGFueSB7XG5cdFx0XHRsZXQgZXhlY3V0aW9uSWQgPSBuZXh0SWQ7XG5cdFx0XHRsZXQgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdGxldCByZXN1bHRzOiBhbnk7XG5cdFx0XHRsZXQgYmVmb3JlID0gZGlzcGF0Y2hlci5iZWZvcmU7XG5cblx0XHRcdHdoaWxlIChiZWZvcmUpIHtcblx0XHRcdFx0aWYgKGJlZm9yZS5hZHZpY2UpIHtcblx0XHRcdFx0XHRhcmdzID0gYmVmb3JlLmFkdmljZS5hcHBseSh0aGlzLCBhcmdzKSB8fCBhcmdzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJlZm9yZSA9IGJlZm9yZS5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGlzcGF0Y2hlci5hcm91bmQgJiYgZGlzcGF0Y2hlci5hcm91bmQuYWR2aWNlKSB7XG5cdFx0XHRcdHJlc3VsdHMgPSBkaXNwYXRjaGVyLmFyb3VuZC5hZHZpY2UodGhpcywgYXJncyk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBhZnRlciA9IGRpc3BhdGNoZXIuYWZ0ZXI7XG5cdFx0XHR3aGlsZSAoYWZ0ZXIgJiYgYWZ0ZXIuaWQgIT09IHVuZGVmaW5lZCAmJiBhZnRlci5pZCA8IGV4ZWN1dGlvbklkKSB7XG5cdFx0XHRcdGlmIChhZnRlci5hZHZpY2UpIHtcblx0XHRcdFx0XHRpZiAoYWZ0ZXIucmVjZWl2ZUFyZ3VtZW50cykge1xuXHRcdFx0XHRcdFx0bGV0IG5ld1Jlc3VsdHMgPSBhZnRlci5hZHZpY2UuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdFx0XHRyZXN1bHRzID0gbmV3UmVzdWx0cyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0cyA6IG5ld1Jlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0cyA9IGFmdGVyLmFkdmljZS5jYWxsKHRoaXMsIHJlc3VsdHMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhZnRlciA9IGFmdGVyLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHRpZiAoaXNNYXBMaWtlKHRhcmdldCkpIHtcblx0XHRcdHRhcmdldC5zZXQobWV0aG9kTmFtZSwgZGlzcGF0Y2hlcik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGFyZ2V0ICYmICh0YXJnZXRbbWV0aG9kTmFtZV0gPSBkaXNwYXRjaGVyKTtcblx0XHR9XG5cblx0XHRpZiAoZXhpc3RpbmcpIHtcblx0XHRcdGRpc3BhdGNoZXIuYXJvdW5kID0ge1xuXHRcdFx0XHRhZHZpY2U6IGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgYXJnczogYW55W10pOiBhbnkge1xuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZy5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGRpc3BhdGNoZXIudGFyZ2V0ID0gdGFyZ2V0O1xuXHR9XG5cdGVsc2Uge1xuXHRcdGRpc3BhdGNoZXIgPSBleGlzdGluZztcblx0fVxuXG5cdHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3BhdGNoZXIgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gam9pblBvaW50IChtZXRob2QvZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBUaGUgZnVuY3Rpb24gdGhhdCBpcyB0byBiZSBhZHZpc2VkXG4gKi9cbmZ1bmN0aW9uIGdldEpvaW5Qb2ludERpc3BhdGNoZXI8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxUPiwgVD4oam9pblBvaW50OiBGKTogRiB7XG5cblx0ZnVuY3Rpb24gZGlzcGF0Y2hlcih0aGlzOiBGdW5jdGlvbiwgLi4uYXJnczogYW55W10pOiBUIHtcblx0XHQvLyBjYW5ub3QgaGF2ZSB1bmRlZmluZWQgaW4gbWFwIGR1ZSB0byBjb2RlIGxvZ2ljLCB1c2luZyAhXG5cdFx0Y29uc3QgeyBiZWZvcmUsIGFmdGVyLCBqb2luUG9pbnQgfSA9IGRpc3BhdGNoQWR2aWNlTWFwLmdldChkaXNwYXRjaGVyKSE7XG5cdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0YXJncyA9IGJlZm9yZS5yZWR1Y2UoKHByZXZpb3VzQXJncywgYWR2aWNlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRBcmdzID0gYWR2aWNlLmFwcGx5KHRoaXMsIHByZXZpb3VzQXJncyk7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50QXJncyB8fCBwcmV2aW91c0FyZ3M7XG5cdFx0XHR9LCBhcmdzKTtcblx0XHR9XG5cdFx0bGV0IHJlc3VsdCA9IGpvaW5Qb2ludC5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdHJlc3VsdCA9IGFmdGVyLnJlZHVjZSgocHJldmlvdXNSZXN1bHQsIGFkdmljZSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gYWR2aWNlLmFwcGx5KHRoaXMsIFsgcHJldmlvdXNSZXN1bHQgXS5jb25jYXQoYXJncykpO1xuXHRcdFx0fSwgcmVzdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qIFdlIHdhbnQgdG8gXCJjbG9uZVwiIHRoZSBhZHZpY2UgdGhhdCBoYXMgYmVlbiBhcHBsaWVkIGFscmVhZHksIGlmIHRoaXNcblx0ICogam9pblBvaW50IGlzIGFscmVhZHkgYWR2aXNlZCAqL1xuXHRpZiAoZGlzcGF0Y2hBZHZpY2VNYXAuaGFzKGpvaW5Qb2ludCkpIHtcblx0XHQvLyBjYW5ub3QgaGF2ZSB1bmRlZmluZWQgaW4gbWFwIGR1ZSB0byBjb2RlIGxvZ2ljLCB1c2luZyAhXG5cdFx0Y29uc3QgYWR2aWNlTWFwID0gZGlzcGF0Y2hBZHZpY2VNYXAuZ2V0KGpvaW5Qb2ludCkhO1xuXHRcdGxldCB7IGJlZm9yZSwgYWZ0ZXIgfSA9IGFkdmljZU1hcDtcblx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRiZWZvcmUgPSBiZWZvcmUuc2xpY2UoMCk7XG5cdFx0fVxuXHRcdGlmIChhZnRlcikge1xuXHRcdFx0YWZ0ZXIgPSBhZnRlci5zbGljZSgwKTtcblx0XHR9XG5cdFx0ZGlzcGF0Y2hBZHZpY2VNYXAuc2V0KGRpc3BhdGNoZXIsIHtcblx0XHRcdGpvaW5Qb2ludDogYWR2aWNlTWFwLmpvaW5Qb2ludCxcblx0XHRcdGJlZm9yZSxcblx0XHRcdGFmdGVyXG5cdFx0fSk7XG5cdH1cblx0LyogT3RoZXJ3aXNlLCB0aGlzIGlzIGEgbmV3IGpvaW5Qb2ludCwgc28gd2Ugd2lsbCBjcmVhdGUgdGhlIGFkdmljZSBtYXAgYWZyZXNoICovXG5cdGVsc2Uge1xuXHRcdGRpc3BhdGNoQWR2aWNlTWFwLnNldChkaXNwYXRjaGVyLCB7IGpvaW5Qb2ludCB9KTtcblx0fVxuXG5cdHJldHVybiBkaXNwYXRjaGVyIGFzIEY7XG59XG5cbi8qKlxuICogQXBwbHkgYWR2aWNlICphZnRlciogdGhlIHN1cHBsaWVkIGpvaW5Qb2ludCAoZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGhhdmUgYWR2aWNlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGFmdGVyIGFkdmljZVxuICovXG5mdW5jdGlvbiBhZnRlckpvaW5Qb2ludDxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihqb2luUG9pbnQ6IEYsIGFkdmljZTogSm9pblBvaW50QWZ0ZXJBZHZpY2U8VD4pOiBGIHtcblx0cmV0dXJuIGFkdmlzZUpvaW5Qb2ludChqb2luUG9pbnQsICdhZnRlcicsIGFkdmljZSk7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgXCJhZnRlclwiIGFkdmljZSB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICogVGhlIGFkdmlzaW5nIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgb3JpZ2luYWwgbWV0aG9kJ3MgcmV0dXJuIHZhbHVlIGFuZCBhcmd1bWVudHMgb2JqZWN0LlxuICogVGhlIHZhbHVlIGl0IHJldHVybnMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoZSBtZXRob2Qgd2hlbiBpdCBpcyBjYWxsZWQgKGV2ZW4gaWYgdGhlIHJldHVybiB2YWx1ZSBpcyB1bmRlZmluZWQpLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHdob3NlIG1ldGhvZCB3aWxsIGJlIGFzcGVjdGVkXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZCB0byBhc3BlY3RcbiAqIEBwYXJhbSBhZHZpY2UgQWR2aXNpbmcgZnVuY3Rpb24gd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBvcmlnaW5hbCBtZXRob2QncyByZXR1cm4gdmFsdWUgYW5kIGFyZ3VtZW50cyBvYmplY3RcbiAqIEByZXR1cm4gQSBoYW5kbGUgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGFzcGVjdCB3aGVuIGRlc3Ryb3kgaXMgY2FsbGVkXG4gKi9cbmZ1bmN0aW9uIGFmdGVyT2JqZWN0KHRhcmdldDogVGFyZ2V0YWJsZSwgbWV0aG9kTmFtZTogc3RyaW5nLCBhZHZpY2U6IChvcmlnaW5hbFJldHVybjogYW55LCBvcmlnaW5hbEFyZ3M6IElBcmd1bWVudHMpID0+IGFueSk6IEhhbmRsZSB7XG5cdHJldHVybiBhZHZpc2VPYmplY3QoZ2V0RGlzcGF0Y2hlck9iamVjdCh0YXJnZXQsIG1ldGhvZE5hbWUpLCAnYWZ0ZXInLCBhZHZpY2UpO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIFwiYWZ0ZXJcIiBhZHZpY2UgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqIFRoZSBhZHZpc2luZyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG9yaWdpbmFsIG1ldGhvZCdzIHJldHVybiB2YWx1ZSBhbmQgYXJndW1lbnRzIG9iamVjdC5cbiAqIFRoZSB2YWx1ZSBpdCByZXR1cm5zIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGUgbWV0aG9kIHdoZW4gaXQgaXMgY2FsbGVkIChldmVuIGlmIHRoZSByZXR1cm4gdmFsdWUgaXMgdW5kZWZpbmVkKS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB3aG9zZSBtZXRob2Qgd2lsbCBiZSBhc3BlY3RlZFxuICogQHBhcmFtIG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2QgdG8gYXNwZWN0XG4gKiBAcGFyYW0gYWR2aWNlIEFkdmlzaW5nIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgb3JpZ2luYWwgbWV0aG9kJ3MgcmV0dXJuIHZhbHVlIGFuZCBhcmd1bWVudHMgb2JqZWN0XG4gKiBAcmV0dXJuIEEgaGFuZGxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBhc3BlY3Qgd2hlbiBkZXN0cm95IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXIodGFyZ2V0OiBUYXJnZXRhYmxlLCBtZXRob2ROYW1lOiBzdHJpbmcsIGFkdmljZTogKG9yaWdpbmFsUmV0dXJuOiBhbnksIG9yaWdpbmFsQXJnczogSUFyZ3VtZW50cykgPT4gYW55KTogSGFuZGxlO1xuLyoqXG4gKiBBcHBseSBhZHZpY2UgKmFmdGVyKiB0aGUgc3VwcGxpZWQgam9pblBvaW50IChmdW5jdGlvbilcbiAqXG4gKiBAcGFyYW0gam9pblBvaW50IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgaGF2ZSBhZHZpY2UgYXBwbGllZCB0b1xuICogQHBhcmFtIGFkdmljZSBUaGUgYWZ0ZXIgYWR2aWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlcjxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihqb2luUG9pbnQ6IEYsIGFkdmljZTogSm9pblBvaW50QWZ0ZXJBZHZpY2U8VD4pOiBGO1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyPEYgZXh0ZW5kcyBHZW5lcmljRnVuY3Rpb248VD4sIFQ+KGpvaW5Qb2ludE9yVGFyZ2V0OiBGIHwgVGFyZ2V0YWJsZSwgbWV0aG9kTmFtZU9yQWR2aWNlOiBzdHJpbmcgfCBKb2luUG9pbnRBZnRlckFkdmljZTxUPiwgb2JqZWN0QWR2aWNlPzogKG9yaWdpbmFsUmV0dXJuOiBhbnksIG9yaWdpbmFsQXJnczogSUFyZ3VtZW50cykgPT4gYW55KTogSGFuZGxlIHwgRiB7XG5cdGlmICh0eXBlb2Ygam9pblBvaW50T3JUYXJnZXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYWZ0ZXJKb2luUG9pbnQoam9pblBvaW50T3JUYXJnZXQsIDxKb2luUG9pbnRBZnRlckFkdmljZTxUPj4gbWV0aG9kTmFtZU9yQWR2aWNlKTtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gYWZ0ZXJPYmplY3Qoam9pblBvaW50T3JUYXJnZXQsIDxzdHJpbmc+IG1ldGhvZE5hbWVPckFkdmljZSwgb2JqZWN0QWR2aWNlISk7XG5cdH1cbn1cblxuLyoqXG4gKiBBcHBseSBhZHZpY2UgKmFyb3VuZCogdGhlIHN1cHBsaWVkIGpvaW5Qb2ludCAoZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGhhdmUgYWR2aWNlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGFyb3VuZCBhZHZpY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyb3VuZEpvaW5Qb2ludDxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihqb2luUG9pbnQ6IEYsIGFkdmljZTogSm9pblBvaW50QXJvdW5kQWR2aWNlPFQ+KTogRiB7XG5cdHJldHVybiBhZHZpc2VKb2luUG9pbnQ8RiwgVD4oam9pblBvaW50LCAnYXJvdW5kJywgYWR2aWNlKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBcImFyb3VuZFwiIGFkdmljZSBhcm91bmQgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB3aG9zZSBtZXRob2Qgd2lsbCBiZSBhc3BlY3RlZFxuICogQHBhcmFtIG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2QgdG8gYXNwZWN0XG4gKiBAcGFyYW0gYWR2aWNlIEFkdmlzaW5nIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb25cbiAqIEByZXR1cm4gQSBoYW5kbGUgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGFzcGVjdCB3aGVuIGRlc3Ryb3kgaXMgY2FsbGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcm91bmRPYmplY3QodGFyZ2V0OiBUYXJnZXRhYmxlLCBtZXRob2ROYW1lOiBzdHJpbmcsIGFkdmljZTogKChwcmV2aW91czogRnVuY3Rpb24pID0+IEZ1bmN0aW9uKSk6IEhhbmRsZSB7XG5cdGxldCBkaXNwYXRjaGVyOiBEaXNwYXRjaGVyIHwgdW5kZWZpbmVkID0gZ2V0RGlzcGF0Y2hlck9iamVjdCh0YXJnZXQsIG1ldGhvZE5hbWUpO1xuXHRsZXQgcHJldmlvdXMgPSBkaXNwYXRjaGVyLmFyb3VuZDtcblx0bGV0IGFkdmlzZWQ6IEZ1bmN0aW9uIHwgdW5kZWZpbmVkO1xuXHRpZiAoYWR2aWNlKSB7XG5cdFx0YWR2aXNlZCA9IGFkdmljZShmdW5jdGlvbiAodGhpczogRGlzcGF0Y2hlcik6IGFueSB7XG5cdFx0XHRpZiAocHJldmlvdXMgJiYgcHJldmlvdXMuYWR2aWNlKSB7XG5cdFx0XHRcdHJldHVybiBwcmV2aW91cy5hZHZpY2UodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGRpc3BhdGNoZXIuYXJvdW5kID0ge1xuXHRcdGFkdmljZTogZnVuY3Rpb24gKHRhcmdldDogYW55LCBhcmdzOiBhbnlbXSk6IGFueSB7XG5cdFx0XHRyZXR1cm4gYWR2aXNlZCA/IGFkdmlzZWQuYXBwbHkodGFyZ2V0LCBhcmdzKSA6IHByZXZpb3VzICYmIHByZXZpb3VzLmFkdmljZSAmJiBwcmV2aW91cy5hZHZpY2UodGFyZ2V0LCBhcmdzKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGNyZWF0ZUhhbmRsZShmdW5jdGlvbiAoKSB7XG5cdFx0YWR2aXNlZCA9IGRpc3BhdGNoZXIgPSB1bmRlZmluZWQ7XG5cdH0pO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIFwiYXJvdW5kXCIgYWR2aWNlIGFyb3VuZCB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHdob3NlIG1ldGhvZCB3aWxsIGJlIGFzcGVjdGVkXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZCB0byBhc3BlY3RcbiAqIEBwYXJhbSBhZHZpY2UgQWR2aXNpbmcgZnVuY3Rpb24gd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBvcmlnaW5hbCBmdW5jdGlvblxuICogQHJldHVybiBBIGhhbmRsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYXNwZWN0IHdoZW4gZGVzdHJveSBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyb3VuZCh0YXJnZXQ6IFRhcmdldGFibGUsIG1ldGhvZE5hbWU6IHN0cmluZywgYWR2aWNlOiAoKHByZXZpb3VzOiBGdW5jdGlvbikgPT4gRnVuY3Rpb24pKTogSGFuZGxlO1xuLyoqXG4gKiBBcHBseSBhZHZpY2UgKmFyb3VuZCogdGhlIHN1cHBsaWVkIGpvaW5Qb2ludCAoZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGhhdmUgYWR2aWNlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGFyb3VuZCBhZHZpY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyb3VuZDxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihqb2luUG9pbnQ6IEYsIGFkdmljZTogSm9pblBvaW50QXJvdW5kQWR2aWNlPFQ+KTogRjtcbmV4cG9ydCBmdW5jdGlvbiBhcm91bmQ8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxUPiwgVD4oam9pblBvaW50T3JUYXJnZXQ6IEYgfCBUYXJnZXRhYmxlLCBtZXRob2ROYW1lT3JBZHZpY2U6IHN0cmluZyB8IEpvaW5Qb2ludEFyb3VuZEFkdmljZTxUPiwgb2JqZWN0QWR2aWNlPzogKChwcmV2aW91czogRnVuY3Rpb24pID0+IEZ1bmN0aW9uKSk6IEhhbmRsZSB8IEYge1xuXHRpZiAodHlwZW9mIGpvaW5Qb2ludE9yVGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGFyb3VuZEpvaW5Qb2ludChqb2luUG9pbnRPclRhcmdldCwgPEpvaW5Qb2ludEFyb3VuZEFkdmljZTxUPj4gbWV0aG9kTmFtZU9yQWR2aWNlKTtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gYXJvdW5kT2JqZWN0KGpvaW5Qb2ludE9yVGFyZ2V0LCA8c3RyaW5nPiBtZXRob2ROYW1lT3JBZHZpY2UsIG9iamVjdEFkdmljZSEpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbHkgYWR2aWNlICpiZWZvcmUqIHRoZSBzdXBwbGllZCBqb2luUG9pbnQgKGZ1bmN0aW9uKVxuICpcbiAqIEBwYXJhbSBqb2luUG9pbnQgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBoYXZlIGFkdmljZSBhcHBsaWVkIHRvXG4gKiBAcGFyYW0gYWR2aWNlIFRoZSBiZWZvcmUgYWR2aWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVKb2luUG9pbnQ8RiBleHRlbmRzIEdlbmVyaWNGdW5jdGlvbjxhbnk+Pihqb2luUG9pbnQ6IEYsIGFkdmljZTogSm9pblBvaW50QmVmb3JlQWR2aWNlKTogRiB7XG5cdHJldHVybiBhZHZpc2VKb2luUG9pbnQoam9pblBvaW50LCAnYmVmb3JlJywgYWR2aWNlKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBcImJlZm9yZVwiIGFkdmljZSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB3aG9zZSBtZXRob2Qgd2lsbCBiZSBhc3BlY3RlZFxuICogQHBhcmFtIG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2QgdG8gYXNwZWN0XG4gKiBAcGFyYW0gYWR2aWNlIEFkdmlzaW5nIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG9yaWdpbmFsLCBhbmQgbWF5IHJldHVybiBuZXcgYXJndW1lbnRzXG4gKiBAcmV0dXJuIEEgaGFuZGxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBhc3BlY3Qgd2hlbiBkZXN0cm95IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlT2JqZWN0KHRhcmdldDogVGFyZ2V0YWJsZSwgbWV0aG9kTmFtZTogc3RyaW5nLCBhZHZpY2U6ICguLi5vcmlnaW5hbEFyZ3M6IGFueVtdKSA9PiBhbnlbXSB8IHZvaWQpOiBIYW5kbGUge1xuXHRyZXR1cm4gYWR2aXNlT2JqZWN0KGdldERpc3BhdGNoZXJPYmplY3QodGFyZ2V0LCBtZXRob2ROYW1lKSwgJ2JlZm9yZScsIGFkdmljZSk7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgXCJiZWZvcmVcIiBhZHZpY2UgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gKlxuICogQHBhcmFtIHRhcmdldCBPYmplY3Qgd2hvc2UgbWV0aG9kIHdpbGwgYmUgYXNwZWN0ZWRcbiAqIEBwYXJhbSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kIHRvIGFzcGVjdFxuICogQHBhcmFtIGFkdmljZSBBZHZpc2luZyBmdW5jdGlvbiB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoZSBvcmlnaW5hbCwgYW5kIG1heSByZXR1cm4gbmV3IGFyZ3VtZW50c1xuICogQHJldHVybiBBIGhhbmRsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYXNwZWN0IHdoZW4gZGVzdHJveSBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZSh0YXJnZXQ6IFRhcmdldGFibGUsIG1ldGhvZE5hbWU6IHN0cmluZywgYWR2aWNlOiAoLi4ub3JpZ2luYWxBcmdzOiBhbnlbXSkgPT4gYW55W10gfCB2b2lkKTogSGFuZGxlO1xuLyoqXG4gKiBBcHBseSBhZHZpY2UgKmJlZm9yZSogdGhlIHN1cHBsaWVkIGpvaW5Qb2ludCAoZnVuY3Rpb24pXG4gKlxuICogQHBhcmFtIGpvaW5Qb2ludCBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGhhdmUgYWR2aWNlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSBhZHZpY2UgVGhlIGJlZm9yZSBhZHZpY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZTxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPGFueT4+KGpvaW5Qb2ludDogRiwgYWR2aWNlOiBKb2luUG9pbnRCZWZvcmVBZHZpY2UpOiBGO1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZTxGIGV4dGVuZHMgR2VuZXJpY0Z1bmN0aW9uPFQ+LCBUPihqb2luUG9pbnRPclRhcmdldDogRiB8IFRhcmdldGFibGUsIG1ldGhvZE5hbWVPckFkdmljZTogc3RyaW5nIHwgSm9pblBvaW50QmVmb3JlQWR2aWNlLCBvYmplY3RBZHZpY2U/OiAoKC4uLm9yaWdpbmFsQXJnczogYW55W10pID0+IGFueVtdIHwgdm9pZCkpOiBIYW5kbGUgfCBGIHtcblx0aWYgKHR5cGVvZiBqb2luUG9pbnRPclRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBiZWZvcmVKb2luUG9pbnQoam9pblBvaW50T3JUYXJnZXQsIDxKb2luUG9pbnRCZWZvcmVBZHZpY2U+IG1ldGhvZE5hbWVPckFkdmljZSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIGJlZm9yZU9iamVjdChqb2luUG9pbnRPclRhcmdldCwgPHN0cmluZz4gbWV0aG9kTmFtZU9yQWR2aWNlLCBvYmplY3RBZHZpY2UhKTtcblx0fVxufVxuXG4vKipcbiAqIEF0dGFjaGVzIGFkdmljZSB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICogVGhlIGFkdmlzaW5nIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAqIFRoZSB2YWx1ZSBpdCByZXR1cm5zIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGUgbWV0aG9kIHdoZW4gaXQgaXMgY2FsbGVkICp1bmxlc3MqIGl0cyByZXR1cm4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHdob3NlIG1ldGhvZCB3aWxsIGJlIGFzcGVjdGVkXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZCB0byBhc3BlY3RcbiAqIEBwYXJhbSBhZHZpY2UgQWR2aXNpbmcgZnVuY3Rpb24gd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgb3JpZ2luYWwgbWV0aG9kXG4gKiBAcmV0dXJuIEEgaGFuZGxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBhc3BlY3Qgd2hlbiBkZXN0cm95IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gb24odGFyZ2V0OiBUYXJnZXRhYmxlLCBtZXRob2ROYW1lOiBzdHJpbmcsIGFkdmljZTogKC4uLm9yaWdpbmFsQXJnczogYW55W10pID0+IGFueSk6IEhhbmRsZSB7XG5cdHJldHVybiBhZHZpc2VPYmplY3QoZ2V0RGlzcGF0Y2hlck9iamVjdCh0YXJnZXQsIG1ldGhvZE5hbWUpLCAnYWZ0ZXInLCBhZHZpY2UsIHRydWUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFzcGVjdC50cyIsImltcG9ydCBoYXMsIHsgYWRkIH0gZnJvbSAnQGRvam8vaGFzL2hhcyc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJy4uL2dsb2JhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGhhcztcbmV4cG9ydCAqIGZyb20gJ0Bkb2pvL2hhcy9oYXMnO1xuXG4vKiBFQ01BU2NyaXB0IDYgYW5kIDcgRmVhdHVyZXMgKi9cblxuLyogQXJyYXkgKi9cbmFkZChcblx0J2VzNi1hcnJheScsXG5cdCgpID0+IHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0Wydmcm9tJywgJ29mJ10uZXZlcnkoKGtleSkgPT4ga2V5IGluIGdsb2JhbC5BcnJheSkgJiZcblx0XHRcdFsnZmluZEluZGV4JywgJ2ZpbmQnLCAnY29weVdpdGhpbiddLmV2ZXJ5KChrZXkpID0+IGtleSBpbiBnbG9iYWwuQXJyYXkucHJvdG90eXBlKVxuXHRcdCk7XG5cdH0sXG5cdHRydWVcbik7XG5cbmFkZChcblx0J2VzNi1hcnJheS1maWxsJyxcblx0KCkgPT4ge1xuXHRcdGlmICgnZmlsbCcgaW4gZ2xvYmFsLkFycmF5LnByb3RvdHlwZSkge1xuXHRcdFx0LyogU29tZSB2ZXJzaW9ucyBvZiBTYWZhcmkgZG8gbm90IHByb3Blcmx5IGltcGxlbWVudCB0aGlzICovXG5cdFx0XHRyZXR1cm4gKDxhbnk+WzFdKS5maWxsKDksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlbMF0gPT09IDE7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuYWRkKCdlczctYXJyYXknLCAoKSA9PiAnaW5jbHVkZXMnIGluIGdsb2JhbC5BcnJheS5wcm90b3R5cGUsIHRydWUpO1xuXG4vKiBNYXAgKi9cbmFkZChcblx0J2VzNi1tYXAnLFxuXHQoKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBnbG9iYWwuTWFwID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvKlxuXHRcdElFMTEgYW5kIG9sZGVyIHZlcnNpb25zIG9mIFNhZmFyaSBhcmUgbWlzc2luZyBjcml0aWNhbCBFUzYgTWFwIGZ1bmN0aW9uYWxpdHlcblx0XHRXZSB3cmFwIHRoaXMgaW4gYSB0cnkvY2F0Y2ggYmVjYXVzZSBzb21ldGltZXMgdGhlIE1hcCBjb25zdHJ1Y3RvciBleGlzdHMsIGJ1dCBkb2VzIG5vdFxuXHRcdHRha2UgYXJndW1lbnRzIChpT1MgOC40KVxuXHRcdCAqL1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgbWFwID0gbmV3IGdsb2JhbC5NYXAoW1swLCAxXV0pO1xuXG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0bWFwLmhhcygwKSAmJlxuXHRcdFx0XHRcdHR5cGVvZiBtYXAua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRcdGhhcygnZXM2LXN5bWJvbCcpICYmXG5cdFx0XHRcdFx0dHlwZW9mIG1hcC52YWx1ZXMgPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0XHR0eXBlb2YgbWFwLmVudHJpZXMgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCB0ZXN0aW5nIG9uIGlPUyBhdCB0aGUgbW9tZW50ICovXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG4vKiBNYXRoICovXG5hZGQoXG5cdCdlczYtbWF0aCcsXG5cdCgpID0+IHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0J2NsejMyJyxcblx0XHRcdCdzaWduJyxcblx0XHRcdCdsb2cxMCcsXG5cdFx0XHQnbG9nMicsXG5cdFx0XHQnbG9nMXAnLFxuXHRcdFx0J2V4cG0xJyxcblx0XHRcdCdjb3NoJyxcblx0XHRcdCdzaW5oJyxcblx0XHRcdCd0YW5oJyxcblx0XHRcdCdhY29zaCcsXG5cdFx0XHQnYXNpbmgnLFxuXHRcdFx0J2F0YW5oJyxcblx0XHRcdCd0cnVuYycsXG5cdFx0XHQnZnJvdW5kJyxcblx0XHRcdCdjYnJ0Jyxcblx0XHRcdCdoeXBvdCdcblx0XHRdLmV2ZXJ5KChuYW1lKSA9PiB0eXBlb2YgZ2xvYmFsLk1hdGhbbmFtZV0gPT09ICdmdW5jdGlvbicpO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG5hZGQoXG5cdCdlczYtbWF0aC1pbXVsJyxcblx0KCkgPT4ge1xuXHRcdGlmICgnaW11bCcgaW4gZ2xvYmFsLk1hdGgpIHtcblx0XHRcdC8qIFNvbWUgdmVyc2lvbnMgb2YgU2FmYXJpIG9uIGlvcyBkbyBub3QgcHJvcGVybHkgaW1wbGVtZW50IHRoaXMgKi9cblx0XHRcdHJldHVybiAoPGFueT5NYXRoKS5pbXVsKDB4ZmZmZmZmZmYsIDUpID09PSAtNTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG4vKiBPYmplY3QgKi9cbmFkZChcblx0J2VzNi1vYmplY3QnLFxuXHQoKSA9PiB7XG5cdFx0cmV0dXJuIChcblx0XHRcdGhhcygnZXM2LXN5bWJvbCcpICYmXG5cdFx0XHRbJ2Fzc2lnbicsICdpcycsICdnZXRPd25Qcm9wZXJ0eVN5bWJvbHMnLCAnc2V0UHJvdG90eXBlT2YnXS5ldmVyeShcblx0XHRcdFx0KG5hbWUpID0+IHR5cGVvZiBnbG9iYWwuT2JqZWN0W25hbWVdID09PSAnZnVuY3Rpb24nXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuYWRkKFxuXHQnZXMyMDE3LW9iamVjdCcsXG5cdCgpID0+IHtcblx0XHRyZXR1cm4gWyd2YWx1ZXMnLCAnZW50cmllcycsICdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJ10uZXZlcnkoXG5cdFx0XHQobmFtZSkgPT4gdHlwZW9mIGdsb2JhbC5PYmplY3RbbmFtZV0gPT09ICdmdW5jdGlvbidcblx0XHQpO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG4vKiBPYnNlcnZhYmxlICovXG5hZGQoJ2VzLW9ic2VydmFibGUnLCAoKSA9PiB0eXBlb2YgZ2xvYmFsLk9ic2VydmFibGUgIT09ICd1bmRlZmluZWQnLCB0cnVlKTtcblxuLyogUHJvbWlzZSAqL1xuYWRkKCdlczYtcHJvbWlzZScsICgpID0+IHR5cGVvZiBnbG9iYWwuUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzKCdlczYtc3ltYm9sJyksIHRydWUpO1xuXG4vKiBTZXQgKi9cbmFkZChcblx0J2VzNi1zZXQnLFxuXHQoKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBnbG9iYWwuU2V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvKiBJRTExIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgYXJlIG1pc3NpbmcgY3JpdGljYWwgRVM2IFNldCBmdW5jdGlvbmFsaXR5ICovXG5cdFx0XHRjb25zdCBzZXQgPSBuZXcgZ2xvYmFsLlNldChbMV0pO1xuXHRcdFx0cmV0dXJuIHNldC5oYXMoMSkgJiYgJ2tleXMnIGluIHNldCAmJiB0eXBlb2Ygc2V0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgaGFzKCdlczYtc3ltYm9sJyk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuLyogU3RyaW5nICovXG5hZGQoXG5cdCdlczYtc3RyaW5nJyxcblx0KCkgPT4ge1xuXHRcdHJldHVybiAoXG5cdFx0XHRbXG5cdFx0XHRcdC8qIHN0YXRpYyBtZXRob2RzICovXG5cdFx0XHRcdCdmcm9tQ29kZVBvaW50J1xuXHRcdFx0XS5ldmVyeSgoa2V5KSA9PiB0eXBlb2YgZ2xvYmFsLlN0cmluZ1trZXldID09PSAnZnVuY3Rpb24nKSAmJlxuXHRcdFx0W1xuXHRcdFx0XHQvKiBpbnN0YW5jZSBtZXRob2RzICovXG5cdFx0XHRcdCdjb2RlUG9pbnRBdCcsXG5cdFx0XHRcdCdub3JtYWxpemUnLFxuXHRcdFx0XHQncmVwZWF0Jyxcblx0XHRcdFx0J3N0YXJ0c1dpdGgnLFxuXHRcdFx0XHQnZW5kc1dpdGgnLFxuXHRcdFx0XHQnaW5jbHVkZXMnXG5cdFx0XHRdLmV2ZXJ5KChrZXkpID0+IHR5cGVvZiBnbG9iYWwuU3RyaW5nLnByb3RvdHlwZVtrZXldID09PSAnZnVuY3Rpb24nKVxuXHRcdCk7XG5cdH0sXG5cdHRydWVcbik7XG5cbmFkZChcblx0J2VzNi1zdHJpbmctcmF3Jyxcblx0KCkgPT4ge1xuXHRcdGZ1bmN0aW9uIGdldENhbGxTaXRlKGNhbGxTaXRlOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uc3Vic3RpdHV0aW9uczogYW55W10pIHtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IFsuLi5jYWxsU2l0ZV07XG5cdFx0XHQocmVzdWx0IGFzIGFueSkucmF3ID0gY2FsbFNpdGUucmF3O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0XHRpZiAoJ3JhdycgaW4gZ2xvYmFsLlN0cmluZykge1xuXHRcdFx0bGV0IGIgPSAxO1xuXHRcdFx0bGV0IGNhbGxTaXRlID0gZ2V0Q2FsbFNpdGVgYVxcbiR7Yn1gO1xuXG5cdFx0XHQoY2FsbFNpdGUgYXMgYW55KS5yYXcgPSBbJ2FcXFxcbiddO1xuXHRcdFx0Y29uc3Qgc3VwcG9ydHNUcnVuYyA9IGdsb2JhbC5TdHJpbmcucmF3KGNhbGxTaXRlLCA0MikgPT09ICdhOlxcXFxuJztcblxuXHRcdFx0cmV0dXJuIHN1cHBvcnRzVHJ1bmM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG5hZGQoXG5cdCdlczIwMTctc3RyaW5nJyxcblx0KCkgPT4ge1xuXHRcdHJldHVybiBbJ3BhZFN0YXJ0JywgJ3BhZEVuZCddLmV2ZXJ5KChrZXkpID0+IHR5cGVvZiBnbG9iYWwuU3RyaW5nLnByb3RvdHlwZVtrZXldID09PSAnZnVuY3Rpb24nKTtcblx0fSxcblx0dHJ1ZVxuKTtcblxuLyogU3ltYm9sICovXG5hZGQoJ2VzNi1zeW1ib2wnLCAoKSA9PiB0eXBlb2YgZ2xvYmFsLlN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09PSAnc3ltYm9sJywgdHJ1ZSk7XG5cbi8qIFdlYWtNYXAgKi9cbmFkZChcblx0J2VzNi13ZWFrbWFwJyxcblx0KCkgPT4ge1xuXHRcdGlmICh0eXBlb2YgZ2xvYmFsLldlYWtNYXAgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHQvKiBJRTExIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgYXJlIG1pc3NpbmcgY3JpdGljYWwgRVM2IE1hcCBmdW5jdGlvbmFsaXR5ICovXG5cdFx0XHRjb25zdCBrZXkxID0ge307XG5cdFx0XHRjb25zdCBrZXkyID0ge307XG5cdFx0XHRjb25zdCBtYXAgPSBuZXcgZ2xvYmFsLldlYWtNYXAoW1trZXkxLCAxXV0pO1xuXHRcdFx0T2JqZWN0LmZyZWV6ZShrZXkxKTtcblx0XHRcdHJldHVybiBtYXAuZ2V0KGtleTEpID09PSAxICYmIG1hcC5zZXQoa2V5MiwgMikgPT09IG1hcCAmJiBoYXMoJ2VzNi1zeW1ib2wnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHR0cnVlXG4pO1xuXG4vKiBNaXNjZWxsYW5lb3VzIGZlYXR1cmVzICovXG5hZGQoJ21pY3JvdGFza3MnLCAoKSA9PiBoYXMoJ2VzNi1wcm9taXNlJykgfHwgaGFzKCdob3N0LW5vZGUnKSB8fCBoYXMoJ2RvbS1tdXRhdGlvbm9ic2VydmVyJyksIHRydWUpO1xuYWRkKFxuXHQncG9zdG1lc3NhZ2UnLFxuXHQoKSA9PiB7XG5cdFx0Ly8gSWYgd2luZG93IGlzIHVuZGVmaW5lZCwgYW5kIHdlIGhhdmUgcG9zdE1lc3NhZ2UsIGl0IHByb2JhYmx5IG1lYW5zIHdlJ3JlIGluIGEgd2ViIHdvcmtlci4gV2ViIHdvcmtlcnMgaGF2ZVxuXHRcdC8vIHBvc3QgbWVzc2FnZSBidXQgaXQgZG9lc24ndCB3b3JrIGhvdyB3ZSBleHBlY3QgaXQgdG8sIHNvIGl0J3MgYmVzdCBqdXN0IHRvIHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cblx0XHRyZXR1cm4gdHlwZW9mIGdsb2JhbC53aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbic7XG5cdH0sXG5cdHRydWVcbik7XG5hZGQoJ3JhZicsICgpID0+IHR5cGVvZiBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nLCB0cnVlKTtcbmFkZCgnc2V0aW1tZWRpYXRlJywgKCkgPT4gdHlwZW9mIGdsb2JhbC5zZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnLCB0cnVlKTtcblxuLyogRE9NIEZlYXR1cmVzICovXG5cbmFkZChcblx0J2RvbS1tdXRhdGlvbm9ic2VydmVyJyxcblx0KCkgPT4ge1xuXHRcdGlmIChoYXMoJ2hvc3QtYnJvd3NlcicpICYmIEJvb2xlYW4oZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIpKSB7XG5cdFx0XHQvLyBJRTExIGhhcyBhbiB1bnJlbGlhYmxlIE11dGF0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24gd2hlcmUgc2V0UHJvcGVydHkoKSBkb2VzIG5vdFxuXHRcdFx0Ly8gZ2VuZXJhdGUgYSBtdXRhdGlvbiBldmVudCwgb2JzZXJ2ZXJzIGNhbiBjcmFzaCwgYW5kIHRoZSBxdWV1ZSBkb2VzIG5vdCBkcmFpblxuXHRcdFx0Ly8gcmVsaWFibHkuIFRoZSBmb2xsb3dpbmcgZmVhdHVyZSB0ZXN0IHdhcyBhZGFwdGVkIGZyb21cblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3QxMGtvLzRhY2ViOGM3MTY4MWZkYjI3NWUzM2VmZTVlNTc2YjE0XG5cdFx0XHRjb25zdCBleGFtcGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHQvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZSAqL1xuXHRcdFx0Y29uc3QgSG9zdE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblx0XHRcdGNvbnN0IG9ic2VydmVyID0gbmV3IEhvc3RNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge30pO1xuXHRcdFx0b2JzZXJ2ZXIub2JzZXJ2ZShleGFtcGxlLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cblx0XHRcdGV4YW1wbGUuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnYmxvY2snKTtcblxuXHRcdFx0cmV0dXJuIEJvb2xlYW4ob2JzZXJ2ZXIudGFrZVJlY29yZHMoKS5sZW5ndGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdHRydWVcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gaGFzLnRzIiwiaW1wb3J0IHsgSGFuZGxlIH0gZnJvbSAnQGRvam8vaW50ZXJmYWNlcy9jb3JlJztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ0Bkb2pvL3NoaW0vb2JqZWN0JztcblxuZXhwb3J0IHsgYXNzaWduIH0gZnJvbSAnQGRvam8vc2hpbS9vYmplY3QnO1xuXG5jb25zdCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRoYXQgZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgY29lcmNlZCB0byBPYmplY3RcbiAqIHRvIHdlZWQgb3V0IGhvc3Qgb2JqZWN0cyB0aGF0IGRvIG5vdCBkZXJpdmUgZnJvbSBPYmplY3QuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBkZWVwIGNvcHkgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIE5vdGU6IEluIEVTNiBpdCBpcyBwb3NzaWJsZSB0byBtb2RpZnkgYW4gb2JqZWN0J3MgU3ltYm9sLnRvU3RyaW5nVGFnIHByb3BlcnR5LCB3aGljaCB3aWxsXG4gKiBjaGFuZ2UgdGhlIHZhbHVlIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AuIFRoaXMgaXMgYSByYXJlIGVkZ2UgY2FzZSB0aGF0IGlzIGRpZmZpY3VsdCB0byBoYW5kbGUsXG4gKiBzbyBpdCBpcyBub3QgaGFuZGxlZCBoZXJlLlxuICogQHBhcmFtICB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm4gICAgICAgSWYgdGhlIHZhbHVlIGlzIGNvZXJjaWJsZSBpbnRvIGFuIE9iamVjdFxuICovXG5mdW5jdGlvbiBzaG91bGREZWVwQ29weU9iamVjdCh2YWx1ZTogYW55KTogdmFsdWUgaXMgT2JqZWN0IHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBjb3B5QXJyYXk8VD4oYXJyYXk6IFRbXSwgaW5oZXJpdGVkOiBib29sZWFuKTogVFtdIHtcblx0cmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbTogVCk6IFQge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG5cdFx0XHRyZXR1cm4gPGFueT4gY29weUFycmF5KDxhbnk+IGl0ZW0sIGluaGVyaXRlZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFzaG91bGREZWVwQ29weU9iamVjdChpdGVtKSA/XG5cdFx0XHRpdGVtIDpcblx0XHRcdF9taXhpbih7XG5cdFx0XHRcdGRlZXA6IHRydWUsXG5cdFx0XHRcdGluaGVyaXRlZDogaW5oZXJpdGVkLFxuXHRcdFx0XHRzb3VyY2VzOiA8QXJyYXk8VD4+IFsgaXRlbSBdLFxuXHRcdFx0XHR0YXJnZXQ6IDxUPiB7fVxuXHRcdFx0fSk7XG5cdH0pO1xufVxuXG5pbnRlcmZhY2UgTWl4aW5BcmdzPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9PiB7XG5cdGRlZXA6IGJvb2xlYW47XG5cdGluaGVyaXRlZDogYm9vbGVhbjtcblx0c291cmNlczogKFUgfCBudWxsIHwgdW5kZWZpbmVkKVtdO1xuXHR0YXJnZXQ6IFQ7XG5cdGNvcGllZD86IGFueVtdO1xufVxuXG5mdW5jdGlvbiBfbWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30+KGt3QXJnczogTWl4aW5BcmdzPFQsIFU+KTogVCZVIHtcblx0Y29uc3QgZGVlcCA9IGt3QXJncy5kZWVwO1xuXHRjb25zdCBpbmhlcml0ZWQgPSBrd0FyZ3MuaW5oZXJpdGVkO1xuXHRjb25zdCB0YXJnZXQ6IGFueSA9IGt3QXJncy50YXJnZXQ7XG5cdGNvbnN0IGNvcGllZCA9IGt3QXJncy5jb3BpZWQgfHwgW107XG5cdGNvbnN0IGNvcGllZENsb25lID0gWyAuLi5jb3BpZWQgXTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGt3QXJncy5zb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qgc291cmNlID0ga3dBcmdzLnNvdXJjZXNbaV07XG5cblx0XHRpZiAoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Zm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRsZXQgdmFsdWU6IGFueSA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRcdGlmIChjb3BpZWRDbG9uZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkZWVwKSB7XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGNvcHlBcnJheSh2YWx1ZSwgaW5oZXJpdGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoc2hvdWxkRGVlcENvcHlPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXRWYWx1ZTogYW55ID0gdGFyZ2V0W2tleV0gfHwge307XG5cdFx0XHRcdFx0XHRjb3BpZWQucHVzaChzb3VyY2UpO1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBfbWl4aW4oe1xuXHRcdFx0XHRcdFx0XHRkZWVwOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRpbmhlcml0ZWQ6IGluaGVyaXRlZCxcblx0XHRcdFx0XHRcdFx0c291cmNlczogWyB2YWx1ZSBdLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQ6IHRhcmdldFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRjb3BpZWRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiA8VCZVPiB0YXJnZXQ7XG59XG5cbmludGVyZmFjZSBPYmplY3RBc3NpZ25Db25zdHJ1Y3RvciBleHRlbmRzIE9iamVjdENvbnN0cnVjdG9yIHtcblx0YXNzaWduPFQsIFU+KHRhcmdldDogVCwgc291cmNlOiBVKTogVCAmIFU7XG5cdGFzc2lnbjxULCBVMSwgVTI+KHRhcmdldDogVCwgc291cmNlMTogVTEsIHNvdXJjZTI6IFUyKTogVCAmIFUxICYgVTI7XG5cdGFzc2lnbjxULCBVMSwgVTIsIFUzPih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUxLCBzb3VyY2UyOiBVMiwgc291cmNlMzogVTMpOiBUICYgVTEgJiBVMiAmIFUzO1xuXHRhc3NpZ24odGFyZ2V0OiBhbnksIC4uLnNvdXJjZXM6IGFueVtdKTogYW55O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSwgYW5kIGNvcGllcyBhbGwgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZiBvbmUgb3IgbW9yZVxuICogc291cmNlIG9iamVjdHMgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcHJvdG90eXBlIFRoZSBwcm90b3R5cGUgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCBmcm9tXG4gKiBAcGFyYW0gbWl4aW5zIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB3aG9zZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdFxuICogQHJldHVybiBUaGUgbmV3IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30sIFcgZXh0ZW5kcyB7fSwgWCBleHRlbmRzIHt9LCBZIGV4dGVuZHMge30sIFogZXh0ZW5kcyB7fT4ocHJvdG90eXBlOiBULCBtaXhpbjE6IFUsIG1peGluMjogViwgbWl4aW4zOiBXLCBtaXhpbjQ6IFgsIG1peGluNTogWSwgbWl4aW42OiBaKTogVCAmIFUgJiBWICYgVyAmIFggJiBZICYgWjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30sIFkgZXh0ZW5kcyB7fT4ocHJvdG90eXBlOiBULCBtaXhpbjE6IFUsIG1peGluMjogViwgbWl4aW4zOiBXLCBtaXhpbjQ6IFgsIG1peGluNTogWSk6IFQgJiBVICYgViAmIFcgJiBYICYgWTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30+KHByb3RvdHlwZTogVCwgbWl4aW4xOiBVLCBtaXhpbjI6IFYsIG1peGluMzogVywgbWl4aW40OiBYKTogVCAmIFUgJiBWICYgVyAmIFg7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30sIFcgZXh0ZW5kcyB7fT4ocHJvdG90eXBlOiBULCBtaXhpbjE6IFUsIG1peGluMjogViwgbWl4aW4zOiBXKTogVCAmIFUgJiBWICYgVztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fT4ocHJvdG90eXBlOiBULCBtaXhpbjE6IFUsIG1peGluMjogVik6IFQgJiBVICYgVjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30+KHByb3RvdHlwZTogVCwgbWl4aW46IFUpOiBUICYgVTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIHt9Pihwcm90b3R5cGU6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGU6IGFueSwgLi4ubWl4aW5zOiBhbnlbXSk6IGFueSB7XG5cdGlmICghbWl4aW5zLmxlbmd0aCkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdsYW5nLmNyZWF0ZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgbWl4aW4gb2JqZWN0LicpO1xuXHR9XG5cblx0Y29uc3QgYXJncyA9IG1peGlucy5zbGljZSgpO1xuXHRhcmdzLnVuc2hpZnQoT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpKTtcblxuXHRyZXR1cm4gYXNzaWduLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGFsbCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIHRoZSB0YXJnZXQgb2JqZWN0LFxuICogcmVjdXJzaXZlbHkgY29weWluZyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGFycmF5cyBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gcmVjZWl2ZSB2YWx1ZXMgZnJvbSBzb3VyY2Ugb2JqZWN0c1xuICogQHBhcmFtIHNvdXJjZXMgQW55IG51bWJlciBvZiBvYmplY3RzIHdob3NlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gVGhlIG1vZGlmaWVkIHRhcmdldCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ248VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30sIFkgZXh0ZW5kcyB7fSwgWiBleHRlbmRzIHt9Pih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUsIHNvdXJjZTI6IFYsIHNvdXJjZTM6IFcsIHNvdXJjZTQ6IFgsIHNvdXJjZTU6IFksIHNvdXJjZTY6IFopOiBUICYgVSAmIFYgJiBXICYgWCAmIFkgJiBaO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ248VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30sIFkgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWLCBzb3VyY2UzOiBXLCBzb3VyY2U0OiBYLCBzb3VyY2U1OiBZKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ248VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVywgc291cmNlNDogWCk6IFQgJiBVICYgViAmIFcgJiBYO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ248VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9Pih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUsIHNvdXJjZTI6IFYsIHNvdXJjZTM6IFcpOiBUICYgVSAmIFYgJiBXO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ248VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWKTogVCAmIFUgJiBWO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ248VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlOiBVKTogVCAmIFU7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQ6IGFueSwgLi4uc291cmNlczogYW55W10pOiBhbnkge1xuXHRyZXR1cm4gX21peGluKHtcblx0XHRkZWVwOiB0cnVlLFxuXHRcdGluaGVyaXRlZDogZmFsc2UsXG5cdFx0c291cmNlczogc291cmNlcyxcblx0XHR0YXJnZXQ6IHRhcmdldFxuXHR9KTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBhbGwgZW51bWVyYWJsZSAob3duIG9yIGluaGVyaXRlZCkgcHJvcGVydGllcyBvZiBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAqIHRhcmdldCBvYmplY3QsIHJlY3Vyc2l2ZWx5IGNvcHlpbmcgYWxsIG5lc3RlZCBvYmplY3RzIGFuZCBhcnJheXMgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIHJlY2VpdmUgdmFsdWVzIGZyb20gc291cmNlIG9iamVjdHNcbiAqIEBwYXJhbSBzb3VyY2VzIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB3aG9zZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gVGhlIG1vZGlmaWVkIHRhcmdldCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fSwgWSBleHRlbmRzIHt9LCBaIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVywgc291cmNlNDogWCwgc291cmNlNTogWSwgc291cmNlNjogWik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gZGVlcE1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30sIFcgZXh0ZW5kcyB7fSwgWCBleHRlbmRzIHt9LCBZIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVywgc291cmNlNDogWCwgc291cmNlNTogWSk6IFQgJiBVICYgViAmIFcgJiBYICYgWTtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVywgc291cmNlNDogWCk6IFQgJiBVICYgViAmIFcgJiBYO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVyk6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gZGVlcE1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogVik6IFQgJiBVICYgVjtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlOiBVKTogVCAmIFU7XG5leHBvcnQgZnVuY3Rpb24gZGVlcE1peGluKHRhcmdldDogYW55LCAuLi5zb3VyY2VzOiBhbnlbXSk6IGFueSB7XG5cdHJldHVybiBfbWl4aW4oe1xuXHRcdGRlZXA6IHRydWUsXG5cdFx0aW5oZXJpdGVkOiB0cnVlLFxuXHRcdHNvdXJjZXM6IHNvdXJjZXMsXG5cdFx0dGFyZ2V0OiB0YXJnZXRcblx0fSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdXNpbmcgdGhlIHByb3ZpZGVkIHNvdXJjZSdzIHByb3RvdHlwZSBhcyB0aGUgcHJvdG90eXBlIGZvciB0aGUgbmV3IG9iamVjdCwgYW5kIHRoZW5cbiAqIGRlZXAgY29waWVzIHRoZSBwcm92aWRlZCBzb3VyY2UncyB2YWx1ZXMgaW50byB0aGUgbmV3IHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gc291cmNlIFRoZSBvYmplY3QgdG8gZHVwbGljYXRlXG4gKiBAcmV0dXJuIFRoZSBuZXcgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkdXBsaWNhdGU8VCBleHRlbmRzIHt9Pihzb3VyY2U6IFQpOiBUIHtcblx0Y29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG5cblx0cmV0dXJuIGRlZXBNaXhpbih0YXJnZXQsIHNvdXJjZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBhIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBiIFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlcyBhcmUgdGhlIHNhbWU7IGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJZGVudGljYWwoYTogYW55LCBiOiBhbnkpOiBib29sZWFuIHtcblx0cmV0dXJuIGEgPT09IGIgfHxcblx0XHQvKiBib3RoIHZhbHVlcyBhcmUgTmFOICovXG5cdFx0KGEgIT09IGEgJiYgYiAhPT0gYik7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYmluZHMgYSBtZXRob2QgdG8gdGhlIHNwZWNpZmllZCBvYmplY3QgYXQgcnVudGltZS4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgLCBidXQgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIGl0IHRha2VzIHRoZSBuYW1lIG9mIGEgbWV0aG9kIG9uIGFuIG9iamVjdC5cbiAqIEFzIGEgcmVzdWx0LCB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgYGxhdGVCaW5kYCB3aWxsIGFsd2F5cyBjYWxsIHRoZSBmdW5jdGlvbiBjdXJyZW50bHkgYXNzaWduZWQgdG9cbiAqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgb24gdGhlIG9iamVjdCBhcyBvZiB0aGUgbW9tZW50IHRoZSBmdW5jdGlvbiBpdCByZXR1cm5zIGlzIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gbWV0aG9kIFRoZSBuYW1lIG9mIHRoZSBtZXRob2Qgb24gdGhlIGNvbnRleHQgb2JqZWN0IHRvIGJpbmQgdG8gaXRzZWxmXG4gKiBAcGFyYW0gc3VwcGxpZWRBcmdzIEFuIG9wdGlvbmFsIGFycmF5IG9mIHZhbHVlcyB0byBwcmVwZW5kIHRvIHRoZSBgaW5zdGFuY2VbbWV0aG9kXWAgYXJndW1lbnRzIGxpc3RcbiAqIEByZXR1cm4gVGhlIGJvdW5kIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXRlQmluZChpbnN0YW5jZToge30sIG1ldGhvZDogc3RyaW5nLCAuLi5zdXBwbGllZEFyZ3M6IGFueVtdKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkge1xuXHRyZXR1cm4gc3VwcGxpZWRBcmdzLmxlbmd0aCA/XG5cdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc3QgYXJnczogYW55W10gPSBhcmd1bWVudHMubGVuZ3RoID8gc3VwcGxpZWRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogc3VwcGxpZWRBcmdzO1xuXG5cdFx0XHQvLyBUUzcwMTdcblx0XHRcdHJldHVybiAoPGFueT4gaW5zdGFuY2UpW21ldGhvZF0uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFRTNzAxN1xuXHRcdFx0cmV0dXJuICg8YW55PiBpbnN0YW5jZSlbbWV0aG9kXS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblx0XHR9O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGFsbCBlbnVtZXJhYmxlIChvd24gb3IgaW5oZXJpdGVkKSBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIFRoZSBtb2RpZmllZCB0YXJnZXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30sIFggZXh0ZW5kcyB7fSwgWSBleHRlbmRzIHt9LCBaIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVywgc291cmNlNDogWCwgc291cmNlNTogWSwgc291cmNlNjogWik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gbWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fSwgVyBleHRlbmRzIHt9LCBYIGV4dGVuZHMge30sIFkgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWLCBzb3VyY2UzOiBXLCBzb3VyY2U0OiBYLCBzb3VyY2U1OiBZKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9LCBWIGV4dGVuZHMge30sIFcgZXh0ZW5kcyB7fSwgWCBleHRlbmRzIHt9Pih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUsIHNvdXJjZTI6IFYsIHNvdXJjZTM6IFcsIHNvdXJjZTQ6IFgpOiBUICYgVSAmIFYgJiBXICYgWDtcbmV4cG9ydCBmdW5jdGlvbiBtaXhpbjxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyB7fSwgViBleHRlbmRzIHt9LCBXIGV4dGVuZHMge30+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogViwgc291cmNlMzogVyk6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gbWl4aW48VCBleHRlbmRzIHt9LCBVIGV4dGVuZHMge30sIFYgZXh0ZW5kcyB7fT4odGFyZ2V0OiBULCBzb3VyY2UxOiBVLCBzb3VyY2UyOiBWKTogVCAmIFUgJiBWO1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluPFQgZXh0ZW5kcyB7fSwgVSBleHRlbmRzIHt9Pih0YXJnZXQ6IFQsIHNvdXJjZTogVSk6IFQgJiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluKHRhcmdldDogYW55LCAuLi5zb3VyY2VzOiBhbnlbXSk6IGFueSB7XG5cdHJldHVybiBfbWl4aW4oe1xuXHRcdGRlZXA6IGZhbHNlLFxuXHRcdGluaGVyaXRlZDogdHJ1ZSxcblx0XHRzb3VyY2VzOiBzb3VyY2VzLFxuXHRcdHRhcmdldDogdGFyZ2V0XG5cdH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMgcHJlcGVuZGVkIHRvIGl0cyBhcmd1bWVudCBsaXN0LlxuICogTGlrZSBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgLCBidXQgZG9lcyBub3QgYWx0ZXIgZXhlY3V0aW9uIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHRhcmdldEZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGJvdW5kXG4gKiBAcGFyYW0gc3VwcGxpZWRBcmdzIEFuIG9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRoZSBgdGFyZ2V0RnVuY3Rpb25gIGFyZ3VtZW50cyBsaXN0XG4gKiBAcmV0dXJuIFRoZSBib3VuZCBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbCh0YXJnZXRGdW5jdGlvbjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIC4uLnN1cHBsaWVkQXJnczogYW55W10pOiAoLi4uYXJnczogYW55W10pID0+IGFueSB7XG5cdHJldHVybiBmdW5jdGlvbiAodGhpczogYW55KSB7XG5cdFx0Y29uc3QgYXJnczogYW55W10gPSBhcmd1bWVudHMubGVuZ3RoID8gc3VwcGxpZWRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogc3VwcGxpZWRBcmdzO1xuXG5cdFx0cmV0dXJuIHRhcmdldEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBkZXN0cm95IG1ldGhvZCB0aGF0LCB3aGVuIGNhbGxlZCwgY2FsbHMgdGhlIHBhc3NlZC1pbiBkZXN0cnVjdG9yLlxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBwcm92aWRlIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGNyZWF0aW5nIFwicmVtb3ZlXCIgLyBcImRlc3Ryb3lcIiBoYW5kbGVycyBmb3JcbiAqIGV2ZW50IGxpc3RlbmVycywgdGltZXJzLCBldGMuXG4gKlxuICogQHBhcmFtIGRlc3RydWN0b3IgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGhhbmRsZSdzIGBkZXN0cm95YCBtZXRob2QgaXMgaW52b2tlZFxuICogQHJldHVybiBUaGUgaGFuZGxlIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFuZGxlKGRlc3RydWN0b3I6ICgpID0+IHZvaWQpOiBIYW5kbGUge1xuXHRyZXR1cm4ge1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICh0aGlzOiBIYW5kbGUpIHtcblx0XHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0ZGVzdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlc3Ryb3kgbXVsdGlwbGUgaGFuZGxlcyBzaW11bHRhbmVvdXNseS5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlcyBBbiBhcnJheSBvZiBoYW5kbGVzIHdpdGggYGRlc3Ryb3lgIG1ldGhvZHNcbiAqIEByZXR1cm4gVGhlIGhhbmRsZSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBvc2l0ZUhhbmRsZSguLi5oYW5kbGVzOiBIYW5kbGVbXSk6IEhhbmRsZSB7XG5cdHJldHVybiBjcmVhdGVIYW5kbGUoZnVuY3Rpb24gKCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFuZGxlc1tpXS5kZXN0cm95KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsYW5nLnRzIiwiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSB2YWx1ZSBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gKlxuICogQHBhcmFtIHZhbHVlICAgICAgICBUaGUgdmFsdWUgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igc2hvdWxkIGJlIHNldCB0b1xuICogQHBhcmFtIGVudW1lcmFibGUgICBJZiB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGVudW1iZXJhYmxlLCBkZWZhdWx0cyB0byBmYWxzZVxuICogQHBhcmFtIHdyaXRhYmxlICAgICBJZiB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHdyaXRhYmxlLCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcGFyYW0gY29uZmlndXJhYmxlIElmIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uZmlndXJhYmxlLCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuICAgICAgICAgICAgIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVEZXNjcmlwdG9yPFQ+KFxuXHR2YWx1ZTogVCxcblx0ZW51bWVyYWJsZTogYm9vbGVhbiA9IGZhbHNlLFxuXHR3cml0YWJsZTogYm9vbGVhbiA9IHRydWUsXG5cdGNvbmZpZ3VyYWJsZTogYm9vbGVhbiA9IHRydWVcbik6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPFQ+IHtcblx0cmV0dXJuIHtcblx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0ZW51bWVyYWJsZTogZW51bWVyYWJsZSxcblx0XHR3cml0YWJsZTogd3JpdGFibGUsXG5cdFx0Y29uZmlndXJhYmxlOiBjb25maWd1cmFibGVcblx0fTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB3aGljaCB3cmFwcyBhIGZ1bmN0aW9uIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBiZWNvbWVzIHRoZSBzY29wZVxuICogb2YgdGhlIGNhbGxcbiAqXG4gKiBAcGFyYW0gbmF0aXZlRnVuY3Rpb24gVGhlIHNvdXJjZSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTmF0aXZlPFQsIFUsIFI+KG5hdGl2ZUZ1bmN0aW9uOiAoYXJnMTogVSkgPT4gUik6ICh0YXJnZXQ6IFQsIGFyZzE6IFUpID0+IFI7XG5leHBvcnQgZnVuY3Rpb24gd3JhcE5hdGl2ZTxULCBVLCBWLCBSPihuYXRpdmVGdW5jdGlvbjogKGFyZzE6IFUsIGFyZzI6IFYpID0+IFIpOiAodGFyZ2V0OiBULCBhcmcxOiBVLCBhcmcyOiBWKSA9PiBSO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOYXRpdmU8VCwgVSwgViwgVywgUj4oXG5cdG5hdGl2ZUZ1bmN0aW9uOiAoYXJnMTogVSwgYXJnMjogViwgYXJnMzogVykgPT4gUlxuKTogKHRhcmdldDogVCwgYXJnMTogVSwgYXJnMjogViwgYXJnMzogVykgPT4gUjtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTmF0aXZlPFQsIFUsIFYsIFcsIFgsIFI+KFxuXHRuYXRpdmVGdW5jdGlvbjogKGFyZzE6IFUsIGFyZzI6IFYsIGFyZzM6IFcpID0+IFJcbik6ICh0YXJnZXQ6IFQsIGFyZzE6IFUsIGFyZzI6IFYsIGFyZzM6IFcpID0+IFI7XG5leHBvcnQgZnVuY3Rpb24gd3JhcE5hdGl2ZTxULCBVLCBWLCBXLCBYLCBZLCBSPihcblx0bmF0aXZlRnVuY3Rpb246IChhcmcxOiBVLCBhcmcyOiBWLCBhcmczOiBXLCBhcmc0OiBZKSA9PiBSXG4pOiAodGFyZ2V0OiBULCBhcmcxOiBVLCBhcmcyOiBWLCBhcmczOiBXLCBhcmc0OiBZKSA9PiBSO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOYXRpdmUobmF0aXZlRnVuY3Rpb246ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KTogKHRhcmdldDogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55IHtcblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCAuLi5hcmdzOiBhbnlbXSk6IGFueSB7XG5cdFx0cmV0dXJuIG5hdGl2ZUZ1bmN0aW9uLmFwcGx5KHRhcmdldCwgYXJncyk7XG5cdH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdXRpbC50cyIsIi8qKlxuICogUmV0dXJucyBhIHY0IGNvbXBsaWFudCBVVUlELlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV1aWQoKTogc3RyaW5nIHtcblx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG5cdFx0cmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHR9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB1dWlkLnRzIiwiLy8gcmVxdWlyZWQgZm9yIEdsb2JhbGl6ZS9DbGRyIHRvIHByb3Blcmx5IHJlc29sdmUgbG9jYWxlcyBpbiB0aGUgYnJvd3Nlci5cbmltcG9ydCAnY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkJztcbmltcG9ydCBQcm9taXNlIGZyb20gJ0Bkb2pvL3NoaW0vUHJvbWlzZSc7XG5pbXBvcnQgKiBhcyBHbG9iYWxpemUgZnJvbSAnZ2xvYmFsaXplJztcbmltcG9ydCBzdXBwb3J0ZWRMb2NhbGVzIGZyb20gJy4vbG9jYWxlcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUxvY2FsZXMsIHZhbGlkYXRlTG9jYWxlIH0gZnJvbSAnLi4vdXRpbC9tYWluJztcblxuZXhwb3J0IGludGVyZmFjZSBDbGRyRGF0YSB7XG5cdG1haW4/OiBMb2NhbGVEYXRhO1xuXHRzdXBwbGVtZW50YWw/OiBhbnk7XG59XG5cbmV4cG9ydCB0eXBlIENsZHJHcm91cCA9ICdtYWluJyB8ICdzdXBwbGVtZW50YWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsZURhdGEge1xuXHRbbG9jYWxlOiBzdHJpbmddOiBhbnk7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbCByZXF1aXJlZCBDTERSIHBhY2thZ2VzIGZvciBhbiBpbmRpdmlkdWFsIGxvY2FsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG1haW5QYWNrYWdlcyA9IE9iamVjdC5mcmVlemUoW1xuXHQnZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbicsXG5cdCdkYXRlcy9maWVsZHMnLFxuXHQnZGF0ZXMvdGltZVpvbmVOYW1lcycsXG5cdCdudW1iZXJzJyxcblx0J251bWJlcnMvY3VycmVuY2llcycsXG5cdCd1bml0cydcbl0pO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgcmVxdWlyZWQgQ0xEUiBzdXBwbGVtZW50IHBhY2thZ2VzLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcGxlbWVudGFsUGFja2FnZXMgPSBPYmplY3QuZnJlZXplKFtcblx0J2N1cnJlbmN5RGF0YScsXG5cdCdsaWtlbHlTdWJ0YWdzJyxcblx0J251bWJlcmluZ1N5c3RlbXMnLFxuXHQncGx1cmFscy10eXBlLWNhcmRpbmFsJyxcblx0J3BsdXJhbHMtdHlwZS1vcmRpbmFsJyxcblx0J3RpbWVEYXRhJyxcblx0J3dlZWtEYXRhJ1xuXSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEEgc2ltcGxlIG1hcCBjb250YWluaW5nIGJvb2xlYW4gZmxhZ3MgaW5kaWNhdGluZyB3aGV0aGVyIGEgcGFydGljdWxhciBDTERSIHBhY2thZ2UgaGFzIGJlZW4gbG9hZGVkLlxuICovXG5jb25zdCBsb2FkQ2FjaGUgPSB7XG5cdG1haW46IE9iamVjdC5jcmVhdGUobnVsbCksXG5cdHN1cHBsZW1lbnRhbDogZ2VuZXJhdGVTdXBwbGVtZW50YWxDYWNoZSgpXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBHZW5lcmF0ZSB0aGUgbG9jYWxlLXNwZWNpZmljIGRhdGEgY2FjaGUgZnJvbSBhIGxpc3Qgb2Yga2V5cy4gTmVzdGVkIG9iamVjdHMgd2lsbCBiZSBnZW5lcmF0ZWQgZnJvbVxuICogc2xhc2gtc2VwYXJhdGVkIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIGNhY2hlXG4gKiBBbiBlbXB0eSBsb2NhbGUgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBrZXlzXG4gKiBUaGUgbGlzdCBvZiBrZXlzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUxvY2FsZUNhY2hlKGNhY2hlOiBhbnksIGtleXM6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuXHRyZXR1cm4ga2V5cy5yZWR1Y2UoKHRyZWU6IGFueSwga2V5OiBzdHJpbmcpID0+IHtcblx0XHRjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLycpO1xuXG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dHJlZVtrZXldID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJlZTtcblx0XHR9XG5cblx0XHRwYXJ0cy5yZWR1Y2UoKHRyZWU6IGFueSwga2V5OiBzdHJpbmcsIGk6IG51bWJlcikgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiB0cmVlW2tleV0gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRyZWVba2V5XSA9IGkgPT09IHBhcnRzLmxlbmd0aCAtIDEgPyBmYWxzZSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJlZVtrZXldO1xuXHRcdH0sIHRyZWUpO1xuXG5cdFx0cmV0dXJuIHRyZWU7XG5cdH0sIGNhY2hlKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogR2VuZXJhdGUgdGhlIHN1cHBsZW1lbnRhbCBkYXRhIGNhY2hlLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVN1cHBsZW1lbnRhbENhY2hlKCkge1xuXHRyZXR1cm4gc3VwcGxlbWVudGFsUGFja2FnZXMucmVkdWNlKChtYXA6IGFueSwga2V5OiBzdHJpbmcpID0+IHtcblx0XHRtYXBba2V5XSA9IGZhbHNlO1xuXHRcdHJldHVybiBtYXA7XG5cdH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWN1cnNpdmVseSBkZXRlcm1pbmUgd2hldGhlciBhIGxpc3Qgb2YgcGFja2FnZXMgaGF2ZSBiZWVuIGxvYWRlZCBmb3IgdGhlIHNwZWNpZmllZCBDTERSIGdyb3VwLlxuICpcbiAqIEBwYXJhbSBncm91cFxuICogVGhlIENMRFIgZ3JvdXAgb2JqZWN0IChlLmcuLCB0aGUgc3VwcGxlbWVudGFsIGRhdGEsIG9yIGEgc3BlY2lmaWMgbG9jYWxlIGdyb3VwKVxuICpcbiAqIEBwYXJhbSBhcmdzXG4gKiBBIGxpc3Qgb2Yga2V5cyB0byByZWN1cnNpdmVseSBjaGVjayBmcm9tIGxlZnQgdG8gcmlnaHQuIEZvciBleGFtcGxlLCBpZiBbIFwiZW5cIiwgXCJudW1iZXJzXCIgXSxcbiAqIHRoZW4gYGdyb3VwLmVuLm51bWJlcnNgIG11c3QgZXhpc3QgZm9yIHRoZSB0ZXN0IHRvIHBhc3MuXG4gKlxuICogQHJldHVyblxuICogYHRydWVgIGlmIHRoZSBkZWVwZXN0IHZhbHVlIGV4aXN0czsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTG9hZGVkRm9yR3JvdXAoZ3JvdXA6IGFueSwgYXJnczogc3RyaW5nW10pIHtcblx0cmV0dXJuIGFyZ3MuZXZlcnkoKGFyZzogc3RyaW5nKSA9PiB7XG5cdFx0Y29uc3QgbmV4dCA9IGdyb3VwW2FyZ107XG5cdFx0Z3JvdXAgPSBuZXh0O1xuXHRcdHJldHVybiBCb29sZWFuKG5leHQpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjdXJzaXZlbHkgZmxhZyBhcyBsb2FkZWQgYWxsIHJlY29nbml6ZWQga2V5cyBvbiB0aGUgcHJvdmlkZWQgQ0xEUiBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2FjaGVcbiAqIFRoZSBsb2FkIGNhY2hlIChlaXRoZXIgdGhlIGVudGlyZSBvYmplY3QsIG9yIGEgbmVzdGVkIHNlZ21lbnQgb2YgaXQpLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVEYXRhXG4gKiBUaGUgQ0xEUiBkYXRhIG9iamVjdCBiZWluZyBsb2FkZWQgKGVpdGhlciB0aGUgZW50aXJlIG9iamVjdCwgb3IgYSBuZXN0ZWQgc2VnbWVudCBvZiBpdCkuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTG9jYWxlRGF0YShjYWNoZTogYW55LCBsb2NhbGVEYXRhOiBhbnkpIHtcblx0T2JqZWN0LmtleXMobG9jYWxlRGF0YSkuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHtcblx0XHRpZiAoa2V5IGluIGNhY2hlKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGNhY2hlW2tleV07XG5cblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRjYWNoZVtrZXldID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlZ2lzdGVyTG9jYWxlRGF0YSh2YWx1ZSwgbG9jYWxlRGF0YVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBGbGFnIGFsbCBzdXBwbGllZCBDTERSIHBhY2thZ2VzIGZvciBhIHNwZWNpZmljIGxvY2FsZSBhcyBsb2FkZWQuXG4gKlxuICogQHBhcmFtIGRhdGFcbiAqIFRoZSBgbWFpbmAgbG9jYWxlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTWFpbihkYXRhPzogTG9jYWxlRGF0YSkge1xuXHRpZiAoIWRhdGEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChsb2NhbGU6IHN0cmluZykgPT4ge1xuXHRcdGlmIChzdXBwb3J0ZWRMb2NhbGVzLmluZGV4T2YobG9jYWxlKSA8IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgbG9hZGVkRGF0YSA9IGxvYWRDYWNoZS5tYWluW2xvY2FsZV07XG5cdFx0aWYgKCFsb2FkZWREYXRhKSB7XG5cdFx0XHRsb2FkZWREYXRhID0gbG9hZENhY2hlLm1haW5bbG9jYWxlXSA9IGdlbmVyYXRlTG9jYWxlQ2FjaGUoT2JqZWN0LmNyZWF0ZShudWxsKSwgbWFpblBhY2thZ2VzKTtcblx0XHR9XG5cblx0XHRyZWdpc3RlckxvY2FsZURhdGEobG9hZGVkRGF0YSwgZGF0YVtsb2NhbGVdKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEZsYWcgYWxsIHN1cHBsaWVkIENMRFIgc3VwcGxlbWVudGFsIHBhY2thZ2VzIGFzIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0gZGF0YVxuICogVGhlIHN1cHBsZW1lbnRhbCBkYXRhLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclN1cHBsZW1lbnRhbChkYXRhPzogYW55KSB7XG5cdGlmICghZGF0YSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHN1cHBsZW1lbnRhbCA9IGxvYWRDYWNoZS5zdXBwbGVtZW50YWw7XG5cdE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0aWYgKGtleSBpbiBzdXBwbGVtZW50YWwpIHtcblx0XHRcdHN1cHBsZW1lbnRhbFtrZXldID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgcGFydGljdWxhciBDTERSIHBhY2thZ2UgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIEV4YW1wbGU6IHRvIGNoZWNrIHRoYXQgYHN1cHBsZW1lbnRhbC5saWtlbHlTdWJ0YWdzYCBoYXMgYmVlbiBsb2FkZWQsIGBpc0xvYWRlZGAgd291bGQgYmUgY2FsbGVkIGFzXG4gKiBgaXNMb2FkZWQoJ3N1cHBsZW1lbnRhbCcsICdsaWtlbHlTdWJ0YWdzJylgLlxuICpcbiAqIEBwYXJhbSBncm91cE5hbWVcbiAqIFRoZSBncm91cCB0byBjaGVjazsgZWl0aGVyIFwibWFpblwiIG9yIFwic3VwcGxlbWVudGFsXCIuXG4gKlxuICogQHBhcmFtIC4uLmFyZ3NcbiAqIEFueSByZW1haW5pbmcga2V5cyBpbiB0aGUgcGF0aCB0byB0aGUgZGVzaXJlZCBwYWNrYWdlLlxuICpcbiAqIEByZXR1cm5cbiAqIGB0cnVlYCBpZiB0aGUgZGVlcGVzdCB2YWx1ZSBleGlzdHM7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2FkZWQoZ3JvdXBOYW1lOiBDbGRyR3JvdXAsIC4uLmFyZ3M6IHN0cmluZ1tdKSB7XG5cdGxldCBncm91cDogYW55ID0gbG9hZENhY2hlW2dyb3VwTmFtZV07XG5cblx0aWYgKGdyb3VwTmFtZSA9PT0gJ21haW4nICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuXHRcdGNvbnN0IGxvY2FsZSA9IGFyZ3NbMF07XG5cblx0XHRpZiAoIXZhbGlkYXRlTG9jYWxlKGxvY2FsZSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRhcmdzID0gYXJncy5zbGljZSgxKTtcblx0XHRyZXR1cm4gZ2VuZXJhdGVMb2NhbGVzKGxvY2FsZSkuc29tZSgobG9jYWxlOiBzdHJpbmcpID0+IHtcblx0XHRcdGNvbnN0IG5leHQgPSBncm91cFtsb2NhbGVdO1xuXHRcdFx0cmV0dXJuIG5leHQgPyBpc0xvYWRlZEZvckdyb3VwKG5leHQsIGFyZ3MpIDogZmFsc2U7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gaXNMb2FkZWRGb3JHcm91cChncm91cCwgYXJncyk7XG59XG5cbi8qKlxuICogTG9hZCB0aGUgc3BlY2lmaWVkIENMRFIgZGF0YSB3aXRoIHRoZSBpMThuIGVjb3N5c3RlbS5cbiAqXG4gKiBAcGFyYW0gZGF0YVxuICogQSBkYXRhIG9iamVjdCBjb250YWluaW5nIGBtYWluYCBhbmQvb3IgYHN1cHBsZW1lbnRhbGAgb2JqZWN0cyB3aXRoIENMRFIgZGF0YS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9hZENsZHJEYXRhKGRhdGE6IENsZHJEYXRhKTogUHJvbWlzZTx2b2lkPiB7XG5cdHJlZ2lzdGVyTWFpbihkYXRhLm1haW4pO1xuXHRyZWdpc3RlclN1cHBsZW1lbnRhbChkYXRhLnN1cHBsZW1lbnRhbCk7XG5cdEdsb2JhbGl6ZS5sb2FkKGRhdGEpO1xuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIGxvYWQgY2FjaGUsIGVpdGhlciB0aGUgZW50aXJlIGNhY2hlIGZvciB0aGUgc3BlY2lmaWVkIGdyb3VwLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLFxuICogYGlzTG9hZGVkYCB3aWxsIHJldHVybiBmYWxzZSBmb3Iga2V5cyB3aXRoaW4gdGhlIHNwZWNpZmllZCBncm91cChzKS5cbiAqXG4gKiBAcGFyYW0gZ3JvdXBcbiAqIEFuIG9wdGlvbmFsIGdyb3VwIG5hbWUuIElmIG5vdCBwcm92aWRlZCwgdGhlbiBib3RoIHRoZSBcIm1haW5cIiBhbmQgXCJzdXBwbGVtZW50YWxcIiBjYWNoZXMgd2lsbCBiZSBjbGVhcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoZ3JvdXA/OiBDbGRyR3JvdXApIHtcblx0aWYgKGdyb3VwICE9PSAnc3VwcGxlbWVudGFsJykge1xuXHRcdGxvYWRDYWNoZS5tYWluID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0fVxuXG5cdGlmIChncm91cCAhPT0gJ21haW4nKSB7XG5cdFx0bG9hZENhY2hlLnN1cHBsZW1lbnRhbCA9IGdlbmVyYXRlU3VwcGxlbWVudGFsQ2FjaGUoKTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxvYWQudHMiLCIvKipcbiAqIEEgbGlzdCBvZiBgY2xkci1kYXRhL21haW5gIGRpcmVjdG9yaWVzIHVzZWQgdG8gbG9hZCB0aGUgY29ycmVjdCBDTERSIGRhdGEgZm9yIGEgZ2l2ZW4gbG9jYWxlLlxuICovXG5jb25zdCBsb2NhbGVzTGlzdCA9IFtcblx0J2FmLU5BJyxcblx0J2FmJyxcblx0J2FncScsXG5cdCdhaycsXG5cdCdhbScsXG5cdCdhci1BRScsXG5cdCdhci1CSCcsXG5cdCdhci1ESicsXG5cdCdhci1EWicsXG5cdCdhci1FRycsXG5cdCdhci1FSCcsXG5cdCdhci1FUicsXG5cdCdhci1JTCcsXG5cdCdhci1JUScsXG5cdCdhci1KTycsXG5cdCdhci1LTScsXG5cdCdhci1LVycsXG5cdCdhci1MQicsXG5cdCdhci1MWScsXG5cdCdhci1NQScsXG5cdCdhci1NUicsXG5cdCdhci1PTScsXG5cdCdhci1QUycsXG5cdCdhci1RQScsXG5cdCdhci1TQScsXG5cdCdhci1TRCcsXG5cdCdhci1TTycsXG5cdCdhci1TUycsXG5cdCdhci1TWScsXG5cdCdhci1URCcsXG5cdCdhci1UTicsXG5cdCdhci1ZRScsXG5cdCdhcicsXG5cdCdhcycsXG5cdCdhc2EnLFxuXHQnYXN0Jyxcblx0J2F6LUN5cmwnLFxuXHQnYXotTGF0bicsXG5cdCdheicsXG5cdCdiYXMnLFxuXHQnYmUnLFxuXHQnYmVtJyxcblx0J2JleicsXG5cdCdiZycsXG5cdCdibScsXG5cdCdibi1JTicsXG5cdCdibicsXG5cdCdiby1JTicsXG5cdCdibycsXG5cdCdicicsXG5cdCdicngnLFxuXHQnYnMtQ3lybCcsXG5cdCdicy1MYXRuJyxcblx0J2JzJyxcblx0J2NhLUFEJyxcblx0J2NhLUVTLVZBTEVOQ0lBJyxcblx0J2NhLUZSJyxcblx0J2NhLUlUJyxcblx0J2NhJyxcblx0J2NlJyxcblx0J2NnZycsXG5cdCdjaHInLFxuXHQnY2tiLUlSJyxcblx0J2NrYicsXG5cdCdjcycsXG5cdCdjdScsXG5cdCdjeScsXG5cdCdkYS1HTCcsXG5cdCdkYScsXG5cdCdkYXYnLFxuXHQnZGUtQVQnLFxuXHQnZGUtQkUnLFxuXHQnZGUtQ0gnLFxuXHQnZGUtSVQnLFxuXHQnZGUtTEknLFxuXHQnZGUtTFUnLFxuXHQnZGUnLFxuXHQnZGplJyxcblx0J2RzYicsXG5cdCdkdWEnLFxuXHQnZHlvJyxcblx0J2R6Jyxcblx0J2VidScsXG5cdCdlZS1URycsXG5cdCdlZScsXG5cdCdlbC1DWScsXG5cdCdlbCcsXG5cdCdlbi0wMDEnLFxuXHQnZW4tMTUwJyxcblx0J2VuLUFHJyxcblx0J2VuLUFJJyxcblx0J2VuLUFTJyxcblx0J2VuLUFUJyxcblx0J2VuLUFVJyxcblx0J2VuLUJCJyxcblx0J2VuLUJFJyxcblx0J2VuLUJJJyxcblx0J2VuLUJNJyxcblx0J2VuLUJTJyxcblx0J2VuLUJXJyxcblx0J2VuLUJaJyxcblx0J2VuLUNBJyxcblx0J2VuLUNDJyxcblx0J2VuLUNIJyxcblx0J2VuLUNLJyxcblx0J2VuLUNNJyxcblx0J2VuLUNYJyxcblx0J2VuLUNZJyxcblx0J2VuLURFJyxcblx0J2VuLURHJyxcblx0J2VuLURLJyxcblx0J2VuLURNJyxcblx0J2VuLUVSJyxcblx0J2VuLUZJJyxcblx0J2VuLUZKJyxcblx0J2VuLUZLJyxcblx0J2VuLUZNJyxcblx0J2VuLUdCJyxcblx0J2VuLUdEJyxcblx0J2VuLUdHJyxcblx0J2VuLUdIJyxcblx0J2VuLUdJJyxcblx0J2VuLUdNJyxcblx0J2VuLUdVJyxcblx0J2VuLUdZJyxcblx0J2VuLUhLJyxcblx0J2VuLUlFJyxcblx0J2VuLUlMJyxcblx0J2VuLUlNJyxcblx0J2VuLUlOJyxcblx0J2VuLUlPJyxcblx0J2VuLUpFJyxcblx0J2VuLUpNJyxcblx0J2VuLUtFJyxcblx0J2VuLUtJJyxcblx0J2VuLUtOJyxcblx0J2VuLUtZJyxcblx0J2VuLUxDJyxcblx0J2VuLUxSJyxcblx0J2VuLUxTJyxcblx0J2VuLU1HJyxcblx0J2VuLU1IJyxcblx0J2VuLU1PJyxcblx0J2VuLU1QJyxcblx0J2VuLU1TJyxcblx0J2VuLU1UJyxcblx0J2VuLU1VJyxcblx0J2VuLU1XJyxcblx0J2VuLU1ZJyxcblx0J2VuLU5BJyxcblx0J2VuLU5GJyxcblx0J2VuLU5HJyxcblx0J2VuLU5MJyxcblx0J2VuLU5SJyxcblx0J2VuLU5VJyxcblx0J2VuLU5aJyxcblx0J2VuLVBHJyxcblx0J2VuLVBIJyxcblx0J2VuLVBLJyxcblx0J2VuLVBOJyxcblx0J2VuLVBSJyxcblx0J2VuLVBXJyxcblx0J2VuLVJXJyxcblx0J2VuLVNCJyxcblx0J2VuLVNDJyxcblx0J2VuLVNEJyxcblx0J2VuLVNFJyxcblx0J2VuLVNHJyxcblx0J2VuLVNIJyxcblx0J2VuLVNJJyxcblx0J2VuLVNMJyxcblx0J2VuLVNTJyxcblx0J2VuLVNYJyxcblx0J2VuLVNaJyxcblx0J2VuLVRDJyxcblx0J2VuLVRLJyxcblx0J2VuLVRPJyxcblx0J2VuLVRUJyxcblx0J2VuLVRWJyxcblx0J2VuLVRaJyxcblx0J2VuLVVHJyxcblx0J2VuLVVNJyxcblx0J2VuLVVTLVBPU0lYJyxcblx0J2VuLVZDJyxcblx0J2VuLVZHJyxcblx0J2VuLVZJJyxcblx0J2VuLVZVJyxcblx0J2VuLVdTJyxcblx0J2VuLVpBJyxcblx0J2VuLVpNJyxcblx0J2VuLVpXJyxcblx0J2VuJyxcblx0J2VvJyxcblx0J2VzLTQxOScsXG5cdCdlcy1BUicsXG5cdCdlcy1CTycsXG5cdCdlcy1CUicsXG5cdCdlcy1DTCcsXG5cdCdlcy1DTycsXG5cdCdlcy1DUicsXG5cdCdlcy1DVScsXG5cdCdlcy1ETycsXG5cdCdlcy1FQScsXG5cdCdlcy1FQycsXG5cdCdlcy1HUScsXG5cdCdlcy1HVCcsXG5cdCdlcy1ITicsXG5cdCdlcy1JQycsXG5cdCdlcy1NWCcsXG5cdCdlcy1OSScsXG5cdCdlcy1QQScsXG5cdCdlcy1QRScsXG5cdCdlcy1QSCcsXG5cdCdlcy1QUicsXG5cdCdlcy1QWScsXG5cdCdlcy1TVicsXG5cdCdlcy1VUycsXG5cdCdlcy1VWScsXG5cdCdlcy1WRScsXG5cdCdlcycsXG5cdCdldCcsXG5cdCdldScsXG5cdCdld28nLFxuXHQnZmEtQUYnLFxuXHQnZmEnLFxuXHQnZmYtQ00nLFxuXHQnZmYtR04nLFxuXHQnZmYtTVInLFxuXHQnZmYnLFxuXHQnZmknLFxuXHQnZmlsJyxcblx0J2ZvLURLJyxcblx0J2ZvJyxcblx0J2ZyLUJFJyxcblx0J2ZyLUJGJyxcblx0J2ZyLUJJJyxcblx0J2ZyLUJKJyxcblx0J2ZyLUJMJyxcblx0J2ZyLUNBJyxcblx0J2ZyLUNEJyxcblx0J2ZyLUNGJyxcblx0J2ZyLUNHJyxcblx0J2ZyLUNIJyxcblx0J2ZyLUNJJyxcblx0J2ZyLUNNJyxcblx0J2ZyLURKJyxcblx0J2ZyLURaJyxcblx0J2ZyLUdBJyxcblx0J2ZyLUdGJyxcblx0J2ZyLUdOJyxcblx0J2ZyLUdQJyxcblx0J2ZyLUdRJyxcblx0J2ZyLUhUJyxcblx0J2ZyLUtNJyxcblx0J2ZyLUxVJyxcblx0J2ZyLU1BJyxcblx0J2ZyLU1DJyxcblx0J2ZyLU1GJyxcblx0J2ZyLU1HJyxcblx0J2ZyLU1MJyxcblx0J2ZyLU1RJyxcblx0J2ZyLU1SJyxcblx0J2ZyLU1VJyxcblx0J2ZyLU5DJyxcblx0J2ZyLU5FJyxcblx0J2ZyLVBGJyxcblx0J2ZyLVBNJyxcblx0J2ZyLVJFJyxcblx0J2ZyLVJXJyxcblx0J2ZyLVNDJyxcblx0J2ZyLVNOJyxcblx0J2ZyLVNZJyxcblx0J2ZyLVREJyxcblx0J2ZyLVRHJyxcblx0J2ZyLVROJyxcblx0J2ZyLVZVJyxcblx0J2ZyLVdGJyxcblx0J2ZyLVlUJyxcblx0J2ZyJyxcblx0J2Z1cicsXG5cdCdmeScsXG5cdCdnYScsXG5cdCdnZCcsXG5cdCdnbCcsXG5cdCdnc3ctRlInLFxuXHQnZ3N3LUxJJyxcblx0J2dzdycsXG5cdCdndScsXG5cdCdndXonLFxuXHQnZ3YnLFxuXHQnaGEtR0gnLFxuXHQnaGEtTkUnLFxuXHQnaGEnLFxuXHQnaGF3Jyxcblx0J2hlJyxcblx0J2hpJyxcblx0J2hyLUJBJyxcblx0J2hyJyxcblx0J2hzYicsXG5cdCdodScsXG5cdCdoeScsXG5cdCdpZCcsXG5cdCdpZycsXG5cdCdpaScsXG5cdCdpcycsXG5cdCdpdC1DSCcsXG5cdCdpdC1TTScsXG5cdCdpdCcsXG5cdCdqYScsXG5cdCdqZ28nLFxuXHQnam1jJyxcblx0J2thJyxcblx0J2thYicsXG5cdCdrYW0nLFxuXHQna2RlJyxcblx0J2tlYScsXG5cdCdraHEnLFxuXHQna2knLFxuXHQna2snLFxuXHQna2tqJyxcblx0J2tsJyxcblx0J2tsbicsXG5cdCdrbScsXG5cdCdrbicsXG5cdCdrby1LUCcsXG5cdCdrbycsXG5cdCdrb2snLFxuXHQna3MnLFxuXHQna3NiJyxcblx0J2tzZicsXG5cdCdrc2gnLFxuXHQna3cnLFxuXHQna3knLFxuXHQnbGFnJyxcblx0J2xiJyxcblx0J2xnJyxcblx0J2xrdCcsXG5cdCdsbi1BTycsXG5cdCdsbi1DRicsXG5cdCdsbi1DRycsXG5cdCdsbicsXG5cdCdsbycsXG5cdCdscmMtSVEnLFxuXHQnbHJjJyxcblx0J2x0Jyxcblx0J2x1Jyxcblx0J2x1bycsXG5cdCdsdXknLFxuXHQnbHYnLFxuXHQnbWFzLVRaJyxcblx0J21hcycsXG5cdCdtZXInLFxuXHQnbWZlJyxcblx0J21nJyxcblx0J21naCcsXG5cdCdtZ28nLFxuXHQnbWsnLFxuXHQnbWwnLFxuXHQnbW4nLFxuXHQnbXInLFxuXHQnbXMtQk4nLFxuXHQnbXMtU0cnLFxuXHQnbXMnLFxuXHQnbXQnLFxuXHQnbXVhJyxcblx0J215Jyxcblx0J216bicsXG5cdCduYXEnLFxuXHQnbmItU0onLFxuXHQnbmInLFxuXHQnbmQnLFxuXHQnbmRzLU5MJyxcblx0J25kcycsXG5cdCduZS1JTicsXG5cdCduZScsXG5cdCdubC1BVycsXG5cdCdubC1CRScsXG5cdCdubC1CUScsXG5cdCdubC1DVycsXG5cdCdubC1TUicsXG5cdCdubC1TWCcsXG5cdCdubCcsXG5cdCdubWcnLFxuXHQnbm4nLFxuXHQnbm5oJyxcblx0J251cycsXG5cdCdueW4nLFxuXHQnb20tS0UnLFxuXHQnb20nLFxuXHQnb3InLFxuXHQnb3MtUlUnLFxuXHQnb3MnLFxuXHQncGEtQXJhYicsXG5cdCdwYS1HdXJ1Jyxcblx0J3BhJyxcblx0J3BsJyxcblx0J3ByZycsXG5cdCdwcycsXG5cdCdwdC1BTycsXG5cdCdwdC1DSCcsXG5cdCdwdC1DVicsXG5cdCdwdC1HUScsXG5cdCdwdC1HVycsXG5cdCdwdC1MVScsXG5cdCdwdC1NTycsXG5cdCdwdC1NWicsXG5cdCdwdC1QVCcsXG5cdCdwdC1TVCcsXG5cdCdwdC1UTCcsXG5cdCdwdCcsXG5cdCdxdS1CTycsXG5cdCdxdS1FQycsXG5cdCdxdScsXG5cdCdybScsXG5cdCdybicsXG5cdCdyby1NRCcsXG5cdCdybycsXG5cdCdyb2YnLFxuXHQncm9vdCcsXG5cdCdydS1CWScsXG5cdCdydS1LRycsXG5cdCdydS1LWicsXG5cdCdydS1NRCcsXG5cdCdydS1VQScsXG5cdCdydScsXG5cdCdydycsXG5cdCdyd2snLFxuXHQnc2FoJyxcblx0J3NhcScsXG5cdCdzYnAnLFxuXHQnc2UtRkknLFxuXHQnc2UtU0UnLFxuXHQnc2UnLFxuXHQnc2VoJyxcblx0J3NlcycsXG5cdCdzZycsXG5cdCdzaGktTGF0bicsXG5cdCdzaGktVGZuZycsXG5cdCdzaGknLFxuXHQnc2knLFxuXHQnc2snLFxuXHQnc2wnLFxuXHQnc21uJyxcblx0J3NuJyxcblx0J3NvLURKJyxcblx0J3NvLUVUJyxcblx0J3NvLUtFJyxcblx0J3NvJyxcblx0J3NxLU1LJyxcblx0J3NxLVhLJyxcblx0J3NxJyxcblx0J3NyLUN5cmwtQkEnLFxuXHQnc3ItQ3lybC1NRScsXG5cdCdzci1DeXJsLVhLJyxcblx0J3NyLUN5cmwnLFxuXHQnc3ItTGF0bi1CQScsXG5cdCdzci1MYXRuLU1FJyxcblx0J3NyLUxhdG4tWEsnLFxuXHQnc3ItTGF0bicsXG5cdCdzcicsXG5cdCdzdi1BWCcsXG5cdCdzdi1GSScsXG5cdCdzdicsXG5cdCdzdy1DRCcsXG5cdCdzdy1LRScsXG5cdCdzdy1VRycsXG5cdCdzdycsXG5cdCd0YS1MSycsXG5cdCd0YS1NWScsXG5cdCd0YS1TRycsXG5cdCd0YScsXG5cdCd0ZScsXG5cdCd0ZW8tS0UnLFxuXHQndGVvJyxcblx0J3RoJyxcblx0J3RpLUVSJyxcblx0J3RpJyxcblx0J3RrJyxcblx0J3RvJyxcblx0J3RyLUNZJyxcblx0J3RyJyxcblx0J3R3cScsXG5cdCd0em0nLFxuXHQndWcnLFxuXHQndWsnLFxuXHQndXItSU4nLFxuXHQndXInLFxuXHQndXotQXJhYicsXG5cdCd1ei1DeXJsJyxcblx0J3V6LUxhdG4nLFxuXHQndXonLFxuXHQndmFpLUxhdG4nLFxuXHQndmFpLVZhaWknLFxuXHQndmFpJyxcblx0J3ZpJyxcblx0J3ZvJyxcblx0J3Z1bicsXG5cdCd3YWUnLFxuXHQneG9nJyxcblx0J3lhdicsXG5cdCd5aScsXG5cdCd5by1CSicsXG5cdCd5bycsXG5cdCd5dWUnLFxuXHQnemdoJyxcblx0J3poLUhhbnMtSEsnLFxuXHQnemgtSGFucy1NTycsXG5cdCd6aC1IYW5zLVNHJyxcblx0J3poLUhhbnMnLFxuXHQnemgtSGFudC1ISycsXG5cdCd6aC1IYW50LU1PJyxcblx0J3poLUhhbnQnLFxuXHQnemgnLFxuXHQnenUnXG5dO1xuZXhwb3J0IGRlZmF1bHQgbG9jYWxlc0xpc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbG9jYWxlcy50cyIsIi8qIHRzbGludDpkaXNhYmxlOmludGVyZmFjZS1uYW1lICovXG5pbXBvcnQgJ0Bkb2pvL3NoaW0vUHJvbWlzZSc7IC8vIGVuc3VyZSBQcm9taXNlLmFsbCBleGlzdHNcbmltcG9ydCBFdmVudGVkIGZyb20gJ0Bkb2pvL2NvcmUvRXZlbnRlZCc7XG5pbXBvcnQgaGFzIGZyb20gJ0Bkb2pvL2NvcmUvaGFzJztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ0Bkb2pvL2NvcmUvbGFuZyc7XG5pbXBvcnQgeyB1c2VEZWZhdWx0IH0gZnJvbSAnQGRvam8vY29yZS9sb2FkL3V0aWwnO1xuaW1wb3J0IHV1aWQgZnJvbSAnQGRvam8vY29yZS91dWlkJztcbmltcG9ydCB7IEhhbmRsZSB9IGZyb20gJ0Bkb2pvL2NvcmUvaW50ZXJmYWNlcyc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJ0Bkb2pvL3NoaW0vZ2xvYmFsJztcbmltcG9ydCBNYXAgZnJvbSAnQGRvam8vc2hpbS9NYXAnO1xuaW1wb3J0IE9ic2VydmFibGUsIHsgT2JzZXJ2ZXIsIFN1YnNjcmlwdGlvbiwgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgfSBmcm9tICdAZG9qby9zaGltL09ic2VydmFibGUnO1xuaW1wb3J0ICogYXMgR2xvYmFsaXplIGZyb20gJ2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9tZXNzYWdlJztcbmltcG9ydCB7IGlzTG9hZGVkIH0gZnJvbSAnLi9jbGRyL2xvYWQnO1xuaW1wb3J0IHsgZ2VuZXJhdGVMb2NhbGVzLCBub3JtYWxpemVMb2NhbGUgfSBmcm9tICcuL3V0aWwvbWFpbic7XG5cbi8qKlxuICogQSBkZWZhdWx0IGJ1bmRsZSB1c2VkIGFzIGJhc2lzIGZvciBsb2FkaW5nIGxvY2FsZS1zcGVjaWZpYyBidW5kbGVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1bmRsZTxUIGV4dGVuZHMgTWVzc2FnZXM+IHtcblx0LyoqXG5cdCAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidW5kbGUgdGhhdCB3aWxsIGJlIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gaXQgaXMgcmVnaXN0ZXJlZC5cblx0ICovXG5cdHJlYWRvbmx5IGlkPzogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZXMuIEFueSBpbmNsdWRlZCBsb2NhbGUgTVVTVCBoYXZlIGFuIGFzc29jaWF0ZWQgYnVuZGxlLlxuXHQgKi9cblx0cmVhZG9ubHkgbG9jYWxlcz86IExvY2FsZUxvYWRlcnM8VD47XG5cblx0LyoqXG5cdCAqIFRoZSBtYXAgb2YgZGVmYXVsdCBtZXNzYWdlcyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGxvY2FsZS1zcGVjaWZpYyBtZXNzYWdlcyBhcmUgdW5hdmFpbGFibGUuXG5cdCAqIE5vdGUgdGhhdCBhbnkgbWVzc2FnZSBrZXkgdXNlZCBpbiB0aGUgaTE4biBzeXN0ZW0gTVVTVCBoYXZlIGEgZGVmYXVsdCBzcGVjaWZpZWQgaGVyZS5cblx0ICovXG5cdHJlYWRvbmx5IG1lc3NhZ2VzOiBUO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byBtZXNzYWdlIGZvcm1hdHRlcnMgYW5kIHVzZWQgZm9yIHRva2VuIHJlcGxhY2VtZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdE9wdGlvbnMge1xuXHRba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSTE4bjxUIGV4dGVuZHMgTWVzc2FnZXM+IHtcblx0KGJ1bmRsZTogQnVuZGxlPFQ+LCBsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPFQ+O1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBuYW1lc3BhY2UgYXMgc2V0IHZpYSBgc3dpdGNoTG9jYWxlYC4gRGVmYXVsdHMgdG8gYHN5c3RlbUxvY2FsZWAuXG5cdCAqL1xuXHRyZWFkb25seSBsb2NhbGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIG1hcCBvZiBsb2NhbGVzIHRvIGZ1bmN0aW9ucyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyB0aGVpciByZXNwZWN0aXZlIHRyYW5zbGF0aW9ucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NhbGVMb2FkZXJzPFQgZXh0ZW5kcyBNZXNzYWdlcz4ge1xuXHRbbG9jYWxlOiBzdHJpbmddOiAoKSA9PiBMb2NhbGVUcmFuc2xhdGlvbnM8VD4gfCBQcm9taXNlPExvY2FsZVRyYW5zbGF0aW9uczxUPj47XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IG9mIGxvY2FsZS1zcGVjaWZpYyB0cmFuc2xhdGlvbnMuXG4gKi9cbmV4cG9ydCB0eXBlIExvY2FsZVRyYW5zbGF0aW9uczxUIGV4dGVuZHMgTWVzc2FnZXM+ID0gUGFydGlhbDxUPiB8IHsgZGVmYXVsdD86IFBhcnRpYWw8VD4gfTtcblxuLyoqXG4gKiBEZXNjcmliZXMgYSBjb21waWxlZCBJQ1UgbWVzc2FnZSBmb3JtYXR0ZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUZvcm1hdHRlciB7XG5cdChvcHRpb25zPzogRm9ybWF0T3B0aW9ucyk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgb2Yga2V5cyB0byBsb2NhbGUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZXMge1xuXHRba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmNvbnN0IFRPS0VOX1BBVFRFUk4gPSAvXFx7KFthLXowLTlfXSspXFx9L2dpO1xuY29uc3QgYnVuZGxlTWFwID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIE1lc3NhZ2VzPj4oKTtcbmNvbnN0IGZvcm1hdHRlck1hcCA9IG5ldyBNYXA8c3RyaW5nLCBNZXNzYWdlRm9ybWF0dGVyPigpO1xuY29uc3QgbG9jYWxlUHJvZHVjZXIgPSBuZXcgRXZlbnRlZCgpO1xubGV0IHJvb3RMb2NhbGU6IHN0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJ1bmRsZSdzIHVuaXF1ZSBpZGVudGlmaWVyLCBjcmVhdGluZyBvbmUgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAqXG4gKiBAcGFyYW0gYnVuZGxlIEEgbWVzc2FnZSBidW5kbGVcbiAqIEByZXR1cm4gVGhlIGJ1bmRsZSdzIHVuaXF1ZSBpZGVudGlmaWVyXG4gKi9cbmZ1bmN0aW9uIGdldEJ1bmRsZUlkPFQgZXh0ZW5kcyBNZXNzYWdlcz4oYnVuZGxlOiBCdW5kbGU8VD4pOiBzdHJpbmcge1xuXHRpZiAoYnVuZGxlLmlkKSB7XG5cdFx0cmV0dXJuIGJ1bmRsZS5pZDtcblx0fVxuXG5cdGNvbnN0IGlkID0gdXVpZCgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCAnaWQnLCB7XG5cdFx0dmFsdWU6IGlkXG5cdH0pO1xuXHRyZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhbiBJQ1Utc3R5bGUgbWVzc2FnZSwgYW5kIHRha2VzIGFuIG9wdGlvbmFsIHZhbHVlIGZvciB0b2tlbiByZXBsYWNlbWVudC5cbiAqXG4gKiBVc2FnZTpcbiAqIGNvbnN0IGZvcm1hdHRlciA9IGdldE1lc3NhZ2VGb3JtYXR0ZXIoYnVuZGxlLCAnZ3Vlc3RJbmZvJywgJ2ZyJyk7XG4gKiBjb25zdCBtZXNzYWdlID0gZm9ybWF0dGVyKHtcbiAqICAgaG9zdDogJ01pbGVzJyxcbiAqICAgZ2VuZGVyOiAnbWFsZScsXG4gKiAgIGd1ZXN0OiAnT3NjYXInLFxuICogICBndWVzdENvdW50OiAnMTUnXG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0gaWRcbiAqIFRoZSBtZXNzYWdlJ3MgYnVuZGxlIGlkLlxuICpcbiAqIEBwYXJhbSBrZXlcbiAqIFRoZSBtZXNzYWdlJ3Mga2V5LlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIEFuIG9wdGlvbmFsIGxvY2FsZSBmb3IgdGhlIGZvcm1hdHRlci4gSWYgbm8gbG9jYWxlIGlzIHN1cHBsaWVkLCBvciBpZiB0aGUgbG9jYWxlIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZVxuICogZGVmYXVsdCBsb2NhbGUgaXMgdXNlZC5cbiAqXG4gKiBAcmV0dXJuXG4gKiBUaGUgbWVzc2FnZSBmb3JtYXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIGdldEljdU1lc3NhZ2VGb3JtYXR0ZXIoaWQ6IHN0cmluZywga2V5OiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyk6IE1lc3NhZ2VGb3JtYXR0ZXIge1xuXHRsb2NhbGUgPSBub3JtYWxpemVMb2NhbGUobG9jYWxlIHx8IGdldFJvb3RMb2NhbGUoKSk7XG5cdGNvbnN0IGZvcm1hdHRlcktleSA9IGAke2xvY2FsZX06JHtpZH06JHtrZXl9YDtcblx0bGV0IGZvcm1hdHRlciA9IGZvcm1hdHRlck1hcC5nZXQoZm9ybWF0dGVyS2V5KTtcblxuXHRpZiAoZm9ybWF0dGVyKSB7XG5cdFx0cmV0dXJuIGZvcm1hdHRlcjtcblx0fVxuXG5cdGNvbnN0IGdsb2JhbGl6ZSA9IGxvY2FsZSAhPT0gZ2V0Um9vdExvY2FsZSgpID8gbmV3IEdsb2JhbGl6ZShub3JtYWxpemVMb2NhbGUobG9jYWxlKSkgOiBHbG9iYWxpemU7XG5cdGZvcm1hdHRlciA9IGdsb2JhbGl6ZS5tZXNzYWdlRm9ybWF0dGVyKGAke2lkfS8ke2tleX1gKTtcblxuXHRjb25zdCBjYWNoZWQgPSBidW5kbGVNYXAuZ2V0KGlkKTtcblx0aWYgKGNhY2hlZCAmJiBjYWNoZWQuZ2V0KGxvY2FsZSkpIHtcblx0XHRmb3JtYXR0ZXJNYXAuc2V0KGZvcm1hdHRlcktleSwgZm9ybWF0dGVyKTtcblx0fVxuXG5cdHJldHVybiBmb3JtYXR0ZXI7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIExvYWQgdGhlIHNwZWNpZmllZCBsb2NhbGUtc3BlY2lmaWMgYnVuZGxlcywgbWFwcGluZyB0aGUgZGVmYXVsdCBleHBvcnRzIHRvIHNpbXBsZSBgTWVzc2FnZXNgIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGxvYWRMb2NhbGVCdW5kbGVzPFQgZXh0ZW5kcyBNZXNzYWdlcz4obG9jYWxlczogTG9jYWxlTG9hZGVyczxUPiwgc3VwcG9ydGVkOiBzdHJpbmdbXSk6IFByb21pc2U8VFtdPiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChzdXBwb3J0ZWQubWFwKChsb2NhbGUpID0+IGxvY2FsZXNbbG9jYWxlXSgpKSkudGhlbigoYnVuZGxlcykgPT4ge1xuXHRcdHJldHVybiBidW5kbGVzLm1hcCgoYnVuZGxlKSA9PiB1c2VEZWZhdWx0KGJ1bmRsZSkpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0dXJuIHRoZSByb290IGxvY2FsZS4gRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3RMb2NhbGUoKTogc3RyaW5nIHtcblx0cmV0dXJuIHJvb3RMb2NhbGUgfHwgc3lzdGVtTG9jYWxlO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXRyaWV2ZSBhIGxpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZXMgdGhhdCBjYW4gcHJvdmlkZSBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIHRhcmdldCBsb2NhbGUuXG4gKlxuICogQHBhcmFtIHN1cHBvcnRlZFxuICogVGhlIGxvY2FsZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBidW5kbGUuXG4gKlxuICogQHJldHVyblxuICogQSBsaXN0IG9mIHN1cHBvcnRlZCBsb2NhbGVzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldCBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZExvY2FsZXMobG9jYWxlOiBzdHJpbmcsIHN1cHBvcnRlZDogc3RyaW5nW10gPSBbXSk6IHN0cmluZ1tdIHtcblx0cmV0dXJuIGdlbmVyYXRlTG9jYWxlcyhsb2NhbGUpLmZpbHRlcigobG9jYWxlOiBzdHJpbmcpID0+IHN1cHBvcnRlZC5pbmRleE9mKGxvY2FsZSkgPiAtMSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEluamVjdCBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUgaW50byB0aGUgaTE4biBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIGlkXG4gKiBUaGUgYnVuZGxlJ3MgdW5pcXVlIGlkZW50aWZpZXJcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZXNcbiAqIFRoZSBtZXNzYWdlcyB0byBpbmplY3RcbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBtZXNzYWdlcyBhcmUgdGhlIGRlZmF1bHRzIGZvciB0aGUgZ2l2ZW5cbiAqIGJ1bmRsZSBwYXRoLlxuICovXG5mdW5jdGlvbiBsb2FkTWVzc2FnZXM8VCBleHRlbmRzIE1lc3NhZ2VzPihpZDogc3RyaW5nLCBtZXNzYWdlczogVCwgbG9jYWxlOiBzdHJpbmcgPSAncm9vdCcpIHtcblx0bGV0IGNhY2hlZCA9IGJ1bmRsZU1hcC5nZXQoaWQpO1xuXG5cdGlmICghY2FjaGVkKSB7XG5cdFx0Y2FjaGVkID0gbmV3IE1hcDxzdHJpbmcsIE1lc3NhZ2VzPigpO1xuXHRcdGJ1bmRsZU1hcC5zZXQoaWQsIGNhY2hlZCk7XG5cdH1cblxuXHRjYWNoZWQuc2V0KGxvY2FsZSwgbWVzc2FnZXMpO1xuXHRHbG9iYWxpemUubG9hZE1lc3NhZ2VzKHtcblx0XHRbbG9jYWxlXToge1xuXHRcdFx0W2lkXTogbWVzc2FnZXNcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZvcm1hdHRlZCBtZXNzYWdlLlxuICpcbiAqIElmIGJvdGggdGhlIFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3NcIiBhbmQgXCJzdXBwbGVtZW50YWwvcGx1cmFscy10eXBlLWNhcmRpbmFsXCIgQ0xEUiBkYXRhIGhhdmUgYmVlbiBsb2FkZWQsIHRoZW5cbiAqIHRoZSBJQ1UgbWVzc2FnZSBmb3JtYXQgaXMgc3VwcG9ydGVkLiBPdGhlcndpc2UsIGEgc2ltcGxlIHRva2VuLXJlcGxhY2VtZW50IG1lY2hhbmlzbSBpcyB1c2VkLlxuICpcbiAqIFVzYWdlOlxuICogZm9ybWF0TWVzc2FnZShidW5kbGUsICdndWVzdEluZm8nLCB7XG4gKiAgIGhvc3Q6ICdCaWxsJyxcbiAqICAgZ3Vlc3Q6ICdKb2huJ1xuICogfSwgJ2ZyJyk7XG4gKlxuICogQHBhcmFtIGJ1bmRsZVxuICogVGhlIGJ1bmRsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBUaGUgbWVzc2FnZSdzIGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQW4gb3B0aW9uYWwgdmFsdWUgdXNlZCBieSB0aGUgZm9ybWF0dGVyIHRvIHJlcGxhY2UgdG9rZW5zIHdpdGggdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIEFuIG9wdGlvbmFsIGxvY2FsZSBmb3IgdGhlIGZvcm1hdHRlci4gSWYgbm8gbG9jYWxlIGlzIHN1cHBsaWVkLCBvciBpZiB0aGUgbG9jYWxlIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZVxuICogZGVmYXVsdCBsb2NhbGUgaXMgdXNlZC5cbiAqXG4gKiBAcmV0dXJuXG4gKiBUaGUgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlPFQgZXh0ZW5kcyBNZXNzYWdlcz4oXG5cdGJ1bmRsZTogQnVuZGxlPFQ+LFxuXHRrZXk6IHN0cmluZyxcblx0b3B0aW9ucz86IEZvcm1hdE9wdGlvbnMsXG5cdGxvY2FsZT86IHN0cmluZ1xuKTogc3RyaW5nIHtcblx0cmV0dXJuIGdldE1lc3NhZ2VGb3JtYXR0ZXIoYnVuZGxlLCBrZXksIGxvY2FsZSkob3B0aW9ucyk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjYWNoZWQgbWVzc2FnZXMgZm9yIHRoZSBzcGVjaWZpZWQgYnVuZGxlIGFuZCBsb2NhbGUuIElmIG1lc3NhZ2VzIGhhdmUgbm90IGJlZW4gcHJldmlvdXNseSBsb2FkZWQgZm9yIHRoZVxuICogc3BlY2lmaWVkIGxvY2FsZSwgbm8gdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gYnVuZGxlXG4gKiBUaGUgZGVmYXVsdCBidW5kbGUgdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVyZSB0aGUgbG9jYWxlLXNwZWNpZmljIGJ1bmRsZXMgYXJlIGxvY2F0ZWQuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIGxvY2FsZSBvZiB0aGUgZGVzaXJlZCBtZXNzYWdlcy5cbiAqXG4gKiBAcmV0dXJuIFRoZSBjYWNoZWQgbWVzc2FnZXMgb2JqZWN0LCBpZiBpdCBleGlzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZWRNZXNzYWdlczxUIGV4dGVuZHMgTWVzc2FnZXM+KGJ1bmRsZTogQnVuZGxlPFQ+LCBsb2NhbGU6IHN0cmluZyk6IFQgfCB2b2lkIHtcblx0Y29uc3QgeyBpZCA9IGdldEJ1bmRsZUlkKGJ1bmRsZSksIGxvY2FsZXMsIG1lc3NhZ2VzIH0gPSBidW5kbGU7XG5cdGNvbnN0IGNhY2hlZCA9IGJ1bmRsZU1hcC5nZXQoaWQpO1xuXG5cdGlmICghY2FjaGVkKSB7XG5cdFx0bG9hZE1lc3NhZ2VzKGlkLCBtZXNzYWdlcyk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgbG9jYWxlTWVzc2FnZXMgPSBjYWNoZWQuZ2V0KGxvY2FsZSk7XG5cdFx0aWYgKGxvY2FsZU1lc3NhZ2VzKSB7XG5cdFx0XHRyZXR1cm4gbG9jYWxlTWVzc2FnZXMgYXMgVDtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBzdXBwb3J0ZWRMb2NhbGVzID0gZ2V0U3VwcG9ydGVkTG9jYWxlcyhsb2NhbGUsIGxvY2FsZXMgJiYgT2JqZWN0LmtleXMobG9jYWxlcykpO1xuXHRpZiAoIXN1cHBvcnRlZExvY2FsZXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2VzO1xuXHR9XG5cblx0aWYgKGNhY2hlZCkge1xuXHRcdHJldHVybiBjYWNoZWQuZ2V0KHN1cHBvcnRlZExvY2FsZXNbc3VwcG9ydGVkTG9jYWxlcy5sZW5ndGggLSAxXSkgYXMgVDtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIHNwZWNpZmljIG1lc3NhZ2UsIGFuZCB0YWtlcyBhbiBvcHRpb25hbCB2YWx1ZSBmb3IgdG9rZW4gcmVwbGFjZW1lbnQuXG4gKlxuICogSWYgYm90aCB0aGUgXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFnc1wiIGFuZCBcInN1cHBsZW1lbnRhbC9wbHVyYWxzLXR5cGUtY2FyZGluYWxcIiBDTERSIGRhdGEgaGF2ZSBiZWVuIGxvYWRlZCwgdGhlblxuICogdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgaGF2ZSBJQ1UgbWVzc2FnZSBmb3JtYXQgc3VwcG9ydC4gT3RoZXJ3aXNlLCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIGEgc2ltcGxlXG4gKiB0b2tlbiByZXBsYWNlbWVudCBvbiB0aGUgbWVzc2FnZSBzdHJpbmcuXG4gKlxuICogVXNhZ2U6XG4gKiBjb25zdCBmb3JtYXR0ZXIgPSBnZXRNZXNzYWdlRm9ybWF0dGVyKGJ1bmRsZSwgJ2d1ZXN0SW5mbycsICdmcicpO1xuICogY29uc3QgbWVzc2FnZSA9IGZvcm1hdHRlcih7XG4gKiAgIGhvc3Q6ICdNaWxlcycsXG4gKiAgIGdlbmRlcjogJ21hbGUnLFxuICogICBndWVzdDogJ09zY2FyJyxcbiAqICAgZ3Vlc3RDb3VudDogJzE1J1xuICogfSk7XG4gKlxuICogQHBhcmFtIGJ1bmRsZVxuICogVGhlIGJ1bmRsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBUaGUgbWVzc2FnZSdzIGtleS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUgZm9yIHRoZSBmb3JtYXR0ZXIuIElmIG5vIGxvY2FsZSBpcyBzdXBwbGllZCwgb3IgaWYgdGhlIGxvY2FsZSBpcyBub3Qgc3VwcG9ydGVkLCB0aGVcbiAqIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuXG4gKlxuICogQHJldHVyblxuICogVGhlIG1lc3NhZ2UgZm9ybWF0dGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZUZvcm1hdHRlcjxUIGV4dGVuZHMgTWVzc2FnZXM+KFxuXHRidW5kbGU6IEJ1bmRsZTxUPixcblx0a2V5OiBzdHJpbmcsXG5cdGxvY2FsZT86IHN0cmluZ1xuKTogTWVzc2FnZUZvcm1hdHRlciB7XG5cdGNvbnN0IHsgaWQgPSBnZXRCdW5kbGVJZChidW5kbGUpIH0gPSBidW5kbGU7XG5cblx0aWYgKGlzTG9hZGVkKCdzdXBwbGVtZW50YWwnLCAnbGlrZWx5U3VidGFncycpICYmIGlzTG9hZGVkKCdzdXBwbGVtZW50YWwnLCAncGx1cmFscy10eXBlLWNhcmRpbmFsJykpIHtcblx0XHRyZXR1cm4gZ2V0SWN1TWVzc2FnZUZvcm1hdHRlcihpZCwga2V5LCBsb2NhbGUpO1xuXHR9XG5cblx0Y29uc3QgY2FjaGVkID0gYnVuZGxlTWFwLmdldChpZCk7XG5cdGNvbnN0IG1lc3NhZ2VzID0gY2FjaGVkID8gY2FjaGVkLmdldChsb2NhbGUgfHwgZ2V0Um9vdExvY2FsZSgpKSB8fCBjYWNoZWQuZ2V0KCdyb290JykgOiBudWxsO1xuXG5cdGlmICghbWVzc2FnZXMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBidW5kbGUgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuYCk7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24ob3B0aW9uczogRm9ybWF0T3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcblx0XHRyZXR1cm4gbWVzc2FnZXNba2V5XS5yZXBsYWNlKFRPS0VOX1BBVFRFUk4sICh0b2tlbjogc3RyaW5nLCBwcm9wZXJ0eTogc3RyaW5nKSA9PiB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IG9wdGlvbnNbcHJvcGVydHldO1xuXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcHJvcGVydHkgJHtwcm9wZXJ0eX1gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0pO1xuXHR9O1xufVxuXG4vKipcbiAqIExvYWQgbG9jYWxlLXNwZWNpZmljIG1lc3NhZ2VzIGZvciB0aGUgc3BlY2lmaWVkIGJ1bmRsZSBhbmQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBidW5kbGVcbiAqIFRoZSBkZWZhdWx0IGJ1bmRsZSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSBsb2NhbGUtc3BlY2lmaWMgYnVuZGxlcyBhcmUgbG9jYXRlZC5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUuIElmIG5vIGxvY2FsZSBpcyBwcm92aWRlZCwgdGhlbiB0aGUgY3VycmVudCBsb2NhbGUgaXMgYXNzdW1lZC5cbiAqXG4gKiBAcmV0dXJuIEEgcHJvbWlzZSB0byB0aGUgbG9jYWxlLXNwZWNpZmljIG1lc3NhZ2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBpMThuPFQgZXh0ZW5kcyBNZXNzYWdlcz4oYnVuZGxlOiBCdW5kbGU8VD4sIGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8VD4ge1xuXHRjb25zdCBjdXJyZW50TG9jYWxlID0gbG9jYWxlID8gbm9ybWFsaXplTG9jYWxlKGxvY2FsZSkgOiBnZXRSb290TG9jYWxlKCk7XG5cdGNvbnN0IGNhY2hlZE1lc3NhZ2VzID0gZ2V0Q2FjaGVkTWVzc2FnZXMoYnVuZGxlLCBjdXJyZW50TG9jYWxlKTtcblxuXHRpZiAoY2FjaGVkTWVzc2FnZXMpIHtcblx0XHRyZXR1cm4gY2FjaGVkTWVzc2FnZXM7XG5cdH1cblxuXHRjb25zdCBsb2NhbGVzID0gYnVuZGxlLmxvY2FsZXMgYXMgTG9jYWxlTG9hZGVyczxUPjtcblx0Y29uc3Qgc3VwcG9ydGVkTG9jYWxlcyA9IGdldFN1cHBvcnRlZExvY2FsZXMoY3VycmVudExvY2FsZSwgT2JqZWN0LmtleXMobG9jYWxlcykpO1xuXHRjb25zdCBidW5kbGVzID0gYXdhaXQgbG9hZExvY2FsZUJ1bmRsZXM8VD4obG9jYWxlcywgc3VwcG9ydGVkTG9jYWxlcyk7XG5cdHJldHVybiBidW5kbGVzLnJlZHVjZSgocHJldmlvdXM6IFQsIHBhcnRpYWw6IFQpOiBUID0+IHtcblx0XHRjb25zdCBsb2NhbGVNZXNzYWdlczogVCA9IGFzc2lnbih7fSwgcHJldmlvdXMsIHBhcnRpYWwpO1xuXHRcdGxvYWRNZXNzYWdlcyhnZXRCdW5kbGVJZChidW5kbGUpLCA8VD5PYmplY3QuZnJlZXplKGxvY2FsZU1lc3NhZ2VzKSwgY3VycmVudExvY2FsZSk7XG5cdFx0cmV0dXJuIGxvY2FsZU1lc3NhZ2VzO1xuXHR9LCBidW5kbGUubWVzc2FnZXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaTE4biwgJ2xvY2FsZScsIHtcblx0Z2V0OiBnZXRSb290TG9jYWxlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaTE4biBhcyBJMThuPE1lc3NhZ2VzPjtcblxuLyoqXG4gKiBJbnZhbGlkYXRlIHRoZSBjYWNoZSBmb3IgYSBwYXJ0aWN1bGFyIGJ1bmRsZSwgb3IgaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLiBOb3RlIHRoYXQgY2FjaGVkIG1lc3NhZ2VzIGZvciBhbGxcbiAqIGxvY2FsZXMgZm9yIGEgZ2l2ZW4gYnVuZGxlIHdpbGwgYmUgY2xlYXJlZC5cbiAqXG4gKiBAcGFyYW0gYnVuZGxlXG4gKiBBbiBvcHRpb25hbCBidW5kbGUgdG8gaW52YWxpZGF0ZS4gSWYgbm8gYnVuZGxlIGlzIHByb3ZpZGVkLCB0aGVuIHRoZSBjYWNoZSBpcyBjbGVhcmVkIGZvciBhbGwgYnVuZGxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGU8VCBleHRlbmRzIE1lc3NhZ2VzPihidW5kbGU/OiBCdW5kbGU8VD4pIHtcblx0aWYgKGJ1bmRsZSkge1xuXHRcdGJ1bmRsZS5pZCAmJiBidW5kbGVNYXAuZGVsZXRlKGJ1bmRsZS5pZCk7XG5cdH0gZWxzZSB7XG5cdFx0YnVuZGxlTWFwLmNsZWFyKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhbiBvYnNlcnZlciB0byBiZSBub3RpZmllZCB3aGVuIHRoZSByb290IGxvY2FsZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBvYnNlcnZlclxuICogVGhlIG9ic2VydmVyIHdob3NlIGBuZXh0YCBtZXRob2Qgd2lsbCByZWNlaXZlIHRoZSBsb2NhbGUgc3RyaW5nIG9uIHVwZGF0ZXMsIGFuZCB3aG9zZSBgZXJyb3JgIG1ldGhvZCB3aWxsIHJlY2VpdmVcbiAqIGFuIEVycm9yIG9iamVjdCBpZiB0aGUgbG9jYWxlIHN3aXRjaCBmYWlscy5cbiAqXG4gKiBAcmV0dXJuXG4gKiBBIHN1YnNjcmlwdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byB1bnN1YnNjcmliZSBmcm9tIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBvYnNlcnZlTG9jYWxlID0gKGZ1bmN0aW9uKCkge1xuXHRjb25zdCBsb2NhbGVTb3VyY2UgPSBuZXcgT2JzZXJ2YWJsZTxzdHJpbmc+KChvYnNlcnZlcjogU3Vic2NyaXB0aW9uT2JzZXJ2ZXI8c3RyaW5nPikgPT4ge1xuXHRcdGNvbnN0IGhhbmRsZXM6IEhhbmRsZVtdID0gW1xuXHRcdFx0bG9jYWxlUHJvZHVjZXIub24oJ2NoYW5nZScsIChldmVudDogYW55KSA9PiB7XG5cdFx0XHRcdG9ic2VydmVyLm5leHQoZXZlbnQudGFyZ2V0KTtcblx0XHRcdH0pXG5cdFx0XTtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGhhbmRsZXMuZm9yRWFjaCgoaGFuZGxlOiBIYW5kbGUpID0+IHtcblx0XHRcdFx0aGFuZGxlLmRlc3Ryb3koKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiBmdW5jdGlvbihvYnNlcnZlcjogT2JzZXJ2ZXI8c3RyaW5nPik6IFN1YnNjcmlwdGlvbiB7XG5cdFx0cmV0dXJuIGxvY2FsZVNvdXJjZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBQcmUtbG9hZCBsb2NhbGUtc3BlY2lmaWMgbWVzc2FnZXMgaW50byB0aGUgaTE4biBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIGJ1bmRsZVxuICogVGhlIGRlZmF1bHQgYnVuZGxlIHRoYXQgaXMgdXNlZCB0byBtZXJnZSBsb2NhbGUtc3BlY2lmaWMgbWVzc2FnZXMgd2l0aCB0aGUgZGVmYXVsdCBtZXNzYWdlcy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZXNcbiAqIFRoZSBtZXNzYWdlcyB0byBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBUaGUgbG9jYWxlIGZvciB0aGUgbWVzc2FnZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExvY2FsZU1lc3NhZ2VzPFQgZXh0ZW5kcyBNZXNzYWdlcz4oXG5cdGJ1bmRsZTogQnVuZGxlPFQ+LFxuXHRsb2NhbGVNZXNzYWdlczogUGFydGlhbDxUPixcblx0bG9jYWxlOiBzdHJpbmdcbik6IHZvaWQge1xuXHRjb25zdCBtZXNzYWdlczogVCA9IGFzc2lnbih7fSwgYnVuZGxlLm1lc3NhZ2VzLCBsb2NhbGVNZXNzYWdlcyk7XG5cdGxvYWRNZXNzYWdlcyhnZXRCdW5kbGVJZChidW5kbGUpLCA8VD5PYmplY3QuZnJlZXplKG1lc3NhZ2VzKSwgbG9jYWxlKTtcbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHJvb3QgbG9jYWxlLCBhbmQgbm90aWZ5IGFueSByZWdpc3RlcmVkIG9ic2VydmVycy5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBUaGUgbmV3IGxvY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaExvY2FsZShsb2NhbGU6IHN0cmluZyk6IHZvaWQge1xuXHRjb25zdCBwcmV2aW91cyA9IHJvb3RMb2NhbGU7XG5cdHJvb3RMb2NhbGUgPSBsb2NhbGUgPyBub3JtYWxpemVMb2NhbGUobG9jYWxlKSA6ICcnO1xuXG5cdGlmIChwcmV2aW91cyAhPT0gcm9vdExvY2FsZSkge1xuXHRcdGlmIChpc0xvYWRlZCgnc3VwcGxlbWVudGFsJywgJ2xpa2VseVN1YnRhZ3MnKSkge1xuXHRcdFx0R2xvYmFsaXplLmxvYWQoe1xuXHRcdFx0XHRtYWluOiB7XG5cdFx0XHRcdFx0W3Jvb3RMb2NhbGVdOiB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdEdsb2JhbGl6ZS5sb2NhbGUocm9vdExvY2FsZSk7XG5cdFx0fVxuXG5cdFx0bG9jYWxlUHJvZHVjZXIuZW1pdCh7IHR5cGU6ICdjaGFuZ2UnLCB0YXJnZXQ6IHJvb3RMb2NhbGUgfSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlbnZpcm9ubWVudCBsb2NhbGUuXG4gKlxuICogSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgd2hpbGUgdGhlIHN5c3RlbSBsb2NhbGUgd2lsbCBiZSBub3JtYWxpemVkIHRvIGEgc2luZ2xlXG4gKiBmb3JtYXQgd2hlbiBsb2FkaW5nIG1lc3NhZ2UgYnVuZGxlcywgdGhpcyB2YWx1ZSByZXByZXNlbnRzIHRoZSB1bmFsdGVyZWRcbiAqIGxvY2FsZSByZXR1cm5lZCBkaXJlY3RseSBieSB0aGUgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBzeXN0ZW1Mb2NhbGU6IHN0cmluZyA9IChmdW5jdGlvbigpIHtcblx0bGV0IHN5c3RlbUxvY2FsZSA9ICdlbic7XG5cdGlmIChoYXMoJ2hvc3QtYnJvd3NlcicpKSB7XG5cdFx0Y29uc3QgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblx0XHRzeXN0ZW1Mb2NhbGUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZTtcblx0fSBlbHNlIGlmIChoYXMoJ2hvc3Qtbm9kZScpKSB7XG5cdFx0c3lzdGVtTG9jYWxlID0gcHJvY2Vzcy5lbnYuTEFORyB8fCBzeXN0ZW1Mb2NhbGU7XG5cdH1cblx0cmV0dXJuIG5vcm1hbGl6ZUxvY2FsZShzeXN0ZW1Mb2NhbGUpO1xufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBpMThuLnRzIiwiLy8gTWF0Y2hlcyBhbiBJU08gNjM5LjEvNjM5LjIgY29tcGF0aWJsZSBsYW5ndWFnZSwgZm9sbG93ZWQgYnkgb3B0aW9uYWwgc3VidGFncy5cbmNvbnN0IFZBTElEX0xPQ0FMRV9QQVRURVJOID0gL15bYS16XXsyLDN9KC1bYS16MC05XFwtXFxfXSspPyQvaTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGxpc3Qgb2YgbG9jYWxlcyB0aGF0IGNhbiBwcm92aWRlIHN1YnN0aXR1dGUgZm9yIHRoZSBzcGVjaWZpZWQgbG9jYWxlXG4gKiAoaW5jbHVkaW5nIGl0c2VsZikuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmICdmci1DQScgaXMgc3BlY2lmaWVkLCB0aGVuIGBbICdmcicsICdmci1DQScgXWAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIHRhcmdldCBsb2NhbGUuXG4gKlxuICogQHJldHVyblxuICogQSBsaXN0IG9mIGxvY2FsZXMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0IGxvY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTG9jYWxlcyhsb2NhbGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcblx0Y29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUxvY2FsZShsb2NhbGUpO1xuXHRjb25zdCBwYXJ0cyA9IG5vcm1hbGl6ZWQuc3BsaXQoJy0nKTtcblx0bGV0IGN1cnJlbnQgPSBwYXJ0c1swXTtcblx0Y29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtjdXJyZW50XTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuXHRcdGN1cnJlbnQgKz0gJy0nICsgcGFydHNbaSArIDFdO1xuXHRcdHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBsb2NhbGUgc28gdGhhdCBpdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYnVuZGxlIHBhdGguXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIHRhcmdldCBsb2NhbGUuXG4gKlxuICogQHJldHVybiBUaGUgbm9ybWFsaXplZCBsb2NhbGUuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVMb2NhbGUgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC8oXFwtfF8pJC8sICcnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShsb2NhbGU6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0aWYgKGxvY2FsZS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3IobG9jYWxlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbG9jYWxlXG5cdFx0XHQuc3BsaXQoJy4nKVxuXHRcdFx0LnNsaWNlKDAsIC0xKVxuXHRcdFx0Lm1hcCgocGFydDogc3RyaW5nKTogc3RyaW5nID0+IHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHBhcnQpLnJlcGxhY2UoL18vZywgJy0nKTtcblx0XHRcdH0pXG5cdFx0XHQuam9pbignLScpO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplKGxvY2FsZSk7XG5cblx0XHRpZiAoIXZhbGlkYXRlTG9jYWxlKG5vcm1hbGl6ZWQpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7bm9ybWFsaXplZH0gaXMgbm90IGEgdmFsaWQgbG9jYWxlLmApO1xuXHRcdH1cblxuXHRcdHJldHVybiBub3JtYWxpemVkO1xuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgcHJvdmlkZWQgbG9jYWxlIGF0IGxlYXN0IGJlZ2lucyB3aXRoIGEgSVNPIDYzOS4xLzYzOS4yIGNvbXB0YWJpbGUgbGFuZ3VhZ2Ugc3VidGFnLFxuICogYW5kIHRoYXQgYW55IGFkZGl0aW9uYWwgc3VidGFncyBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycy5cbiAqXG4gKiBXaGlsZSBsb2NhbGVzIHNob3VsZCBhZGhlcmUgdG8gdGhlIGd1aWRlbGluZXMgc2V0IGZvcnRoIGJ5IFJGQyA1NjQ2IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTY0NiksXG4gKiBvbmx5IHRoZSBsYW5ndWFnZSBzdWJ0YWcgaXMgc3RyaWN0bHkgZW5mb3JjZWQuXG4gKlxuICogQHBhcmFtIGxvY2FsZVxuICogVGhlIGxvY2FsZSB0byB2YWxpZGF0ZS5cbiAqXG4gKiBAcmV0dXJuXG4gKiBgdHJ1ZWAgaWYgdGhlIGxvY2FsZSBpcyB2YWxpZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxvY2FsZShsb2NhbGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gVkFMSURfTE9DQUxFX1BBVFRFUk4udGVzdChsb2NhbGUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG1haW4udHMiLCJpbXBvcnQgeyBpc0FycmF5TGlrZSwgSXRlcmFibGUsIEl0ZXJhYmxlSXRlcmF0b3IsIFNoaW1JdGVyYXRvciB9IGZyb20gJy4vaXRlcmF0b3InO1xuaW1wb3J0IGdsb2JhbCBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgeyBpcyBhcyBvYmplY3RJcyB9IGZyb20gJy4vb2JqZWN0JztcbmltcG9ydCBoYXMgZnJvbSAnLi9zdXBwb3J0L2hhcyc7XG5pbXBvcnQgJy4vU3ltYm9sJztcblxuZXhwb3J0IGludGVyZmFjZSBNYXA8SywgVj4ge1xuXHQvKipcblx0ICogRGVsZXRlcyBhbGwga2V5cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMuXG5cdCAqL1xuXHRjbGVhcigpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGEgZ2l2ZW4ga2V5IGFuZCBpdHMgYXNzb2NpYXRlZCB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGRlbGV0ZVxuXHQgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGtleSBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXMgbm90XG5cdCAqL1xuXHRkZWxldGUoa2V5OiBLKTogYm9vbGVhbjtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IHlpZWxkcyBlYWNoIGtleS92YWx1ZSBwYWlyIGFzIGFuIGFycmF5LlxuXHQgKlxuXHQgKiBAcmV0dXJuIEFuIGl0ZXJhdG9yIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdGVudHJpZXMoKTogSXRlcmFibGVJdGVyYXRvcjxbSywgVl0+O1xuXG5cdC8qKlxuXHQgKiBFeGVjdXRlcyBhIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIG1hcCBlbnRyeS4gVGhlIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IHRoZSBlbGVtZW50IHZhbHVlLCB0aGVcblx0ICogZWxlbWVudCBrZXksIGFuZCB0aGUgYXNzb2NpYXRlZCBNYXAgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFja2ZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIG1hcCBlbnRyeSxcblx0ICogQHBhcmFtIHRoaXNBcmcgVGhlIHZhbHVlIHRvIHVzZSBmb3IgYHRoaXNgIGZvciBlYWNoIGV4ZWN1dGlvbiBvZiB0aGUgY2FsYmFja1xuXHQgKi9cblx0Zm9yRWFjaChjYWxsYmFja2ZuOiAodmFsdWU6IFYsIGtleTogSywgbWFwOiBNYXA8SywgVj4pID0+IHZvaWQsIHRoaXNBcmc/OiBhbnkpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXkuXG5cdCAqXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBsb29rIHVwXG5cdCAqIEByZXR1cm4gVGhlIHZhbHVlIGlmIG9uZSBleGlzdHMgb3IgdW5kZWZpbmVkXG5cdCAqL1xuXHRnZXQoa2V5OiBLKTogViB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IHlpZWxkcyBlYWNoIGtleSBpbiB0aGUgbWFwLlxuXHQgKlxuXHQgKiBAcmV0dXJuIEFuIGl0ZXJhdG9yIGNvbnRhaW5pbmcgdGhlIGluc3RhbmNlJ3Mga2V5cy5cblx0ICovXG5cdGtleXMoKTogSXRlcmFibGVJdGVyYXRvcjxLPjtcblxuXHQvKipcblx0ICogQ2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBnaXZlbiBrZXkuXG5cdCAqXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVjayBmb3Jcblx0ICogQHJldHVybiB0cnVlIGlmIHRoZSBrZXkgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2VzIG5vdFxuXHQgKi9cblx0aGFzKGtleTogSyk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleS5cblx0ICpcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGRlZmluZSBhIHZhbHVlIHRvXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduXG5cdCAqIEByZXR1cm4gVGhlIE1hcCBpbnN0YW5jZVxuXHQgKi9cblx0c2V0KGtleTogSywgdmFsdWU6IFYpOiB0aGlzO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5IC8gdmFsdWUgcGFpcnMgaW4gdGhlIE1hcC5cblx0ICovXG5cdHJlYWRvbmx5IHNpemU6IG51bWJlcjtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IHlpZWxkcyBlYWNoIHZhbHVlIGluIHRoZSBtYXAuXG5cdCAqXG5cdCAqIEByZXR1cm4gQW4gaXRlcmF0b3IgY29udGFpbmluZyB0aGUgaW5zdGFuY2UncyB2YWx1ZXMuXG5cdCAqL1xuXHR2YWx1ZXMoKTogSXRlcmFibGVJdGVyYXRvcjxWPjtcblxuXHQvKiogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiBlbnRyaWVzIGluIHRoZSBtYXAuICovXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W0ssIFZdPjtcblxuXHRyZWFkb25seSBbU3ltYm9sLnRvU3RyaW5nVGFnXTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcENvbnN0cnVjdG9yIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgTWFwXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0bmV3ICgpOiBNYXA8YW55LCBhbnk+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IE1hcFxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIGl0ZXJhdG9yXG5cdCAqIEFycmF5IG9yIGl0ZXJhdG9yIGNvbnRhaW5pbmcgdHdvLWl0ZW0gdHVwbGVzIHVzZWQgdG8gaW5pdGlhbGx5IHBvcHVsYXRlIHRoZSBtYXAuXG5cdCAqIFRoZSBmaXJzdCBpdGVtIGluIGVhY2ggdHVwbGUgY29ycmVzcG9uZHMgdG8gdGhlIGtleSBvZiB0aGUgbWFwIGVudHJ5LlxuXHQgKiBUaGUgc2Vjb25kIGl0ZW0gY29ycmVzcG9uZHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBtYXAgZW50cnkuXG5cdCAqL1xuXHRuZXcgPEssIFY+KGl0ZXJhdG9yPzogW0ssIFZdW10pOiBNYXA8SywgVj47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgTWFwXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKlxuXHQgKiBAcGFyYW0gaXRlcmF0b3Jcblx0ICogQXJyYXkgb3IgaXRlcmF0b3IgY29udGFpbmluZyB0d28taXRlbSB0dXBsZXMgdXNlZCB0byBpbml0aWFsbHkgcG9wdWxhdGUgdGhlIG1hcC5cblx0ICogVGhlIGZpcnN0IGl0ZW0gaW4gZWFjaCB0dXBsZSBjb3JyZXNwb25kcyB0byB0aGUga2V5IG9mIHRoZSBtYXAgZW50cnkuXG5cdCAqIFRoZSBzZWNvbmQgaXRlbSBjb3JyZXNwb25kcyB0byB0aGUgdmFsdWUgb2YgdGhlIG1hcCBlbnRyeS5cblx0ICovXG5cdG5ldyA8SywgVj4oaXRlcmF0b3I6IEl0ZXJhYmxlPFtLLCBWXT4pOiBNYXA8SywgVj47XG5cblx0cmVhZG9ubHkgcHJvdG90eXBlOiBNYXA8YW55LCBhbnk+O1xuXG5cdHJlYWRvbmx5IFtTeW1ib2wuc3BlY2llc106IE1hcENvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgbGV0IE1hcDogTWFwQ29uc3RydWN0b3IgPSBnbG9iYWwuTWFwO1xuXG5pZiAoIWhhcygnZXM2LW1hcCcpKSB7XG5cdE1hcCA9IGNsYXNzIE1hcDxLLCBWPiB7XG5cdFx0cHJvdGVjdGVkIHJlYWRvbmx5IF9rZXlzOiBLW10gPSBbXTtcblx0XHRwcm90ZWN0ZWQgcmVhZG9ubHkgX3ZhbHVlczogVltdID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBhbHRlcm5hdGl2ZSB0byBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB1c2luZyBPYmplY3QuaXNcblx0XHQgKiB0byBjaGVjayBmb3IgZXF1YWxpdHkuIFNlZSBodHRwOi8vbXpsLmxhLzF6dUtPMlZcblx0XHQgKi9cblx0XHRwcm90ZWN0ZWQgX2luZGV4T2ZLZXkoa2V5czogS1tdLCBrZXk6IEspOiBudW1iZXIge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG9iamVjdElzKGtleXNbaV0sIGtleSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBbU3ltYm9sLnNwZWNpZXNdID0gTWFwO1xuXG5cdFx0Y29uc3RydWN0b3IoaXRlcmFibGU/OiBBcnJheUxpa2U8W0ssIFZdPiB8IEl0ZXJhYmxlPFtLLCBWXT4pIHtcblx0XHRcdGlmIChpdGVyYWJsZSkge1xuXHRcdFx0XHRpZiAoaXNBcnJheUxpa2UoaXRlcmFibGUpKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpdGVyYWJsZVtpXTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2V0IHNpemUoKTogbnVtYmVyIHtcblx0XHRcdHJldHVybiB0aGlzLl9rZXlzLmxlbmd0aDtcblx0XHR9XG5cblx0XHRjbGVhcigpOiB2b2lkIHtcblx0XHRcdHRoaXMuX2tleXMubGVuZ3RoID0gdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlKGtleTogSyk6IGJvb2xlYW4ge1xuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLl9pbmRleE9mS2V5KHRoaXMuX2tleXMsIGtleSk7XG5cdFx0XHRpZiAoaW5kZXggPCAwKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2tleXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdHRoaXMuX3ZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0ZW50cmllcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFtLLCBWXT4ge1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5fa2V5cy5tYXAoKGtleTogSywgaTogbnVtYmVyKTogW0ssIFZdID0+IHtcblx0XHRcdFx0cmV0dXJuIFtrZXksIHRoaXMuX3ZhbHVlc1tpXV07XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIG5ldyBTaGltSXRlcmF0b3IodmFsdWVzKTtcblx0XHR9XG5cblx0XHRmb3JFYWNoKGNhbGxiYWNrOiAodmFsdWU6IFYsIGtleTogSywgbWFwSW5zdGFuY2U6IE1hcDxLLCBWPikgPT4gYW55LCBjb250ZXh0Pzoge30pIHtcblx0XHRcdGNvbnN0IGtleXMgPSB0aGlzLl9rZXlzO1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0LCB2YWx1ZXNbaV0sIGtleXNbaV0sIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdldChrZXk6IEspOiBWIHwgdW5kZWZpbmVkIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXhPZktleSh0aGlzLl9rZXlzLCBrZXkpO1xuXHRcdFx0cmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpbmRleF07XG5cdFx0fVxuXG5cdFx0aGFzKGtleTogSyk6IGJvb2xlYW4ge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2luZGV4T2ZLZXkodGhpcy5fa2V5cywga2V5KSA+IC0xO1xuXHRcdH1cblxuXHRcdGtleXMoKTogSXRlcmFibGVJdGVyYXRvcjxLPiB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoaW1JdGVyYXRvcih0aGlzLl9rZXlzKTtcblx0XHR9XG5cblx0XHRzZXQoa2V5OiBLLCB2YWx1ZTogVik6IE1hcDxLLCBWPiB7XG5cdFx0XHRsZXQgaW5kZXggPSB0aGlzLl9pbmRleE9mS2V5KHRoaXMuX2tleXMsIGtleSk7XG5cdFx0XHRpbmRleCA9IGluZGV4IDwgMCA/IHRoaXMuX2tleXMubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHR0aGlzLl9rZXlzW2luZGV4XSA9IGtleTtcblx0XHRcdHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHZhbHVlcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFY+IHtcblx0XHRcdHJldHVybiBuZXcgU2hpbUl0ZXJhdG9yKHRoaXMuX3ZhbHVlcyk7XG5cdFx0fVxuXG5cdFx0W1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxbSywgVl0+IHtcblx0XHRcdHJldHVybiB0aGlzLmVudHJpZXMoKTtcblx0XHR9XG5cblx0XHRbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ01hcCcgPSAnTWFwJztcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIE1hcC50cyIsImltcG9ydCBnbG9iYWwgZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHsgaXNBcnJheUxpa2UsIGlzSXRlcmFibGUsIEl0ZXJhYmxlIH0gZnJvbSAnLi9pdGVyYXRvcic7XG5pbXBvcnQgaGFzIGZyb20gJy4vc3VwcG9ydC9oYXMnO1xuaW1wb3J0ICcuL1N5bWJvbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGVPYmplY3Qge1xuXHQvKipcblx0ICogUmVnaXN0ZXJzIGhhbmRsZXJzIGZvciBoYW5kbGluZyBlbWl0dGVkIHZhbHVlcywgZXJyb3IgYW5kIGNvbXBsZXRpb25zIGZyb20gdGhlIG9ic2VydmFibGUsIGFuZFxuXHQgKiBleGVjdXRlcyB0aGUgb2JzZXJ2YWJsZSdzIHN1YnNjcmliZXIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgdGFrZSBhY3Rpb24gdG8gc2V0IHVwIHRoZSB1bmRlcmx5aW5nIGRhdGEgc3RyZWFtLlxuXHQgKlxuXHQgKiBAcGFyYW0gb2JzZXJ2ZXIgICAgVGhlIG9ic2VydmVyIG9iamVjdCB0aGF0IHdpbGwgaGFuZGxlIGV2ZW50c1xuXHQgKlxuXHQgKiBAcmV0dXJuIEEgU3Vic2NyaXB0aW9uIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1hbmFnZSB0aGUgc3Vic2NyaXB0aW9uLlxuXHQgKi9cblx0c3Vic2NyaWJlKG9ic2VydmVyOiBPYnNlcnZlcjxUPik6IFN1YnNjcmlwdGlvbjtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGhhbmRsZXJzIGZvciBoYW5kbGluZyBlbWl0dGVkIHZhbHVlcywgZXJyb3IgYW5kIGNvbXBsZXRpb25zIGZyb20gdGhlIG9ic2VydmFibGUsIGFuZFxuXHQgKiBleGVjdXRlcyB0aGUgb2JzZXJ2YWJsZSdzIHN1YnNjcmliZXIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgdGFrZSBhY3Rpb24gdG8gc2V0IHVwIHRoZSB1bmRlcmx5aW5nIGRhdGEgc3RyZWFtLlxuXHQgKlxuXHQgKiBAcGFyYW0gb25OZXh0IEEgZnVuY3Rpb24gdG8gaGFuZGxlIGFuIGVtaXR0ZWQgdmFsdWUuIFZhbHVlIGlzIHBhc3NlZCBpbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIHRoZSBmdW5jdGlvbi5cblx0ICogQHBhcmFtIG9uRXJyb3IgQSBmdW5jdGlvbiB0byBoYW5kbGUgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIG9uTmV4dCwgb3IgZHVyaW5nIHN1YnNjcmlwdGlvbi5cblx0ICogQHBhcmFtIG9uQ29tcGxldGUgQSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiBpcyBjb21wbGV0ZSwgYW5kIHdpbGwgbm90IHNlbmQgYW55IG1vcmUgdmFsdWVzLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyBnZXQgY2FsbGVkIGlmIGFuIGVycm9yIG9jY3VycyBhbmQgb25FcnJvciBpcyBub3QgZGVmaW5lZC5cblx0ICpcblx0ICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBBIFN1YnNjcmlwdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgdGhlIHN1YnNjcmlwdGlvbi5cblx0ICovXG5cdHN1YnNjcmliZShcblx0XHRvbk5leHQ6ICh2YWx1ZTogVCkgPT4gYW55LFxuXHRcdG9uRXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gYW55LFxuXHRcdG9uQ29tcGxldGU/OiAoY29tcGxldGVWYWx1ZT86IGFueSkgPT4gdm9pZFxuXHQpOiBTdWJzY3JpcHRpb247XG5cblx0W1N5bWJvbC5vYnNlcnZhYmxlXSgpOiB0aGlzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmFibGVDb25zdHJ1Y3RvciB7XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgb2JzZXJ2ZXJhYmxlIHdpdGggYSBzdWJzY3JpYmVyIGZ1bmN0aW9uLiBUaGUgc3Vic2NyaWJlciBmdW5jdGlvbiB3aWxsIGdldCBjYWxsZWQgd2l0aCBhXG5cdCAqIFN1YnNjcmlwdGlvbk9ic2VydmVyIHBhcmFtZXRlciBmb3IgY29udHJvbGxpbmcgdGhlIHN1YnNjcmlwdGlvbi4gIEkgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZVxuXHQgKiBydW4gd2hlbiB0aGUgc3Vic2NyaXB0aW9uIGlzIGNvbXBsZXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0gc3Vic2NyaWJlciBUaGUgc3Vic2NyaXB0aW9uIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIG9ic2VydmVycyBhcmUgc3Vic2NyaWJlZFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGB0c1xuXHQgKiBjb25zdCBzb3VyY2UgPSBuZXcgT2JzZXJ2ZXI8bnVtYmVyPigob2JzZXJ2ZXIpID0+IHtcblx0ICogICAgIG9ic2VydmVyLm5leHQoMSk7XG5cdCAqICAgICBvYnNlcnZlci5uZXh0KDIpO1xuXHQgKiAgICAgb2JzZXJ2ZXIubmV4dCgzKTtcblx0ICogfSk7XG5cdCAqIGBgYHRzXG5cdCAqL1xuXHRuZXcgPFQ+KHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiBPYnNlcnZhYmxlPFQ+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gT2JzZXJ2YWJsZSBmcm9tIGFub3RoZXIgb2JqZWN0LiBJZiB0aGUgb2JqZWN0IGlzIGluIGl0c2VsZiBPYnNlcnZhYmxlLCB0aGUgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIE90aGVyd2lzZSwgdGhlIHZhbHVlIHdpbGwgYmUgd3JhcHBlZCBpbiBhbiBPYnNlcnZhYmxlLiBJZiB0aGUgb2JqZWN0IGlzIGl0ZXJhYmxlLCBhbiBPYnNlcnZhYmxlIHdpbGwgYmUgY3JlYXRlZFxuXHQgKiB0aGF0IGVtaXRzIGVhY2ggaXRlbSBvZiB0aGUgaXRlcmFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGJlIHR1cm5lZCBpbnRvIGFuIE9ic2VydmFibGVcblx0ICogQHJldHVybiBBbiBvYnNlcnZhYmxlIGZvciB0aGUgaXRlbSB5b3UgcGFzc2VkIGluXG5cdCAqL1xuXHRmcm9tPFQ+KGl0ZW06IEl0ZXJhYmxlPFQ+IHwgQXJyYXlMaWtlPFQ+IHwgT2JzZXJ2YWJsZU9iamVjdCk6IE9ic2VydmFibGU8VD47XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBPYnNlcnZhYmxlIGZyb20gYSBsaXN0IG9mIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIGl0ZW1zIFRoZSB2YWx1ZXMgdG8gYmUgZW1pdHRlZFxuXHQgKiBAcmV0dXJuIEFuIE9ic2VydmFibGUgdGhhdCB3aWxsIGVtaXQgdGhlIHNwZWNpZmllZCB2YWx1ZXNcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgdHNcblx0ICogbGV0IHNvdXJjZSA9IE9ic2VydmFibGUub2YoMSwgMiwgMyk7XG5cdCAqIC8vIHdpbGwgZW1pdCB0aHJlZSBzZXBhcmF0ZSB2YWx1ZXMsIDEsIDIsIGFuZCAzLlxuXHQgKiBgYGBcblx0ICovXG5cdG9mPFQ+KC4uLml0ZW1zOiBUW10pOiBPYnNlcnZhYmxlPFQ+O1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgYSBTeW1ib2wub2JzZXJ2ZXJhYmxlIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZhYmxlT2JqZWN0IHtcblx0W1N5bWJvbC5vYnNlcnZhYmxlXTogKCkgPT4gYW55O1xufVxuXG4vKipcbiAqIEhhbmRsZXMgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGUgc3Vic2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2ZXI8VD4ge1xuXHQvKipcblx0ICogQ2FsbGVkIHRvIGhhbmRsZSBhIHNpbmdsZSBlbWl0dGVkIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgd2FzIGVtaXR0ZWQuXG5cdCAqL1xuXHRuZXh0Pyh2YWx1ZTogVCk6IGFueTtcblxuXHQvKipcblx0ICogQW4gb3B0aW9uYWwgbWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gc3RhcnRzIChiZWZvcmUgYW55IGV2ZW50cyBhcmUgZW1pdHRlZCkuXG5cdCAqIEBwYXJhbSBvYnNlcnZlclxuXHQgKi9cblx0c3RhcnQ/KG9ic2VydmVyOiBTdWJzY3JpcHRpb24pOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBBbiBvcHRpb25hbCBtZXRob2QgdG8gYmUgY2FsbGVkIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgc3Vic2NyaXB0aW9uIG9yIGhhbmRsaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0gZXJyb3JWYWx1ZSBUaGUgZXJyb3Jcblx0ICovXG5cdGVycm9yPyhlcnJvclZhbHVlOiBhbnkpOiBhbnk7XG5cblx0LyoqXG5cdCAqIEFuIG9wdGlvbmFsIG1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIGlzIGNvbXBsZXRlZCAodW5sZXNzIGFuIGVycm9yIG9jY3VycmVkIGFuZCB0aGUgZXJyb3IgbWV0aG9kIHdhcyBzcGVjaWZpZWQpXG5cdCAqXG5cdCAqIEBwYXJhbSBjb21wbGV0ZVZhbHVlIFRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbXBsZXRpb24gbWV0aG9kLlxuXHQgKi9cblx0Y29tcGxldGU/KGNvbXBsZXRlVmFsdWU/OiBhbnkpOiB2b2lkO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0b1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmliYWJsZTxUPiB7XG5cdHN1YnNjcmliZShvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pOiBTdWJzY3JpcHRpb247XG5cdHN1YnNjcmliZShcblx0XHRvbk5leHQ6ICh2YWx1ZTogVCkgPT4gYW55LFxuXHRcdG9uRXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gYW55LFxuXHRcdG9uQ29tcGxldGU/OiAoY29tcGxldGVWYWx1ZT86IGFueSkgPT4gdm9pZFxuXHQpOiBTdWJzY3JpcHRpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaWJlcjxUPiB7XG5cdChvYnNlcnZlcjogU3Vic2NyaXB0aW9uT2JzZXJ2ZXI8VD4pOiAoKCkgPT4gdm9pZCkgfCB2b2lkIHwgeyB1bnN1YnNjcmliZTogKCkgPT4gdm9pZCB9O1xufVxuXG4vKipcbiAqIEhhbmRsZXMgYW4gaW5kaXZpZHVhbCBzdWJzY3JpcHRpb24gdG8gYW4gT2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIHN1YnNjcmlwdGlvbiBpcyBjbG9zZWQuIENsb3NlZCBzdWJzY3JpcHRpb25zIHdpbGwgbm90IGVtaXQgdmFsdWVzLlxuXHQgKi9cblx0Y2xvc2VkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBBIGZ1bmN0aW9uIHRvIGNhbGwgdG8gY2xvc2UgdGhlIHN1YnNjcmlwdGlvbi4gQ2FsbGluZyB0aGlzIHdpbGwgY2FsbCBhbnkgYXNzb2NpYXRlZCB0ZWFyIGRvd24gbWV0aG9kcy5cblx0ICovXG5cdHVuc3Vic2NyaWJlOiAoKCkgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHVzZWQgdG8gY29udHJvbCBhIHNpbmdsZSBzdWJzY3JpcHRpb24gYW5kIGFuIG9ic2VydmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmlwdGlvbk9ic2VydmVyPFQ+IHtcblx0LyoqXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBzdWJzY3JpcHRpb24gaXMgY2xvc2VkLlxuXHQgKi9cblx0cmVhZG9ubHkgY2xvc2VkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBFbWl0IGFuIGV2ZW50IHRvIHRoZSBvYnNlcnZlci5cblx0ICpcblx0ICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBlbWl0dGVkLlxuXHQgKi9cblx0bmV4dCh2YWx1ZTogVCk6IGFueTtcblxuXHQvKipcblx0ICogUmVwb3J0IGFuIGVycm9yLiBUaGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgY2xvc2VkIGFmdGVyIGFuIGVycm9yIGhhcyBvY2N1cnJlZC5cblx0ICpcblx0ICogQHBhcmFtIGVycm9yVmFsdWUgVGhlIGVycm9yIHRvIGJlIHJlcG9ydGVkLlxuXHQgKi9cblx0ZXJyb3IoZXJyb3JWYWx1ZTogYW55KTogYW55O1xuXG5cdC8qKlxuXHQgKiBSZXBvcnQgY29tcGxldGlvbiBvZiB0aGUgc3Vic2NyaXB0aW9uLiBUaGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgY2xvc2VkLCBhbmQgbm8gbmV3IHZhbHVlcyB3aWxsIGJlIGVtaXR0ZWQsXG5cdCAqIGFmdGVyIGNvbXBsZXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSBjb21wbGV0ZVZhbHVlIEEgdmFsdWUgdG8gcGFzcyB0byB0aGUgY29tcGxldGlvbiBoYW5kbGVyLlxuXHQgKi9cblx0Y29tcGxldGUoY29tcGxldGVWYWx1ZT86IGFueSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBsZXQgT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUNvbnN0cnVjdG9yID0gZ2xvYmFsLk9ic2VydmFibGU7XG5cbmlmICghaGFzKCdlcy1vYnNlcnZhYmxlJykpIHtcblx0Lypcblx0ICogQ3JlYXRlIGEgc3Vic2NyaXB0aW9uIG9ic2VydmVyIGZvciBhIGdpdmVuIG9ic2VydmVyLCBhbmQgcmV0dXJuIHRoZSBzdWJzY3JpcHRpb24uICBUaGUgXCJsb2dpY1wiIGZvciBPYnNlcnZlcmFibGVzXG5cdCAqIGlzIGluIGhlcmUhXG5cdCAqL1xuXHRjb25zdCBzdGFydFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0U3Vic2NyaXB0aW9uPFQ+KFxuXHRcdGV4ZWN1dG9yOiBTdWJzY3JpYmVyPFQ+LFxuXHRcdG9ic2VydmVyOiBPYnNlcnZlcjxUPlxuXHQpOiBTdWJzY3JpcHRpb24ge1xuXHRcdGxldCBjbG9zZWQgPSBmYWxzZTtcblx0XHRsZXQgY2xlYW5VcDogKCkgPT4gdm9pZCB8IHVuZGVmaW5lZDtcblxuXHRcdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuXHRcdFx0aWYgKCFjbG9zZWQpIHtcblx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoY2xlYW5VcCkge1xuXHRcdFx0XHRcdGNsZWFuVXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0YXJ0KHN1YnNjcmlwdGlvbk9ic2VydmVyOiBTdWJzY3JpcHRpb25PYnNlcnZlcjxUPikge1xuXHRcdFx0aWYgKG9ic2VydmVyLnN0YXJ0KSB7XG5cdFx0XHRcdG9ic2VydmVyLnN0YXJ0KHN1YnNjcmlwdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCByZXN1bHQ6IGFueSA9IGV4ZWN1dG9yKHN1YnNjcmlwdGlvbk9ic2VydmVyKTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNsZWFuVXAgPSByZXN1bHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICYmICd1bnN1YnNjcmliZScgaW4gcmVzdWx0KSB7XG5cdFx0XHRcdFx0Y2xlYW5VcCA9IHJlc3VsdC51bnN1YnNjcmliZTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdTdWJzY3JpYmVyIG11c3QgcmV0dXJuIGEgY2FsbGFibGUgb3Igc3Vic2NyaXB0aW9uJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdFx0aWYgKGNsZWFuVXApIHtcblx0XHRcdFx0XHRcdGNsZWFuVXAoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmV4dCh2YWx1ZTogVCk6IGFueSB7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbmV4dCA9IG9ic2VydmVyLm5leHQ7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgbmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybiBuZXh0KHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmVyLm5leHQgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvcihlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlcnJvcihlcnJvclZhbHVlPzogYW55KTogYW55IHtcblx0XHRcdGlmICghY2xvc2VkKSB7XG5cdFx0XHRcdGxldCBjbGVhblVwRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNsZWFuVXBFcnJvciA9IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBvYnNlcnZlckVycm9yID0gb2JzZXJ2ZXIuZXJyb3I7XG5cblx0XHRcdFx0aWYgKG9ic2VydmVyRXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYnNlcnZlckVycm9yICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYnNlcnZlckVycm9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBlcnJvclJlc3VsdCA9IG9ic2VydmVyRXJyb3IoZXJyb3JWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdGlmIChjbGVhblVwRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBjbGVhblVwRXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBlcnJvclJlc3VsdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JzZXJ2ZXIuZXJyb3IgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JzZXJ2ZXIuY29tcGxldGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JzZXJ2ZXIuY29tcGxldGUoZXJyb3JWYWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgZXJyb3JWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wbGV0ZShjb21wbGV0ZVZhbHVlPzogYW55KTogYW55IHtcblx0XHRcdGlmICghY2xvc2VkKSB7XG5cdFx0XHRcdGxldCBjbGVhblVwRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNsZWFuVXBFcnJvciA9IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBvYnNlcnZlckNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGU7XG5cblx0XHRcdFx0aWYgKG9ic2VydmVyQ29tcGxldGUgIT09IHVuZGVmaW5lZCAmJiBvYnNlcnZlckNvbXBsZXRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYnNlcnZlckNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjb21wbGV0ZVJlc3VsdCA9IG9ic2VydmVyQ29tcGxldGUoY29tcGxldGVWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdGlmIChjbGVhblVwRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBjbGVhblVwRXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZVJlc3VsdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JzZXJ2ZXIuY29tcGxldGUgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2xlYW5VcEVycm9yKSB7XG5cdFx0XHRcdFx0dGhyb3cgY2xlYW5VcEVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3Vic2NyaXB0aW9uID0gT2JqZWN0LmNyZWF0ZShcblx0XHRcdE9iamVjdC5jcmVhdGUoXG5cdFx0XHRcdHt9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2xvc2VkOiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsb3NlZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHVuc3Vic2NyaWJlOiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHVuc3Vic2NyaWJlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblxuXHRcdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXG5cdFx0XHR7fSxcblx0XHRcdHtcblx0XHRcdFx0bmV4dDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiBuZXh0LFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiBlcnJvcixcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGU6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogY29tcGxldGUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNsb3NlZDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY2xvc2VkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHQvLyBjcmVhdGUgdGhlIFN1YnNjcmlwdGlvbk9ic2VydmVyIGFuZCBraWNrIHRoaW5ncyBvZmZcblx0XHRzdGFydChPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpO1xuXG5cdFx0Ly8gdGhlIE9OTFkgd2F5IHRvIGNvbnRyb2wgdGhlIFN1YnNjcmlwdGlvbk9ic2VydmVyIGlzIHdpdGggdGhlIHN1YnNjcmlwdGlvbiBvciBmcm9tIGEgc3Vic2NyaWJlclxuXHRcdHJldHVybiBzdWJzY3JpcHRpb247XG5cdH07XG5cblx0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBub25FbnVtZXJhYmxlKHRhcmdldDogYW55LCBrZXk6IHN0cmluZyB8IHN5bWJvbCwgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSB7XG5cdFx0XHRkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRjbGFzcyBPYnNlcnZhYmxlPFQ+IHtcblx0XHRcdHByaXZhdGUgX2V4ZWN1dG9yOiBTdWJzY3JpYmVyPFQ+O1xuXG5cdFx0XHRAbm9uRW51bWVyYWJsZVxuXHRcdFx0W1N5bWJvbC5vYnNlcnZhYmxlXSgpOiB0aGlzIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0cnVjdG9yKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzdWJzY3JpYmVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignc3Vic2NyaWJlciBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZXhlY3V0b3IgPSBzdWJzY3JpYmVyO1xuXHRcdFx0fVxuXG5cdFx0XHRAbm9uRW51bWVyYWJsZVxuXHRcdFx0c3Vic2NyaWJlKG9ic2VydmVyT3JOZXh0OiBhbnksIC4uLmxpc3RlbmVyczogYW55W10pIHtcblx0XHRcdFx0Y29uc3QgW29uRXJyb3IsIG9uQ29tcGxldGVdID0gWy4uLmxpc3RlbmVyc107XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFvYnNlcnZlck9yTmV4dCB8fFxuXHRcdFx0XHRcdHR5cGVvZiBvYnNlcnZlck9yTmV4dCA9PT0gJ251bWJlcicgfHxcblx0XHRcdFx0XHR0eXBlb2Ygb2JzZXJ2ZXJPck5leHQgPT09ICdzdHJpbmcnIHx8XG5cdFx0XHRcdFx0dHlwZW9mIG9ic2VydmVyT3JOZXh0ID09PSAnYm9vbGVhbidcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYnNlcnZlcicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IG9ic2VydmVyOiBPYnNlcnZlcjxUPjtcblxuXHRcdFx0XHRpZiAodHlwZW9mIG9ic2VydmVyT3JOZXh0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXIgPSB7XG5cdFx0XHRcdFx0XHRuZXh0OiBvYnNlcnZlck9yTmV4dFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdG9ic2VydmVyLmVycm9yID0gb25FcnJvcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIG9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdG9ic2VydmVyLmNvbXBsZXRlID0gb25Db21wbGV0ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXIgPSBvYnNlcnZlck9yTmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzdGFydFN1YnNjcmlwdGlvbih0aGlzLl9leGVjdXRvciwgb2JzZXJ2ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRAbm9uRW51bWVyYWJsZVxuXHRcdFx0c3RhdGljIG9mPFU+KC4uLml0ZW1zOiBVW10pOiBPYnNlcnZhYmxlPFU+IHtcblx0XHRcdFx0bGV0IGNvbnN0cnVjdG9yOiB0eXBlb2YgT2JzZXJ2YWJsZTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdHJ1Y3RvciA9IE9ic2VydmFibGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3RydWN0b3IgPSB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3Rvcigob2JzZXJ2ZXI6IFN1YnNjcmlwdGlvbk9ic2VydmVyPFU+KSA9PiB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBvIG9mIGl0ZW1zKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlci5uZXh0KG8pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvYnNlcnZlci5jb21wbGV0ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0QG5vbkVudW1lcmFibGVcblx0XHRcdHN0YXRpYyBmcm9tPFU+KGl0ZW06IEl0ZXJhYmxlPFU+IHwgQXJyYXlMaWtlPFU+IHwgT2JzZXJ2YWJsZTxVPik6IE9ic2VydmFibGU8VT4ge1xuXHRcdFx0XHRpZiAoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVtIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IGNvbnN0cnVjdG9yOiB0eXBlb2YgT2JzZXJ2YWJsZTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdHJ1Y3RvciA9IE9ic2VydmFibGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3RydWN0b3IgPSB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgb2JzZXJ2YWJsZVN5bWJvbCA9IChpdGVtIGFzIE9ic2VydmFibGU8VT4pW1N5bWJvbC5vYnNlcnZhYmxlXTtcblxuXHRcdFx0XHRpZiAob2JzZXJ2YWJsZVN5bWJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYnNlcnZhYmxlU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wub2JzZXJ2YWJsZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCByZXN1bHQ6IGFueSA9IG9ic2VydmFibGVTeW1ib2wuY2FsbChpdGVtKTtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0XHRyZXN1bHQgPT09IG51bGwgfHxcblx0XHRcdFx0XHRcdHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInIHx8XG5cdFx0XHRcdFx0XHR0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicgfHxcblx0XHRcdFx0XHRcdHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXR1cm4gdmFsdWUgb2YgU3ltYm9sLm9ic2VydmFibGUgbXVzdCBiZSBvYmplY3QnKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoKHJlc3VsdC5jb25zdHJ1Y3RvciAmJiByZXN1bHQuY29uc3RydWN0b3IgPT09IHRoaXMpIHx8IHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyZXN1bHQuc3Vic2NyaWJlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKHJlc3VsdC5zdWJzY3JpYmUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoY29uc3RydWN0b3Iub2YpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnN0cnVjdG9yLm9mKHJlc3VsdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gT2JzZXJ2YWJsZS5vZihyZXN1bHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpc0l0ZXJhYmxlKGl0ZW0pIHx8IGlzQXJyYXlMaWtlKGl0ZW0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3Rvcigob2JzZXJ2ZXI6IFN1YnNjcmlwdGlvbk9ic2VydmVyPFU+KSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoaXNBcnJheUxpa2UoaXRlbSkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0b2JzZXJ2ZXIubmV4dChpdGVtW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBvIG9mIGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0XHRvYnNlcnZlci5uZXh0KG8pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvYnNlcnZlci5jb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBpcyBuZWl0aGVyIE9ic2VydmFibGUgbm9yIEl0ZXJhYmxlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE9ic2VydmFibGU7XG5cdH0pKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9ic2VydmFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IFRoZW5hYmxlIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHsgcXVldWVNaWNyb1Rhc2sgfSBmcm9tICcuL3N1cHBvcnQvcXVldWUnO1xuaW1wb3J0IHsgSXRlcmFibGUgfSBmcm9tICcuL2l0ZXJhdG9yJztcbmltcG9ydCAnLi9TeW1ib2wnO1xuaW1wb3J0IGhhcyBmcm9tICcuL3N1cHBvcnQvaGFzJztcblxuLyoqXG4gKiBFeGVjdXRvciBpcyB0aGUgaW50ZXJmYWNlIGZvciBmdW5jdGlvbnMgdXNlZCB0byBpbml0aWFsaXplIGEgUHJvbWlzZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeGVjdXRvcjxUPiB7XG5cdC8qKlxuXHQgKiBUaGUgZXhlY3V0b3IgZm9yIHRoZSBwcm9taXNlXG5cdCAqXG5cdCAqIEBwYXJhbSByZXNvbHZlIFRoZSByZXNvbHZlciBjYWxsYmFjayBvZiB0aGUgcHJvbWlzZVxuXHQgKiBAcGFyYW0gcmVqZWN0IFRoZSByZWplY3RvciBjYWxsYmFjayBvZiB0aGUgcHJvbWlzZVxuXHQgKi9cblx0KHJlc29sdmU6ICh2YWx1ZT86IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkKTogdm9pZDtcbn1cblxuZXhwb3J0IGxldCBTaGltUHJvbWlzZTogdHlwZW9mIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcblxuZXhwb3J0IGNvbnN0IGlzVGhlbmFibGUgPSBmdW5jdGlvbiBpc1RoZW5hYmxlPFQ+KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBQcm9taXNlTGlrZTxUPiB7XG5cdHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmlmICghaGFzKCdlczYtcHJvbWlzZScpKSB7XG5cdGNvbnN0IGVudW0gU3RhdGUge1xuXHRcdEZ1bGZpbGxlZCxcblx0XHRQZW5kaW5nLFxuXHRcdFJlamVjdGVkXG5cdH1cblxuXHRnbG9iYWwuUHJvbWlzZSA9IFNoaW1Qcm9taXNlID0gY2xhc3MgUHJvbWlzZTxUPiBpbXBsZW1lbnRzIFRoZW5hYmxlPFQ+IHtcblx0XHRzdGF0aWMgYWxsKGl0ZXJhYmxlOiBJdGVyYWJsZTxhbnkgfCBQcm9taXNlTGlrZTxhbnk+PiB8IChhbnkgfCBQcm9taXNlTGlrZTxhbnk+KVtdKTogUHJvbWlzZTxhbnk+IHtcblx0XHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0Y29uc3QgdmFsdWVzOiBhbnlbXSA9IFtdO1xuXHRcdFx0XHRsZXQgY29tcGxldGUgPSAwO1xuXHRcdFx0XHRsZXQgdG90YWwgPSAwO1xuXHRcdFx0XHRsZXQgcG9wdWxhdGluZyA9IHRydWU7XG5cblx0XHRcdFx0ZnVuY3Rpb24gZnVsZmlsbChpbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KTogdm9pZCB7XG5cdFx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHRcdFx0XHRcdCsrY29tcGxldGU7XG5cdFx0XHRcdFx0ZmluaXNoKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBmaW5pc2goKTogdm9pZCB7XG5cdFx0XHRcdFx0aWYgKHBvcHVsYXRpbmcgfHwgY29tcGxldGUgPCB0b3RhbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNvbHZlKHZhbHVlcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBwcm9jZXNzSXRlbShpbmRleDogbnVtYmVyLCBpdGVtOiBhbnkpOiB2b2lkIHtcblx0XHRcdFx0XHQrK3RvdGFsO1xuXHRcdFx0XHRcdGlmIChpc1RoZW5hYmxlKGl0ZW0pKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiBhbiBpdGVtIFByb21pc2UgcmVqZWN0cywgdGhpcyBQcm9taXNlIGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlIGl0ZW1cblx0XHRcdFx0XHRcdC8vIFByb21pc2UncyByZWplY3Rpb24gZXJyb3IuXG5cdFx0XHRcdFx0XHRpdGVtLnRoZW4oZnVsZmlsbC5iaW5kKG51bGwsIGluZGV4KSwgcmVqZWN0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKGl0ZW0pLnRoZW4oZnVsZmlsbC5iaW5kKG51bGwsIGluZGV4KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG5cdFx0XHRcdFx0cHJvY2Vzc0l0ZW0oaSwgdmFsdWUpO1xuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3B1bGF0aW5nID0gZmFsc2U7XG5cblx0XHRcdFx0ZmluaXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRzdGF0aWMgcmFjZTxUPihpdGVyYWJsZTogSXRlcmFibGU8VCB8IFByb21pc2VMaWtlPFQ+PiB8IChUIHwgUHJvbWlzZUxpa2U8VD4pW10pOiBQcm9taXNlPFRbXT4ge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uKHJlc29sdmU6ICh2YWx1ZT86IGFueSkgPT4gdm9pZCwgcmVqZWN0KSB7XG5cdFx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuXHRcdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgYSBQcm9taXNlIGl0ZW0gcmVqZWN0cywgdGhpcyBQcm9taXNlIGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlIGl0ZW1cblx0XHRcdFx0XHRcdC8vIFByb21pc2UncyByZWplY3Rpb24gZXJyb3IuXG5cdFx0XHRcdFx0XHRpdGVtLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKGl0ZW0pLnRoZW4ocmVzb2x2ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRzdGF0aWMgcmVqZWN0KHJlYXNvbj86IGFueSk6IFByb21pc2U8bmV2ZXI+IHtcblx0XHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0cmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRzdGF0aWMgcmVzb2x2ZSgpOiBQcm9taXNlPHZvaWQ+O1xuXHRcdHN0YXRpYyByZXNvbHZlPFQ+KHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlPFQ+O1xuXHRcdHN0YXRpYyByZXNvbHZlPFQ+KHZhbHVlPzogYW55KTogUHJvbWlzZTxUPiB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHRcdFx0XHRyZXNvbHZlKDxUPnZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBbU3ltYm9sLnNwZWNpZXNdOiBQcm9taXNlQ29uc3RydWN0b3IgPSBTaGltUHJvbWlzZSBhcyBQcm9taXNlQ29uc3RydWN0b3I7XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFByb21pc2UuXG5cdFx0ICpcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBleGVjdXRvclxuXHRcdCAqIFRoZSBleGVjdXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgUHJvbWlzZSBpcyBpbnN0YW50aWF0ZWQuIEl0IGlzIHJlc3BvbnNpYmxlIGZvclxuXHRcdCAqIHN0YXJ0aW5nIHRoZSBhc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoZW4gaXQgaXMgaW52b2tlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSBleGVjdXRvciBtdXN0IGNhbGwgZWl0aGVyIHRoZSBwYXNzZWQgYHJlc29sdmVgIGZ1bmN0aW9uIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxuXHRcdCAqIHN1Y2Nlc3NmdWxseSwgb3IgdGhlIGByZWplY3RgIGZ1bmN0aW9uIHdoZW4gdGhlIG9wZXJhdGlvbiBmYWlscy5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3RvcihleGVjdXRvcjogRXhlY3V0b3I8VD4pIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogSWYgdHJ1ZSwgdGhlIHJlc29sdXRpb24gb2YgdGhpcyBwcm9taXNlIGlzIGNoYWluZWQgKFwibG9ja2VkIGluXCIpIHRvIGFub3RoZXIgcHJvbWlzZS5cblx0XHRcdCAqL1xuXHRcdFx0bGV0IGlzQ2hhaW5lZCA9IGZhbHNlO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZXRoZXIgb3Igbm90IHRoaXMgcHJvbWlzZSBpcyBpbiBhIHJlc29sdmVkIHN0YXRlLlxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCBpc1Jlc29sdmVkID0gKCk6IGJvb2xlYW4gPT4ge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUGVuZGluZyB8fCBpc0NoYWluZWQ7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIENhbGxiYWNrcyB0aGF0IHNob3VsZCBiZSBpbnZva2VkIG9uY2UgdGhlIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cblx0XHRcdCAqL1xuXHRcdFx0bGV0IGNhbGxiYWNrczogbnVsbCB8IChBcnJheTwoKSA9PiB2b2lkPikgPSBbXTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbml0aWFsbHkgcHVzaGVzIGNhbGxiYWNrcyBvbnRvIGEgcXVldWUgZm9yIGV4ZWN1dGlvbiBvbmNlIHRoaXMgcHJvbWlzZSBzZXR0bGVzLiBBZnRlciB0aGUgcHJvbWlzZSBzZXR0bGVzLFxuXHRcdFx0ICogZW5xdWV1ZXMgY2FsbGJhY2tzIGZvciBleGVjdXRpb24gb24gdGhlIG5leHQgZXZlbnQgbG9vcCB0dXJuLlxuXHRcdFx0ICovXG5cdFx0XHRsZXQgd2hlbkZpbmlzaGVkID0gZnVuY3Rpb24oY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrcykge1xuXHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXR0bGVzIHRoaXMgcHJvbWlzZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHJlc29sdmVkIHN0YXRlIGZvciB0aGlzIHByb21pc2UuXG5cdFx0XHQgKiBAcGFyYW0ge1R8YW55fSB2YWx1ZSBUaGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoaXMgcHJvbWlzZS5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3Qgc2V0dGxlID0gKG5ld1N0YXRlOiBTdGF0ZSwgdmFsdWU6IGFueSk6IHZvaWQgPT4ge1xuXHRcdFx0XHQvLyBBIHByb21pc2UgY2FuIG9ubHkgYmUgc2V0dGxlZCBvbmNlLlxuXHRcdFx0XHRpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUGVuZGluZykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHdoZW5GaW5pc2hlZCA9IHF1ZXVlTWljcm9UYXNrO1xuXG5cdFx0XHRcdC8vIE9ubHkgZW5xdWV1ZSBhIGNhbGxiYWNrIHJ1bm5lciBpZiB0aGVyZSBhcmUgY2FsbGJhY2tzIHNvIHRoYXQgaW5pdGlhbGx5IGZ1bGZpbGxlZCBQcm9taXNlcyBkb24ndCBoYXZlIHRvXG5cdFx0XHRcdC8vIHdhaXQgYW4gZXh0cmEgdHVybi5cblx0XHRcdFx0aWYgKGNhbGxiYWNrcyAmJiBjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uKCk6IHZvaWQge1xuXHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrcykge1xuXHRcdFx0XHRcdFx0XHRsZXQgY291bnQgPSBjYWxsYmFja3MubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja3NbaV0uY2FsbChudWxsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlc29sdmVzIHRoaXMgcHJvbWlzZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHJlc29sdmVkIHN0YXRlIGZvciB0aGlzIHByb21pc2UuXG5cdFx0XHQgKiBAcGFyYW0ge1R8YW55fSB2YWx1ZSBUaGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoaXMgcHJvbWlzZS5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgcmVzb2x2ZSA9IChuZXdTdGF0ZTogU3RhdGUsIHZhbHVlOiBhbnkpOiB2b2lkID0+IHtcblx0XHRcdFx0aWYgKGlzUmVzb2x2ZWQoKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc1RoZW5hYmxlKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhbHVlLnRoZW4oc2V0dGxlLmJpbmQobnVsbCwgU3RhdGUuRnVsZmlsbGVkKSwgc2V0dGxlLmJpbmQobnVsbCwgU3RhdGUuUmVqZWN0ZWQpKTtcblx0XHRcdFx0XHRpc0NoYWluZWQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldHRsZShuZXdTdGF0ZSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnRoZW4gPSA8VFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcblx0XHRcdFx0b25GdWxmaWxsZWQ/OiAoKHZhbHVlOiBUKSA9PiBUUmVzdWx0MSB8IFByb21pc2VMaWtlPFRSZXN1bHQxPikgfCB1bmRlZmluZWQgfCBudWxsLFxuXHRcdFx0XHRvblJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbFxuXHRcdFx0KTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiA9PiB7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRcdFx0Ly8gd2hlbkZpbmlzaGVkIGluaXRpYWxseSBxdWV1ZXMgdXAgY2FsbGJhY2tzIGZvciBleGVjdXRpb24gYWZ0ZXIgdGhlIHByb21pc2UgaGFzIHNldHRsZWQuIE9uY2UgdGhlXG5cdFx0XHRcdFx0Ly8gcHJvbWlzZSBoYXMgc2V0dGxlZCwgd2hlbkZpbmlzaGVkIHdpbGwgc2NoZWR1bGUgY2FsbGJhY2tzIGZvciBleGVjdXRpb24gb24gdGhlIG5leHQgdHVybiB0aHJvdWdoIHRoZVxuXHRcdFx0XHRcdC8vIGV2ZW50IGxvb3AuXG5cdFx0XHRcdFx0d2hlbkZpbmlzaGVkKCgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrOiAoKHZhbHVlPzogYW55KSA9PiBhbnkpIHwgdW5kZWZpbmVkIHwgbnVsbCA9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPT09IFN0YXRlLlJlamVjdGVkID8gb25SZWplY3RlZCA6IG9uRnVsZmlsbGVkO1xuXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjYWxsYmFjayh0aGlzLnJlc29sdmVkVmFsdWUpKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlJlamVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdCh0aGlzLnJlc29sdmVkVmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSh0aGlzLnJlc29sdmVkVmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGV4ZWN1dG9yKHJlc29sdmUuYmluZChudWxsLCBTdGF0ZS5GdWxmaWxsZWQpLCByZXNvbHZlLmJpbmQobnVsbCwgU3RhdGUuUmVqZWN0ZWQpKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHNldHRsZShTdGF0ZS5SZWplY3RlZCwgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG5cdFx0XHRvblJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdCB8IFByb21pc2VMaWtlPFRSZXN1bHQ+KSB8IHVuZGVmaW5lZCB8IG51bGxcblx0XHQpOiBQcm9taXNlPFQgfCBUUmVzdWx0PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBwcm9taXNlLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgc3RhdGUgPSBTdGF0ZS5QZW5kaW5nO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlc29sdmVkIHZhbHVlIGZvciB0aGlzIHByb21pc2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VHxhbnl9XG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZXNvbHZlZFZhbHVlOiBhbnk7XG5cblx0XHR0aGVuOiA8VFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcblx0XHRcdG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcblx0XHRcdG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPikgfCB1bmRlZmluZWQgfCBudWxsXG5cdFx0KSA9PiBQcm9taXNlPFRSZXN1bHQxIHwgVFJlc3VsdDI+O1xuXG5cdFx0W1N5bWJvbC50b1N0cmluZ1RhZ106ICdQcm9taXNlJyA9ICdQcm9taXNlJztcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2hpbVByb21pc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gUHJvbWlzZS50cyIsImltcG9ydCBoYXMgZnJvbSAnLi9zdXBwb3J0L2hhcyc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IGdldFZhbHVlRGVzY3JpcHRvciB9IGZyb20gJy4vc3VwcG9ydC91dGlsJztcblxuZGVjbGFyZSBnbG9iYWwge1xuXHRpbnRlcmZhY2UgU3ltYm9sQ29uc3RydWN0b3Ige1xuXHRcdG9ic2VydmFibGU6IHN5bWJvbDtcblx0fVxufVxuXG5leHBvcnQgbGV0IFN5bWJvbDogU3ltYm9sQ29uc3RydWN0b3IgPSBnbG9iYWwuU3ltYm9sO1xuXG5pZiAoIWhhcygnZXM2LXN5bWJvbCcpKSB7XG5cdC8qKlxuXHQgKiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBhIHN5bWJvbCwgdXNlZCBpbnRlcm5hbGx5IHdpdGhpbiB0aGUgU2hpbVxuXHQgKiBAcGFyYW0gIHthbnl9ICAgIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVja1xuXHQgKiBAcmV0dXJuIHtzeW1ib2x9ICAgICAgIFJldHVybnMgdGhlIHN5bWJvbCBvciB0aHJvd3Ncblx0ICovXG5cdGNvbnN0IHZhbGlkYXRlU3ltYm9sID0gZnVuY3Rpb24gdmFsaWRhdGVTeW1ib2wodmFsdWU6IGFueSk6IHN5bWJvbCB7XG5cdFx0aWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0Y29uc3QgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuXHRjb25zdCBkZWZpbmVQcm9wZXJ0eTogKFxuXHRcdG86IGFueSxcblx0XHRwOiBzdHJpbmcgfCBzeW1ib2wsXG5cdFx0YXR0cmlidXRlczogUHJvcGVydHlEZXNjcmlwdG9yICYgVGhpc1R5cGU8YW55PlxuXHQpID0+IGFueSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhcyBhbnk7XG5cdGNvbnN0IGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cblx0Y29uc3Qgb2JqUHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHRjb25zdCBnbG9iYWxTeW1ib2xzOiB7IFtrZXk6IHN0cmluZ106IHN5bWJvbCB9ID0ge307XG5cblx0Y29uc3QgZ2V0U3ltYm9sTmFtZSA9IChmdW5jdGlvbigpIHtcblx0XHRjb25zdCBjcmVhdGVkID0gY3JlYXRlKG51bGwpO1xuXHRcdHJldHVybiBmdW5jdGlvbihkZXNjOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuXHRcdFx0bGV0IHBvc3RmaXggPSAwO1xuXHRcdFx0bGV0IG5hbWU6IHN0cmluZztcblx0XHRcdHdoaWxlIChjcmVhdGVkW1N0cmluZyhkZXNjKSArIChwb3N0Zml4IHx8ICcnKV0pIHtcblx0XHRcdFx0Kytwb3N0Zml4O1xuXHRcdFx0fVxuXHRcdFx0ZGVzYyArPSBTdHJpbmcocG9zdGZpeCB8fCAnJyk7XG5cdFx0XHRjcmVhdGVkW2Rlc2NdID0gdHJ1ZTtcblx0XHRcdG5hbWUgPSAnQEAnICsgZGVzYztcblxuXHRcdFx0Ly8gRklYTUU6IFRlbXBvcmFyeSBndWFyZCB1bnRpbCB0aGUgZHVwbGljYXRlIGV4ZWN1dGlvbiB3aGVuIHRlc3RpbmcgY2FuIGJlXG5cdFx0XHQvLyBwaW5uZWQgZG93bi5cblx0XHRcdGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmpQcm90b3R5cGUsIG5hbWUpKSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KG9ialByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odGhpczogU3ltYm9sLCB2YWx1ZTogYW55KSB7XG5cdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBnZXRWYWx1ZURlc2NyaXB0b3IodmFsdWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9O1xuXHR9KSgpO1xuXG5cdGNvbnN0IEludGVybmFsU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKHRoaXM6IGFueSwgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCBudW1iZXIpOiBzeW1ib2wge1xuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgSW50ZXJuYWxTeW1ib2wpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGVFcnJvcjogU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG5cdFx0fVxuXHRcdHJldHVybiBTeW1ib2woZGVzY3JpcHRpb24pO1xuXHR9O1xuXG5cdFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2wodGhpczogU3ltYm9sLCBkZXNjcmlwdGlvbj86IHN0cmluZyB8IG51bWJlcik6IHN5bWJvbCB7XG5cdFx0aWYgKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGVFcnJvcjogU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG5cdFx0fVxuXHRcdGNvbnN0IHN5bSA9IE9iamVjdC5jcmVhdGUoSW50ZXJuYWxTeW1ib2wucHJvdG90eXBlKTtcblx0XHRkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhkZXNjcmlwdGlvbik7XG5cdFx0cmV0dXJuIGRlZmluZVByb3BlcnRpZXMoc3ltLCB7XG5cdFx0XHRfX2Rlc2NyaXB0aW9uX186IGdldFZhbHVlRGVzY3JpcHRvcihkZXNjcmlwdGlvbiksXG5cdFx0XHRfX25hbWVfXzogZ2V0VmFsdWVEZXNjcmlwdG9yKGdldFN5bWJvbE5hbWUoZGVzY3JpcHRpb24pKVxuXHRcdH0pO1xuXHR9IGFzIFN5bWJvbENvbnN0cnVjdG9yO1xuXG5cdC8qIERlY29yYXRlIHRoZSBTeW1ib2wgZnVuY3Rpb24gd2l0aCB0aGUgYXBwcm9wcmlhdGUgcHJvcGVydGllcyAqL1xuXHRkZWZpbmVQcm9wZXJ0eShcblx0XHRTeW1ib2wsXG5cdFx0J2ZvcicsXG5cdFx0Z2V0VmFsdWVEZXNjcmlwdG9yKGZ1bmN0aW9uKGtleTogc3RyaW5nKTogc3ltYm9sIHtcblx0XHRcdGlmIChnbG9iYWxTeW1ib2xzW2tleV0pIHtcblx0XHRcdFx0cmV0dXJuIGdsb2JhbFN5bWJvbHNba2V5XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoZ2xvYmFsU3ltYm9sc1trZXldID0gU3ltYm9sKFN0cmluZyhrZXkpKSk7XG5cdFx0fSlcblx0KTtcblx0ZGVmaW5lUHJvcGVydGllcyhTeW1ib2wsIHtcblx0XHRrZXlGb3I6IGdldFZhbHVlRGVzY3JpcHRvcihmdW5jdGlvbihzeW06IHN5bWJvbCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG5cdFx0XHRsZXQga2V5OiBzdHJpbmc7XG5cdFx0XHR2YWxpZGF0ZVN5bWJvbChzeW0pO1xuXHRcdFx0Zm9yIChrZXkgaW4gZ2xvYmFsU3ltYm9scykge1xuXHRcdFx0XHRpZiAoZ2xvYmFsU3ltYm9sc1trZXldID09PSBzeW0pIHtcblx0XHRcdFx0XHRyZXR1cm4ga2V5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0aGFzSW5zdGFuY2U6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdoYXNJbnN0YW5jZScpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdGlzQ29uY2F0U3ByZWFkYWJsZTogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ2lzQ29uY2F0U3ByZWFkYWJsZScpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdGl0ZXJhdG9yOiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcignaXRlcmF0b3InKSwgZmFsc2UsIGZhbHNlKSxcblx0XHRtYXRjaDogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ21hdGNoJyksIGZhbHNlLCBmYWxzZSksXG5cdFx0b2JzZXJ2YWJsZTogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ29ic2VydmFibGUnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHRyZXBsYWNlOiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcigncmVwbGFjZScpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdHNlYXJjaDogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ3NlYXJjaCcpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdHNwZWNpZXM6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdzcGVjaWVzJyksIGZhbHNlLCBmYWxzZSksXG5cdFx0c3BsaXQ6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCdzcGxpdCcpLCBmYWxzZSwgZmFsc2UpLFxuXHRcdHRvUHJpbWl0aXZlOiBnZXRWYWx1ZURlc2NyaXB0b3IoU3ltYm9sLmZvcigndG9QcmltaXRpdmUnKSwgZmFsc2UsIGZhbHNlKSxcblx0XHR0b1N0cmluZ1RhZzogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3IoJ3RvU3RyaW5nVGFnJyksIGZhbHNlLCBmYWxzZSksXG5cdFx0dW5zY29wYWJsZXM6IGdldFZhbHVlRGVzY3JpcHRvcihTeW1ib2wuZm9yKCd1bnNjb3BhYmxlcycpLCBmYWxzZSwgZmFsc2UpXG5cdH0pO1xuXG5cdC8qIERlY29yYXRlIHRoZSBJbnRlcm5hbFN5bWJvbCBvYmplY3QgKi9cblx0ZGVmaW5lUHJvcGVydGllcyhJbnRlcm5hbFN5bWJvbC5wcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbCksXG5cdFx0dG9TdHJpbmc6IGdldFZhbHVlRGVzY3JpcHRvcihcblx0XHRcdGZ1bmN0aW9uKHRoaXM6IHsgX19uYW1lX186IHN0cmluZyB9KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fbmFtZV9fO1xuXHRcdFx0fSxcblx0XHRcdGZhbHNlLFxuXHRcdFx0ZmFsc2Vcblx0XHQpXG5cdH0pO1xuXG5cdC8qIERlY29yYXRlIHRoZSBTeW1ib2wucHJvdG90eXBlICovXG5cdGRlZmluZVByb3BlcnRpZXMoU3ltYm9sLnByb3RvdHlwZSwge1xuXHRcdHRvU3RyaW5nOiBnZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24odGhpczogU3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gJ1N5bWJvbCAoJyArICg8YW55PnZhbGlkYXRlU3ltYm9sKHRoaXMpKS5fX2Rlc2NyaXB0aW9uX18gKyAnKSc7XG5cdFx0fSksXG5cdFx0dmFsdWVPZjogZ2V0VmFsdWVEZXNjcmlwdG9yKGZ1bmN0aW9uKHRoaXM6IFN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRlU3ltYm9sKHRoaXMpO1xuXHRcdH0pXG5cdH0pO1xuXG5cdGRlZmluZVByb3BlcnR5KFxuXHRcdFN5bWJvbC5wcm90b3R5cGUsXG5cdFx0U3ltYm9sLnRvUHJpbWl0aXZlLFxuXHRcdGdldFZhbHVlRGVzY3JpcHRvcihmdW5jdGlvbih0aGlzOiBTeW1ib2wpIHtcblx0XHRcdHJldHVybiB2YWxpZGF0ZVN5bWJvbCh0aGlzKTtcblx0XHR9KVxuXHQpO1xuXHRkZWZpbmVQcm9wZXJ0eShTeW1ib2wucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGdldFZhbHVlRGVzY3JpcHRvcignU3ltYm9sJywgZmFsc2UsIGZhbHNlLCB0cnVlKSk7XG5cblx0ZGVmaW5lUHJvcGVydHkoXG5cdFx0SW50ZXJuYWxTeW1ib2wucHJvdG90eXBlLFxuXHRcdFN5bWJvbC50b1ByaW1pdGl2ZSxcblx0XHRnZXRWYWx1ZURlc2NyaXB0b3IoKDxhbnk+U3ltYm9sKS5wcm90b3R5cGVbU3ltYm9sLnRvUHJpbWl0aXZlXSwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuXHQpO1xuXHRkZWZpbmVQcm9wZXJ0eShcblx0XHRJbnRlcm5hbFN5bWJvbC5wcm90b3R5cGUsXG5cdFx0U3ltYm9sLnRvU3RyaW5nVGFnLFxuXHRcdGdldFZhbHVlRGVzY3JpcHRvcigoPGFueT5TeW1ib2wpLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddLCBmYWxzZSwgZmFsc2UsIHRydWUpXG5cdCk7XG59XG5cbi8qKlxuICogQSBjdXN0b20gZ3VhcmQgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBpcyBhIHN5bWJvbCBvciBub3RcbiAqIEBwYXJhbSAge2FueX0gICAgICAgdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyBhIHN5bWJvbCBvciBub3RcbiAqIEByZXR1cm4ge2lzIHN5bWJvbH0gICAgICAgUmV0dXJucyB0cnVlIGlmIGEgc3ltYm9sIG9yIG5vdCAoYW5kIG5hcnJvd3MgdGhlIHR5cGUgZ3VhcmQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZTogYW55KTogdmFsdWUgaXMgc3ltYm9sIHtcblx0cmV0dXJuICh2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fCB2YWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykpIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbGwgYW55IG1pc3Npbmcgd2VsbCBrbm93biBzeW1ib2xzIGlmIHRoZSBuYXRpdmUgU3ltYm9sIGlzIG1pc3NpbmcgdGhlbVxuICovXG5bXG5cdCdoYXNJbnN0YW5jZScsXG5cdCdpc0NvbmNhdFNwcmVhZGFibGUnLFxuXHQnaXRlcmF0b3InLFxuXHQnc3BlY2llcycsXG5cdCdyZXBsYWNlJyxcblx0J3NlYXJjaCcsXG5cdCdzcGxpdCcsXG5cdCdtYXRjaCcsXG5cdCd0b1ByaW1pdGl2ZScsXG5cdCd0b1N0cmluZ1RhZycsXG5cdCd1bnNjb3BhYmxlcycsXG5cdCdvYnNlcnZhYmxlJ1xuXS5mb3JFYWNoKCh3ZWxsS25vd24pID0+IHtcblx0aWYgKCEoU3ltYm9sIGFzIGFueSlbd2VsbEtub3duXSkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW1ib2wsIHdlbGxLbm93biwgZ2V0VmFsdWVEZXNjcmlwdG9yKFN5bWJvbC5mb3Iod2VsbEtub3duKSwgZmFsc2UsIGZhbHNlKSk7XG5cdH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gU3ltYm9sLnRzIiwiaW1wb3J0IGdsb2JhbCBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgeyBpc0FycmF5TGlrZSwgSXRlcmFibGUgfSBmcm9tICcuL2l0ZXJhdG9yJztcbmltcG9ydCBoYXMgZnJvbSAnLi9zdXBwb3J0L2hhcyc7XG5pbXBvcnQgJy4vU3ltYm9sJztcblxuZXhwb3J0IGludGVyZmFjZSBXZWFrTWFwPEsgZXh0ZW5kcyBvYmplY3QsIFY+IHtcblx0LyoqXG5cdCAqIFJlbW92ZSBhIGBrZXlgIGZyb20gdGhlIG1hcFxuXHQgKlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlXG5cdCAqIEByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSB3YXMgcmVtb3ZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcblx0ICovXG5cdGRlbGV0ZShrZXk6IEspOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSB0aGUgdmFsdWUsIGJhc2VkIG9uIHRoZSBzdXBwbGllZCBga2V5YFxuXHQgKlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIGB2YWx1ZWAgZm9yXG5cdCAqIEByZXR1cm4gdGhlIGB2YWx1ZWAgYmFzZWQgb24gdGhlIGBrZXlgIGlmIGZvdW5kLCBvdGhlcndpc2UgYGZhbHNlYFxuXHQgKi9cblx0Z2V0KGtleTogSyk6IFYgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgYSBga2V5YCBpcyBwcmVzZW50IGluIHRoZSBtYXBcblx0ICpcblx0ICogQHBhcmFtIGtleSBUaGUgYGtleWAgdG8gY2hlY2tcblx0ICogQHJldHVybiBgdHJ1ZWAgaWYgdGhlIGtleSBpcyBwYXJ0IG9mIHRoZSBtYXAsIG90aGVyd2lzZSBgZmFsc2VgLlxuXHQgKi9cblx0aGFzKGtleTogSyk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFNldCBhIGB2YWx1ZWAgZm9yIGEgcGFydGljdWxhciBga2V5YC5cblx0ICpcblx0ICogQHBhcmFtIGtleSBUaGUgYGtleWAgdG8gc2V0IHRoZSBgdmFsdWVgIGZvclxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGB2YWx1ZWAgdG8gc2V0XG5cdCAqIEByZXR1cm4gdGhlIGluc3RhbmNlc1xuXHQgKi9cblx0c2V0KGtleTogSywgdmFsdWU6IFYpOiB0aGlzO1xuXG5cdHJlYWRvbmx5IFtTeW1ib2wudG9TdHJpbmdUYWddOiAnV2Vha01hcCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vha01hcENvbnN0cnVjdG9yIHtcblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIGBXZWFrTWFwYFxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdG5ldyAoKTogV2Vha01hcDxvYmplY3QsIGFueT47XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIGBXZWFrTWFwYFxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIGl0ZXJhYmxlIEFuIGl0ZXJhYmxlIHRoYXQgY29udGFpbnMgeWllbGRzIHVwIGtleS92YWx1ZSBwYWlyIGVudHJpZXNcblx0ICovXG5cdG5ldyA8SyBleHRlbmRzIG9iamVjdCwgVj4oaXRlcmFibGU/OiBbSywgVl1bXSk6IFdlYWtNYXA8SywgVj47XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIGBXZWFrTWFwYFxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIGl0ZXJhYmxlIEFuIGl0ZXJhYmxlIHRoYXQgY29udGFpbnMgeWllbGRzIHVwIGtleS92YWx1ZSBwYWlyIGVudHJpZXNcblx0ICovXG5cdG5ldyA8SyBleHRlbmRzIG9iamVjdCwgVj4oaXRlcmFibGU6IEl0ZXJhYmxlPFtLLCBWXT4pOiBXZWFrTWFwPEssIFY+O1xuXG5cdHJlYWRvbmx5IHByb3RvdHlwZTogV2Vha01hcDxvYmplY3QsIGFueT47XG59XG5cbmV4cG9ydCBsZXQgV2Vha01hcDogV2Vha01hcENvbnN0cnVjdG9yID0gZ2xvYmFsLldlYWtNYXA7XG5cbmludGVyZmFjZSBFbnRyeTxLLCBWPiB7XG5cdGtleTogSztcblx0dmFsdWU6IFY7XG59XG5cbmlmICghaGFzKCdlczYtd2Vha21hcCcpKSB7XG5cdGNvbnN0IERFTEVURUQ6IGFueSA9IHt9O1xuXG5cdGNvbnN0IGdldFVJRCA9IGZ1bmN0aW9uIGdldFVJRCgpOiBudW1iZXIge1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuXHR9O1xuXG5cdGNvbnN0IGdlbmVyYXRlTmFtZSA9IChmdW5jdGlvbigpIHtcblx0XHRsZXQgc3RhcnRJZCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAlIDEwMDAwMDAwMCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGVOYW1lKCk6IHN0cmluZyB7XG5cdFx0XHRyZXR1cm4gJ19fd20nICsgZ2V0VUlEKCkgKyAoc3RhcnRJZCsrICsgJ19fJyk7XG5cdFx0fTtcblx0fSkoKTtcblxuXHRXZWFrTWFwID0gY2xhc3MgV2Vha01hcDxLLCBWPiB7XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfbmFtZTogc3RyaW5nO1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgX2Zyb3plbkVudHJpZXM6IEVudHJ5PEssIFY+W107XG5cblx0XHRjb25zdHJ1Y3RvcihpdGVyYWJsZT86IEFycmF5TGlrZTxbSywgVl0+IHwgSXRlcmFibGU8W0ssIFZdPikge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfbmFtZScsIHtcblx0XHRcdFx0dmFsdWU6IGdlbmVyYXRlTmFtZSgpXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fZnJvemVuRW50cmllcyA9IFtdO1xuXG5cdFx0XHRpZiAoaXRlcmFibGUpIHtcblx0XHRcdFx0aWYgKGlzQXJyYXlMaWtlKGl0ZXJhYmxlKSkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGl0ZW0gPSBpdGVyYWJsZVtpXTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KGl0ZW1bMF0sIGl0ZW1bMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVyYWJsZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cHJpdmF0ZSBfZ2V0RnJvemVuRW50cnlJbmRleChrZXk6IGFueSk6IG51bWJlciB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2Zyb3plbkVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRoaXMuX2Zyb3plbkVudHJpZXNbaV0ua2V5ID09PSBrZXkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlKGtleTogYW55KTogYm9vbGVhbiB7XG5cdFx0XHRpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW50cnk6IEVudHJ5PEssIFY+ID0ga2V5W3RoaXMuX25hbWVdO1xuXHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5LmtleSA9PT0ga2V5ICYmIGVudHJ5LnZhbHVlICE9PSBERUxFVEVEKSB7XG5cdFx0XHRcdGVudHJ5LnZhbHVlID0gREVMRVRFRDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZyb3plbkluZGV4ID0gdGhpcy5fZ2V0RnJvemVuRW50cnlJbmRleChrZXkpO1xuXHRcdFx0aWYgKGZyb3plbkluZGV4ID49IDApIHtcblx0XHRcdFx0dGhpcy5fZnJvemVuRW50cmllcy5zcGxpY2UoZnJvemVuSW5kZXgsIDEpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGdldChrZXk6IGFueSk6IFYgfCB1bmRlZmluZWQge1xuXHRcdFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBlbnRyeTogRW50cnk8SywgVj4gPSBrZXlbdGhpcy5fbmFtZV07XG5cdFx0XHRpZiAoZW50cnkgJiYgZW50cnkua2V5ID09PSBrZXkgJiYgZW50cnkudmFsdWUgIT09IERFTEVURUQpIHtcblx0XHRcdFx0cmV0dXJuIGVudHJ5LnZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmcm96ZW5JbmRleCA9IHRoaXMuX2dldEZyb3plbkVudHJ5SW5kZXgoa2V5KTtcblx0XHRcdGlmIChmcm96ZW5JbmRleCA+PSAwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9mcm96ZW5FbnRyaWVzW2Zyb3plbkluZGV4XS52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYXMoa2V5OiBhbnkpOiBib29sZWFuIHtcblx0XHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBlbnRyeTogRW50cnk8SywgVj4gPSBrZXlbdGhpcy5fbmFtZV07XG5cdFx0XHRpZiAoQm9vbGVhbihlbnRyeSAmJiBlbnRyeS5rZXkgPT09IGtleSAmJiBlbnRyeS52YWx1ZSAhPT0gREVMRVRFRCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZyb3plbkluZGV4ID0gdGhpcy5fZ2V0RnJvemVuRW50cnlJbmRleChrZXkpO1xuXHRcdFx0aWYgKGZyb3plbkluZGV4ID49IDApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRzZXQoa2V5OiBhbnksIHZhbHVlPzogYW55KTogdGhpcyB7XG5cdFx0XHRpZiAoIWtleSB8fCAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleSAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2YWx1ZSB1c2VkIGFzIHdlYWsgbWFwIGtleScpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGVudHJ5OiBFbnRyeTxLLCBWPiA9IGtleVt0aGlzLl9uYW1lXTtcblx0XHRcdGlmICghZW50cnkgfHwgZW50cnkua2V5ICE9PSBrZXkpIHtcblx0XHRcdFx0ZW50cnkgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcblx0XHRcdFx0XHRrZXk6IHsgdmFsdWU6IGtleSB9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChPYmplY3QuaXNGcm96ZW4oa2V5KSkge1xuXHRcdFx0XHRcdHRoaXMuX2Zyb3plbkVudHJpZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5fbmFtZSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IGVudHJ5XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVudHJ5LnZhbHVlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1dlYWtNYXAnID0gJ1dlYWtNYXAnO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBXZWFrTWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFdlYWtNYXAudHMiLCJjb25zdCBnbG9iYWxPYmplY3Q6IGFueSA9IChmdW5jdGlvbigpOiBhbnkge1xuXHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQvLyBnbG9iYWwgc3BlYyBkZWZpbmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGNhbGxlZCAnZ2xvYmFsJ1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxuXHRcdC8vIGBnbG9iYWxgIGlzIGFsc28gZGVmaW5lZCBpbiBOb2RlSlNcblx0XHRyZXR1cm4gZ2xvYmFsO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0Ly8gd2luZG93IGlzIGRlZmluZWQgaW4gYnJvd3NlcnNcblx0XHRyZXR1cm4gd2luZG93O1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHRcdC8vIHNlbGYgaXMgZGVmaW5lZCBpbiBXZWJXb3JrZXJzXG5cdFx0cmV0dXJuIHNlbGY7XG5cdH1cbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbE9iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnbG9iYWwudHMiLCJpbXBvcnQgJy4vU3ltYm9sJztcbmltcG9ydCB7IEhJR0hfU1VSUk9HQVRFX01BWCwgSElHSF9TVVJST0dBVEVfTUlOIH0gZnJvbSAnLi9zdHJpbmcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZXJhdG9yUmVzdWx0PFQ+IHtcblx0cmVhZG9ubHkgZG9uZTogYm9vbGVhbjtcblx0cmVhZG9ubHkgdmFsdWU6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRlcmF0b3I8VD4ge1xuXHRuZXh0KHZhbHVlPzogYW55KTogSXRlcmF0b3JSZXN1bHQ8VD47XG5cblx0cmV0dXJuPyh2YWx1ZT86IGFueSk6IEl0ZXJhdG9yUmVzdWx0PFQ+O1xuXG5cdHRocm93PyhlPzogYW55KTogSXRlcmF0b3JSZXN1bHQ8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRlcmFibGU8VD4ge1xuXHRbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYXRvcjxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJdGVyYWJsZUl0ZXJhdG9yPFQ+IGV4dGVuZHMgSXRlcmF0b3I8VD4ge1xuXHRbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+O1xufVxuXG5jb25zdCBzdGF0aWNEb25lOiBJdGVyYXRvclJlc3VsdDxhbnk+ID0geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IF9zaGltc18gYW4gaXRlcmF0b3IgaW50ZXJmYWNlIG9uIGFycmF5IGxpa2Ugb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoaW1JdGVyYXRvcjxUPiB7XG5cdHByaXZhdGUgX2xpc3Q6IEFycmF5TGlrZTxUPjtcblx0cHJpdmF0ZSBfbmV4dEluZGV4ID0gLTE7XG5cdHByaXZhdGUgX25hdGl2ZUl0ZXJhdG9yOiBJdGVyYXRvcjxUPjtcblxuXHRjb25zdHJ1Y3RvcihsaXN0OiBBcnJheUxpa2U8VD4gfCBJdGVyYWJsZTxUPikge1xuXHRcdGlmIChpc0l0ZXJhYmxlKGxpc3QpKSB7XG5cdFx0XHR0aGlzLl9uYXRpdmVJdGVyYXRvciA9IGxpc3RbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9saXN0ID0gbGlzdDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBuZXh0IGl0ZXJhdGlvbiByZXN1bHQgZm9yIHRoZSBJdGVyYXRvclxuXHQgKi9cblx0bmV4dCgpOiBJdGVyYXRvclJlc3VsdDxUPiB7XG5cdFx0aWYgKHRoaXMuX25hdGl2ZUl0ZXJhdG9yKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmF0aXZlSXRlcmF0b3IubmV4dCgpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuX2xpc3QpIHtcblx0XHRcdHJldHVybiBzdGF0aWNEb25lO1xuXHRcdH1cblx0XHRpZiAoKyt0aGlzLl9uZXh0SW5kZXggPCB0aGlzLl9saXN0Lmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZG9uZTogZmFsc2UsXG5cdFx0XHRcdHZhbHVlOiB0aGlzLl9saXN0W3RoaXMuX25leHRJbmRleF1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBzdGF0aWNEb25lO1xuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxUPiB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHNvbWV0aGluZyBoYXMgYW4gSXRlcmFibGUgaW50ZXJmYWNlXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0eXBlIGd1YXJkIGFnYWluc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWU6IGFueSk6IHZhbHVlIGlzIEl0ZXJhYmxlPGFueT4ge1xuXHRyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiBzb21ldGhpbmcgaXMgQXJyYXlMaWtlXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0eXBlIGd1YXJkIGFnYWluc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBBcnJheUxpa2U8YW55PiB7XG5cdHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBmb3IgYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIGl0ZXJhYmxlIFRoZSBpdGVyYWJsZSBvYmplY3QgdG8gcmV0dXJuIHRoZSBpdGVyYXRvciBmb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldDxUPihpdGVyYWJsZTogSXRlcmFibGU8VD4gfCBBcnJheUxpa2U8VD4pOiBJdGVyYXRvcjxUPiB8IHVuZGVmaW5lZCB7XG5cdGlmIChpc0l0ZXJhYmxlKGl0ZXJhYmxlKSkge1xuXHRcdHJldHVybiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG5cdH0gZWxzZSBpZiAoaXNBcnJheUxpa2UoaXRlcmFibGUpKSB7XG5cdFx0cmV0dXJuIG5ldyBTaGltSXRlcmF0b3IoaXRlcmFibGUpO1xuXHR9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9yT2ZDYWxsYmFjazxUPiB7XG5cdC8qKlxuXHQgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhIGZvck9mKCkgaXRlcmF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3ZlclxuXHQgKiBAcGFyYW0gZG9CcmVhayBBIGZ1bmN0aW9uLCBpZiBjYWxsZWQsIHdpbGwgc3RvcCB0aGUgaXRlcmF0aW9uXG5cdCAqL1xuXHQodmFsdWU6IFQsIG9iamVjdDogSXRlcmFibGU8VD4gfCBBcnJheUxpa2U8VD4gfCBzdHJpbmcsIGRvQnJlYWs6ICgpID0+IHZvaWQpOiB2b2lkO1xufVxuXG4vKipcbiAqIFNoaW1zIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGBmb3IgLi4uIG9mYCBibG9ja3NcbiAqXG4gKiBAcGFyYW0gaXRlcmFibGUgVGhlIG9iamVjdCB0aGUgcHJvdmlkZXMgYW4gaW50ZXJhdG9yIGludGVyZmFjZVxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIG9mIHRoZSBpdGVyYWJsZVxuICogQHBhcmFtIHRoaXNBcmcgT3B0aW9uYWwgc2NvcGUgdG8gcGFzcyB0aGUgY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvck9mPFQ+KFxuXHRpdGVyYWJsZTogSXRlcmFibGU8VD4gfCBBcnJheUxpa2U8VD4gfCBzdHJpbmcsXG5cdGNhbGxiYWNrOiBGb3JPZkNhbGxiYWNrPFQ+LFxuXHR0aGlzQXJnPzogYW55XG4pOiB2b2lkIHtcblx0bGV0IGJyb2tlbiA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGRvQnJlYWsoKSB7XG5cdFx0YnJva2VuID0gdHJ1ZTtcblx0fVxuXG5cdC8qIFdlIG5lZWQgdG8gaGFuZGxlIGl0ZXJhdGlvbiBvZiBkb3VibGUgYnl0ZSBzdHJpbmdzIHByb3Blcmx5ICovXG5cdGlmIChpc0FycmF5TGlrZShpdGVyYWJsZSkgJiYgdHlwZW9mIGl0ZXJhYmxlID09PSAnc3RyaW5nJykge1xuXHRcdGNvbnN0IGwgPSBpdGVyYWJsZS5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0XHRcdGxldCBjaGFyID0gaXRlcmFibGVbaV07XG5cdFx0XHRpZiAoaSArIDEgPCBsKSB7XG5cdFx0XHRcdGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdGlmIChjb2RlID49IEhJR0hfU1VSUk9HQVRFX01JTiAmJiBjb2RlIDw9IEhJR0hfU1VSUk9HQVRFX01BWCkge1xuXHRcdFx0XHRcdGNoYXIgKz0gaXRlcmFibGVbKytpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzQXJnLCBjaGFyLCBpdGVyYWJsZSwgZG9CcmVhayk7XG5cdFx0XHRpZiAoYnJva2VuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgaXRlcmF0b3IgPSBnZXQoaXRlcmFibGUpO1xuXHRcdGlmIChpdGVyYXRvcikge1xuXHRcdFx0bGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblxuXHRcdFx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgaXRlcmFibGUsIGRvQnJlYWspO1xuXHRcdFx0XHRpZiAoYnJva2VuKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBpdGVyYXRvci50cyIsImltcG9ydCBnbG9iYWwgZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IGhhcyBmcm9tICcuL3N1cHBvcnQvaGFzJztcbmltcG9ydCB7IGlzU3ltYm9sIH0gZnJvbSAnLi9TeW1ib2wnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEFzc2lnbiB7XG5cdC8qKlxuXHQgKiBDb3B5IHRoZSB2YWx1ZXMgb2YgYWxsIG9mIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIGZyb20gb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gYVxuXHQgKiB0YXJnZXQgb2JqZWN0LiBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGNvcHkgdG8uXG5cdCAqIEBwYXJhbSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QgZnJvbSB3aGljaCB0byBjb3B5IHByb3BlcnRpZXMuXG5cdCAqL1xuXHQ8VCwgVT4odGFyZ2V0OiBULCBzb3VyY2U6IFUpOiBUICYgVTtcblxuXHQvKipcblx0ICogQ29weSB0aGUgdmFsdWVzIG9mIGFsbCBvZiB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGFcblx0ICogdGFyZ2V0IG9iamVjdC4gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBjb3B5IHRvLlxuXHQgKiBAcGFyYW0gc291cmNlMSBUaGUgZmlyc3Qgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHNvdXJjZTIgVGhlIHNlY29uZCBzb3VyY2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gY29weSBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0PFQsIFUsIFY+KHRhcmdldDogVCwgc291cmNlMTogVSwgc291cmNlMjogVik6IFQgJiBVICYgVjtcblxuXHQvKipcblx0ICogQ29weSB0aGUgdmFsdWVzIG9mIGFsbCBvZiB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGFcblx0ICogdGFyZ2V0IG9iamVjdC4gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBjb3B5IHRvLlxuXHQgKiBAcGFyYW0gc291cmNlMSBUaGUgZmlyc3Qgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHNvdXJjZTIgVGhlIHNlY29uZCBzb3VyY2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gY29weSBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0gc291cmNlMyBUaGUgdGhpcmQgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cblx0ICovXG5cdDxULCBVLCBWLCBXPih0YXJnZXQ6IFQsIHNvdXJjZTE6IFUsIHNvdXJjZTI6IFYsIHNvdXJjZTM6IFcpOiBUICYgVSAmIFYgJiBXO1xuXG5cdC8qKlxuXHQgKiBDb3B5IHRoZSB2YWx1ZXMgb2YgYWxsIG9mIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIGZyb20gb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gYVxuXHQgKiB0YXJnZXQgb2JqZWN0LiBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGNvcHkgdG8uXG5cdCAqIEBwYXJhbSBzb3VyY2VzIE9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIGZyb20gd2hpY2ggdG8gY29weSBwcm9wZXJ0aWVzXG5cdCAqL1xuXHQodGFyZ2V0OiBvYmplY3QsIC4uLnNvdXJjZXM6IGFueVtdKTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEVudGVyaWVzIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yga2V5L3ZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuXHQgKiBAcGFyYW0gbyBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy4gVGhpcyBjYW4gYmUgYW4gb2JqZWN0IHRoYXQgeW91IGNyZWF0ZWQgb3IgYW4gZXhpc3RpbmcgRG9jdW1lbnQgT2JqZWN0IE1vZGVsIChET00pIG9iamVjdC5cblx0ICovXG5cdDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSwgSyBleHRlbmRzIGtleW9mIFQ+KG86IFQpOiBba2V5b2YgVCwgVFtLXV1bXTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBrZXkvdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG5cdCAqIEBwYXJhbSBvIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLiBUaGlzIGNhbiBiZSBhbiBvYmplY3QgdGhhdCB5b3UgY3JlYXRlZCBvciBhbiBleGlzdGluZyBEb2N1bWVudCBPYmplY3QgTW9kZWwgKERPTSkgb2JqZWN0LlxuXHQgKi9cblx0KG86IG9iamVjdCk6IFtzdHJpbmcsIGFueV1bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHtcblx0PFQ+KG86IFQpOiB7IFtLIGluIGtleW9mIFRdOiBQcm9wZXJ0eURlc2NyaXB0b3IgfTtcblx0KG86IGFueSk6IHsgW2tleTogc3RyaW5nXTogUHJvcGVydHlEZXNjcmlwdG9yIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0VmFsdWVzIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG5cdCAqIEBwYXJhbSBvIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLiBUaGlzIGNhbiBiZSBhbiBvYmplY3QgdGhhdCB5b3UgY3JlYXRlZCBvciBhbiBleGlzdGluZyBEb2N1bWVudCBPYmplY3QgTW9kZWwgKERPTSkgb2JqZWN0LlxuXHQgKi9cblx0PFQ+KG86IHsgW3M6IHN0cmluZ106IFQgfSk6IFRbXTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3Rcblx0ICogQHBhcmFtIG8gT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuIFRoaXMgY2FuIGJlIGFuIG9iamVjdCB0aGF0IHlvdSBjcmVhdGVkIG9yIGFuIGV4aXN0aW5nIERvY3VtZW50IE9iamVjdCBNb2RlbCAoRE9NKSBvYmplY3QuXG5cdCAqL1xuXHQobzogb2JqZWN0KTogYW55W107XG59XG5cbmV4cG9ydCBsZXQgYXNzaWduOiBPYmplY3RBc3NpZ247XG5cbi8qKlxuICogR2V0cyB0aGUgb3duIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gKiBBbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBpcyBvbmUgdGhhdCBpcyBkZWZpbmVkIGRpcmVjdGx5IG9uIHRoZSBvYmplY3QgYW5kIGlzIG5vdFxuICogaW5oZXJpdGVkIGZyb20gdGhlIG9iamVjdCdzIHByb3RvdHlwZS5cbiAqIEBwYXJhbSBvIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBwIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICovXG5leHBvcnQgbGV0IGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPihvOiBULCBwcm9wZXJ0eUtleTogSykgPT4gUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBvd24gcHJvcGVydGllcyBvZiBhbiBvYmplY3QuIFRoZSBvd24gcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYXJlIHRob3NlIHRoYXQgYXJlIGRlZmluZWQgZGlyZWN0bHlcbiAqIG9uIHRoYXQgb2JqZWN0LCBhbmQgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgb2JqZWN0J3MgcHJvdG90eXBlLiBUaGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW5jbHVkZSBib3RoIGZpZWxkcyAob2JqZWN0cykgYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBvIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBvd24gcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGxldCBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAobzogYW55KSA9PiBzdHJpbmdbXTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBzeW1ib2wgcHJvcGVydGllcyBmb3VuZCBkaXJlY3RseSBvbiBvYmplY3Qgby5cbiAqIEBwYXJhbSBvIE9iamVjdCB0byByZXRyaWV2ZSB0aGUgc3ltYm9scyBmcm9tLlxuICovXG5leHBvcnQgbGV0IGdldE93blByb3BlcnR5U3ltYm9sczogKG86IGFueSkgPT4gc3ltYm9sW107XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZXMgYXJlIHRoZSBzYW1lIHZhbHVlLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUxIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZTIgVGhlIHNlY29uZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGxldCBpczogKHZhbHVlMTogYW55LCB2YWx1ZTI6IGFueSkgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIGFuIG9iamVjdC5cbiAqIEBwYXJhbSBvIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLiBUaGlzIGNhbiBiZSBhbiBvYmplY3QgdGhhdCB5b3UgY3JlYXRlZCBvciBhbiBleGlzdGluZyBEb2N1bWVudCBPYmplY3QgTW9kZWwgKERPTSkgb2JqZWN0LlxuICovXG5leHBvcnQgbGV0IGtleXM6IChvOiBvYmplY3QpID0+IHN0cmluZ1tdO1xuXG4vKiBFUzcgT2JqZWN0IHN0YXRpYyBtZXRob2RzICovXG5cbmV4cG9ydCBsZXQgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblxuZXhwb3J0IGxldCBlbnRyaWVzOiBPYmplY3RFbnRlcmllcztcblxuZXhwb3J0IGxldCB2YWx1ZXM6IE9iamVjdFZhbHVlcztcblxuaWYgKGhhcygnZXM2LW9iamVjdCcpKSB7XG5cdGNvbnN0IGdsb2JhbE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG5cdGFzc2lnbiA9IGdsb2JhbE9iamVjdC5hc3NpZ247XG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdsb2JhbE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cdGdldE93blByb3BlcnR5TmFtZXMgPSBnbG9iYWxPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcblx0Z2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2xvYmFsT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblx0aXMgPSBnbG9iYWxPYmplY3QuaXM7XG5cdGtleXMgPSBnbG9iYWxPYmplY3Qua2V5cztcbn0gZWxzZSB7XG5cdGtleXMgPSBmdW5jdGlvbiBzeW1ib2xBd2FyZUtleXMobzogb2JqZWN0KTogc3RyaW5nW10ge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyhvKS5maWx0ZXIoKGtleSkgPT4gIUJvb2xlYW4oa2V5Lm1hdGNoKC9eQEAuKy8pKSk7XG5cdH07XG5cblx0YXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldDogYW55LCAuLi5zb3VyY2VzOiBhbnlbXSkge1xuXHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0Ly8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcblx0XHR9XG5cblx0XHRjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpO1xuXHRcdHNvdXJjZXMuZm9yRWFjaCgobmV4dFNvdXJjZSkgPT4ge1xuXHRcdFx0aWYgKG5leHRTb3VyY2UpIHtcblx0XHRcdFx0Ly8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHRcdGtleXMobmV4dFNvdXJjZSkuZm9yRWFjaCgobmV4dEtleSkgPT4ge1xuXHRcdFx0XHRcdHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdG87XG5cdH07XG5cblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuXHRcdG86IGFueSxcblx0XHRwcm9wOiBzdHJpbmcgfCBzeW1ib2xcblx0KTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcblx0XHRpZiAoaXNTeW1ib2wocHJvcCkpIHtcblx0XHRcdHJldHVybiAoPGFueT5PYmplY3QpLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBwcm9wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgcHJvcCk7XG5cdFx0fVxuXHR9O1xuXG5cdGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG86IGFueSk6IHN0cmluZ1tdIHtcblx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZmlsdGVyKChrZXkpID0+ICFCb29sZWFuKGtleS5tYXRjaCgvXkBALisvKSkpO1xuXHR9O1xuXG5cdGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhvOiBhbnkpOiBzeW1ib2xbXSB7XG5cdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8pXG5cdFx0XHQuZmlsdGVyKChrZXkpID0+IEJvb2xlYW4oa2V5Lm1hdGNoKC9eQEAuKy8pKSlcblx0XHRcdC5tYXAoKGtleSkgPT4gU3ltYm9sLmZvcihrZXkuc3Vic3RyaW5nKDIpKSk7XG5cdH07XG5cblx0aXMgPSBmdW5jdGlvbiBpcyh2YWx1ZTE6IGFueSwgdmFsdWUyOiBhbnkpOiBib29sZWFuIHtcblx0XHRpZiAodmFsdWUxID09PSB2YWx1ZTIpIHtcblx0XHRcdHJldHVybiB2YWx1ZTEgIT09IDAgfHwgMSAvIHZhbHVlMSA9PT0gMSAvIHZhbHVlMjsgLy8gLTBcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlMSAhPT0gdmFsdWUxICYmIHZhbHVlMiAhPT0gdmFsdWUyOyAvLyBOYU5cblx0fTtcbn1cblxuaWYgKGhhcygnZXMyMDE3LW9iamVjdCcpKSB7XG5cdGNvbnN0IGdsb2JhbE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBnbG9iYWxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblx0ZW50cmllcyA9IGdsb2JhbE9iamVjdC5lbnRyaWVzO1xuXHR2YWx1ZXMgPSBnbG9iYWxPYmplY3QudmFsdWVzO1xufSBlbHNlIHtcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobzogYW55KSB7XG5cdFx0cmV0dXJuIGdldE93blByb3BlcnR5TmFtZXMobykucmVkdWNlKFxuXHRcdFx0KHByZXZpb3VzLCBrZXkpID0+IHtcblx0XHRcdFx0cHJldmlvdXNba2V5XSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBrZXkpITtcblx0XHRcdFx0cmV0dXJuIHByZXZpb3VzO1xuXHRcdFx0fSxcblx0XHRcdHt9IGFzIHsgW2tleTogc3RyaW5nXTogUHJvcGVydHlEZXNjcmlwdG9yIH1cblx0XHQpO1xuXHR9O1xuXG5cdGVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKG86IGFueSk6IFtzdHJpbmcsIGFueV1bXSB7XG5cdFx0cmV0dXJuIGtleXMobykubWFwKChrZXkpID0+IFtrZXksIG9ba2V5XV0gYXMgW3N0cmluZywgYW55XSk7XG5cdH07XG5cblx0dmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKG86IGFueSk6IGFueVtdIHtcblx0XHRyZXR1cm4ga2V5cyhvKS5tYXAoKGtleSkgPT4gb1trZXldKTtcblx0fTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvYmplY3QudHMiLCJpbXBvcnQgZ2xvYmFsIGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCBoYXMgZnJvbSAnLi9zdXBwb3J0L2hhcyc7XG5pbXBvcnQgeyB3cmFwTmF0aXZlIH0gZnJvbSAnLi9zdXBwb3J0L3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmluZ05vcm1hbGl6ZSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBTdHJpbmcgdmFsdWUgcmVzdWx0IG9mIG5vcm1hbGl6aW5nIHRoZSBzdHJpbmcgaW50byB0aGUgbm9ybWFsaXphdGlvbiBmb3JtXG5cdCAqIG5hbWVkIGJ5IGZvcm0gYXMgc3BlY2lmaWVkIGluIFVuaWNvZGUgU3RhbmRhcmQgQW5uZXggIzE1LCBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybXMuXG5cdCAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBzdHJpbmdcblx0ICogQHBhcmFtIGZvcm0gQXBwbGljYWJsZSB2YWx1ZXM6IFwiTkZDXCIsIFwiTkZEXCIsIFwiTkZLQ1wiLCBvciBcIk5GS0RcIiwgSWYgbm90IHNwZWNpZmllZCBkZWZhdWx0XG5cdCAqIGlzIFwiTkZDXCJcblx0ICovXG5cdCh0YXJnZXQ6IHN0cmluZywgZm9ybTogJ05GQycgfCAnTkZEJyB8ICdORktDJyB8ICdORktEJyk6IHN0cmluZztcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgU3RyaW5nIHZhbHVlIHJlc3VsdCBvZiBub3JtYWxpemluZyB0aGUgc3RyaW5nIGludG8gdGhlIG5vcm1hbGl6YXRpb24gZm9ybVxuXHQgKiBuYW1lZCBieSBmb3JtIGFzIHNwZWNpZmllZCBpbiBVbmljb2RlIFN0YW5kYXJkIEFubmV4ICMxNSwgVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm1zLlxuXHQgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nXG5cdCAqIEBwYXJhbSBmb3JtIEFwcGxpY2FibGUgdmFsdWVzOiBcIk5GQ1wiLCBcIk5GRFwiLCBcIk5GS0NcIiwgb3IgXCJORktEXCIsIElmIG5vdCBzcGVjaWZpZWQgZGVmYXVsdFxuXHQgKiBpcyBcIk5GQ1wiXG5cdCAqL1xuXHQodGFyZ2V0OiBzdHJpbmcsIGZvcm0/OiBzdHJpbmcpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIG1pbmltdW0gbG9jYXRpb24gb2YgaGlnaCBzdXJyb2dhdGVzXG4gKi9cbmV4cG9ydCBjb25zdCBISUdIX1NVUlJPR0FURV9NSU4gPSAweGQ4MDA7XG5cbi8qKlxuICogVGhlIG1heGltdW0gbG9jYXRpb24gb2YgaGlnaCBzdXJyb2dhdGVzXG4gKi9cbmV4cG9ydCBjb25zdCBISUdIX1NVUlJPR0FURV9NQVggPSAweGRiZmY7XG5cbi8qKlxuICogVGhlIG1pbmltdW0gbG9jYXRpb24gb2YgbG93IHN1cnJvZ2F0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IExPV19TVVJST0dBVEVfTUlOID0gMHhkYzAwO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGxvY2F0aW9uIG9mIGxvdyBzdXJyb2dhdGVzXG4gKi9cbmV4cG9ydCBjb25zdCBMT1dfU1VSUk9HQVRFX01BWCA9IDB4ZGZmZjtcblxuLyogRVM2IHN0YXRpYyBtZXRob2RzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBTdHJpbmcgdmFsdWUgd2hvc2UgZWxlbWVudHMgYXJlLCBpbiBvcmRlciwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXN0IGVsZW1lbnRzLlxuICogSWYgbGVuZ3RoIGlzIDAsIHRoZSBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0gY29kZVBvaW50cyBUaGUgY29kZSBwb2ludHMgdG8gZ2VuZXJhdGUgdGhlIHN0cmluZ1xuICovXG5leHBvcnQgbGV0IGZyb21Db2RlUG9pbnQ6ICguLi5jb2RlUG9pbnRzOiBudW1iZXJbXSkgPT4gc3RyaW5nO1xuXG4vKipcbiAqIGByYXdgIGlzIGludGVuZGVkIGZvciB1c2UgYXMgYSB0YWcgZnVuY3Rpb24gb2YgYSBUYWdnZWQgVGVtcGxhdGUgU3RyaW5nLiBXaGVuIGNhbGxlZFxuICogYXMgc3VjaCB0aGUgZmlyc3QgYXJndW1lbnQgd2lsbCBiZSBhIHdlbGwgZm9ybWVkIHRlbXBsYXRlIGNhbGwgc2l0ZSBvYmplY3QgYW5kIHRoZSByZXN0XG4gKiBwYXJhbWV0ZXIgd2lsbCBjb250YWluIHRoZSBzdWJzdGl0dXRpb24gdmFsdWVzLlxuICogQHBhcmFtIHRlbXBsYXRlIEEgd2VsbC1mb3JtZWQgdGVtcGxhdGUgc3RyaW5nIGNhbGwgc2l0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSBzdWJzdGl0dXRpb25zIEEgc2V0IG9mIHN1YnN0aXR1dGlvbiB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBsZXQgcmF3OiAodGVtcGxhdGU6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5zdWJzdGl0dXRpb25zOiBhbnlbXSkgPT4gc3RyaW5nO1xuXG4vKiBFUzYgaW5zdGFuY2UgbWV0aG9kcyAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyIE51bWJlciBsZXNzIHRoYW4gMTExNDExMiAoMHgxMTAwMDApIHRoYXQgaXMgdGhlIGNvZGUgcG9pbnRcbiAqIHZhbHVlIG9mIHRoZSBVVEYtMTYgZW5jb2RlZCBjb2RlIHBvaW50IHN0YXJ0aW5nIGF0IHRoZSBzdHJpbmcgZWxlbWVudCBhdCBwb3NpdGlvbiBwb3MgaW5cbiAqIHRoZSBTdHJpbmcgcmVzdWx0aW5nIGZyb20gY29udmVydGluZyB0aGlzIG9iamVjdCB0byBhIFN0cmluZy5cbiAqIElmIHRoZXJlIGlzIG5vIGVsZW1lbnQgYXQgdGhhdCBwb3NpdGlvbiwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWQuXG4gKiBJZiBhIHZhbGlkIFVURi0xNiBzdXJyb2dhdGUgcGFpciBkb2VzIG5vdCBiZWdpbiBhdCBwb3MsIHRoZSByZXN1bHQgaXMgdGhlIGNvZGUgdW5pdCBhdCBwb3MuXG4gKi9cbmV4cG9ydCBsZXQgY29kZVBvaW50QXQ6ICh0YXJnZXQ6IHN0cmluZywgcG9zPzogbnVtYmVyKSA9PiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZXF1ZW5jZSBvZiBlbGVtZW50cyBvZiBzZWFyY2hTdHJpbmcgY29udmVydGVkIHRvIGEgU3RyaW5nIGlzIHRoZVxuICogc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBvZiB0aGlzIG9iamVjdCAoY29udmVydGVkIHRvIGEgU3RyaW5nKSBzdGFydGluZyBhdFxuICogZW5kUG9zaXRpb24g4oCTIGxlbmd0aCh0aGlzKS4gT3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gKi9cbmV4cG9ydCBsZXQgZW5kc1dpdGg6ICh0YXJnZXQ6IHN0cmluZywgc2VhcmNoU3RyaW5nOiBzdHJpbmcsIGVuZFBvc2l0aW9uPzogbnVtYmVyKSA9PiBib29sZWFuO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzZWFyY2hTdHJpbmcgYXBwZWFycyBhcyBhIHN1YnN0cmluZyBvZiB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgdGhpc1xuICogb2JqZWN0IHRvIGEgU3RyaW5nLCBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgdGhhdCBhcmVcbiAqIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBwb3NpdGlvbjsgb3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZ1xuICogQHBhcmFtIHNlYXJjaFN0cmluZyBzZWFyY2ggc3RyaW5nXG4gKiBAcGFyYW0gcG9zaXRpb24gSWYgcG9zaXRpb24gaXMgdW5kZWZpbmVkLCAwIGlzIGFzc3VtZWQsIHNvIGFzIHRvIHNlYXJjaCBhbGwgb2YgdGhlIFN0cmluZy5cbiAqL1xuZXhwb3J0IGxldCBpbmNsdWRlczogKHRhcmdldDogc3RyaW5nLCBzZWFyY2hTdHJpbmc6IHN0cmluZywgcG9zaXRpb24/OiBudW1iZXIpID0+IGJvb2xlYW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgU3RyaW5nIHZhbHVlIHJlc3VsdCBvZiBub3JtYWxpemluZyB0aGUgc3RyaW5nIGludG8gdGhlIG5vcm1hbGl6YXRpb24gZm9ybVxuICogbmFtZWQgYnkgZm9ybSBhcyBzcGVjaWZpZWQgaW4gVW5pY29kZSBTdGFuZGFyZCBBbm5leCAjMTUsIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3Jtcy5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBzdHJpbmdcbiAqIEBwYXJhbSBmb3JtIEFwcGxpY2FibGUgdmFsdWVzOiBcIk5GQ1wiLCBcIk5GRFwiLCBcIk5GS0NcIiwgb3IgXCJORktEXCIsIElmIG5vdCBzcGVjaWZpZWQgZGVmYXVsdFxuICogaXMgXCJORkNcIlxuICovXG5leHBvcnQgbGV0IG5vcm1hbGl6ZTogU3RyaW5nTm9ybWFsaXplO1xuXG4vKipcbiAqIFJldHVybnMgYSBTdHJpbmcgdmFsdWUgdGhhdCBpcyBtYWRlIGZyb20gY291bnQgY29waWVzIGFwcGVuZGVkIHRvZ2V0aGVyLiBJZiBjb3VudCBpcyAwLFxuICogVCBpcyB0aGUgZW1wdHkgU3RyaW5nIGlzIHJldHVybmVkLlxuICogQHBhcmFtIGNvdW50IG51bWJlciBvZiBjb3BpZXMgdG8gYXBwZW5kXG4gKi9cbmV4cG9ydCBsZXQgcmVwZWF0OiAodGFyZ2V0OiBzdHJpbmcsIGNvdW50PzogbnVtYmVyKSA9PiBzdHJpbmc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZXF1ZW5jZSBvZiBlbGVtZW50cyBvZiBzZWFyY2hTdHJpbmcgY29udmVydGVkIHRvIGEgU3RyaW5nIGlzIHRoZVxuICogc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBvZiB0aGlzIG9iamVjdCAoY29udmVydGVkIHRvIGEgU3RyaW5nKSBzdGFydGluZyBhdFxuICogcG9zaXRpb24uIE90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICovXG5leHBvcnQgbGV0IHN0YXJ0c1dpdGg6ICh0YXJnZXQ6IHN0cmluZywgc2VhcmNoU3RyaW5nOiBzdHJpbmcsIHBvc2l0aW9uPzogbnVtYmVyKSA9PiBib29sZWFuO1xuXG4vKiBFUzcgaW5zdGFuY2UgbWV0aG9kcyAqL1xuXG4vKipcbiAqIFBhZHMgdGhlIGN1cnJlbnQgc3RyaW5nIHdpdGggYSBnaXZlbiBzdHJpbmcgKHBvc3NpYmx5IHJlcGVhdGVkKSBzbyB0aGF0IHRoZSByZXN1bHRpbmcgc3RyaW5nIHJlYWNoZXMgYSBnaXZlbiBsZW5ndGguXG4gKiBUaGUgcGFkZGluZyBpcyBhcHBsaWVkIGZyb20gdGhlIGVuZCAocmlnaHQpIG9mIHRoZSBjdXJyZW50IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBzdHJpbmcgb25jZSB0aGUgY3VycmVudCBzdHJpbmcgaGFzIGJlZW4gcGFkZGVkLlxuICogICAgICAgIElmIHRoaXMgcGFyYW1ldGVyIGlzIHNtYWxsZXIgdGhhbiB0aGUgY3VycmVudCBzdHJpbmcncyBsZW5ndGgsIHRoZSBjdXJyZW50IHN0cmluZyB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzLlxuICpcbiAqIEBwYXJhbSBmaWxsU3RyaW5nIFRoZSBzdHJpbmcgdG8gcGFkIHRoZSBjdXJyZW50IHN0cmluZyB3aXRoLlxuICogICAgICAgIElmIHRoaXMgc3RyaW5nIGlzIHRvbyBsb25nLCBpdCB3aWxsIGJlIHRydW5jYXRlZCBhbmQgdGhlIGxlZnQtbW9zdCBwYXJ0IHdpbGwgYmUgYXBwbGllZC5cbiAqICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBwYXJhbWV0ZXIgaXMgXCIgXCIgKFUrMDAyMCkuXG4gKi9cbmV4cG9ydCBsZXQgcGFkRW5kOiAodGFyZ2V0OiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyLCBmaWxsU3RyaW5nPzogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbi8qKlxuICogUGFkcyB0aGUgY3VycmVudCBzdHJpbmcgd2l0aCBhIGdpdmVuIHN0cmluZyAocG9zc2libHkgcmVwZWF0ZWQpIHNvIHRoYXQgdGhlIHJlc3VsdGluZyBzdHJpbmcgcmVhY2hlcyBhIGdpdmVuIGxlbmd0aC5cbiAqIFRoZSBwYWRkaW5nIGlzIGFwcGxpZWQgZnJvbSB0aGUgc3RhcnQgKGxlZnQpIG9mIHRoZSBjdXJyZW50IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBzdHJpbmcgb25jZSB0aGUgY3VycmVudCBzdHJpbmcgaGFzIGJlZW4gcGFkZGVkLlxuICogICAgICAgIElmIHRoaXMgcGFyYW1ldGVyIGlzIHNtYWxsZXIgdGhhbiB0aGUgY3VycmVudCBzdHJpbmcncyBsZW5ndGgsIHRoZSBjdXJyZW50IHN0cmluZyB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzLlxuICpcbiAqIEBwYXJhbSBmaWxsU3RyaW5nIFRoZSBzdHJpbmcgdG8gcGFkIHRoZSBjdXJyZW50IHN0cmluZyB3aXRoLlxuICogICAgICAgIElmIHRoaXMgc3RyaW5nIGlzIHRvbyBsb25nLCBpdCB3aWxsIGJlIHRydW5jYXRlZCBhbmQgdGhlIGxlZnQtbW9zdCBwYXJ0IHdpbGwgYmUgYXBwbGllZC5cbiAqICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBwYXJhbWV0ZXIgaXMgXCIgXCIgKFUrMDAyMCkuXG4gKi9cbmV4cG9ydCBsZXQgcGFkU3RhcnQ6ICh0YXJnZXQ6IHN0cmluZywgbWF4TGVuZ3RoOiBudW1iZXIsIGZpbGxTdHJpbmc/OiBzdHJpbmcpID0+IHN0cmluZztcblxuaWYgKGhhcygnZXM2LXN0cmluZycpICYmIGhhcygnZXM2LXN0cmluZy1yYXcnKSkge1xuXHRmcm9tQ29kZVBvaW50ID0gZ2xvYmFsLlN0cmluZy5mcm9tQ29kZVBvaW50O1xuXHRyYXcgPSBnbG9iYWwuU3RyaW5nLnJhdztcblxuXHRjb2RlUG9pbnRBdCA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQpO1xuXHRlbmRzV2l0aCA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpO1xuXHRpbmNsdWRlcyA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMpO1xuXHRub3JtYWxpemUgPSB3cmFwTmF0aXZlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSk7XG5cdHJlcGVhdCA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUucmVwZWF0KTtcblx0c3RhcnRzV2l0aCA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCk7XG59IGVsc2Uge1xuXHQvKipcblx0ICogVmFsaWRhdGVzIHRoYXQgdGV4dCBpcyBkZWZpbmVkLCBhbmQgbm9ybWFsaXplcyBwb3NpdGlvbiAoYmFzZWQgb24gdGhlIGdpdmVuIGRlZmF1bHQgaWYgdGhlIGlucHV0IGlzIE5hTikuXG5cdCAqIFVzZWQgYnkgc3RhcnRzV2l0aCwgaW5jbHVkZXMsIGFuZCBlbmRzV2l0aC5cblx0ICpcblx0ICogQHJldHVybiBOb3JtYWxpemVkIHBvc2l0aW9uLlxuXHQgKi9cblx0Y29uc3Qgbm9ybWFsaXplU3Vic3RyaW5nQXJncyA9IGZ1bmN0aW9uKFxuXHRcdG5hbWU6IHN0cmluZyxcblx0XHR0ZXh0OiBzdHJpbmcsXG5cdFx0c2VhcmNoOiBzdHJpbmcsXG5cdFx0cG9zaXRpb246IG51bWJlcixcblx0XHRpc0VuZDogYm9vbGVhbiA9IGZhbHNlXG5cdCk6IFtzdHJpbmcsIHN0cmluZywgbnVtYmVyXSB7XG5cdFx0aWYgKHRleHQgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nLicgKyBuYW1lICsgJyByZXF1aXJlcyBhIHZhbGlkIHN0cmluZyB0byBzZWFyY2ggYWdhaW5zdC4nKTtcblx0XHR9XG5cblx0XHRjb25zdCBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblx0XHRwb3NpdGlvbiA9IHBvc2l0aW9uICE9PSBwb3NpdGlvbiA/IChpc0VuZCA/IGxlbmd0aCA6IDApIDogcG9zaXRpb247XG5cdFx0cmV0dXJuIFt0ZXh0LCBTdHJpbmcoc2VhcmNoKSwgTWF0aC5taW4oTWF0aC5tYXgocG9zaXRpb24sIDApLCBsZW5ndGgpXTtcblx0fTtcblxuXHRmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzOiBudW1iZXJbXSk6IHN0cmluZyB7XG5cdFx0Ly8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5mcm9tQ29kZVBvaW50XG5cdFx0Y29uc3QgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAoIWxlbmd0aCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cdFx0Y29uc3QgTUFYX1NJWkUgPSAweDQwMDA7XG5cdFx0bGV0IGNvZGVVbml0czogbnVtYmVyW10gPSBbXTtcblx0XHRsZXQgaW5kZXggPSAtMTtcblx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0bGV0IGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcblxuXHRcdFx0Ly8gQ29kZSBwb2ludHMgbXVzdCBiZSBmaW5pdGUgaW50ZWdlcnMgd2l0aGluIHRoZSB2YWxpZCByYW5nZVxuXHRcdFx0bGV0IGlzVmFsaWQgPVxuXHRcdFx0XHRpc0Zpbml0ZShjb2RlUG9pbnQpICYmIE1hdGguZmxvb3IoY29kZVBvaW50KSA9PT0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA+PSAwICYmIGNvZGVQb2ludCA8PSAweDEwZmZmZjtcblx0XHRcdGlmICghaXNWYWxpZCkge1xuXHRcdFx0XHR0aHJvdyBSYW5nZUVycm9yKCdzdHJpbmcuZnJvbUNvZGVQb2ludDogSW52YWxpZCBjb2RlIHBvaW50ICcgKyBjb2RlUG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuXHRcdFx0XHQvLyBCTVAgY29kZSBwb2ludFxuXHRcdFx0XHRjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcblx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHRcdFx0XHRsZXQgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgSElHSF9TVVJST0dBVEVfTUlOO1xuXHRcdFx0XHRsZXQgbG93U3Vycm9nYXRlID0gY29kZVBvaW50ICUgMHg0MDAgKyBMT1dfU1VSUk9HQVRFX01JTjtcblx0XHRcdFx0Y29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuXHRcdFx0XHRyZXN1bHQgKz0gZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cyk7XG5cdFx0XHRcdGNvZGVVbml0cy5sZW5ndGggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHJhdyA9IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZTogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnN1YnN0aXR1dGlvbnM6IGFueVtdKTogc3RyaW5nIHtcblx0XHRsZXQgcmF3U3RyaW5ncyA9IGNhbGxTaXRlLnJhdztcblx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cdFx0bGV0IG51bVN1YnN0aXR1dGlvbnMgPSBzdWJzdGl0dXRpb25zLmxlbmd0aDtcblxuXHRcdGlmIChjYWxsU2l0ZSA9PSBudWxsIHx8IGNhbGxTaXRlLnJhdyA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcucmF3IHJlcXVpcmVzIGEgdmFsaWQgY2FsbFNpdGUgb2JqZWN0IHdpdGggYSByYXcgdmFsdWUnKTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcmF3U3RyaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0cmVzdWx0ICs9IHJhd1N0cmluZ3NbaV0gKyAoaSA8IG51bVN1YnN0aXR1dGlvbnMgJiYgaSA8IGxlbmd0aCAtIDEgPyBzdWJzdGl0dXRpb25zW2ldIDogJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Y29kZVBvaW50QXQgPSBmdW5jdGlvbiBjb2RlUG9pbnRBdCh0ZXh0OiBzdHJpbmcsIHBvc2l0aW9uOiBudW1iZXIgPSAwKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcblx0XHQvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdFxuXHRcdGlmICh0ZXh0ID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZy5jb2RlUG9pbnRBdCByZXF1cmllcyBhIHZhbGlkIHN0cmluZy4nKTtcblx0XHR9XG5cdFx0Y29uc3QgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cblx0XHRpZiAocG9zaXRpb24gIT09IHBvc2l0aW9uKSB7XG5cdFx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0fVxuXHRcdGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gbGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0aGUgZmlyc3QgY29kZSB1bml0XG5cdFx0Y29uc3QgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuXHRcdGlmIChmaXJzdCA+PSBISUdIX1NVUlJPR0FURV9NSU4gJiYgZmlyc3QgPD0gSElHSF9TVVJST0dBVEVfTUFYICYmIGxlbmd0aCA+IHBvc2l0aW9uICsgMSkge1xuXHRcdFx0Ly8gU3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpciAoaGlnaCBzdXJyb2dhdGUgYW5kIHRoZXJlIGlzIGEgbmV4dCBjb2RlIHVuaXQpOyBjaGVjayBmb3IgbG93IHN1cnJvZ2F0ZVxuXHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRjb25zdCBzZWNvbmQgPSB0ZXh0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKTtcblx0XHRcdGlmIChzZWNvbmQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgc2Vjb25kIDw9IExPV19TVVJST0dBVEVfTUFYKSB7XG5cdFx0XHRcdHJldHVybiAoZmlyc3QgLSBISUdIX1NVUlJPR0FURV9NSU4pICogMHg0MDAgKyBzZWNvbmQgLSBMT1dfU1VSUk9HQVRFX01JTiArIDB4MTAwMDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmaXJzdDtcblx0fTtcblxuXHRlbmRzV2l0aCA9IGZ1bmN0aW9uIGVuZHNXaXRoKHRleHQ6IHN0cmluZywgc2VhcmNoOiBzdHJpbmcsIGVuZFBvc2l0aW9uPzogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0aWYgKGVuZFBvc2l0aW9uID09IG51bGwpIHtcblx0XHRcdGVuZFBvc2l0aW9uID0gdGV4dC5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0W3RleHQsIHNlYXJjaCwgZW5kUG9zaXRpb25dID0gbm9ybWFsaXplU3Vic3RyaW5nQXJncygnZW5kc1dpdGgnLCB0ZXh0LCBzZWFyY2gsIGVuZFBvc2l0aW9uLCB0cnVlKTtcblxuXHRcdGNvbnN0IHN0YXJ0ID0gZW5kUG9zaXRpb24gLSBzZWFyY2gubGVuZ3RoO1xuXHRcdGlmIChzdGFydCA8IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dC5zbGljZShzdGFydCwgZW5kUG9zaXRpb24pID09PSBzZWFyY2g7XG5cdH07XG5cblx0aW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh0ZXh0OiBzdHJpbmcsIHNlYXJjaDogc3RyaW5nLCBwb3NpdGlvbjogbnVtYmVyID0gMCk6IGJvb2xlYW4ge1xuXHRcdFt0ZXh0LCBzZWFyY2gsIHBvc2l0aW9uXSA9IG5vcm1hbGl6ZVN1YnN0cmluZ0FyZ3MoJ2luY2x1ZGVzJywgdGV4dCwgc2VhcmNoLCBwb3NpdGlvbik7XG5cdFx0cmV0dXJuIHRleHQuaW5kZXhPZihzZWFyY2gsIHBvc2l0aW9uKSAhPT0gLTE7XG5cdH07XG5cblx0cmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHRleHQ6IHN0cmluZywgY291bnQ6IG51bWJlciA9IDApOiBzdHJpbmcge1xuXHRcdC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLnJlcGVhdFxuXHRcdGlmICh0ZXh0ID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZy5yZXBlYXQgcmVxdWlyZXMgYSB2YWxpZCBzdHJpbmcuJyk7XG5cdFx0fVxuXHRcdGlmIChjb3VudCAhPT0gY291bnQpIHtcblx0XHRcdGNvdW50ID0gMDtcblx0XHR9XG5cdFx0aWYgKGNvdW50IDwgMCB8fCBjb3VudCA9PT0gSW5maW5pdHkpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdzdHJpbmcucmVwZWF0IHJlcXVpcmVzIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBjb3VudC4nKTtcblx0XHR9XG5cblx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cdFx0d2hpbGUgKGNvdW50KSB7XG5cdFx0XHRpZiAoY291bnQgJSAyKSB7XG5cdFx0XHRcdHJlc3VsdCArPSB0ZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHR0ZXh0ICs9IHRleHQ7XG5cdFx0XHR9XG5cdFx0XHRjb3VudCA+Pj0gMTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aCh0ZXh0OiBzdHJpbmcsIHNlYXJjaDogc3RyaW5nLCBwb3NpdGlvbjogbnVtYmVyID0gMCk6IGJvb2xlYW4ge1xuXHRcdHNlYXJjaCA9IFN0cmluZyhzZWFyY2gpO1xuXHRcdFt0ZXh0LCBzZWFyY2gsIHBvc2l0aW9uXSA9IG5vcm1hbGl6ZVN1YnN0cmluZ0FyZ3MoJ3N0YXJ0c1dpdGgnLCB0ZXh0LCBzZWFyY2gsIHBvc2l0aW9uKTtcblxuXHRcdGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgc2VhcmNoLmxlbmd0aDtcblx0XHRpZiAoZW5kID4gdGV4dC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dC5zbGljZShwb3NpdGlvbiwgZW5kKSA9PT0gc2VhcmNoO1xuXHR9O1xufVxuXG5pZiAoaGFzKCdlczIwMTctc3RyaW5nJykpIHtcblx0cGFkRW5kID0gd3JhcE5hdGl2ZShnbG9iYWwuU3RyaW5nLnByb3RvdHlwZS5wYWRFbmQpO1xuXHRwYWRTdGFydCA9IHdyYXBOYXRpdmUoZ2xvYmFsLlN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQpO1xufSBlbHNlIHtcblx0cGFkRW5kID0gZnVuY3Rpb24gcGFkRW5kKHRleHQ6IHN0cmluZywgbWF4TGVuZ3RoOiBudW1iZXIsIGZpbGxTdHJpbmc6IHN0cmluZyA9ICcgJyk6IHN0cmluZyB7XG5cdFx0aWYgKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcucmVwZWF0IHJlcXVpcmVzIGEgdmFsaWQgc3RyaW5nLicpO1xuXHRcdH1cblxuXHRcdGlmIChtYXhMZW5ndGggPT09IEluZmluaXR5KSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RyaW5nLnBhZEVuZCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgY291bnQuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG1heExlbmd0aCA9PT0gbnVsbCB8fCBtYXhMZW5ndGggPT09IHVuZGVmaW5lZCB8fCBtYXhMZW5ndGggPCAwKSB7XG5cdFx0XHRtYXhMZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGxldCBzdHJUZXh0ID0gU3RyaW5nKHRleHQpO1xuXHRcdGNvbnN0IHBhZGRpbmcgPSBtYXhMZW5ndGggLSBzdHJUZXh0Lmxlbmd0aDtcblxuXHRcdGlmIChwYWRkaW5nID4gMCkge1xuXHRcdFx0c3RyVGV4dCArPVxuXHRcdFx0XHRyZXBlYXQoZmlsbFN0cmluZywgTWF0aC5mbG9vcihwYWRkaW5nIC8gZmlsbFN0cmluZy5sZW5ndGgpKSArXG5cdFx0XHRcdGZpbGxTdHJpbmcuc2xpY2UoMCwgcGFkZGluZyAlIGZpbGxTdHJpbmcubGVuZ3RoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyVGV4dDtcblx0fTtcblxuXHRwYWRTdGFydCA9IGZ1bmN0aW9uIHBhZFN0YXJ0KHRleHQ6IHN0cmluZywgbWF4TGVuZ3RoOiBudW1iZXIsIGZpbGxTdHJpbmc6IHN0cmluZyA9ICcgJyk6IHN0cmluZyB7XG5cdFx0aWYgKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcucmVwZWF0IHJlcXVpcmVzIGEgdmFsaWQgc3RyaW5nLicpO1xuXHRcdH1cblxuXHRcdGlmIChtYXhMZW5ndGggPT09IEluZmluaXR5KSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RyaW5nLnBhZFN0YXJ0IHJlcXVpcmVzIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBjb3VudC4nKTtcblx0XHR9XG5cblx0XHRpZiAobWF4TGVuZ3RoID09PSBudWxsIHx8IG1heExlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IG1heExlbmd0aCA8IDApIHtcblx0XHRcdG1heExlbmd0aCA9IDA7XG5cdFx0fVxuXG5cdFx0bGV0IHN0clRleHQgPSBTdHJpbmcodGV4dCk7XG5cdFx0Y29uc3QgcGFkZGluZyA9IG1heExlbmd0aCAtIHN0clRleHQubGVuZ3RoO1xuXG5cdFx0aWYgKHBhZGRpbmcgPiAwKSB7XG5cdFx0XHRzdHJUZXh0ID1cblx0XHRcdFx0cmVwZWF0KGZpbGxTdHJpbmcsIE1hdGguZmxvb3IocGFkZGluZyAvIGZpbGxTdHJpbmcubGVuZ3RoKSkgK1xuXHRcdFx0XHRmaWxsU3RyaW5nLnNsaWNlKDAsIHBhZGRpbmcgJSBmaWxsU3RyaW5nLmxlbmd0aCkgK1xuXHRcdFx0XHRzdHJUZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHJUZXh0O1xuXHR9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHN0cmluZy50cyIsImltcG9ydCBnbG9iYWwgZnJvbSAnLi4vZ2xvYmFsJztcbmltcG9ydCBoYXMgZnJvbSAnLi9oYXMnO1xuaW1wb3J0IHsgSGFuZGxlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5cbmZ1bmN0aW9uIGV4ZWN1dGVUYXNrKGl0ZW06IFF1ZXVlSXRlbSB8IHVuZGVmaW5lZCk6IHZvaWQge1xuXHRpZiAoaXRlbSAmJiBpdGVtLmlzQWN0aXZlICYmIGl0ZW0uY2FsbGJhY2spIHtcblx0XHRpdGVtLmNhbGxiYWNrKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0UXVldWVIYW5kbGUoaXRlbTogUXVldWVJdGVtLCBkZXN0cnVjdG9yPzogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRyZXR1cm4ge1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKHRoaXM6IEhhbmRsZSkge1xuXHRcdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdGl0ZW0uaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdGl0ZW0uY2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0XHRpZiAoZGVzdHJ1Y3Rvcikge1xuXHRcdFx0XHRkZXN0cnVjdG9yKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5pbnRlcmZhY2UgUG9zdE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcblx0c291cmNlOiBhbnk7XG5cdGRhdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWV1ZUl0ZW0ge1xuXHRpc0FjdGl2ZTogYm9vbGVhbjtcblx0Y2FsbGJhY2s6IG51bGwgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpO1xufVxuXG5sZXQgY2hlY2tNaWNyb1Rhc2tRdWV1ZTogKCkgPT4gdm9pZDtcbmxldCBtaWNyb1Rhc2tzOiBRdWV1ZUl0ZW1bXTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byB0aGUgbWFjcm90YXNrIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gYmUgcXVldWVkIGFuZCBsYXRlciBleGVjdXRlZC5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGEgYGRlc3Ryb3lgIG1ldGhvZCB0aGF0LCB3aGVuIGNhbGxlZCwgcHJldmVudHMgdGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2sgZnJvbSBleGVjdXRpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBxdWV1ZVRhc2sgPSAoZnVuY3Rpb24oKSB7XG5cdGxldCBkZXN0cnVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IGFueTtcblx0bGV0IGVucXVldWU6IChpdGVtOiBRdWV1ZUl0ZW0pID0+IHZvaWQ7XG5cblx0Ly8gU2luY2UgdGhlIElFIGltcGxlbWVudGF0aW9uIG9mIGBzZXRJbW1lZGlhdGVgIGlzIG5vdCBmbGF3bGVzcywgd2Ugd2lsbCB0ZXN0IGZvciBgcG9zdE1lc3NhZ2VgIGZpcnN0LlxuXHRpZiAoaGFzKCdwb3N0bWVzc2FnZScpKSB7XG5cdFx0Y29uc3QgcXVldWU6IFF1ZXVlSXRlbVtdID0gW107XG5cblx0XHRnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50OiBQb3N0TWVzc2FnZUV2ZW50KTogdm9pZCB7XG5cdFx0XHQvLyBDb25maXJtIHRoYXQgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGN1cnJlbnQgd2luZG93IGFuZCBieSB0aGlzIHBhcnRpY3VsYXIgaW1wbGVtZW50YXRpb24uXG5cdFx0XHRpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiYgZXZlbnQuZGF0YSA9PT0gJ2Rvam8tcXVldWUtbWVzc2FnZScpIHtcblx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdFx0aWYgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdGV4ZWN1dGVUYXNrKHF1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRlbnF1ZXVlID0gZnVuY3Rpb24oaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG5cdFx0XHRxdWV1ZS5wdXNoKGl0ZW0pO1xuXHRcdFx0Z2xvYmFsLnBvc3RNZXNzYWdlKCdkb2pvLXF1ZXVlLW1lc3NhZ2UnLCAnKicpO1xuXHRcdH07XG5cdH0gZWxzZSBpZiAoaGFzKCdzZXRpbW1lZGlhdGUnKSkge1xuXHRcdGRlc3RydWN0b3IgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG5cdFx0ZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW06IFF1ZXVlSXRlbSk6IGFueSB7XG5cdFx0XHRyZXR1cm4gc2V0SW1tZWRpYXRlKGV4ZWN1dGVUYXNrLmJpbmQobnVsbCwgaXRlbSkpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZGVzdHJ1Y3RvciA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG5cdFx0ZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW06IFF1ZXVlSXRlbSk6IGFueSB7XG5cdFx0XHRyZXR1cm4gc2V0VGltZW91dChleGVjdXRlVGFzay5iaW5kKG51bGwsIGl0ZW0pLCAwKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcXVldWVUYXNrKGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSk6IEhhbmRsZSB7XG5cdFx0Y29uc3QgaXRlbTogUXVldWVJdGVtID0ge1xuXHRcdFx0aXNBY3RpdmU6IHRydWUsXG5cdFx0XHRjYWxsYmFjazogY2FsbGJhY2tcblx0XHR9O1xuXHRcdGNvbnN0IGlkOiBhbnkgPSBlbnF1ZXVlKGl0ZW0pO1xuXG5cdFx0cmV0dXJuIGdldFF1ZXVlSGFuZGxlKFxuXHRcdFx0aXRlbSxcblx0XHRcdGRlc3RydWN0b3IgJiZcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVzdHJ1Y3RvcihpZCk7XG5cdFx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0Ly8gVE9ETzogVXNlIGFzcGVjdC5iZWZvcmUgd2hlbiBpdCBpcyBhdmFpbGFibGUuXG5cdHJldHVybiBoYXMoJ21pY3JvdGFza3MnKVxuXHRcdD8gcXVldWVUYXNrXG5cdFx0OiBmdW5jdGlvbihjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiBIYW5kbGUge1xuXHRcdFx0XHRjaGVja01pY3JvVGFza1F1ZXVlKCk7XG5cdFx0XHRcdHJldHVybiBxdWV1ZVRhc2soY2FsbGJhY2spO1xuXHRcdFx0fTtcbn0pKCk7XG5cbi8vIFdoZW4gbm8gbWVjaGFuaXNtIGZvciByZWdpc3RlcmluZyBtaWNyb3Rhc2tzIGlzIGV4cG9zZWQgYnkgdGhlIGVudmlyb25tZW50LCBtaWNyb3Rhc2tzIHdpbGxcbi8vIGJlIHF1ZXVlZCBhbmQgdGhlbiBleGVjdXRlZCBpbiBhIHNpbmdsZSBtYWNyb3Rhc2sgYmVmb3JlIHRoZSBvdGhlciBtYWNyb3Rhc2tzIGFyZSBleGVjdXRlZC5cbmlmICghaGFzKCdtaWNyb3Rhc2tzJykpIHtcblx0bGV0IGlzTWljcm9UYXNrUXVldWVkID0gZmFsc2U7XG5cblx0bWljcm9UYXNrcyA9IFtdO1xuXHRjaGVja01pY3JvVGFza1F1ZXVlID0gZnVuY3Rpb24oKTogdm9pZCB7XG5cdFx0aWYgKCFpc01pY3JvVGFza1F1ZXVlZCkge1xuXHRcdFx0aXNNaWNyb1Rhc2tRdWV1ZWQgPSB0cnVlO1xuXHRcdFx0cXVldWVUYXNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpc01pY3JvVGFza1F1ZXVlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChtaWNyb1Rhc2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGxldCBpdGVtOiBRdWV1ZUl0ZW0gfCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0d2hpbGUgKChpdGVtID0gbWljcm9UYXNrcy5zaGlmdCgpKSkge1xuXHRcdFx0XHRcdFx0ZXhlY3V0ZVRhc2soaXRlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGFuIGFuaW1hdGlvbiB0YXNrIHdpdGggYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGlmIGl0IGV4aXN0cywgb3Igd2l0aCBgcXVldWVUYXNrYCBvdGhlcndpc2UuXG4gKlxuICogU2luY2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJ3MgYmVoYXZpb3IgZG9lcyBub3QgbWF0Y2ggdGhhdCBleHBlY3RlZCBmcm9tIGBxdWV1ZVRhc2tgLCBpdCBpcyBub3QgdXNlZCB0aGVyZS5cbiAqIEhvd2V2ZXIsIGF0IHRpbWVzIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVsZWdhdGUgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lOyBoZW5jZSB0aGUgZm9sbG93aW5nIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGJlIHF1ZXVlZCBhbmQgbGF0ZXIgZXhlY3V0ZWQuXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhIGBkZXN0cm95YCBtZXRob2QgdGhhdCwgd2hlbiBjYWxsZWQsIHByZXZlbnRzIHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZyb20gZXhlY3V0aW5nLlxuICovXG5leHBvcnQgY29uc3QgcXVldWVBbmltYXRpb25UYXNrID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAoIWhhcygncmFmJykpIHtcblx0XHRyZXR1cm4gcXVldWVUYXNrO1xuXHR9XG5cblx0ZnVuY3Rpb24gcXVldWVBbmltYXRpb25UYXNrKGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSk6IEhhbmRsZSB7XG5cdFx0Y29uc3QgaXRlbTogUXVldWVJdGVtID0ge1xuXHRcdFx0aXNBY3RpdmU6IHRydWUsXG5cdFx0XHRjYWxsYmFjazogY2FsbGJhY2tcblx0XHR9O1xuXHRcdGNvbnN0IHJhZklkOiBudW1iZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZXhlY3V0ZVRhc2suYmluZChudWxsLCBpdGVtKSk7XG5cblx0XHRyZXR1cm4gZ2V0UXVldWVIYW5kbGUoaXRlbSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBUT0RPOiBVc2UgYXNwZWN0LmJlZm9yZSB3aGVuIGl0IGlzIGF2YWlsYWJsZS5cblx0cmV0dXJuIGhhcygnbWljcm90YXNrcycpXG5cdFx0PyBxdWV1ZUFuaW1hdGlvblRhc2tcblx0XHQ6IGZ1bmN0aW9uKGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSk6IEhhbmRsZSB7XG5cdFx0XHRcdGNoZWNrTWljcm9UYXNrUXVldWUoKTtcblx0XHRcdFx0cmV0dXJuIHF1ZXVlQW5pbWF0aW9uVGFzayhjYWxsYmFjayk7XG5cdFx0XHR9O1xufSkoKTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxuICpcbiAqIEFueSBjYWxsYmFja3MgcmVnaXN0ZXJlZCB3aXRoIGBxdWV1ZU1pY3JvVGFza2Agd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIG5leHQgbWFjcm90YXNrLiBJZiBubyBuYXRpdmVcbiAqIG1lY2hhbmlzbSBmb3Igc2NoZWR1bGluZyBtYWNyb3Rhc2tzIGlzIGV4cG9zZWQsIHRoZW4gYW55IGNhbGxiYWNrcyB3aWxsIGJlIGZpcmVkIGJlZm9yZSBhbnkgbWFjcm90YXNrXG4gKiByZWdpc3RlcmVkIHdpdGggYHF1ZXVlVGFza2Agb3IgYHF1ZXVlQW5pbWF0aW9uVGFza2AuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBiZSBxdWV1ZWQgYW5kIGxhdGVyIGV4ZWN1dGVkLlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYSBgZGVzdHJveWAgbWV0aG9kIHRoYXQsIHdoZW4gY2FsbGVkLCBwcmV2ZW50cyB0aGUgcmVnaXN0ZXJlZCBjYWxsYmFjayBmcm9tIGV4ZWN1dGluZy5cbiAqL1xuZXhwb3J0IGxldCBxdWV1ZU1pY3JvVGFzayA9IChmdW5jdGlvbigpIHtcblx0bGV0IGVucXVldWU6IChpdGVtOiBRdWV1ZUl0ZW0pID0+IHZvaWQ7XG5cblx0aWYgKGhhcygnaG9zdC1ub2RlJykpIHtcblx0XHRlbnF1ZXVlID0gZnVuY3Rpb24oaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG5cdFx0XHRnbG9iYWwucHJvY2Vzcy5uZXh0VGljayhleGVjdXRlVGFzay5iaW5kKG51bGwsIGl0ZW0pKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYgKGhhcygnZXM2LXByb21pc2UnKSkge1xuXHRcdGVucXVldWUgPSBmdW5jdGlvbihpdGVtOiBRdWV1ZUl0ZW0pOiB2b2lkIHtcblx0XHRcdGdsb2JhbC5Qcm9taXNlLnJlc29sdmUoaXRlbSkudGhlbihleGVjdXRlVGFzayk7XG5cdFx0fTtcblx0fSBlbHNlIGlmIChoYXMoJ2RvbS1tdXRhdGlvbm9ic2VydmVyJykpIHtcblx0XHQvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZSAqL1xuXHRcdGNvbnN0IEhvc3RNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cdFx0Y29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGNvbnN0IHF1ZXVlOiBRdWV1ZUl0ZW1bXSA9IFtdO1xuXHRcdGNvbnN0IG9ic2VydmVyID0gbmV3IEhvc3RNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCk6IHZvaWQge1xuXHRcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgaXRlbSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdGlmIChpdGVtICYmIGl0ZW0uaXNBY3RpdmUgJiYgaXRlbS5jYWxsYmFjaykge1xuXHRcdFx0XHRcdGl0ZW0uY2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0b2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cblx0XHRlbnF1ZXVlID0gZnVuY3Rpb24oaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG5cdFx0XHRxdWV1ZS5wdXNoKGl0ZW0pO1xuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ3F1ZXVlU3RhdHVzJywgJzEnKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGVucXVldWUgPSBmdW5jdGlvbihpdGVtOiBRdWV1ZUl0ZW0pOiB2b2lkIHtcblx0XHRcdGNoZWNrTWljcm9UYXNrUXVldWUoKTtcblx0XHRcdG1pY3JvVGFza3MucHVzaChpdGVtKTtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSk6IEhhbmRsZSB7XG5cdFx0Y29uc3QgaXRlbTogUXVldWVJdGVtID0ge1xuXHRcdFx0aXNBY3RpdmU6IHRydWUsXG5cdFx0XHRjYWxsYmFjazogY2FsbGJhY2tcblx0XHR9O1xuXG5cdFx0ZW5xdWV1ZShpdGVtKTtcblxuXHRcdHJldHVybiBnZXRRdWV1ZUhhbmRsZShpdGVtKTtcblx0fTtcbn0pKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcXVldWUudHMiLCJjb25zdCBpMThuID0gcmVxdWlyZSgnQGRvam8vaTE4bi9pMThuJyk7XG5jb25zdCBsb2FkQ2xkckRhdGEgPSByZXF1aXJlKCdAZG9qby9pMThuL2NsZHIvbG9hZCcpLmRlZmF1bHQ7XG5jb25zdCBzeXN0ZW1Mb2NhbGUgPSBpMThuLnN5c3RlbUxvY2FsZTtcblxuZGVjbGFyZSBjb25zdCBfX2NsZHJEYXRhX186IGFueTtcbmRlY2xhcmUgY29uc3QgX19kZWZhdWx0TG9jYWxlX186IHN0cmluZztcbmRlY2xhcmUgY29uc3QgX19zdXBwb3J0ZWRMb2NhbGVzX186IHN0cmluZ1tdO1xuXG5jb25zdCB1c2VyTG9jYWxlID0gc3lzdGVtTG9jYWxlLnJlcGxhY2UoL14oW2Etel17Mn0pLiovaSwgJyQxJyk7XG5jb25zdCBpc1VzZXJMb2NhbGVTdXBwb3J0ZWQgPVxuXHR1c2VyTG9jYWxlID09PSBfX2RlZmF1bHRMb2NhbGVfXyB8fFxuXHRfX3N1cHBvcnRlZExvY2FsZXNfXy5zb21lKGZ1bmN0aW9uKGxvY2FsZTogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGxvY2FsZSA9PT0gc3lzdGVtTG9jYWxlIHx8IGxvY2FsZSA9PT0gdXNlckxvY2FsZTtcblx0fSk7XG5cbmxvYWRDbGRyRGF0YShfX2NsZHJEYXRhX18pO1xuaTE4bi5zd2l0Y2hMb2NhbGUoaXNVc2VyTG9jYWxlU3VwcG9ydGVkID8gc3lzdGVtTG9jYWxlIDogX19kZWZhdWx0TG9jYWxlX18pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNldExvY2FsZURhdGEudHMiLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0cmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cdFx0cmVzb2x2ZShyZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3N0YXRpYy1idWlsZC1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0wIS4uL25vZGVfbW9kdWxlcy91bWQtY29tcGF0LWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTEhLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTIhLi4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9jc3MtbW9kdWxlLWR0cy1sb2FkZXIvaW5kZXguanM/dHlwZT10cyZpbnN0YW5jZU5hbWU9MF9kb2pvIS4vRm9vLnRzXCIpKTtcblx0fSwgXCJzcmMvRm9vXCIpO1xuXHR9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvcHJvbWlzZS1sb2FkZXI/Z2xvYmFsLHNyYy9Gb28hLi9zcmMvRm9vLnRzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvcHJvbWlzZS1sb2FkZXIvaW5kZXguanM/Z2xvYmFsLHNyYy9Gb28hLi9zcmMvRm9vLnRzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRyZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24gKHJlcXVpcmUpIHtcblx0XHRyZXNvbHZlKHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvc3RhdGljLWJ1aWxkLWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTAhLi4vbm9kZV9tb2R1bGVzL3VtZC1jb21wYXQtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMSEuLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMiEuLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2Nzcy1tb2R1bGUtZHRzLWxvYWRlci9pbmRleC5qcz90eXBlPXRzJmluc3RhbmNlTmFtZT0wX2Rvam8hLi9CYXIudHNcIikpO1xuXHR9LCBcIndpZGdldHNcIik7XG5cdH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9wcm9taXNlLWxvYWRlcj9nbG9iYWwsd2lkZ2V0cyEuL3NyYy9CYXIudHNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9wcm9taXNlLWxvYWRlci9pbmRleC5qcz9nbG9iYWwsd2lkZ2V0cyEuL3NyYy9CYXIudHNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdHJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbiAocmVxdWlyZSkge1xuXHRcdHJlc29sdmUocmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9zdGF0aWMtYnVpbGQtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMCEuLi9ub2RlX21vZHVsZXMvdW1kLWNvbXBhdC1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0xIS4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0yIS4uL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvY3NzLW1vZHVsZS1kdHMtbG9hZGVyL2luZGV4LmpzP3R5cGU9dHMmaW5zdGFuY2VOYW1lPTBfZG9qbyEuL0Jhei50c1wiKSk7XG5cdH0sIFwid2lkZ2V0c1wiKTtcblx0fSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3Byb21pc2UtbG9hZGVyP2dsb2JhbCx3aWRnZXRzIS4vc3JjL0Jhei50c1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3Byb21pc2UtbG9hZGVyL2luZGV4LmpzP2dsb2JhbCx3aWRnZXRzIS4vc3JjL0Jhei50c1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKipcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgUmFmYWVsIFhhdmllciBkZSBTb3V6YVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0xMS0yNlQxNTowM1pcbiAqL1xuLyohXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjggMjAxNi0xMS0yNlQxNTowM1ogTUlUIGxpY2Vuc2UgwqkgUmFmYWVsIFhhdmllclxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1ELlxuXHRcdGRlZmluZSggZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBOb2RlLiBDb21tb25KUy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBHbG9iYWxcblx0XHRyb290LkNsZHIgPSBmYWN0b3J5KCk7XG5cdH1cblxufSggdGhpcywgZnVuY3Rpb24oKSB7XG5cblxuXHR2YXIgYXJyYXlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIG9iaiApID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdH07XG5cblxuXG5cblx0dmFyIHBhdGhOb3JtYWxpemUgPSBmdW5jdGlvbiggcGF0aCwgYXR0cmlidXRlcyApIHtcblx0XHRpZiAoIGFycmF5SXNBcnJheSggcGF0aCApICkge1xuXHRcdFx0cGF0aCA9IHBhdGguam9pbiggXCIvXCIgKTtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgcGF0aCAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJpbnZhbGlkIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiICk7XG5cdFx0fVxuXHRcdC8vIDE6IElnbm9yZSBsZWFkaW5nIHNsYXNoIGAvYFxuXHRcdC8vIDI6IElnbm9yZSBsZWFkaW5nIGBjbGRyL2Bcblx0XHRwYXRoID0gcGF0aFxuXHRcdFx0LnJlcGxhY2UoIC9eXFwvLyAsIFwiXCIgKSAvKiAxICovXG5cdFx0XHQucmVwbGFjZSggL15jbGRyXFwvLyAsIFwiXCIgKTsgLyogMiAqL1xuXG5cdFx0Ly8gUmVwbGFjZSB7YXR0cmlidXRlfSdzXG5cdFx0cGF0aCA9IHBhdGgucmVwbGFjZSggL3tbYS16QS1aXSt9L2csIGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZSggL157KFtefV0qKX0kLywgXCIkMVwiICk7XG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHBhdGguc3BsaXQoIFwiL1wiICk7XG5cdH07XG5cblxuXG5cblx0dmFyIGFycmF5U29tZSA9IGZ1bmN0aW9uKCBhcnJheSwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGksIGxlbmd0aDtcblx0XHRpZiAoIGFycmF5LnNvbWUgKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuc29tZSggY2FsbGJhY2sgKTtcblx0XHR9XG5cdFx0Zm9yICggaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBjYWxsYmFjayggYXJyYXlbIGkgXSwgaSwgYXJyYXkgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBtYXhpbWl6ZWQgbGFuZ3VhZ2UgaWQgYXMgZGVmaW5lZCBpblxuXHQgKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jTGlrZWx5X1N1YnRhZ3Ncblx0ICogMS4gQ2Fub25pY2FsaXplLlxuXHQgKiAxLjEgTWFrZSBzdXJlIHRoZSBpbnB1dCBsb2NhbGUgaXMgaW4gY2Fub25pY2FsIGZvcm06IHVzZXMgdGhlIHJpZ2h0XG5cdCAqIHNlcGFyYXRvciwgYW5kIGhhcyB0aGUgcmlnaHQgY2FzaW5nLlxuXHQgKiBUT0RPIFJpZ2h0IGNhc2luZz8gV2hhdCBkZj8gSXQgc2VlbXMgbGFuZ3VhZ2VzIGFyZSBsb3dlcmNhc2UsIHNjcmlwdHMgYXJlXG5cdCAqIENhcGl0YWxpemVkLCB0ZXJyaXRvcnkgaXMgdXBwZXJjYXNlLiBJIGFtIGxlYXZpbmcgdGhpcyBhcyBhbiBleGVyY2lzZSB0b1xuXHQgKiB0aGUgdXNlci5cblx0ICpcblx0ICogMS4yIFJlcGxhY2UgYW55IGRlcHJlY2F0ZWQgc3VidGFncyB3aXRoIHRoZWlyIGNhbm9uaWNhbCB2YWx1ZXMgdXNpbmcgdGhlXG5cdCAqIDxhbGlhcz4gZGF0YSBpbiBzdXBwbGVtZW50YWwgbWV0YWRhdGEuIFVzZSB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlXG5cdCAqIHJlcGxhY2VtZW50IGxpc3QsIGlmIGl0IGV4aXN0cy4gTGFuZ3VhZ2UgdGFnIHJlcGxhY2VtZW50cyBtYXkgaGF2ZSBtdWx0aXBsZVxuXHQgKiBwYXJ0cywgc3VjaCBhcyBcInNoXCIg4p6eIFwic3JfTGF0blwiIG9yIG1vXCIg4p6eIFwicm9fTURcIi4gSW4gc3VjaCBhIGNhc2UsIHRoZVxuXHQgKiBvcmlnaW5hbCBzY3JpcHQgYW5kL29yIHJlZ2lvbiBhcmUgcmV0YWluZWQgaWYgdGhlcmUgaXMgb25lLiBUaHVzXG5cdCAqIFwic2hfQXJhYl9BUVwiIOKeniBcInNyX0FyYWJfQVFcIiwgbm90IFwic3JfTGF0bl9BUVwiLlxuXHQgKiBUT0RPIFdoYXQgPGFsaWFzPiBkYXRhP1xuXHQgKlxuXHQgKiAxLjMgSWYgdGhlIHRhZyBpcyBncmFuZGZhdGhlcmVkIChzZWUgPHZhcmlhYmxlIGlkPVwiJGdyYW5kZmF0aGVyZWRcIlxuXHQgKiB0eXBlPVwiY2hvaWNlXCI+IGluIHRoZSBzdXBwbGVtZW50YWwgZGF0YSksIHRoZW4gcmV0dXJuIGl0LlxuXHQgKiBUT0RPIGdyYW5kZmF0aGVyZWQ/XG5cdCAqXG5cdCAqIDEuNCBSZW1vdmUgdGhlIHNjcmlwdCBjb2RlICdaenp6JyBhbmQgdGhlIHJlZ2lvbiBjb2RlICdaWicgaWYgdGhleSBvY2N1ci5cblx0ICogMS41IEdldCB0aGUgY29tcG9uZW50cyBvZiB0aGUgY2xlYW5lZC11cCBzb3VyY2UgdGFnIChsYW5ndWFnZXMsIHNjcmlwdHMsXG5cdCAqIGFuZCByZWdpb25zKSwgcGx1cyBhbnkgdmFyaWFudHMgYW5kIGV4dGVuc2lvbnMuXG5cdCAqIDIuIExvb2t1cC4gTG9va3VwIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBpbiBvcmRlciwgYW5kIHN0b3Agb24gdGhlIGZpcnN0XG5cdCAqIG1hdGNoOlxuXHQgKiAyLjEgbGFuZ3VhZ2VzX3NjcmlwdHNfcmVnaW9uc1xuXHQgKiAyLjIgbGFuZ3VhZ2VzX3JlZ2lvbnNcblx0ICogMi4zIGxhbmd1YWdlc19zY3JpcHRzXG5cdCAqIDIuNCBsYW5ndWFnZXNcblx0ICogMi41IHVuZF9zY3JpcHRzXG5cdCAqIDMuIFJldHVyblxuXHQgKiAzLjEgSWYgdGhlcmUgaXMgbm8gbWF0Y2gsIGVpdGhlciByZXR1cm4gYW4gZXJyb3IgdmFsdWUsIG9yIHRoZSBtYXRjaCBmb3Jcblx0ICogXCJ1bmRcIiAoaW4gQVBJcyB3aGVyZSBhIHZhbGlkIGxhbmd1YWdlIHRhZyBpcyByZXF1aXJlZCkuXG5cdCAqIDMuMiBPdGhlcndpc2UgdGhlcmUgaXMgYSBtYXRjaCA9IGxhbmd1YWdlbV9zY3JpcHRtX3JlZ2lvbm1cblx0ICogMy4zIExldCB4ciA9IHhzIGlmIHhzIGlzIG5vdCBlbXB0eSwgYW5kIHhtIG90aGVyd2lzZS5cblx0ICogMy40IFJldHVybiB0aGUgbGFuZ3VhZ2UgdGFnIGNvbXBvc2VkIG9mIGxhbmd1YWdlciBfIHNjcmlwdHIgXyByZWdpb25yICtcblx0ICogdmFyaWFudHMgKyBleHRlbnNpb25zLlxuXHQgKlxuXHQgKiBAc3VidGFncyBbQXJyYXldIG5vcm1hbGl6ZWQgbGFuZ3VhZ2UgaWQgc3VidGFncyB0dXBsZSAoc2VlIGluaXQuanMpLlxuXHQgKi9cblx0dmFyIGNvcmVMaWtlbHlTdWJ0YWdzID0gZnVuY3Rpb24oIENsZHIsIGNsZHIsIHN1YnRhZ3MsIG9wdGlvbnMgKSB7XG5cdFx0dmFyIG1hdGNoLCBtYXRjaEZvdW5kLFxuXHRcdFx0bGFuZ3VhZ2UgPSBzdWJ0YWdzWyAwIF0sXG5cdFx0XHRzY3JpcHQgPSBzdWJ0YWdzWyAxIF0sXG5cdFx0XHRzZXAgPSBDbGRyLmxvY2FsZVNlcCxcblx0XHRcdHRlcnJpdG9yeSA9IHN1YnRhZ3NbIDIgXSxcblx0XHRcdHZhcmlhbnRzID0gc3VidGFncy5zbGljZSggMywgNCApO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gU2tpcCBpZiAobGFuZ3VhZ2UsIHNjcmlwdCwgdGVycml0b3J5KSBpcyBub3QgZW1wdHkgWzMuM11cblx0XHRpZiAoIGxhbmd1YWdlICE9PSBcInVuZFwiICYmIHNjcmlwdCAhPT0gXCJaenp6XCIgJiYgdGVycml0b3J5ICE9PSBcIlpaXCIgKSB7XG5cdFx0XHRyZXR1cm4gWyBsYW5ndWFnZSwgc2NyaXB0LCB0ZXJyaXRvcnkgXS5jb25jYXQoIHZhcmlhbnRzICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2tpcCBpZiBubyBzdXBwbGVtZW50YWwgbGlrZWx5U3VidGFncyBkYXRhIGlzIHByZXNlbnRcblx0XHRpZiAoIHR5cGVvZiBjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFnc1wiICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gWzJdXG5cdFx0bWF0Y2hGb3VuZCA9IGFycmF5U29tZShbXG5cdFx0XHRbIGxhbmd1YWdlLCBzY3JpcHQsIHRlcnJpdG9yeSBdLFxuXHRcdFx0WyBsYW5ndWFnZSwgdGVycml0b3J5IF0sXG5cdFx0XHRbIGxhbmd1YWdlLCBzY3JpcHQgXSxcblx0XHRcdFsgbGFuZ3VhZ2UgXSxcblx0XHRcdFsgXCJ1bmRcIiwgc2NyaXB0IF1cblx0XHRdLCBmdW5jdGlvbiggdGVzdCApIHtcblx0XHRcdHJldHVybiBtYXRjaCA9ICEoL1xcYihaenp6fFpaKVxcYi8pLnRlc3QoIHRlc3Quam9pbiggc2VwICkgKSAvKiBbMS40XSAqLyAmJiBjbGRyLmdldCggWyBcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzXCIsIHRlc3Quam9pbiggc2VwICkgXSApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gWzNdXG5cdFx0aWYgKCBtYXRjaEZvdW5kICkge1xuXHRcdFx0Ly8gWzMuMiAuLiAzLjRdXG5cdFx0XHRtYXRjaCA9IG1hdGNoLnNwbGl0KCBzZXAgKTtcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdGxhbmd1YWdlICE9PSBcInVuZFwiID8gbGFuZ3VhZ2UgOiBtYXRjaFsgMCBdLFxuXHRcdFx0XHRzY3JpcHQgIT09IFwiWnp6elwiID8gc2NyaXB0IDogbWF0Y2hbIDEgXSxcblx0XHRcdFx0dGVycml0b3J5ICE9PSBcIlpaXCIgPyB0ZXJyaXRvcnkgOiBtYXRjaFsgMiBdXG5cdFx0XHRdLmNvbmNhdCggdmFyaWFudHMgKTtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLmZvcmNlICkge1xuXHRcdFx0Ly8gWzMuMS4yXVxuXHRcdFx0cmV0dXJuIGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzL3VuZFwiICkuc3BsaXQoIHNlcCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBbMy4xLjFdXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9O1xuXG5cblxuXHQvKipcblx0ICogR2l2ZW4gYSBsb2NhbGUsIHJlbW92ZSBhbnkgZmllbGRzIHRoYXQgQWRkIExpa2VseSBTdWJ0YWdzIHdvdWxkIGFkZC5cblx0ICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI0xpa2VseV9TdWJ0YWdzXG5cdCAqIDEuIEZpcnN0IGdldCBtYXggPSBBZGRMaWtlbHlTdWJ0YWdzKGlucHV0TG9jYWxlKS4gSWYgYW4gZXJyb3IgaXMgc2lnbmFsZWQsXG5cdCAqIHJldHVybiBpdC5cblx0ICogMi4gUmVtb3ZlIHRoZSB2YXJpYW50cyBmcm9tIG1heC5cblx0ICogMy4gVGhlbiBmb3IgdHJpYWwgaW4ge2xhbmd1YWdlLCBsYW5ndWFnZSBfIHJlZ2lvbiwgbGFuZ3VhZ2UgXyBzY3JpcHR9LiBJZlxuXHQgKiBBZGRMaWtlbHlTdWJ0YWdzKHRyaWFsKSA9IG1heCwgdGhlbiByZXR1cm4gdHJpYWwgKyB2YXJpYW50cy5cblx0ICogNC4gSWYgeW91IGRvIG5vdCBnZXQgYSBtYXRjaCwgcmV0dXJuIG1heCArIHZhcmlhbnRzLlxuXHQgKiBcblx0ICogQG1heExhbmd1YWdlSWQgW0FycmF5XSBtYXhMYW5ndWFnZUlkIHR1cGxlIChzZWUgaW5pdC5qcykuXG5cdCAqL1xuXHR2YXIgY29yZVJlbW92ZUxpa2VseVN1YnRhZ3MgPSBmdW5jdGlvbiggQ2xkciwgY2xkciwgbWF4TGFuZ3VhZ2VJZCApIHtcblx0XHR2YXIgbWF0Y2gsIG1hdGNoRm91bmQsXG5cdFx0XHRsYW5ndWFnZSA9IG1heExhbmd1YWdlSWRbIDAgXSxcblx0XHRcdHNjcmlwdCA9IG1heExhbmd1YWdlSWRbIDEgXSxcblx0XHRcdHRlcnJpdG9yeSA9IG1heExhbmd1YWdlSWRbIDIgXSxcblx0XHRcdHZhcmlhbnRzID0gbWF4TGFuZ3VhZ2VJZFsgMyBdO1xuXG5cdFx0Ly8gWzNdXG5cdFx0bWF0Y2hGb3VuZCA9IGFycmF5U29tZShbXG5cdFx0XHRbIFsgbGFuZ3VhZ2UsIFwiWnp6elwiLCBcIlpaXCIgXSwgWyBsYW5ndWFnZSBdIF0sXG5cdFx0XHRbIFsgbGFuZ3VhZ2UsIFwiWnp6elwiLCB0ZXJyaXRvcnkgXSwgWyBsYW5ndWFnZSwgdGVycml0b3J5IF0gXSxcblx0XHRcdFsgWyBsYW5ndWFnZSwgc2NyaXB0LCBcIlpaXCIgXSwgWyBsYW5ndWFnZSwgc2NyaXB0IF0gXVxuXHRcdF0sIGZ1bmN0aW9uKCB0ZXN0ICkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGNvcmVMaWtlbHlTdWJ0YWdzKCBDbGRyLCBjbGRyLCB0ZXN0WyAwIF0gKTtcblx0XHRcdG1hdGNoID0gdGVzdFsgMSBdO1xuXHRcdFx0cmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbIDAgXSA9PT0gbWF4TGFuZ3VhZ2VJZFsgMCBdICYmXG5cdFx0XHRcdHJlc3VsdFsgMSBdID09PSBtYXhMYW5ndWFnZUlkWyAxIF0gJiZcblx0XHRcdFx0cmVzdWx0WyAyIF0gPT09IG1heExhbmd1YWdlSWRbIDIgXTtcblx0XHR9KTtcblxuXHRcdGlmICggbWF0Y2hGb3VuZCApIHtcblx0XHRcdGlmICggdmFyaWFudHMgKSB7XG5cdFx0XHRcdG1hdGNoLnB1c2goIHZhcmlhbnRzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gWzRdXG5cdFx0cmV0dXJuIG1heExhbmd1YWdlSWQ7XG5cdH07XG5cblxuXG5cblx0LyoqXG5cdCAqIHN1YnRhZ3MoIGxvY2FsZSApXG5cdCAqXG5cdCAqIEBsb2NhbGUgW1N0cmluZ11cblx0ICovXG5cdHZhciBjb3JlU3VidGFncyA9IGZ1bmN0aW9uKCBsb2NhbGUgKSB7XG5cdFx0dmFyIGF1eCwgdW5pY29kZUxhbmd1YWdlSWQsXG5cdFx0XHRzdWJ0YWdzID0gW107XG5cblx0XHRsb2NhbGUgPSBsb2NhbGUucmVwbGFjZSggL18vLCBcIi1cIiApO1xuXG5cdFx0Ly8gVW5pY29kZSBsb2NhbGUgZXh0ZW5zaW9ucy5cblx0XHRhdXggPSBsb2NhbGUuc3BsaXQoIFwiLXUtXCIgKTtcblx0XHRpZiAoIGF1eFsgMSBdICkge1xuXHRcdFx0YXV4WyAxIF0gPSBhdXhbIDEgXS5zcGxpdCggXCItdC1cIiApO1xuXHRcdFx0bG9jYWxlID0gYXV4WyAwIF0gKyAoIGF1eFsgMSBdWyAxIF0gPyBcIi10LVwiICsgYXV4WyAxIF1bIDEgXSA6IFwiXCIpO1xuXHRcdFx0c3VidGFnc1sgNCAvKiB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucyAqLyBdID0gYXV4WyAxIF1bIDAgXTtcblx0XHR9XG5cblx0XHQvLyBUT0RPIG5vcm1hbGl6ZSB0cmFuc2Zvcm1lZCBleHRlbnNpb25zLiBDdXJyZW50bHksIHNraXBwZWQuXG5cdFx0Ly8gc3VidGFnc1sgeCBdID0gbG9jYWxlLnNwbGl0KCBcIi10LVwiIClbIDEgXTtcblx0XHR1bmljb2RlTGFuZ3VhZ2VJZCA9IGxvY2FsZS5zcGxpdCggXCItdC1cIiApWyAwIF07XG5cblx0XHQvLyB1bmljb2RlX2xhbmd1YWdlX2lkID0gXCJyb290XCJcblx0XHQvLyAgIHwgdW5pY29kZV9sYW5ndWFnZV9zdWJ0YWcgICAgICAgICBcblx0XHQvLyAgICAgKHNlcCB1bmljb2RlX3NjcmlwdF9zdWJ0YWcpPyBcblx0XHQvLyAgICAgKHNlcCB1bmljb2RlX3JlZ2lvbl9zdWJ0YWcpP1xuXHRcdC8vICAgICAoc2VwIHVuaWNvZGVfdmFyaWFudF9zdWJ0YWcpKiA7XG5cdFx0Ly9cblx0XHQvLyBBbHRob3VnaCB1bmljb2RlX2xhbmd1YWdlX3N1YnRhZyA9IGFscGhhezIsOH0sIEknbSB1c2luZyBhbHBoYXsyLDN9LiBCZWNhdXNlLCB0aGVyZSdzIG5vIGxhbmd1YWdlIG9uIENMRFIgbGVuZ3RoaWVyIHRoYW4gMy5cblx0XHRhdXggPSB1bmljb2RlTGFuZ3VhZ2VJZC5tYXRjaCggL14oKFthLXpdezIsM30pKC0oW0EtWl1bYS16XXszfSkpPygtKFtBLVpdezJ9fFswLTldezN9KSk/KSgoLShbYS16QS1aMC05XXs1LDh9fFswLTldW2EtekEtWjAtOV17M30pKSopJHxeKHJvb3QpJC8gKTtcblx0XHRpZiAoIGF1eCA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBbIFwidW5kXCIsIFwiWnp6elwiLCBcIlpaXCIgXTtcblx0XHR9XG5cdFx0c3VidGFnc1sgMCAvKiBsYW5ndWFnZSAqLyBdID0gYXV4WyAxMCBdIC8qIHJvb3QgKi8gfHwgYXV4WyAyIF0gfHwgXCJ1bmRcIjtcblx0XHRzdWJ0YWdzWyAxIC8qIHNjcmlwdCAqLyBdID0gYXV4WyA0IF0gfHwgXCJaenp6XCI7XG5cdFx0c3VidGFnc1sgMiAvKiB0ZXJyaXRvcnkgKi8gXSA9IGF1eFsgNiBdIHx8IFwiWlpcIjtcblx0XHRpZiAoIGF1eFsgNyBdICYmIGF1eFsgNyBdLmxlbmd0aCApIHtcblx0XHRcdHN1YnRhZ3NbIDMgLyogdmFyaWFudCAqLyBdID0gYXV4WyA3IF0uc2xpY2UoIDEgKSAvKiByZW1vdmUgbGVhZGluZyBcIi1cIiAqLztcblx0XHR9XG5cblx0XHQvLyAwOiBsYW5ndWFnZVxuXHRcdC8vIDE6IHNjcmlwdFxuXHRcdC8vIDI6IHRlcnJpdG9yeSAoYWthIHJlZ2lvbilcblx0XHQvLyAzOiB2YXJpYW50XG5cdFx0Ly8gNDogdW5pY29kZUxvY2FsZUV4dGVuc2lvbnNcblx0XHRyZXR1cm4gc3VidGFncztcblx0fTtcblxuXG5cblxuXHR2YXIgYXJyYXlGb3JFYWNoID0gZnVuY3Rpb24oIGFycmF5LCBjYWxsYmFjayApIHtcblx0XHR2YXIgaSwgbGVuZ3RoO1xuXHRcdGlmICggYXJyYXkuZm9yRWFjaCApIHtcblx0XHRcdHJldHVybiBhcnJheS5mb3JFYWNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0XHRmb3IgKCBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFjayggYXJyYXlbIGkgXSwgaSwgYXJyYXkgKTtcblx0XHR9XG5cdH07XG5cblxuXG5cblx0LyoqXG5cdCAqIGJ1bmRsZUxvb2t1cCggbWluTGFuZ3VhZ2VJZCApXG5cdCAqXG5cdCAqIEBDbGRyIFtDbGRyIGNsYXNzXVxuXHQgKlxuXHQgKiBAY2xkciBbQ2xkciBpbnN0YW5jZV1cblx0ICpcblx0ICogQG1pbkxhbmd1YWdlSWQgW1N0cmluZ10gcmVxdWVzdGVkIGxhbmd1YWdlSWQgYWZ0ZXIgYXBwbGllZCByZW1vdmUgbGlrZWx5IHN1YnRhZ3MuXG5cdCAqL1xuXHR2YXIgYnVuZGxlTG9va3VwID0gZnVuY3Rpb24oIENsZHIsIGNsZHIsIG1pbkxhbmd1YWdlSWQgKSB7XG5cdFx0dmFyIGF2YWlsYWJsZUJ1bmRsZU1hcCA9IENsZHIuX2F2YWlsYWJsZUJ1bmRsZU1hcCxcblx0XHRcdGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlID0gQ2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWU7XG5cblx0XHRpZiAoIGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlLmxlbmd0aCApIHtcblx0XHRcdGFycmF5Rm9yRWFjaCggYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUsIGZ1bmN0aW9uKCBidW5kbGUgKSB7XG5cdFx0XHRcdHZhciBleGlzdGluZywgbWF4QnVuZGxlLCBtaW5CdW5kbGUsIHN1YnRhZ3M7XG5cdFx0XHRcdHN1YnRhZ3MgPSBjb3JlU3VidGFncyggYnVuZGxlICk7XG5cdFx0XHRcdG1heEJ1bmRsZSA9IGNvcmVMaWtlbHlTdWJ0YWdzKCBDbGRyLCBjbGRyLCBzdWJ0YWdzICk7XG5cdFx0XHRcdG1pbkJ1bmRsZSA9IGNvcmVSZW1vdmVMaWtlbHlTdWJ0YWdzKCBDbGRyLCBjbGRyLCBtYXhCdW5kbGUgKTtcblx0XHRcdFx0bWluQnVuZGxlID0gbWluQnVuZGxlLmpvaW4oIENsZHIubG9jYWxlU2VwICk7XG5cdFx0XHRcdGV4aXN0aW5nID0gYXZhaWxhYmxlQnVuZGxlTWFwUXVldWVbIG1pbkJ1bmRsZSBdO1xuXHRcdFx0XHRpZiAoIGV4aXN0aW5nICYmIGV4aXN0aW5nLmxlbmd0aCA8IGJ1bmRsZS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF2YWlsYWJsZUJ1bmRsZU1hcFsgbWluQnVuZGxlIF0gPSBidW5kbGU7XG5cdFx0XHR9KTtcblx0XHRcdENsZHIuX2F2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlID0gW107XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF2YWlsYWJsZUJ1bmRsZU1hcFsgbWluTGFuZ3VhZ2VJZCBdIHx8IG51bGw7XG5cdH07XG5cblxuXG5cblx0dmFyIG9iamVjdEtleXMgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0cmVzdWx0ID0gW107XG5cblx0XHRpZiAoIE9iamVjdC5rZXlzICkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKCBvYmplY3QgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpIGluIG9iamVjdCApIHtcblx0XHRcdHJlc3VsdC5wdXNoKCBpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXG5cblxuXHR2YXIgY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiggY29kZSwgYXR0cmlidXRlcyApIHtcblx0XHR2YXIgZXJyb3IsIG1lc3NhZ2U7XG5cblx0XHRtZXNzYWdlID0gY29kZSArICggYXR0cmlidXRlcyAmJiBKU09OID8gXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoIGF0dHJpYnV0ZXMgKSA6IFwiXCIgKTtcblx0XHRlcnJvciA9IG5ldyBFcnJvciggbWVzc2FnZSApO1xuXHRcdGVycm9yLmNvZGUgPSBjb2RlO1xuXG5cdFx0Ly8gZXh0ZW5kKCBlcnJvciwgYXR0cmlidXRlcyApO1xuXHRcdGFycmF5Rm9yRWFjaCggb2JqZWN0S2V5cyggYXR0cmlidXRlcyApLCBmdW5jdGlvbiggYXR0cmlidXRlICkge1xuXHRcdFx0ZXJyb3JbIGF0dHJpYnV0ZSBdID0gYXR0cmlidXRlc1sgYXR0cmlidXRlIF07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZXJyb3I7XG5cdH07XG5cblxuXG5cblx0dmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oIGNvZGUsIGNoZWNrLCBhdHRyaWJ1dGVzICkge1xuXHRcdGlmICggIWNoZWNrICkge1xuXHRcdFx0dGhyb3cgY3JlYXRlRXJyb3IoIGNvZGUsIGF0dHJpYnV0ZXMgKTtcblx0XHR9XG5cdH07XG5cblxuXG5cblx0dmFyIHZhbGlkYXRlUHJlc2VuY2UgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFsaWRhdGUoIFwiRV9NSVNTSU5HX1BBUkFNRVRFUlwiLCB0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIsIHtcblx0XHRcdG5hbWU6IG5hbWVcblx0XHR9KTtcblx0fTtcblxuXG5cblxuXHR2YXIgdmFsaWRhdGVUeXBlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lLCBjaGVjaywgZXhwZWN0ZWQgKSB7XG5cdFx0dmFsaWRhdGUoIFwiRV9JTlZBTElEX1BBUl9UWVBFXCIsIGNoZWNrLCB7XG5cdFx0XHRleHBlY3RlZDogZXhwZWN0ZWQsXG5cdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fSk7XG5cdH07XG5cblxuXG5cblx0dmFyIHZhbGlkYXRlVHlwZVBhdGggPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IGFycmF5SXNBcnJheSggdmFsdWUgKSwgXCJTdHJpbmcgb3IgQXJyYXlcIiApO1xuXHR9O1xuXG5cblxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiBpbnNwaXJlZCBieSBqUXVlcnkgQ29yZSwgYnV0IHJlZHVjZWQgdG8gb3VyIHVzZSBjYXNlLlxuXHQgKi9cblx0dmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT09IG51bGwgJiYgXCJcIiArIG9iaiA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcblx0fTtcblxuXG5cblxuXHR2YXIgdmFsaWRhdGVUeXBlUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzUGxhaW5PYmplY3QoIHZhbHVlICksIFwiUGxhaW4gT2JqZWN0XCIgKTtcblx0fTtcblxuXG5cblxuXHR2YXIgdmFsaWRhdGVUeXBlU3RyaW5nID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHRcdHZhbGlkYXRlVHlwZSggdmFsdWUsIG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiwgXCJhIHN0cmluZ1wiICk7XG5cdH07XG5cblxuXG5cblx0Ly8gQHBhdGg6IG5vcm1hbGl6ZWQgcGF0aFxuXHR2YXIgcmVzb3VyY2VHZXQgPSBmdW5jdGlvbiggZGF0YSwgcGF0aCApIHtcblx0XHR2YXIgaSxcblx0XHRcdG5vZGUgPSBkYXRhLFxuXHRcdFx0bGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdG5vZGUgPSBub2RlWyBwYXRoWyBpIF0gXTtcblx0XHRcdGlmICggIW5vZGUgKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlWyBwYXRoWyBpIF0gXTtcblx0fTtcblxuXG5cblxuXHQvKipcblx0ICogc2V0QXZhaWxhYmxlQnVuZGxlcyggQ2xkciwganNvbiApXG5cdCAqXG5cdCAqIEBDbGRyIFtDbGRyIGNsYXNzXVxuXHQgKlxuXHQgKiBAanNvbiByZXNvbHZlZC91bnJlc29sdmVkIGNsZHIgZGF0YS5cblx0ICpcblx0ICogU2V0IGF2YWlsYWJsZSBidW5kbGVzIHF1ZXVlIGJhc2VkIG9uIHBhc3NlZCBqc29uIENMRFIgZGF0YS4gQ29uc2lkZXJzIGEgYnVuZGxlIGFzIGFueSBTdHJpbmcgYXQgL21haW4ve2J1bmRsZX0uXG5cdCAqL1xuXHR2YXIgY29yZVNldEF2YWlsYWJsZUJ1bmRsZXMgPSBmdW5jdGlvbiggQ2xkciwganNvbiApIHtcblx0XHR2YXIgYnVuZGxlLFxuXHRcdFx0YXZhaWxhYmxlQnVuZGxlTWFwUXVldWUgPSBDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSxcblx0XHRcdG1haW4gPSByZXNvdXJjZUdldCgganNvbiwgWyBcIm1haW5cIiBdICk7XG5cblx0XHRpZiAoIG1haW4gKSB7XG5cdFx0XHRmb3IgKCBidW5kbGUgaW4gbWFpbiApIHtcblx0XHRcdFx0aWYgKCBtYWluLmhhc093blByb3BlcnR5KCBidW5kbGUgKSAmJiBidW5kbGUgIT09IFwicm9vdFwiICYmXG5cdFx0XHRcdFx0XHRcdGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlLmluZGV4T2YoIGJ1bmRsZSApID09PSAtMSApIHtcblx0XHRcdFx0XHRhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZS5wdXNoKCBidW5kbGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cblx0dmFyIGFsd2F5c0FycmF5ID0gZnVuY3Rpb24oIHNvbWV0aGluZ09yQXJyYXkgKSB7XG5cdFx0cmV0dXJuIGFycmF5SXNBcnJheSggc29tZXRoaW5nT3JBcnJheSApID8gIHNvbWV0aGluZ09yQXJyYXkgOiBbIHNvbWV0aGluZ09yQXJyYXkgXTtcblx0fTtcblxuXG5cdHZhciBqc29uTWVyZ2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0Ly8gUmV0dXJucyBuZXcgZGVlcGx5IG1lcmdlZCBKU09OLlxuXHQvL1xuXHQvLyBFZy5cblx0Ly8gbWVyZ2UoIHsgYTogeyBiOiAxLCBjOiAyIH0gfSwgeyBhOiB7IGI6IDMsIGQ6IDQgfSB9IClcblx0Ly8gLT4geyBhOiB7IGI6IDMsIGM6IDIsIGQ6IDQgfSB9XG5cdC8vXG5cdC8vIEBhcmd1bWVudHMgSlNPTidzXG5cdC8vIFxuXHR2YXIgbWVyZ2UgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVzdGluYXRpb24gPSB7fSxcblx0XHRcdHNvdXJjZXMgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblx0XHRhcnJheUZvckVhY2goIHNvdXJjZXMsIGZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xuXHRcdFx0XHRpZiAoIHByb3AgaW4gZGVzdGluYXRpb24gJiYgdHlwZW9mIGRlc3RpbmF0aW9uWyBwcm9wIF0gPT09IFwib2JqZWN0XCIgJiYgIWFycmF5SXNBcnJheSggZGVzdGluYXRpb25bIHByb3AgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gTWVyZ2UgT2JqZWN0c1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uWyBwcm9wIF0gPSBtZXJnZSggZGVzdGluYXRpb25bIHByb3AgXSwgc291cmNlWyBwcm9wIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IG5ldyB2YWx1ZXNcblx0XHRcdFx0XHRkZXN0aW5hdGlvblsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBkZXN0aW5hdGlvbjtcblx0fTtcblxuXHRyZXR1cm4gbWVyZ2U7XG5cbn0oKSk7XG5cblxuXHQvKipcblx0ICogbG9hZCggQ2xkciwgc291cmNlLCBqc29ucyApXG5cdCAqXG5cdCAqIEBDbGRyIFtDbGRyIGNsYXNzXVxuXHQgKlxuXHQgKiBAc291cmNlIFtPYmplY3RdXG5cdCAqXG5cdCAqIEBqc29ucyBbYXJndW1lbnRzXVxuXHQgKi9cblx0dmFyIGNvcmVMb2FkID0gZnVuY3Rpb24oIENsZHIsIHNvdXJjZSwganNvbnMgKSB7XG5cdFx0dmFyIGksIGosIGpzb247XG5cblx0XHR2YWxpZGF0ZVByZXNlbmNlKCBqc29uc1sgMCBdLCBcImpzb25cIiApO1xuXG5cdFx0Ly8gU3VwcG9ydCBhcmJpdHJhcnkgcGFyYW1ldGVycywgZS5nLiwgYENsZHIubG9hZCh7Li4ufSwgey4uLn0pYC5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IHBhcmFtZXRlcnMsIGUuZy4sIGBDbGRyLmxvYWQoW3suLi59LCB7Li4ufV0pYC5cblx0XHRcdGpzb24gPSBhbHdheXNBcnJheSgganNvbnNbIGkgXSApO1xuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IGpzb24ubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdHZhbGlkYXRlVHlwZVBsYWluT2JqZWN0KCBqc29uWyBqIF0sIFwianNvblwiICk7XG5cdFx0XHRcdHNvdXJjZSA9IGpzb25NZXJnZSggc291cmNlLCBqc29uWyBqIF0gKTtcblx0XHRcdFx0Y29yZVNldEF2YWlsYWJsZUJ1bmRsZXMoIENsZHIsIGpzb25bIGogXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH07XG5cblxuXG5cdHZhciBpdGVtR2V0UmVzb2x2ZWQgPSBmdW5jdGlvbiggQ2xkciwgcGF0aCwgYXR0cmlidXRlcyApIHtcblx0XHQvLyBSZXNvbHZlIHBhdGhcblx0XHR2YXIgbm9ybWFsaXplZFBhdGggPSBwYXRoTm9ybWFsaXplKCBwYXRoLCBhdHRyaWJ1dGVzICk7XG5cblx0XHRyZXR1cm4gcmVzb3VyY2VHZXQoIENsZHIuX3Jlc29sdmVkLCBub3JtYWxpemVkUGF0aCApO1xuXHR9O1xuXG5cblxuXG5cdC8qKlxuXHQgKiBuZXcgQ2xkcigpXG5cdCAqL1xuXHR2YXIgQ2xkciA9IGZ1bmN0aW9uKCBsb2NhbGUgKSB7XG5cdFx0dGhpcy5pbml0KCBsb2NhbGUgKTtcblx0fTtcblxuXHQvLyBCdWlsZCBvcHRpbWl6YXRpb24gaGFjayB0byBhdm9pZCBkdXBsaWNhdGluZyBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXG5cdENsZHIuX2Fsd2F5c0FycmF5ID0gYWx3YXlzQXJyYXk7XG5cdENsZHIuX2NvcmVMb2FkID0gY29yZUxvYWQ7XG5cdENsZHIuX2NyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XG5cdENsZHIuX2l0ZW1HZXRSZXNvbHZlZCA9IGl0ZW1HZXRSZXNvbHZlZDtcblx0Q2xkci5fanNvbk1lcmdlID0ganNvbk1lcmdlO1xuXHRDbGRyLl9wYXRoTm9ybWFsaXplID0gcGF0aE5vcm1hbGl6ZTtcblx0Q2xkci5fcmVzb3VyY2VHZXQgPSByZXNvdXJjZUdldDtcblx0Q2xkci5fdmFsaWRhdGVQcmVzZW5jZSA9IHZhbGlkYXRlUHJlc2VuY2U7XG5cdENsZHIuX3ZhbGlkYXRlVHlwZSA9IHZhbGlkYXRlVHlwZTtcblx0Q2xkci5fdmFsaWRhdGVUeXBlUGF0aCA9IHZhbGlkYXRlVHlwZVBhdGg7XG5cdENsZHIuX3ZhbGlkYXRlVHlwZVBsYWluT2JqZWN0ID0gdmFsaWRhdGVUeXBlUGxhaW5PYmplY3Q7XG5cblx0Q2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwID0ge307XG5cdENsZHIuX2F2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlID0gW107XG5cdENsZHIuX3Jlc29sdmVkID0ge307XG5cblx0Ly8gQWxsb3cgdXNlciB0byBvdmVycmlkZSBsb2NhbGUgc2VwYXJhdG9yIFwiLVwiIChkZWZhdWx0KSB8IFwiX1wiLiBBY2NvcmRpbmcgdG8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI1VuaWNvZGVfbGFuZ3VhZ2VfaWRlbnRpZmllciwgYm90aCBcIi1cIiBhbmQgXCJfXCIgYXJlIHZhbGlkIGxvY2FsZSBzZXBhcmF0b3JzIChlZy4gXCJlbl9HQlwiLCBcImVuLUdCXCIpLiBBY2NvcmRpbmcgdG8gaHR0cDovL3VuaWNvZGUub3JnL2NsZHIvdHJhYy90aWNrZXQvNjc4NiBpdHMgdXNhZ2UgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgdGhlIGRhdGEgc2V0LlxuXHRDbGRyLmxvY2FsZVNlcCA9IFwiLVwiO1xuXG5cdC8qKlxuXHQgKiBDbGRyLmxvYWQoIGpzb24gWywganNvbiwgLi4uXSApXG5cdCAqXG5cdCAqIEBqc29uIFtKU09OXSBDTERSIGRhdGEgb3IgW0FycmF5XSBBcnJheSBvZiBAanNvbidzLlxuXHQgKlxuXHQgKiBMb2FkIHJlc29sdmVkIGNsZHIgZGF0YS5cblx0ICovXG5cdENsZHIubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdENsZHIuX3Jlc29sdmVkID0gY29yZUxvYWQoIENsZHIsIENsZHIuX3Jlc29sdmVkLCBhcmd1bWVudHMgKTtcblx0fTtcblxuXHQvKipcblx0ICogLmluaXQoKSBhdXRvbWF0aWNhbGx5IHJ1biBvbiBpbnN0YW50aWF0aW9uL2NvbnN0cnVjdGlvbi5cblx0ICovXG5cdENsZHIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggbG9jYWxlICkge1xuXHRcdHZhciBhdHRyaWJ1dGVzLCBsYW5ndWFnZSwgbWF4TGFuZ3VhZ2VJZCwgbWluTGFuZ3VhZ2VJZCwgc2NyaXB0LCBzdWJ0YWdzLCB0ZXJyaXRvcnksIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zLCB2YXJpYW50LFxuXHRcdFx0c2VwID0gQ2xkci5sb2NhbGVTZXAsXG5cdFx0XHR1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1JhdyA9IFwiXCI7XG5cblx0XHR2YWxpZGF0ZVByZXNlbmNlKCBsb2NhbGUsIFwibG9jYWxlXCIgKTtcblx0XHR2YWxpZGF0ZVR5cGVTdHJpbmcoIGxvY2FsZSwgXCJsb2NhbGVcIiApO1xuXG5cdFx0c3VidGFncyA9IGNvcmVTdWJ0YWdzKCBsb2NhbGUgKTtcblxuXHRcdGlmICggc3VidGFncy5sZW5ndGggPT09IDUgKSB7XG5cdFx0XHR1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucyA9IHN1YnRhZ3MucG9wKCk7XG5cdFx0XHR1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1JhdyA9IHNlcCArIFwidVwiICsgc2VwICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnM7XG5cdFx0XHQvLyBSZW1vdmUgdHJhaWxpbmcgbnVsbCB3aGVuIHRoZXJlIGlzIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zIGJ1dCBubyB2YXJpYW50cy5cblx0XHRcdGlmICggIXN1YnRhZ3NbIDMgXSApIHtcblx0XHRcdFx0c3VidGFncy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyaWFudCA9IHN1YnRhZ3NbIDMgXTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBsb2NhbGUgY29kZS5cblx0XHQvLyBHZXQgKG9yIGRlZHVjZSkgdGhlIFwidHJpcGxlIHN1YnRhZ3NcIjogbGFuZ3VhZ2UsIHRlcnJpdG9yeSAoYWxzbyBhbGlhc2VkIGFzIHJlZ2lvbiksIGFuZCBzY3JpcHQgc3VidGFncy5cblx0XHQvLyBHZXQgdGhlIHZhcmlhbnQgc3VidGFncyAoY2FsZW5kYXIsIGNvbGxhdGlvbiwgY3VycmVuY3ksIGV0YykuXG5cdFx0Ly8gcmVmczpcblx0XHQvLyAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNGaWVsZF9EZWZpbml0aW9uc1xuXHRcdC8vIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI0xhbmd1YWdlX2FuZF9Mb2NhbGVfSURzXG5cdFx0Ly8gLSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jVW5pY29kZV9sb2NhbGVfaWRlbnRpZmllclxuXG5cdFx0Ly8gV2hlbiBhIGxvY2FsZSBpZCBkb2VzIG5vdCBzcGVjaWZ5IGEgbGFuZ3VhZ2UsIG9yIHRlcnJpdG9yeSAocmVnaW9uKSwgb3Igc2NyaXB0LCB0aGV5IGFyZSBvYnRhaW5lZCBieSBMaWtlbHkgU3VidGFncy5cblx0XHRtYXhMYW5ndWFnZUlkID0gY29yZUxpa2VseVN1YnRhZ3MoIENsZHIsIHRoaXMsIHN1YnRhZ3MsIHsgZm9yY2U6IHRydWUgfSApIHx8IHN1YnRhZ3M7XG5cdFx0bGFuZ3VhZ2UgPSBtYXhMYW5ndWFnZUlkWyAwIF07XG5cdFx0c2NyaXB0ID0gbWF4TGFuZ3VhZ2VJZFsgMSBdO1xuXHRcdHRlcnJpdG9yeSA9IG1heExhbmd1YWdlSWRbIDIgXTtcblxuXHRcdG1pbkxhbmd1YWdlSWQgPSBjb3JlUmVtb3ZlTGlrZWx5U3VidGFncyggQ2xkciwgdGhpcywgbWF4TGFuZ3VhZ2VJZCApLmpvaW4oIHNlcCApO1xuXG5cdFx0Ly8gU2V0IGF0dHJpYnV0ZXNcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzID0ge1xuXHRcdFx0YnVuZGxlOiBidW5kbGVMb29rdXAoIENsZHIsIHRoaXMsIG1pbkxhbmd1YWdlSWQgKSxcblxuXHRcdFx0Ly8gVW5pY29kZSBMYW5ndWFnZSBJZFxuXHRcdFx0bWluTGFuZ3VhZ2VJZDogbWluTGFuZ3VhZ2VJZCArIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zUmF3LFxuXHRcdFx0bWF4TGFuZ3VhZ2VJZDogbWF4TGFuZ3VhZ2VJZC5qb2luKCBzZXAgKSArIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zUmF3LFxuXG5cdFx0XHQvLyBVbmljb2RlIExhbmd1YWdlIElkIFN1YnRhYnNcblx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZSxcblx0XHRcdHNjcmlwdDogc2NyaXB0LFxuXHRcdFx0dGVycml0b3J5OiB0ZXJyaXRvcnksXG5cdFx0XHRyZWdpb246IHRlcnJpdG9yeSwgLyogYWxpYXMgKi9cblx0XHRcdHZhcmlhbnQ6IHZhcmlhbnRcblx0XHR9O1xuXG5cdFx0Ly8gVW5pY29kZSBsb2NhbGUgZXh0ZW5zaW9ucy5cblx0XHR1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucyAmJiAoIFwiLVwiICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgKS5yZXBsYWNlKCAvLVthLXpdezMsOH18KC1bYS16XXsyfSktKFthLXpdezMsOH0pL2csIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIGtleSwgdHlwZSApIHtcblxuXHRcdFx0aWYgKCBrZXkgKSB7XG5cblx0XHRcdFx0Ly8gRXh0ZW5zaW9uIGlzIGluIHRoZSBga2V5d29yZGAgZm9ybS5cblx0XHRcdFx0YXR0cmlidXRlc1sgXCJ1XCIgKyBrZXkgXSA9IHR5cGU7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dGVuc2lvbiBpcyBpbiB0aGUgYGF0dHJpYnV0ZWAgZm9ybS5cblx0XHRcdFx0YXR0cmlidXRlc1sgXCJ1XCIgKyBhdHRyaWJ1dGUgXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblx0fTtcblxuXHQvKipcblx0ICogLmdldCgpXG5cdCAqL1xuXHRDbGRyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiggcGF0aCApIHtcblxuXHRcdHZhbGlkYXRlUHJlc2VuY2UoIHBhdGgsIFwicGF0aFwiICk7XG5cdFx0dmFsaWRhdGVUeXBlUGF0aCggcGF0aCwgXCJwYXRoXCIgKTtcblxuXHRcdHJldHVybiBpdGVtR2V0UmVzb2x2ZWQoIENsZHIsIHBhdGgsIHRoaXMuYXR0cmlidXRlcyApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAubWFpbigpXG5cdCAqL1xuXHRDbGRyLnByb3RvdHlwZS5tYWluID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdFx0dmFsaWRhdGVQcmVzZW5jZSggcGF0aCwgXCJwYXRoXCIgKTtcblx0XHR2YWxpZGF0ZVR5cGVQYXRoKCBwYXRoLCBcInBhdGhcIiApO1xuXG5cdFx0dmFsaWRhdGUoIFwiRV9NSVNTSU5HX0JVTkRMRVwiLCB0aGlzLmF0dHJpYnV0ZXMuYnVuZGxlICE9PSBudWxsLCB7XG5cdFx0XHRsb2NhbGU6IHRoaXMubG9jYWxlXG5cdFx0fSk7XG5cblx0XHRwYXRoID0gYWx3YXlzQXJyYXkoIHBhdGggKTtcblx0XHRyZXR1cm4gdGhpcy5nZXQoIFsgXCJtYWluL3tidW5kbGV9XCIgXS5jb25jYXQoIHBhdGggKSApO1xuXHR9O1xuXG5cdHJldHVybiBDbGRyO1xuXG5cblxuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKlxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBSYWZhZWwgWGF2aWVyIGRlIFNvdXphXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTExLTI2VDE1OjAzWlxuICovXG4vKiFcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOCAyMDE2LTExLTI2VDE1OjAzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXG4gKiBodHRwOi8vZ2l0LmlvL2g0bG1WZ1xuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQuXG5cdFx0ZGVmaW5lKCBbIFwiLi4vY2xkclwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gTm9kZS4gQ29tbW9uSlMuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcIi4uL2NsZHJcIiApICk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gR2xvYmFsXG5cdFx0ZmFjdG9yeSggQ2xkciApO1xuXHR9XG5cbn0oZnVuY3Rpb24oIENsZHIgKSB7XG5cblx0Ly8gQnVpbGQgb3B0aW1pemF0aW9uIGhhY2sgdG8gYXZvaWQgZHVwbGljYXRpbmcgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxuXHR2YXIgcGF0aE5vcm1hbGl6ZSA9IENsZHIuX3BhdGhOb3JtYWxpemUsXG5cdFx0dmFsaWRhdGVQcmVzZW5jZSA9IENsZHIuX3ZhbGlkYXRlUHJlc2VuY2UsXG5cdFx0dmFsaWRhdGVUeXBlID0gQ2xkci5fdmFsaWRhdGVUeXBlO1xuXG4vKiFcbiAqIEV2ZW50RW1pdHRlciB2NC4yLjcgLSBnaXQuaW8vZWVcbiAqIE9saXZlciBDYWxkd2VsbFxuICogTUlUIGxpY2Vuc2VcbiAqIEBwcmVzZXJ2ZVxuICovXG5cbnZhciBFdmVudEVtaXR0ZXI7XG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5FdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0LyoqXG5cdCAqIENsYXNzIGZvciBtYW5hZ2luZyBldmVudHMuXG5cdCAqIENhbiBiZSBleHRlbmRlZCB0byBwcm92aWRlIGV2ZW50IGZ1bmN0aW9uYWxpdHkgaW4gb3RoZXIgY2xhc3Nlcy5cblx0ICpcblx0ICogQGNsYXNzIEV2ZW50RW1pdHRlciBNYW5hZ2VzIGV2ZW50IHJlZ2lzdGVyaW5nIGFuZCBlbWl0dGluZy5cblx0ICovXG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XG5cblx0Ly8gU2hvcnRjdXRzIHRvIGltcHJvdmUgc3BlZWQgYW5kIHNpemVcblx0dmFyIHByb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblx0dmFyIGV4cG9ydHMgPSB0aGlzO1xuXHR2YXIgb3JpZ2luYWxHbG9iYWxWYWx1ZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyO1xuXG5cdC8qKlxuXHQgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgaW4gaXQncyBzdG9yYWdlIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uW119IGxpc3RlbmVycyBBcnJheSBvZiBsaXN0ZW5lcnMgdG8gc2VhcmNoIHRocm91Z2guXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBsb29rIGZvci5cblx0ICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyLCAtMSBpZiBub3QgZm91bmRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xuXHRcdHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHQvKipcblx0ICogQWxpYXMgYSBtZXRob2Qgd2hpbGUga2VlcGluZyB0aGUgY29udGV4dCBjb3JyZWN0LCB0byBhbGxvdyBmb3Igb3ZlcndyaXRpbmcgb2YgdGFyZ2V0IG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhcmdldCBtZXRob2QuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgYWxpYXNlZCBtZXRob2Rcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhbGlhcyhuYW1lKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFsaWFzQ2xvc3VyZSgpIHtcblx0XHRcdHJldHVybiB0aGlzW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICogV2lsbCBpbml0aWFsaXNlIHRoZSBldmVudCBvYmplY3QgYW5kIGxpc3RlbmVyIGFycmF5cyBpZiByZXF1aXJlZC5cblx0ICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxuXHQgKiBFYWNoIHByb3BlcnR5IGluIHRoZSBvYmplY3QgcmVzcG9uc2UgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbltdfE9iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgdGhlIGV2ZW50LlxuXHQgKi9cblx0cHJvdG8uZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuXHRcdHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcblx0XHR2YXIgcmVzcG9uc2U7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIFJldHVybiBhIGNvbmNhdGVuYXRlZCBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgZXZlbnRzIGlmXG5cdFx0Ly8gdGhlIHNlbGVjdG9yIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuXHRcdGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdHJlc3BvbnNlID0ge307XG5cdFx0XHRmb3IgKGtleSBpbiBldmVudHMpIHtcblx0XHRcdFx0aWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRyZXNwb25zZVtrZXldID0gZXZlbnRzW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXNwb25zZSA9IGV2ZW50c1tldnRdIHx8IChldmVudHNbZXZ0XSA9IFtdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgbGlzdCBvZiBsaXN0ZW5lciBvYmplY3RzIGFuZCBmbGF0dGVucyBpdCBpbnRvIGEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0W119IGxpc3RlbmVycyBSYXcgbGlzdGVuZXIgb2JqZWN0cy5cblx0ICogQHJldHVybiB7RnVuY3Rpb25bXX0gSnVzdCB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxuXHQgKi9cblx0cHJvdG8uZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uIGZsYXR0ZW5MaXN0ZW5lcnMobGlzdGVuZXJzKSB7XG5cdFx0dmFyIGZsYXRMaXN0ZW5lcnMgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGZsYXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbGF0TGlzdGVuZXJzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGZXRjaGVzIHRoZSByZXF1ZXN0ZWQgbGlzdGVuZXJzIHZpYSBnZXRMaXN0ZW5lcnMgYnV0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgcmVzdWx0cyBpbnNpZGUgYW4gb2JqZWN0LiBUaGlzIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlIGJ1dCBvdGhlcnMgbWF5IGZpbmQgaXQgdXNlZnVsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IGluIGFuIG9iamVjdC5cblx0ICovXG5cdHByb3RvLmdldExpc3RlbmVyc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XG5cdFx0dmFyIHJlc3BvbnNlO1xuXG5cdFx0aWYgKGxpc3RlbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRyZXNwb25zZSA9IHt9O1xuXHRcdFx0cmVzcG9uc2VbZXZ0XSA9IGxpc3RlbmVycztcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzcG9uc2UgfHwgbGlzdGVuZXJzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxuXHQgKiBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGl0IGlzIGNhbGxlZC5cblx0ICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUgdGhlbiB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG5cdFx0dmFyIGxpc3RlbmVySXNXcmFwcGVkID0gdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0Jztcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG5cdFx0XHRpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcikgPT09IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyc1trZXldLnB1c2gobGlzdGVuZXJJc1dyYXBwZWQgPyBsaXN0ZW5lciA6IHtcblx0XHRcdFx0XHRsaXN0ZW5lcjogbGlzdGVuZXIsXG5cdFx0XHRcdFx0b25jZTogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFsaWFzIG9mIGFkZExpc3RlbmVyXG5cdCAqL1xuXHRwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xuXG5cdC8qKlxuXHQgKiBTZW1pLWFsaWFzIG9mIGFkZExpc3RlbmVyLiBJdCB3aWxsIGFkZCBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZVxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgaXQncyBmaXJzdCBleGVjdXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmFkZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZE9uY2VMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZ0LCB7XG5cdFx0XHRsaXN0ZW5lcjogbGlzdGVuZXIsXG5cdFx0XHRvbmNlOiB0cnVlXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFsaWFzIG9mIGFkZE9uY2VMaXN0ZW5lci5cblx0ICovXG5cdHByb3RvLm9uY2UgPSBhbGlhcygnYWRkT25jZUxpc3RlbmVyJyk7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgYW4gZXZlbnQgbmFtZS4gVGhpcyBpcyByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSByZWdleCB0byBhZGQgYSBsaXN0ZW5lciB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gSWYgeW91IGRvbid0IGRvIHRoaXMgdGhlbiBob3cgZG8geW91IGV4cGVjdCBpdCB0byBrbm93IHdoYXQgZXZlbnQgdG8gYWRkIHRvPyBTaG91bGQgaXQganVzdCBhZGQgdG8gZXZlcnkgcG9zc2libGUgbWF0Y2ggZm9yIGEgcmVnZXg/IE5vLiBUaGF0IGlzIHNjYXJ5IGFuZCBiYWQuXG5cdCAqIFlvdSBuZWVkIHRvIHRlbGwgaXQgd2hhdCBldmVudCBuYW1lcyBzaG91bGQgYmUgbWF0Y2hlZCBieSBhIHJlZ2V4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50KGV2dCkge1xuXHRcdHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZXMgZGVmaW5lRXZlbnQgdG8gZGVmaW5lIG11bHRpcGxlIGV2ZW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmdbXX0gZXZ0cyBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkZWZpbmUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uZGVmaW5lRXZlbnRzID0gZnVuY3Rpb24gZGVmaW5lRXZlbnRzKGV2dHMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdHRoaXMuZGVmaW5lRXZlbnQoZXZ0c1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiBXaGVuIHBhc3NlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSwgaXQgd2lsbCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcblx0XHR2YXIgaW5kZXg7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuXHRcdFx0aWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcik7XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyc1trZXldLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWxpYXMgb2YgcmVtb3ZlTGlzdGVuZXJcblx0ICovXG5cdHByb3RvLm9mZiA9IGFsaWFzKCdyZW1vdmVMaXN0ZW5lcicpO1xuXG5cdC8qKlxuXHQgKiBBZGRzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cblx0ICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy4gWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBhZGQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqIFllYWgsIHRoaXMgZnVuY3Rpb24gZG9lcyBxdWl0ZSBhIGJpdC4gVGhhdCdzIHByb2JhYmx5IGEgYmFkIHRoaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XG5cdFx0Ly8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcblx0XHRyZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKGZhbHNlLCBldnQsIGxpc3RlbmVycyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuXHQgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSByZW1vdmVkLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmUgdGhlIGxpc3RlbmVycyBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8ucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XG5cdFx0Ly8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcblx0XHRyZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKHRydWUsIGV2dCwgbGlzdGVuZXJzKTtcblx0fTtcblxuXHQvKipcblx0ICogRWRpdHMgbGlzdGVuZXJzIGluIGJ1bGsuIFRoZSBhZGRMaXN0ZW5lcnMgYW5kIHJlbW92ZUxpc3RlbmVycyBtZXRob2RzIGJvdGggdXNlIHRoaXMgdG8gZG8gdGhlaXIgam9iLiBZb3Ugc2hvdWxkIHJlYWxseSB1c2UgdGhvc2UgaW5zdGVhZCwgdGhpcyBpcyBhIGxpdHRsZSBsb3dlciBsZXZlbC5cblx0ICogVGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgKHRydWUpIG9yIGFkZGVkIChmYWxzZSkuXG5cdCAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC9yZW1vdmVkLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYW5pcHVsYXRlIHRoZSBsaXN0ZW5lcnMgb2YgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSBUcnVlIGlmIHlvdSB3YW50IHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGZhbHNlIGlmIHlvdSB3YW50IHRvIGFkZC5cblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkL3JlbW92ZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5tYW5pcHVsYXRlTGlzdGVuZXJzID0gZnVuY3Rpb24gbWFuaXB1bGF0ZUxpc3RlbmVycyhyZW1vdmUsIGV2dCwgbGlzdGVuZXJzKSB7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBzaW5nbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVyIDogdGhpcy5hZGRMaXN0ZW5lcjtcblx0XHR2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xuXG5cdFx0Ly8gSWYgZXZ0IGlzIGFuIG9iamVjdCB0aGVuIHBhc3MgZWFjaCBvZiBpdCdzIHByb3BlcnRpZXMgdG8gdGhpcyBtZXRob2Rcblx0XHRpZiAodHlwZW9mIGV2dCA9PT0gJ29iamVjdCcgJiYgIShldnQgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG5cdFx0XHRmb3IgKGkgaW4gZXZ0KSB7XG5cdFx0XHRcdGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkgJiYgKHZhbHVlID0gZXZ0W2ldKSkge1xuXHRcdFx0XHRcdC8vIFBhc3MgdGhlIHNpbmdsZSBsaXN0ZW5lciBzdHJhaWdodCB0aHJvdWdoIHRvIHRoZSBzaW5ndWxhciBtZXRob2Rcblx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRzaW5nbGUuY2FsbCh0aGlzLCBpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHBhc3MgYmFjayB0byB0aGUgbXVsdGlwbGUgZnVuY3Rpb25cblx0XHRcdFx0XHRcdG11bHRpcGxlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXG5cdFx0XHQvLyBBbmQgbGlzdGVuZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgbGlzdGVuZXJzXG5cdFx0XHQvLyBMb29wIG92ZXIgaXQgYW5kIHBhc3MgZWFjaCBvbmUgdG8gdGhlIG11bHRpcGxlIG1ldGhvZFxuXHRcdFx0aSA9IGxpc3RlbmVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHNpbmdsZS5jYWxsKHRoaXMsIGV2dCwgbGlzdGVuZXJzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqIElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbiBldmVudCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiBUaGF0IG1lYW5zIGV2ZXJ5IGV2ZW50IHdpbGwgYmUgZW1wdGllZC5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWdleCB0byByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IFtldnRdIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci4gV2lsbCByZW1vdmUgZnJvbSBldmVyeSBldmVudCBpZiBub3QgcGFzc2VkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZXZ0KSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgZXZ0O1xuXHRcdHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gUmVtb3ZlIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZiBldnRcblx0XHRpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG5cdFx0XHRkZWxldGUgZXZlbnRzW2V2dF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIHJlZ2V4LlxuXHRcdFx0Zm9yIChrZXkgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGV2ZW50c1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gYWxsIGV2ZW50c1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXG5cdCAqXG5cdCAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXG5cdCAqL1xuXHRwcm90by5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBhbGlhcygncmVtb3ZlRXZlbnQnKTtcblxuXHQvKipcblx0ICogRW1pdHMgYW4gZXZlbnQgb2YgeW91ciBjaG9pY2UuXG5cdCAqIFdoZW4gZW1pdHRlZCwgZXZlcnkgbGlzdGVuZXIgYXR0YWNoZWQgdG8gdGhhdCBldmVudCB3aWxsIGJlIGV4ZWN1dGVkLlxuXHQgKiBJZiB5b3UgcGFzcyB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYXJyYXkgdGhlbiB0aG9zZSBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgdG8gZXZlcnkgbGlzdGVuZXIgdXBvbiBleGVjdXRpb24uXG5cdCAqIEJlY2F1c2UgaXQgdXNlcyBgYXBwbHlgLCB5b3VyIGFycmF5IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBpZiB5b3Ugd3JvdGUgdGhlbSBvdXQgc2VwYXJhdGVseS5cblx0ICogU28gdGhleSB3aWxsIG5vdCBhcnJpdmUgd2l0aGluIHRoZSBhcnJheSBvbiB0aGUgb3RoZXIgc2lkZSwgdGhleSB3aWxsIGJlIHNlcGFyYXRlLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdCBhbmQgZXhlY3V0ZSBsaXN0ZW5lcnMgZm9yLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gT3B0aW9uYWwgYXJyYXkgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uIGVtaXRFdmVudChldnQsIGFyZ3MpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuXHRcdHZhciBsaXN0ZW5lcjtcblx0XHR2YXIgaTtcblx0XHR2YXIga2V5O1xuXHRcdHZhciByZXNwb25zZTtcblxuXHRcdGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuXHRcdFx0aWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdGkgPSBsaXN0ZW5lcnNba2V5XS5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdC8vIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCBzaGFsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGVpdGhlciB3aXRoIGEgYmFzaWMgY2FsbCBvciBhbiBhcHBseSBpZiB0aGVyZSBpcyBhbiBhcmdzIGFycmF5XG5cdFx0XHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lcnNba2V5XVtpXTtcblxuXHRcdFx0XHRcdGlmIChsaXN0ZW5lci5vbmNlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIubGlzdGVuZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc3BvbnNlID0gbGlzdGVuZXIubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyB8fCBbXSk7XG5cblx0XHRcdFx0XHRpZiAocmVzcG9uc2UgPT09IHRoaXMuX2dldE9uY2VSZXR1cm5WYWx1ZSgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIubGlzdGVuZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlhcyBvZiBlbWl0RXZlbnRcblx0ICovXG5cdHByb3RvLnRyaWdnZXIgPSBhbGlhcygnZW1pdEV2ZW50Jyk7XG5cblx0LyoqXG5cdCAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cblx0ICogQXMgd2l0aCBlbWl0RXZlbnQsIHlvdSBjYW4gcGFzcyBhIHJlZ2V4IGluIHBsYWNlIG9mIHRoZSBldmVudCBuYW1lIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG5cdCAqIEBwYXJhbSB7Li4uKn0gT3B0aW9uYWwgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdHJldHVybiB0aGlzLmVtaXRFdmVudChldnQsIGFyZ3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZiBhXG5cdCAqIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGUgb25lIHNldCBoZXJlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGFmdGVyIGV4ZWN1dGlvbi4gVGhpcyB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gY2hlY2sgZm9yIHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5zZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBzZXRPbmNlUmV0dXJuVmFsdWUodmFsdWUpIHtcblx0XHR0aGlzLl9vbmNlUmV0dXJuVmFsdWUgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogRmV0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWZcblx0ICogdGhlIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGlzIG9uZSB0aGVuIGl0IHNob3VsZCBiZSByZW1vdmVkXG5cdCAqIGF1dG9tYXRpY2FsbHkuIEl0IHdpbGwgcmV0dXJuIHRydWUgYnkgZGVmYXVsdC5cblx0ICpcblx0ICogQHJldHVybiB7KnxCb29sZWFufSBUaGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBmb3Igb3IgdGhlIGRlZmF1bHQsIHRydWUuXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0cHJvdG8uX2dldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIF9nZXRPbmNlUmV0dXJuVmFsdWUoKSB7XG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ19vbmNlUmV0dXJuVmFsdWUnKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29uY2VSZXR1cm5WYWx1ZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEZldGNoZXMgdGhlIGV2ZW50cyBvYmplY3QgYW5kIGNyZWF0ZXMgb25lIGlmIHJlcXVpcmVkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0cHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXZlcnRzIHRoZSBnbG9iYWwge0BsaW5rIEV2ZW50RW1pdHRlcn0gdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmVyc2lvbi5cblx0ICpcblx0ICogQHJldHVybiB7RnVuY3Rpb259IE5vbiBjb25mbGljdGluZyBFdmVudEVtaXR0ZXIgY2xhc3MuXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG5cdFx0ZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBvcmlnaW5hbEdsb2JhbFZhbHVlO1xuXHRcdHJldHVybiBFdmVudEVtaXR0ZXI7XG5cdH07XG5cblx0cmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cblxuXHR2YXIgdmFsaWRhdGVUeXBlRnVuY3Rpb24gPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiLCBcIkZ1bmN0aW9uXCIgKTtcblx0fTtcblxuXG5cblxuXHR2YXIgc3VwZXJHZXQsIHN1cGVySW5pdCxcblx0XHRnbG9iYWxFZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRmdW5jdGlvbiB2YWxpZGF0ZVR5cGVFdmVudCggdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwLCBcIlN0cmluZyBvciBSZWdFeHBcIiApO1xuXHR9XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVUaGVuQ2FsbCggbWV0aG9kLCBzZWxmICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggZXZlbnQsIGxpc3RlbmVyICkge1xuXHRcdFx0dmFsaWRhdGVQcmVzZW5jZSggZXZlbnQsIFwiZXZlbnRcIiApO1xuXHRcdFx0dmFsaWRhdGVUeXBlRXZlbnQoIGV2ZW50LCBcImV2ZW50XCIgKTtcblxuXHRcdFx0dmFsaWRhdGVQcmVzZW5jZSggbGlzdGVuZXIsIFwibGlzdGVuZXJcIiApO1xuXHRcdFx0dmFsaWRhdGVUeXBlRnVuY3Rpb24oIGxpc3RlbmVyLCBcImxpc3RlbmVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIHNlbGZbIG1ldGhvZCBdLmFwcGx5KCBzZWxmLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gb2ZmKCBzZWxmICkge1xuXHRcdHJldHVybiB2YWxpZGF0ZVRoZW5DYWxsKCBcIm9mZlwiLCBzZWxmICk7XG5cdH1cblxuXHRmdW5jdGlvbiBvbiggc2VsZiApIHtcblx0XHRyZXR1cm4gdmFsaWRhdGVUaGVuQ2FsbCggXCJvblwiLCBzZWxmICk7XG5cdH1cblxuXHRmdW5jdGlvbiBvbmNlKCBzZWxmICkge1xuXHRcdHJldHVybiB2YWxpZGF0ZVRoZW5DYWxsKCBcIm9uY2VcIiwgc2VsZiApO1xuXHR9XG5cblx0Q2xkci5vZmYgPSBvZmYoIGdsb2JhbEVlICk7XG5cdENsZHIub24gPSBvbiggZ2xvYmFsRWUgKTtcblx0Q2xkci5vbmNlID0gb25jZSggZ2xvYmFsRWUgKTtcblxuXHQvKipcblx0ICogT3ZlcmxvYWQgQ2xkci5wcm90b3R5cGUuaW5pdCgpLlxuXHQgKi9cblx0c3VwZXJJbml0ID0gQ2xkci5wcm90b3R5cGUuaW5pdDtcblx0Q2xkci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlZTtcblx0XHR0aGlzLmVlID0gZWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdFx0dGhpcy5vZmYgPSBvZmYoIGVlICk7XG5cdFx0dGhpcy5vbiA9IG9uKCBlZSApO1xuXHRcdHRoaXMub25jZSA9IG9uY2UoIGVlICk7XG5cdFx0c3VwZXJJbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fTtcblxuXHQvKipcblx0ICogZ2V0T3ZlcmxvYWQgaXMgZW5jYXBzdWxhdGVkLCBiZWNhdXNlIG9mIGNsZHIvdW5yZXNvbHZlZC4gSWYgaXQncyBsb2FkZWRcblx0ICogYWZ0ZXIgY2xkci9ldmVudCAoYW5kIG5vdGUgaXQgb3ZlcndyaXRlcyAuZ2V0KSwgaXQgY2FuIHRyaWdnZXIgdGhpc1xuXHQgKiBvdmVybG9hZCBhZ2Fpbi5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE92ZXJsb2FkKCkge1xuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcmxvYWQgQ2xkci5wcm90b3R5cGUuZ2V0KCkuXG5cdFx0ICovXG5cdFx0c3VwZXJHZXQgPSBDbGRyLnByb3RvdHlwZS5nZXQ7XG5cdFx0Q2xkci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBzdXBlckdldC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRwYXRoID0gcGF0aE5vcm1hbGl6ZSggcGF0aCwgdGhpcy5hdHRyaWJ1dGVzICkuam9pbiggXCIvXCIgKTtcblx0XHRcdGdsb2JhbEVlLnRyaWdnZXIoIFwiZ2V0XCIsIFsgcGF0aCwgdmFsdWUgXSApO1xuXHRcdFx0dGhpcy5lZS50cmlnZ2VyKCBcImdldFwiLCBbIHBhdGgsIHZhbHVlIF0gKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0Q2xkci5fZXZlbnRJbml0ID0gZ2V0T3ZlcmxvYWQ7XG5cdGdldE92ZXJsb2FkKCk7XG5cblx0cmV0dXJuIENsZHI7XG5cblxuXG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvZXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvZXZlbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjhcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMTEtMjZUMTU6MDNaXG4gKi9cbi8qIVxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44IDIwMTYtMTEtMjZUMTU6MDNaIE1JVCBsaWNlbnNlIMKpIFJhZmFlbCBYYXZpZXJcbiAqIGh0dHA6Ly9naXQuaW8vaDRsbVZnXG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRC5cblx0XHRkZWZpbmUoIFsgXCIuLi9jbGRyXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBOb2RlLiBDb21tb25KUy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiLi4vY2xkclwiICkgKTtcblx0fSBlbHNlIHtcblx0XHQvLyBHbG9iYWxcblx0XHRmYWN0b3J5KCBDbGRyICk7XG5cdH1cblxufShmdW5jdGlvbiggQ2xkciApIHtcblxuXHQvLyBCdWlsZCBvcHRpbWl6YXRpb24gaGFjayB0byBhdm9pZCBkdXBsaWNhdGluZyBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXG5cdHZhciBhbHdheXNBcnJheSA9IENsZHIuX2Fsd2F5c0FycmF5O1xuXG5cblxuXHR2YXIgc3VwcGxlbWVudGFsTWFpbiA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXG5cdFx0dmFyIHByZXBlbmQsIHN1cHBsZW1lbnRhbDtcblx0XHRcblx0XHRwcmVwZW5kID0gZnVuY3Rpb24oIHByZXBlbmQgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhdGggKSB7XG5cdFx0XHRcdHBhdGggPSBhbHdheXNBcnJheSggcGF0aCApO1xuXHRcdFx0XHRyZXR1cm4gY2xkci5nZXQoIFsgcHJlcGVuZCBdLmNvbmNhdCggcGF0aCApICk7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHRzdXBwbGVtZW50YWwgPSBwcmVwZW5kKCBcInN1cHBsZW1lbnRhbFwiICk7XG5cblx0XHQvLyBXZWVrIERhdGFcblx0XHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjV2Vla19EYXRhXG5cdFx0c3VwcGxlbWVudGFsLndlZWtEYXRhID0gcHJlcGVuZCggXCJzdXBwbGVtZW50YWwvd2Vla0RhdGFcIiApO1xuXG5cdFx0c3VwcGxlbWVudGFsLndlZWtEYXRhLmZpcnN0RGF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3dlZWtEYXRhL2ZpcnN0RGF5L3t0ZXJyaXRvcnl9XCIgKSB8fFxuXHRcdFx0XHRjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvd2Vla0RhdGEvZmlyc3REYXkvMDAxXCIgKTtcblx0XHR9O1xuXG5cdFx0c3VwcGxlbWVudGFsLndlZWtEYXRhLm1pbkRheXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtaW5EYXlzID0gY2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3dlZWtEYXRhL21pbkRheXMve3RlcnJpdG9yeX1cIiApIHx8XG5cdFx0XHRcdGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC93ZWVrRGF0YS9taW5EYXlzLzAwMVwiICk7XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQoIG1pbkRheXMsIDEwICk7XG5cdFx0fTtcblxuXHRcdC8vIFRpbWUgRGF0YVxuXHRcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNUaW1lX0RhdGFcblx0XHRzdXBwbGVtZW50YWwudGltZURhdGEgPSBwcmVwZW5kKCBcInN1cHBsZW1lbnRhbC90aW1lRGF0YVwiICk7XG5cblx0XHRzdXBwbGVtZW50YWwudGltZURhdGEuYWxsb3dlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC90aW1lRGF0YS97dGVycml0b3J5fS9fYWxsb3dlZFwiICkgfHxcblx0XHRcdFx0Y2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3RpbWVEYXRhLzAwMS9fYWxsb3dlZFwiICk7XG5cdFx0fTtcblxuXHRcdHN1cHBsZW1lbnRhbC50aW1lRGF0YS5wcmVmZXJyZWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvdGltZURhdGEve3RlcnJpdG9yeX0vX3ByZWZlcnJlZFwiICkgfHxcblx0XHRcdFx0Y2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3RpbWVEYXRhLzAwMS9fcHJlZmVycmVkXCIgKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHN1cHBsZW1lbnRhbDtcblxuXHR9O1xuXG5cblxuXG5cdHZhciBpbml0U3VwZXIgPSBDbGRyLnByb3RvdHlwZS5pbml0O1xuXG5cdC8qKlxuXHQgKiAuaW5pdCgpIGF1dG9tYXRpY2FsbHkgcmFuIG9uIGNvbnN0cnVjdGlvbi5cblx0ICpcblx0ICogT3ZlcmxvYWQgLmluaXQoKS5cblx0ICovXG5cdENsZHIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcblx0XHRpbml0U3VwZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdHRoaXMuc3VwcGxlbWVudGFsID0gc3VwcGxlbWVudGFsTWFpbiggdGhpcyApO1xuXHR9O1xuXG5cdHJldHVybiBDbGRyO1xuXG5cblxuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3N1cHBsZW1lbnRhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9zdXBwbGVtZW50YWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjhcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMTEtMjZUMTU6MDNaXG4gKi9cbi8qIVxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44IDIwMTYtMTEtMjZUMTU6MDNaIE1JVCBsaWNlbnNlIMKpIFJhZmFlbCBYYXZpZXJcbiAqIGh0dHA6Ly9naXQuaW8vaDRsbVZnXG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRC5cblx0XHRkZWZpbmUoIFsgXCIuLi9jbGRyXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBOb2RlLiBDb21tb25KUy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiLi4vY2xkclwiICkgKTtcblx0fSBlbHNlIHtcblx0XHQvLyBHbG9iYWxcblx0XHRmYWN0b3J5KCBDbGRyICk7XG5cdH1cblxufShmdW5jdGlvbiggQ2xkciApIHtcblxuXHQvLyBCdWlsZCBvcHRpbWl6YXRpb24gaGFjayB0byBhdm9pZCBkdXBsaWNhdGluZyBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXG5cdHZhciBjb3JlTG9hZCA9IENsZHIuX2NvcmVMb2FkO1xuXHR2YXIganNvbk1lcmdlID0gQ2xkci5fanNvbk1lcmdlO1xuXHR2YXIgcGF0aE5vcm1hbGl6ZSA9IENsZHIuX3BhdGhOb3JtYWxpemU7XG5cdHZhciByZXNvdXJjZUdldCA9IENsZHIuX3Jlc291cmNlR2V0O1xuXHR2YXIgdmFsaWRhdGVQcmVzZW5jZSA9IENsZHIuX3ZhbGlkYXRlUHJlc2VuY2U7XG5cdHZhciB2YWxpZGF0ZVR5cGVQYXRoID0gQ2xkci5fdmFsaWRhdGVUeXBlUGF0aDtcblxuXG5cblx0dmFyIGJ1bmRsZVBhcmVudExvb2t1cCA9IGZ1bmN0aW9uKCBDbGRyLCBsb2NhbGUgKSB7XG5cdFx0dmFyIG5vcm1hbGl6ZWRQYXRoLCBwYXJlbnQ7XG5cblx0XHRpZiAoIGxvY2FsZSA9PT0gXCJyb290XCIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmlyc3QsIHRyeSB0byBmaW5kIHBhcmVudCBvbiBzdXBwbGVtZW50YWwgZGF0YS5cblx0XHRub3JtYWxpemVkUGF0aCA9IHBhdGhOb3JtYWxpemUoIFsgXCJzdXBwbGVtZW50YWwvcGFyZW50TG9jYWxlcy9wYXJlbnRMb2NhbGVcIiwgbG9jYWxlIF0gKTtcblx0XHRwYXJlbnQgPSByZXNvdXJjZUdldCggQ2xkci5fcmVzb2x2ZWQsIG5vcm1hbGl6ZWRQYXRoICkgfHwgcmVzb3VyY2VHZXQoIENsZHIuX3Jhdywgbm9ybWFsaXplZFBhdGggKTtcblx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gT3IgdHJ1bmNhdGUgbG9jYWxlLlxuXHRcdHBhcmVudCA9IGxvY2FsZS5zdWJzdHIoIDAsIGxvY2FsZS5sYXN0SW5kZXhPZiggQ2xkci5sb2NhbGVTZXAgKSApO1xuXHRcdGlmICggIXBhcmVudCApIHtcblx0XHRcdHJldHVybiBcInJvb3RcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyZW50O1xuXHR9O1xuXG5cblxuXG5cdC8vIEBwYXRoOiBub3JtYWxpemVkIHBhdGhcblx0dmFyIHJlc291cmNlU2V0ID0gZnVuY3Rpb24oIGRhdGEsIHBhdGgsIHZhbHVlICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bm9kZSA9IGRhdGEsXG5cdFx0XHRsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0aWYgKCAhbm9kZVsgcGF0aFsgaSBdIF0gKSB7XG5cdFx0XHRcdG5vZGVbIHBhdGhbIGkgXSBdID0ge307XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gbm9kZVsgcGF0aFsgaSBdIF07XG5cdFx0fVxuXHRcdG5vZGVbIHBhdGhbIGkgXSBdID0gdmFsdWU7XG5cdH07XG5cblxuXHR2YXIgaXRlbUxvb2t1cCA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgbG9va3VwO1xuXG5cdGxvb2t1cCA9IGZ1bmN0aW9uKCBDbGRyLCBsb2NhbGUsIHBhdGgsIGF0dHJpYnV0ZXMsIGNoaWxkTG9jYWxlICkge1xuXHRcdHZhciBub3JtYWxpemVkUGF0aCwgcGFyZW50LCB2YWx1ZTtcblxuXHRcdC8vIDE6IEZpbmlzaCByZWN1cnNpb25cblx0XHQvLyAyOiBBdm9pZCBpbmZpbml0ZSBsb29wXG5cdFx0aWYgKCB0eXBlb2YgbG9jYWxlID09PSBcInVuZGVmaW5lZFwiIC8qIDEgKi8gfHwgbG9jYWxlID09PSBjaGlsZExvY2FsZSAvKiAyICovICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlc29sdmUgcGF0aFxuXHRcdG5vcm1hbGl6ZWRQYXRoID0gcGF0aE5vcm1hbGl6ZSggcGF0aCwgYXR0cmlidXRlcyApO1xuXG5cdFx0Ly8gQ2hlY2sgcmVzb2x2ZWQgKGNhY2hlZCkgZGF0YSBmaXJzdFxuXHRcdC8vIDE6IER1ZSB0byAjMTYsIG5ldmVyIHVzZSB0aGUgY2FjaGVkIHJlc29sdmVkIG5vbi1sZWFmIG5vZGVzLiBJdCBtYXkgbm90XG5cdFx0Ly8gICAgcmVwcmVzZW50IGl0cyBsZWFmcyBpbiBpdHMgZW50aXJldHkuXG5cdFx0dmFsdWUgPSByZXNvdXJjZUdldCggQ2xkci5fcmVzb2x2ZWQsIG5vcm1hbGl6ZWRQYXRoICk7XG5cdFx0aWYgKCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgLyogMSAqLyApIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayByYXcgZGF0YVxuXHRcdHZhbHVlID0gcmVzb3VyY2VHZXQoIENsZHIuX3Jhdywgbm9ybWFsaXplZFBhdGggKTtcblxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0Ly8gT3IsIGxvb2t1cCBhdCBwYXJlbnQgbG9jYWxlXG5cdFx0XHRwYXJlbnQgPSBidW5kbGVQYXJlbnRMb29rdXAoIENsZHIsIGxvY2FsZSApO1xuXHRcdFx0dmFsdWUgPSBsb29rdXAoIENsZHIsIHBhcmVudCwgcGF0aCwganNvbk1lcmdlKCBhdHRyaWJ1dGVzLCB7IGJ1bmRsZTogcGFyZW50IH0pLCBsb2NhbGUgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0Ly8gU2V0IHJlc29sdmVkIChjYWNoZWQpXG5cdFx0XHRyZXNvdXJjZVNldCggQ2xkci5fcmVzb2x2ZWQsIG5vcm1hbGl6ZWRQYXRoLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHRyZXR1cm4gbG9va3VwO1xuXG59KCkpO1xuXG5cblx0Q2xkci5fcmF3ID0ge307XG5cblx0LyoqXG5cdCAqIENsZHIubG9hZCgganNvbiBbLCBqc29uLCAuLi5dIClcblx0ICpcblx0ICogQGpzb24gW0pTT05dIENMRFIgZGF0YSBvciBbQXJyYXldIEFycmF5IG9mIEBqc29uJ3MuXG5cdCAqXG5cdCAqIExvYWQgcmVzb2x2ZWQgb3IgdW5yZXNvbHZlZCBjbGRyIGRhdGEuXG5cdCAqIE92ZXJ3cml0ZSBDbGRyLmxvYWQoKS5cblx0ICovXG5cdENsZHIubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdENsZHIuX3JhdyA9IGNvcmVMb2FkKCBDbGRyLCBDbGRyLl9yYXcsIGFyZ3VtZW50cyApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVyd3JpdGUgQ2xkci5wcm90b3R5cGUuZ2V0KCkuXG5cdCAqL1xuXHRDbGRyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiggcGF0aCApIHtcblx0XHR2YWxpZGF0ZVByZXNlbmNlKCBwYXRoLCBcInBhdGhcIiApO1xuXHRcdHZhbGlkYXRlVHlwZVBhdGgoIHBhdGgsIFwicGF0aFwiICk7XG5cblx0XHQvLyAxOiB1c2UgYnVuZGxlIGFzIGxvY2FsZSBvbiBpdGVtIGxvb2t1cCBmb3Igc2ltcGxpZmljYXRpb24gcHVycG9zZXMsIGJlY2F1c2Ugbm8gb3RoZXIgZXh0ZW5kZWQgc3VidGFnIGlzIHVzZWQgYW55d2F5IG9uIGJ1bmRsZSBwYXJlbnQgbG9va3VwLlxuXHRcdC8vIDI6IGR1cmluZyBpbml0KCksIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYnV0IGJ1bmRsZSBpcyB5ZXQgbm90IGRlZmluZWQuIFVzZSBcIlwiIGFzIGEgd29ya2Fyb3VuZCBpbiB0aGlzIHZlcnkgc3BlY2lmaWMgc2NlbmFyaW8uXG5cdFx0cmV0dXJuIGl0ZW1Mb29rdXAoIENsZHIsIHRoaXMuYXR0cmlidXRlcyAmJiB0aGlzLmF0dHJpYnV0ZXMuYnVuZGxlIC8qIDEgKi8gfHwgXCJcIiAvKiAyICovLCBwYXRoLCB0aGlzLmF0dHJpYnV0ZXMgKTtcblx0fTtcblxuXHQvLyBJbiBjYXNlIGNsZHIvdW5yZXNvbHZlZCBpcyBsb2FkZWQgYWZ0ZXIgY2xkci9ldmVudCwgd2UgdHJpZ2dlciBpdHMgb3ZlcmxvYWRzIGFnYWluLiBCZWNhdXNlLCAuZ2V0IGlzIG92ZXJ3cml0dGVuIGluIGhlcmUuXG5cdGlmICggQ2xkci5fZXZlbnRJbml0ICkge1xuXHRcdENsZHIuX2V2ZW50SW5pdCgpO1xuXHR9XG5cblx0cmV0dXJuIENsZHI7XG5cblxuXG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvdW5yZXNvbHZlZC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKlxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBSYWZhZWwgWGF2aWVyIGRlIFNvdXphXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTExLTI2VDE1OjAzWlxuICovXG4vKiFcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOCAyMDE2LTExLTI2VDE1OjAzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXG4gKiBodHRwOi8vZ2l0LmlvL2g0bG1WZ1xuICovXG5cbi8vIENsZHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggXCIuL2NsZHJcIiApO1xuXG4vLyBFeHRlbnQgQ2xkciB3aXRoIHRoZSBmb2xsb3dpbmcgbW9kdWxlc1xucmVxdWlyZSggXCIuL2NsZHIvZXZlbnRcIiApO1xucmVxdWlyZSggXCIuL2NsZHIvc3VwcGxlbWVudGFsXCIgKTtcbnJlcXVpcmUoIFwiLi9jbGRyL3VucmVzb2x2ZWRcIiApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3Qvbm9kZV9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9ub2RlX21haW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gR2xvYmFsXG5cdFx0cm9vdC5HbG9iYWxpemUgPSBmYWN0b3J5KCByb290LkNsZHIgKTtcblx0fVxufSggdGhpcywgZnVuY3Rpb24oIENsZHIgKSB7XG5cblxuLyoqXG4gKiBBIHRvU3RyaW5nIG1ldGhvZCB0aGF0IG91dHB1dHMgbWVhbmluZ2Z1bCB2YWx1ZXMgZm9yIG9iamVjdHMgb3IgYXJyYXlzIGFuZFxuICogc3RpbGwgcGVyZm9ybXMgYXMgZmFzdCBhcyBhIHBsYWluIHN0cmluZyBpbiBjYXNlIHZhcmlhYmxlIGlzIHN0cmluZywgb3IgYXNcbiAqIGZhc3QgYXMgYFwiXCIgKyBudW1iZXJgIGluIGNhc2UgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gKiBSZWY6IGh0dHA6Ly9qc3BlcmYuY29tL215LXN0cmluZ2lmeVxuICovXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiggdmFyaWFibGUgKSB7XG5cdHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT09IFwic3RyaW5nXCIgPyB2YXJpYWJsZSA6ICggdHlwZW9mIHZhcmlhYmxlID09PSBcIm51bWJlclwiID8gXCJcIiArXG5cdFx0dmFyaWFibGUgOiBKU09OLnN0cmluZ2lmeSggdmFyaWFibGUgKSApO1xufTtcblxuXG5cblxuLyoqXG4gKiBmb3JtYXRNZXNzYWdlKCBtZXNzYWdlLCBkYXRhIClcbiAqXG4gKiBAbWVzc2FnZSBbU3RyaW5nXSBBIG1lc3NhZ2Ugd2l0aCBvcHRpb25hbCB7dmFyc30gdG8gYmUgcmVwbGFjZWQuXG4gKlxuICogQGRhdGEgW0FycmF5IG9yIEpTT05dIE9iamVjdCB3aXRoIHJlcGxhY2luZy12YXJpYWJsZXMgY29udGVudC5cbiAqXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBtZXNzYWdlLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAtIGZvcm1hdE1lc3NhZ2UoIFwiezB9IHNlY29uZFwiLCBbIDEgXSApOyAvLyAxIHNlY29uZFxuICpcbiAqIC0gZm9ybWF0TWVzc2FnZSggXCJ7MH0vezF9XCIsIFtcIm1cIiwgXCJzXCJdICk7IC8vIG0vc1xuICpcbiAqIC0gZm9ybWF0TWVzc2FnZSggXCJ7bmFtZX0gPHtlbWFpbH0+XCIsIHtcbiAqICAgICBuYW1lOiBcIkZvb1wiLFxuICogICAgIGVtYWlsOiBcImJhckBiYXoucXV4XCJcbiAqICAgfSk7IC8vIEZvbyA8YmFyQGJhei5xdXg+XG4gKi9cbnZhciBmb3JtYXRNZXNzYWdlID0gZnVuY3Rpb24oIG1lc3NhZ2UsIGRhdGEgKSB7XG5cblx0Ly8gUmVwbGFjZSB7YXR0cmlidXRlfSdzXG5cdG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoIC97WzAtOWEtekEtWi1fLiBdK30vZywgZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0bmFtZSA9IG5hbWUucmVwbGFjZSggL157KFtefV0qKX0kLywgXCIkMVwiICk7XG5cdFx0cmV0dXJuIHRvU3RyaW5nKCBkYXRhWyBuYW1lIF0gKTtcblx0fSk7XG5cblx0cmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5cblxuXG52YXIgb2JqZWN0RXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IGFyZ3VtZW50c1sgMCBdLFxuXHRcdHNvdXJjZXMgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblxuXHRzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oIHNvdXJjZSApIHtcblx0XHR2YXIgcHJvcDtcblx0XHRmb3IgKCBwcm9wIGluIHNvdXJjZSApIHtcblx0XHRcdGRlc3RpbmF0aW9uWyBwcm9wIF0gPSBzb3VyY2VbIHByb3AgXTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cblxuXG5cbnZhciBjcmVhdGVFcnJvciA9IGZ1bmN0aW9uKCBjb2RlLCBtZXNzYWdlLCBhdHRyaWJ1dGVzICkge1xuXHR2YXIgZXJyb3I7XG5cblx0bWVzc2FnZSA9IGNvZGUgKyAoIG1lc3NhZ2UgPyBcIjogXCIgKyBmb3JtYXRNZXNzYWdlKCBtZXNzYWdlLCBhdHRyaWJ1dGVzICkgOiBcIlwiICk7XG5cdGVycm9yID0gbmV3IEVycm9yKCBtZXNzYWdlICk7XG5cdGVycm9yLmNvZGUgPSBjb2RlO1xuXG5cdG9iamVjdEV4dGVuZCggZXJyb3IsIGF0dHJpYnV0ZXMgKTtcblxuXHRyZXR1cm4gZXJyb3I7XG59O1xuXG5cblxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XG52YXIgc3RyaW5nSGFzaCA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdHJldHVybiBbXS5yZWR1Y2UuY2FsbCggc3RyLCBmdW5jdGlvbiggaGFzaCwgaSApIHtcblx0XHR2YXIgY2hyID0gaS5jaGFyQ29kZUF0KCAwICk7XG5cdFx0aGFzaCA9ICggKCBoYXNoIDw8IDUgKSAtIGhhc2ggKSArIGNocjtcblx0XHRyZXR1cm4gaGFzaCB8IDA7XG5cdH0sIDAgKTtcbn07XG5cblxuXG5cbnZhciBydW50aW1lS2V5ID0gZnVuY3Rpb24oIGZuTmFtZSwgbG9jYWxlLCBhcmdzLCBhcmdzU3RyICkge1xuXHR2YXIgaGFzaDtcblx0YXJnc1N0ciA9IGFyZ3NTdHIgfHwgSlNPTi5zdHJpbmdpZnkoIGFyZ3MgKTtcblx0aGFzaCA9IHN0cmluZ0hhc2goIGZuTmFtZSArIGxvY2FsZSArIGFyZ3NTdHIgKTtcblx0cmV0dXJuIGhhc2ggPiAwID8gXCJhXCIgKyBoYXNoIDogXCJiXCIgKyBNYXRoLmFicyggaGFzaCApO1xufTtcblxuXG5cblxudmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0aWYgKCBmbi5uYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIGZuLm5hbWU7XG5cdH1cblxuXHQvLyBmbi5uYW1lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXG5cdHZhciBtYXRjaGVzID0gL15mdW5jdGlvblxccysoW1xcd1xcJF0rKVxccypcXCgvLmV4ZWMoIGZuLnRvU3RyaW5nKCkgKTtcblxuXHRpZiAoIG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwICkge1xuXHRcdHJldHVybiBtYXRjaGVzWyAxIF07XG5cdH1cbn07XG5cblxuXG5cbnZhciBydW50aW1lQmluZCA9IGZ1bmN0aW9uKCBhcmdzLCBjbGRyLCBmbiwgcnVudGltZUFyZ3MgKSB7XG5cblx0dmFyIGFyZ3NTdHIgPSBKU09OLnN0cmluZ2lmeSggYXJncyApLFxuXHRcdGZuTmFtZSA9IGZ1bmN0aW9uTmFtZSggZm4gKSxcblx0XHRsb2NhbGUgPSBjbGRyLmxvY2FsZTtcblxuXHQvLyBJZiBuYW1lIG9mIHRoZSBmdW5jdGlvbiBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIGlzIG1vc3QgbGlrZWx5IGR1ZSB0byB1Z2xpZmljYXRpb24sXG5cdC8vIHdoaWNoIG1vc3QgbGlrZWx5IG1lYW5zIHdlIGFyZSBpbiBwcm9kdWN0aW9uLCBhbmQgcnVudGltZUJpbmQgaGVyZSBpcyBub3QgbmVjZXNzYXJ5LlxuXHRpZiAoICFmbk5hbWUgKSB7XG5cdFx0cmV0dXJuIGZuO1xuXHR9XG5cblx0Zm4ucnVudGltZUtleSA9IHJ1bnRpbWVLZXkoIGZuTmFtZSwgbG9jYWxlLCBudWxsLCBhcmdzU3RyICk7XG5cblx0Zm4uZ2VuZXJhdG9yU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiR2xvYmFsaXplKFxcXCJcIiArIGxvY2FsZSArIFwiXFxcIikuXCIgKyBmbk5hbWUgKyBcIihcIiArIGFyZ3NTdHIuc2xpY2UoIDEsIC0xICkgKyBcIilcIjtcblx0fTtcblxuXHRmbi5ydW50aW1lQXJncyA9IHJ1bnRpbWVBcmdzO1xuXG5cdHJldHVybiBmbjtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKCBjb2RlLCBtZXNzYWdlLCBjaGVjaywgYXR0cmlidXRlcyApIHtcblx0aWYgKCAhY2hlY2sgKSB7XG5cdFx0dGhyb3cgY3JlYXRlRXJyb3IoIGNvZGUsIG1lc3NhZ2UsIGF0dHJpYnV0ZXMgKTtcblx0fVxufTtcblxuXG5cblxudmFyIGFsd2F5c0FycmF5ID0gZnVuY3Rpb24oIHN0cmluZ09yQXJyYXkgKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KCBzdHJpbmdPckFycmF5ICkgPyBzdHJpbmdPckFycmF5IDogc3RyaW5nT3JBcnJheSA/IFsgc3RyaW5nT3JBcnJheSBdIDogW107XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVDbGRyID0gZnVuY3Rpb24oIHBhdGgsIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YXIgc2tpcEJvb2xlYW47XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdHNraXBCb29sZWFuID0gYWx3YXlzQXJyYXkoIG9wdGlvbnMuc2tpcCApLnNvbWUoZnVuY3Rpb24oIHBhdGhSZSApIHtcblx0XHRyZXR1cm4gcGF0aFJlLnRlc3QoIHBhdGggKTtcblx0fSk7XG5cblx0dmFsaWRhdGUoIFwiRV9NSVNTSU5HX0NMRFJcIiwgXCJNaXNzaW5nIHJlcXVpcmVkIENMRFIgY29udGVudCBge3BhdGh9YC5cIiwgdmFsdWUgfHwgc2tpcEJvb2xlYW4sIHtcblx0XHRwYXRoOiBwYXRoXG5cdH0pO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0dmFsaWRhdGUoIFwiRV9ERUZBVUxUX0xPQ0FMRV9OT1RfREVGSU5FRFwiLCBcIkRlZmF1bHQgbG9jYWxlIGhhcyBub3QgYmVlbiBkZWZpbmVkLlwiLFxuXHRcdHZhbHVlICE9PSB1bmRlZmluZWQsIHt9ICk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGUoIFwiRV9NSVNTSU5HX1BBUkFNRVRFUlwiLCBcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGB7bmFtZX1gLlwiLFxuXHRcdHZhbHVlICE9PSB1bmRlZmluZWQsIHsgbmFtZTogbmFtZSB9KTtcbn07XG5cblxuXG5cbi8qKlxuICogcmFuZ2UoIHZhbHVlLCBuYW1lLCBtaW5pbXVtLCBtYXhpbXVtIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl0uXG4gKlxuICogQG5hbWUgW1N0cmluZ10gbmFtZSBvZiB2YXJpYWJsZS5cbiAqXG4gKiBAbWluaW11bSBbTnVtYmVyXS4gVGhlIGxvd2VzdCB2YWxpZCB2YWx1ZSwgaW5jbHVzaXZlLlxuICpcbiAqIEBtYXhpbXVtIFtOdW1iZXJdLiBUaGUgZ3JlYXRlc3QgdmFsaWQgdmFsdWUsIGluY2x1c2l2ZS5cbiAqL1xudmFyIHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUsIG1pbmltdW0sIG1heGltdW0gKSB7XG5cdHZhbGlkYXRlKFxuXHRcdFwiRV9QQVJfT1VUX09GX1JBTkdFXCIsXG5cdFx0XCJQYXJhbWV0ZXIgYHtuYW1lfWAgaGFzIHZhbHVlIGB7dmFsdWV9YCBvdXQgb2YgcmFuZ2UgW3ttaW5pbXVtfSwge21heGltdW19XS5cIixcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID49IG1pbmltdW0gJiYgdmFsdWUgPD0gbWF4aW11bSxcblx0XHR7XG5cdFx0XHRtYXhpbXVtOiBtYXhpbXVtLFxuXHRcdFx0bWluaW11bTogbWluaW11bSxcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9XG5cdCk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lLCBjaGVjaywgZXhwZWN0ZWQgKSB7XG5cdHZhbGlkYXRlKFxuXHRcdFwiRV9JTlZBTElEX1BBUl9UWVBFXCIsXG5cdFx0XCJJbnZhbGlkIGB7bmFtZX1gIHBhcmFtZXRlciAoe3ZhbHVlfSkuIHtleHBlY3RlZH0gZXhwZWN0ZWQuXCIsXG5cdFx0Y2hlY2ssXG5cdFx0e1xuXHRcdFx0ZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH1cblx0KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVMb2NhbGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgQ2xkcixcblx0XHRcIlN0cmluZyBvciBDbGRyIGluc3RhbmNlXCJcblx0KTtcbn07XG5cblxuXG5cbi8qKlxuICogRnVuY3Rpb24gaW5zcGlyZWQgYnkgalF1ZXJ5IENvcmUsIGJ1dCByZWR1Y2VkIHRvIG91ciB1c2UgY2FzZS5cbiAqL1xudmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggb2JqICkge1xuXHRyZXR1cm4gb2JqICE9PSBudWxsICYmIFwiXCIgKyBvYmogPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNQbGFpbk9iamVjdCggdmFsdWUgKSxcblx0XHRcIlBsYWluIE9iamVjdFwiXG5cdCk7XG59O1xuXG5cblxuXG52YXIgYWx3YXlzQ2xkciA9IGZ1bmN0aW9uKCBsb2NhbGVPckNsZHIgKSB7XG5cdHJldHVybiBsb2NhbGVPckNsZHIgaW5zdGFuY2VvZiBDbGRyID8gbG9jYWxlT3JDbGRyIDogbmV3IENsZHIoIGxvY2FsZU9yQ2xkciApO1xufTtcblxuXG5cblxuLy8gcmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnM/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZHdWlkZSUyRlJlZ3VsYXJfRXhwcmVzc2lvbnNcbnZhciByZWdleHBFc2NhcGUgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIC8oWy4qKz9ePSE6JHt9KCl8XFxbXFxdXFwvXFxcXF0pL2csIFwiXFxcXCQxXCIgKTtcbn07XG5cblxuXG5cbnZhciBzdHJpbmdQYWQgPSBmdW5jdGlvbiggc3RyLCBjb3VudCwgcmlnaHQgKSB7XG5cdHZhciBsZW5ndGg7XG5cdGlmICggdHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRzdHIgPSBTdHJpbmcoIHN0ciApO1xuXHR9XG5cdGZvciAoIGxlbmd0aCA9IHN0ci5sZW5ndGg7IGxlbmd0aCA8IGNvdW50OyBsZW5ndGggKz0gMSApIHtcblx0XHRzdHIgPSAoIHJpZ2h0ID8gKCBzdHIgKyBcIjBcIiApIDogKCBcIjBcIiArIHN0ciApICk7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGlrZWx5U3VidGFncyggY2xkciApIHtcblx0Y2xkci5vbmNlKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblx0Y2xkci5nZXQoIFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3NcIiApO1xufVxuXG4vKipcbiAqIFtuZXddIEdsb2JhbGl6ZSggbG9jYWxlfGNsZHIgKVxuICpcbiAqIEBsb2NhbGUgW1N0cmluZ11cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV1cbiAqXG4gKiBDcmVhdGUgYSBHbG9iYWxpemUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIEdsb2JhbGl6ZSggbG9jYWxlICkge1xuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBHbG9iYWxpemUgKSApIHtcblx0XHRyZXR1cm4gbmV3IEdsb2JhbGl6ZSggbG9jYWxlICk7XG5cdH1cblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBsb2NhbGUsIFwibG9jYWxlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTG9jYWxlKCBsb2NhbGUsIFwibG9jYWxlXCIgKTtcblxuXHR0aGlzLmNsZHIgPSBhbHdheXNDbGRyKCBsb2NhbGUgKTtcblxuXHR2YWxpZGF0ZUxpa2VseVN1YnRhZ3MoIHRoaXMuY2xkciApO1xufVxuXG4vKipcbiAqIEdsb2JhbGl6ZS5sb2FkKCBqc29uLCAuLi4gKVxuICpcbiAqIEBqc29uIFtKU09OXVxuICpcbiAqIExvYWQgcmVzb2x2ZWQgb3IgdW5yZXNvbHZlZCBjbGRyIGRhdGEuXG4gKiBTb21ld2hhdCBlcXVpdmFsZW50IHRvIHByZXZpb3VzIEdsb2JhbGl6ZS5hZGRDdWx0dXJlSW5mbyguLi4pLlxuICovXG5HbG9iYWxpemUubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIHZhbGlkYXRpb25zIGFyZSBkZWxlZ2F0ZWQgdG8gQ2xkci5sb2FkKCkuXG5cdENsZHIubG9hZC5hcHBseSggQ2xkciwgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIEdsb2JhbGl6ZS5sb2NhbGUoIFtsb2NhbGV8Y2xkcl0gKVxuICpcbiAqIEBsb2NhbGUgW1N0cmluZ11cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV1cbiAqXG4gKiBTZXQgZGVmYXVsdCBDbGRyIGluc3RhbmNlIGlmIGxvY2FsZSBvciBjbGRyIGFyZ3VtZW50IGlzIHBhc3NlZC5cbiAqXG4gKiBSZXR1cm4gdGhlIGRlZmF1bHQgQ2xkciBpbnN0YW5jZS5cbiAqL1xuR2xvYmFsaXplLmxvY2FsZSA9IGZ1bmN0aW9uKCBsb2NhbGUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZUxvY2FsZSggbG9jYWxlLCBcImxvY2FsZVwiICk7XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdHRoaXMuY2xkciA9IGFsd2F5c0NsZHIoIGxvY2FsZSApO1xuXHRcdHZhbGlkYXRlTGlrZWx5U3VidGFncyggdGhpcy5jbGRyICk7XG5cdH1cblx0cmV0dXJuIHRoaXMuY2xkcjtcbn07XG5cbi8qKlxuICogT3B0aW1pemF0aW9uIHRvIGF2b2lkIGR1cGxpY2F0aW5nIHNvbWUgaW50ZXJuYWwgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxuICovXG5HbG9iYWxpemUuX2Fsd2F5c0FycmF5ID0gYWx3YXlzQXJyYXk7XG5HbG9iYWxpemUuX2NyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XG5HbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlO1xuR2xvYmFsaXplLl9pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbkdsb2JhbGl6ZS5fb2JqZWN0RXh0ZW5kID0gb2JqZWN0RXh0ZW5kO1xuR2xvYmFsaXplLl9yZWdleHBFc2NhcGUgPSByZWdleHBFc2NhcGU7XG5HbG9iYWxpemUuX3J1bnRpbWVCaW5kID0gcnVudGltZUJpbmQ7XG5HbG9iYWxpemUuX3N0cmluZ1BhZCA9IHN0cmluZ1BhZDtcbkdsb2JhbGl6ZS5fdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyID0gdmFsaWRhdGVDbGRyO1xuR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSB2YWxpZGF0ZURlZmF1bHRMb2NhbGU7XG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSB2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlO1xuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclJhbmdlID0gdmFsaWRhdGVQYXJhbWV0ZXJSYW5nZTtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gdmFsaWRhdGVQYXJhbWV0ZXJUeXBlO1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcIi4vbnVtYmVyXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIixcblx0XHRcdFwiY2xkci9zdXBwbGVtZW50YWxcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgYWx3YXlzQXJyYXkgPSBHbG9iYWxpemUuX2Fsd2F5c0FycmF5LFxuXHRmb3JtYXRNZXNzYWdlID0gR2xvYmFsaXplLl9mb3JtYXRNZXNzYWdlLFxuXHRudW1iZXJOdW1iZXJpbmdTeXN0ZW0gPSBHbG9iYWxpemUuX251bWJlck51bWJlcmluZ1N5c3RlbSxcblx0bnVtYmVyUGF0dGVybiA9IEdsb2JhbGl6ZS5fbnVtYmVyUGF0dGVybixcblx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHRzdHJpbmdQYWQgPSBHbG9iYWxpemUuX3N0cmluZ1BhZCxcblx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlQ3VycmVuY3kgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICggL15bQS1aYS16XXszfSQvICkudGVzdCggdmFsdWUgKSxcblx0XHRcIjMtbGV0dGVyIGN1cnJlbmN5IGNvZGUgc3RyaW5nIGFzIGRlZmluZWQgYnkgSVNPIDQyMTdcIlxuXHQpO1xufTtcblxuXG5cblxuLyoqXG4gKiBzdXBwbGVtZW50YWxPdmVycmlkZSggY3VycmVuY3ksIHBhdHRlcm4sIGNsZHIgKVxuICpcbiAqIFJldHVybiBwYXR0ZXJuIHdpdGggZnJhY3Rpb24gZGlnaXRzIG92ZXJyaWRlbiBieSBzdXBwbGVtZW50YWwgY3VycmVuY3kgZGF0YS5cbiAqL1xudmFyIGN1cnJlbmN5U3VwcGxlbWVudGFsT3ZlcnJpZGUgPSBmdW5jdGlvbiggY3VycmVuY3ksIHBhdHRlcm4sIGNsZHIgKSB7XG5cdHZhciBkaWdpdHMsXG5cdFx0ZnJhY3Rpb24gPSBcIlwiLFxuXHRcdGZyYWN0aW9uRGF0YSA9IGNsZHIuc3VwcGxlbWVudGFsKFsgXCJjdXJyZW5jeURhdGEvZnJhY3Rpb25zXCIsIGN1cnJlbmN5IF0pIHx8XG5cdFx0XHRjbGRyLnN1cHBsZW1lbnRhbCggXCJjdXJyZW5jeURhdGEvZnJhY3Rpb25zL0RFRkFVTFRcIiApO1xuXG5cdGRpZ2l0cyA9ICtmcmFjdGlvbkRhdGEuX2RpZ2l0cztcblxuXHRpZiAoIGRpZ2l0cyApIHtcblx0XHRmcmFjdGlvbiA9IFwiLlwiICsgc3RyaW5nUGFkKCBcIjBcIiwgZGlnaXRzICkuc2xpY2UoIDAsIC0xICkgKyBmcmFjdGlvbkRhdGEuX3JvdW5kaW5nO1xuXHR9XG5cblx0cmV0dXJuIHBhdHRlcm4ucmVwbGFjZSggL1xcLigjK3wwKlswLTldfDArWzAtOV0/KS9nLCBmcmFjdGlvbiApO1xufTtcblxuXG5cblxudmFyIG9iamVjdEZpbHRlciA9IGZ1bmN0aW9uKCBvYmplY3QsIHRlc3RSZSApIHtcblx0dmFyIGtleSxcblx0XHRjb3B5ID0ge307XG5cblx0Zm9yICgga2V5IGluIG9iamVjdCApIHtcblx0XHRpZiAoIHRlc3RSZS50ZXN0KCBrZXkgKSApIHtcblx0XHRcdGNvcHlbIGtleSBdID0gb2JqZWN0WyBrZXkgXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29weTtcbn07XG5cblxuXG5cbnZhciBjdXJyZW5jeVVuaXRQYXR0ZXJucyA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHRyZXR1cm4gb2JqZWN0RmlsdGVyKCBjbGRyLm1haW4oW1xuXHRcdFwibnVtYmVyc1wiLFxuXHRcdFwiY3VycmVuY3lGb3JtYXRzLW51bWJlclN5c3RlbS1cIiArIG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApXG5cdF0pLCAvXnVuaXRQYXR0ZXJuLyApO1xufTtcblxuXG5cblxuLyoqXG4gKiBjb2RlUHJvcGVydGllcyggY3VycmVuY3ksIGNsZHIgKVxuICpcbiAqIFJldHVybiBudW1iZXIgcGF0dGVybiB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjdXJyZW5jeSBjb2RlIGluIGFzIGxpdGVyYWwuXG4gKi9cbnZhciBjdXJyZW5jeUNvZGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBjbGRyICkge1xuXHR2YXIgcGF0dGVybiA9IG51bWJlclBhdHRlcm4oIFwiZGVjaW1hbFwiLCBjbGRyICk7XG5cblx0Ly8gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBhbmQgdGhlIHJvdW5kaW5nIGZvciBlYWNoIGN1cnJlbmN5IGlzIG5vdCBsb2NhbGUtc3BlY2lmaWMuIFRob3NlXG5cdC8vIHZhbHVlcyBvdmVycmlkZGVuIGJ5IFN1cHBsZW1lbnRhbCBDdXJyZW5jeSBEYXRhLlxuXHRwYXR0ZXJuID0gY3VycmVuY3lTdXBwbGVtZW50YWxPdmVycmlkZSggY3VycmVuY3ksIHBhdHRlcm4sIGNsZHIgKTtcblxuXHRyZXR1cm4ge1xuXHRcdGN1cnJlbmN5OiBjdXJyZW5jeSxcblx0XHRwYXR0ZXJuOiBwYXR0ZXJuLFxuXHRcdHVuaXRQYXR0ZXJuczogY3VycmVuY3lVbml0UGF0dGVybnMoIGNsZHIgKVxuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiBuYW1lRm9ybWF0KCBmb3JtYXR0ZWROdW1iZXIsIHBsdXJhbEZvcm0sIHByb3BlcnRpZXMgKVxuICpcbiAqIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmFtZSBmb3JtIGN1cnJlbmN5IGZvcm1hdC5cbiAqL1xudmFyIGN1cnJlbmN5TmFtZUZvcm1hdCA9IGZ1bmN0aW9uKCBmb3JtYXR0ZWROdW1iZXIsIHBsdXJhbEZvcm0sIHByb3BlcnRpZXMgKSB7XG5cdHZhciBkaXNwbGF5TmFtZSwgdW5pdFBhdHRlcm4sXG5cdFx0ZGlzcGxheU5hbWVzID0gcHJvcGVydGllcy5kaXNwbGF5TmFtZXMgfHwge30sXG5cdFx0dW5pdFBhdHRlcm5zID0gcHJvcGVydGllcy51bml0UGF0dGVybnM7XG5cblx0ZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZXNbIFwiZGlzcGxheU5hbWUtY291bnQtXCIgKyBwbHVyYWxGb3JtIF0gfHxcblx0XHRkaXNwbGF5TmFtZXNbIFwiZGlzcGxheU5hbWUtY291bnQtb3RoZXJcIiBdIHx8XG5cdFx0ZGlzcGxheU5hbWVzLmRpc3BsYXlOYW1lIHx8XG5cdFx0cHJvcGVydGllcy5jdXJyZW5jeTtcblx0dW5pdFBhdHRlcm4gPSB1bml0UGF0dGVybnNbIFwidW5pdFBhdHRlcm4tY291bnQtXCIgKyBwbHVyYWxGb3JtIF0gfHxcblx0XHR1bml0UGF0dGVybnNbIFwidW5pdFBhdHRlcm4tY291bnQtb3RoZXJcIiBdO1xuXG5cdHJldHVybiBmb3JtYXRNZXNzYWdlKCB1bml0UGF0dGVybiwgWyBmb3JtYXR0ZWROdW1iZXIsIGRpc3BsYXlOYW1lIF0pO1xufTtcblxuXG5cblxudmFyIGN1cnJlbmN5Rm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKSB7XG5cdHZhciBmbjtcblxuXHQvLyBSZXR1cm4gZm9ybWF0dGVyIHdoZW4gc3R5bGUgaXMgXCJjb2RlXCIgb3IgXCJuYW1lXCIuXG5cdGlmICggcGx1cmFsR2VuZXJhdG9yICYmIHByb3BlcnRpZXMgKSB7XG5cdFx0Zm4gPSBmdW5jdGlvbiBjdXJyZW5jeUZvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHRcdHJldHVybiBjdXJyZW5jeU5hbWVGb3JtYXQoXG5cdFx0XHRcdG51bWJlckZvcm1hdHRlciggdmFsdWUgKSxcblx0XHRcdFx0cGx1cmFsR2VuZXJhdG9yKCB2YWx1ZSApLFxuXHRcdFx0XHRwcm9wZXJ0aWVzXG5cdFx0XHQpO1xuXHRcdH07XG5cblx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFwic3ltYm9sXCIgb3IgXCJhY2NvdW50aW5nXCIuXG5cdH0gZWxzZSB7XG5cdFx0Zm4gPSBmdW5jdGlvbiBjdXJyZW5jeUZvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gbnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApO1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gZm47XG59O1xuXG5cblxuXG4vKipcbiAqIG5hbWVQcm9wZXJ0aWVzKCBjdXJyZW5jeSwgY2xkciApXG4gKlxuICogUmV0dXJuIG51bWJlciBwYXR0ZXJuIHdpdGggdGhlIGFwcHJvcHJpYXRlIGN1cnJlbmN5IGNvZGUgaW4gYXMgbGl0ZXJhbC5cbiAqL1xudmFyIGN1cnJlbmN5TmFtZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3VycmVuY3ksIGNsZHIgKSB7XG5cdHZhciBwcm9wZXJ0aWVzID0gY3VycmVuY3lDb2RlUHJvcGVydGllcyggY3VycmVuY3ksIGNsZHIgKTtcblxuXHRwcm9wZXJ0aWVzLmRpc3BsYXlOYW1lcyA9IG9iamVjdEZpbHRlciggY2xkci5tYWluKFtcblx0XHRcIm51bWJlcnMvY3VycmVuY2llc1wiLFxuXHRcdGN1cnJlbmN5XG5cdF0pLCAvXmRpc3BsYXlOYW1lLyApO1xuXG5cdHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuXG5cblxuLyoqXG4gKiBVbmljb2RlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3I6IGV2ZXJ5dGhpbmcgZXhjZXB0IG1hdGggc3ltYm9scywgY3VycmVuY3kgc2lnbnMsIGRpbmdiYXRzLCBhbmRcbiAqIGJveC1kcmF3aW5nIGNoYXJhY3RlcnMuXG4gKlxuICogR2VuZXJhdGVkIGJ5OlxuICpcbiAqIHJlZ2VuZXJhdGUoKVxuICogICAuYWRkUmFuZ2UoIDB4MCwgMHgxMEZGRkYgKVxuICogICAucmVtb3ZlKCByZXF1aXJlKCBcInVuaWNvZGUtNy4wLjAvY2F0ZWdvcmllcy9TL3N5bWJvbHNcIiApICkudG9TdHJpbmcoKTtcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9yZWdlbmVyYXRlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTcuMC4wXG4gKi9cbnZhciByZWdleHBOb3RTID0gL1tcXDAtIyUtXFwqLC07XFw/LVxcXV9hLVxce1xcfVxceDdGLVxceEExXFx4QTdcXHhBQVxceEFCXFx4QURcXHhCMlxceEIzXFx4QjUtXFx4QjdcXHhCOS1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3Ni1cXHUwMzgzXFx1MDM4Ni1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNThDXFx1MDU5MC1cXHUwNjA1XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MTAtXFx1MDZERFxcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkYtXFx1MDdGNVxcdTA3RjctXFx1MDlGMVxcdTA5RjQtXFx1MDlGOVxcdTA5RkMtXFx1MEFGMFxcdTBBRjItXFx1MEI2RlxcdTBCNzEtXFx1MEJGMlxcdTBCRkItXFx1MEM3RVxcdTBDODAtXFx1MEQ3OFxcdTBEN0EtXFx1MEUzRVxcdTBFNDAtXFx1MEYwMFxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYzM1xcdTBGMzVcXHUwRjM3XFx1MEYzOS1cXHUwRkJEXFx1MEZDNlxcdTBGQ0RcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5LVxcdTEwOURcXHUxMEEwLVxcdTEzOEZcXHUxMzlBLVxcdTE3REFcXHUxN0RDLVxcdTE5M0ZcXHUxOTQxLVxcdTE5RERcXHUxQTAwLVxcdTFCNjBcXHUxQjZCLVxcdTFCNzNcXHUxQjdELVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkNDXFx1MUZEMC1cXHUxRkRDXFx1MUZFMC1cXHUxRkVDXFx1MUZGMC1cXHUxRkZDXFx1MUZGRi1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDc5XFx1MjA3RC1cXHUyMDg5XFx1MjA4RC1cXHUyMDlGXFx1MjBCRS1cXHUyMEZGXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNTAtXFx1MjE4RlxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1MjNGQi1cXHUyM0ZGXFx1MjQyNy1cXHUyNDNGXFx1MjQ0Qi1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc2OC1cXHUyNzkzXFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJCNzRcXHUyQjc1XFx1MkI5NlxcdTJCOTdcXHUyQkJBLVxcdTJCQkNcXHUyQkM5XFx1MkJEMi1cXHUyQ0U0XFx1MkNFQi1cXHUyRTdGXFx1MkU5QVxcdTJFRjQtXFx1MkVGRlxcdTJGRDYtXFx1MkZFRlxcdTJGRkMtXFx1MzAwM1xcdTMwMDUtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMjEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzRFxcdTMwNDAtXFx1MzA5QVxcdTMwOUQtXFx1MzE4RlxcdTMxOTItXFx1MzE5NVxcdTMxQTAtXFx1MzFCRlxcdTMxRTQtXFx1MzFGRlxcdTMyMUYtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdTMyRkZcXHUzNDAwLVxcdTREQkZcXHU0RTAwLVxcdUE0OEZcXHVBNEM3LVxcdUE2RkZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE4MjdcXHVBODJDLVxcdUE4MzVcXHVBODNBLVxcdUFBNzZcXHVBQTdBLVxcdUFCNUFcXHVBQjVDLVxcdUQ3RkZcXHVEQzAwLVxcdUZCMjhcXHVGQjJBLVxcdUZCQjFcXHVGQkMyLVxcdUZERkJcXHVGREZFLVxcdUZFNjFcXHVGRTYzXFx1RkU2N1xcdUZFNjhcXHVGRTZBLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMUJcXHVGRjFGLVxcdUZGM0RcXHVGRjNGXFx1RkY0MS1cXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkZERlxcdUZGRTdcXHVGRkVGLVxcdUZGRkJcXHVGRkZFXFx1RkZGRl18XFx1RDgwMFtcXHVEQzAwLVxcdUREMzZcXHVERDQwLVxcdURENzhcXHVERDhBXFx1REQ4QlxcdUREOEQtXFx1REQ4RlxcdUREOUMtXFx1REQ5RlxcdUREQTEtXFx1RERDRlxcdURERkQtXFx1REZGRl18W1xcdUQ4MDFcXHVEODAzLVxcdUQ4MTlcXHVEODFCLVxcdUQ4MkVcXHVEODMwLVxcdUQ4MzNcXHVEODM2LVxcdUQ4M0FcXHVEODNGLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwMltcXHVEQzAwLVxcdURDNzZcXHVEQzc5LVxcdURFQzdcXHVERUM5LVxcdURGRkZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERjNCXFx1REY0MC1cXHVERjQ0XFx1REY0Ni1cXHVERkZGXXxcXHVEODJGW1xcdURDMDAtXFx1REM5QlxcdURDOUQtXFx1REZGRl18XFx1RDgzNFtcXHVEQ0Y2LVxcdURDRkZcXHVERDI3XFx1REQyOFxcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdUREREUtXFx1RERGRlxcdURFNDItXFx1REU0NFxcdURFNDYtXFx1REVGRlxcdURGNTctXFx1REZGRl18XFx1RDgzNVtcXHVEQzAwLVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGRkZdfFxcdUQ4M0JbXFx1REMwMC1cXHVERUVGXFx1REVGMi1cXHVERkZGXXxcXHVEODNDW1xcdURDMkMtXFx1REMyRlxcdURDOTQtXFx1REM5RlxcdURDQUZcXHVEQ0IwXFx1RENDMFxcdURDRDBcXHVEQ0Y2LVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDZGXFx1REQ5Qi1cXHVEREU1XFx1REUwMy1cXHVERTBGXFx1REUzQi1cXHVERTNGXFx1REU0OS1cXHVERTRGXFx1REU1Mi1cXHVERUZGXFx1REYyRC1cXHVERjJGXFx1REY3RVxcdURGN0ZcXHVERkNGLVxcdURGRDNcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1RENGRlxcdURENEItXFx1REQ0RlxcdUREN0FcXHVEREE0XFx1REU0M1xcdURFNDRcXHVERUQwLVxcdURFREZcXHVERUVELVxcdURFRUZcXHVERUY0LVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXS87XG5cblxuXG5cbi8qKlxuICogc3ltYm9sUHJvcGVydGllcyggY3VycmVuY3ksIGNsZHIgKVxuICpcbiAqIFJldHVybiBwYXR0ZXJuIHJlcGxhY2luZyBgwqRgIHdpdGggdGhlIGFwcHJvcHJpYXRlIGN1cnJlbmN5IHN5bWJvbCBsaXRlcmFsLlxuICovXG52YXIgY3VycmVuY3lTeW1ib2xQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBjbGRyLCBvcHRpb25zICkge1xuXHR2YXIgY3VycmVuY3lTcGFjaW5nLCBwYXR0ZXJuLFxuXHRcdHJlZ2V4cCA9IHtcblx0XHRcdFwiWzpkaWdpdDpdXCI6IC9cXGQvLFxuXHRcdFx0XCJbOl5TOl1cIjogcmVnZXhwTm90U1xuXHRcdH0sXG5cdFx0c3ltYm9sID0gY2xkci5tYWluKFtcblx0XHRcdFwibnVtYmVycy9jdXJyZW5jaWVzXCIsXG5cdFx0XHRjdXJyZW5jeSxcblx0XHRcdFwic3ltYm9sXCJcblx0XHRdKTtcblxuXHRjdXJyZW5jeVNwYWNpbmcgPSBbIFwiYmVmb3JlQ3VycmVuY3lcIiwgXCJhZnRlckN1cnJlbmN5XCIgXS5tYXAoZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuXHRcdHJldHVybiBjbGRyLm1haW4oW1xuXHRcdFx0XCJudW1iZXJzXCIsXG5cdFx0XHRcImN1cnJlbmN5Rm9ybWF0cy1udW1iZXJTeXN0ZW0tXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKSxcblx0XHRcdFwiY3VycmVuY3lTcGFjaW5nXCIsXG5cdFx0XHRwb3NpdGlvblxuXHRcdF0pO1xuXHR9KTtcblxuXHRwYXR0ZXJuID0gY2xkci5tYWluKFtcblx0XHRcIm51bWJlcnNcIixcblx0XHRcImN1cnJlbmN5Rm9ybWF0cy1udW1iZXJTeXN0ZW0tXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKSxcblx0XHRvcHRpb25zLnN0eWxlID09PSBcImFjY291bnRpbmdcIiA/IFwiYWNjb3VudGluZ1wiIDogXCJzdGFuZGFyZFwiXG5cdF0pO1xuXG5cdHBhdHRlcm4gPVxuXG5cdFx0Ly8gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBhbmQgdGhlIHJvdW5kaW5nIGZvciBlYWNoIGN1cnJlbmN5IGlzIG5vdCBsb2NhbGUtc3BlY2lmaWMuXG5cdFx0Ly8gVGhvc2UgdmFsdWVzIGFyZSBvdmVycmlkZGVuIGJ5IFN1cHBsZW1lbnRhbCBDdXJyZW5jeSBEYXRhLlxuXHRcdGN1cnJlbmN5U3VwcGxlbWVudGFsT3ZlcnJpZGUoIGN1cnJlbmN5LCBwYXR0ZXJuLCBjbGRyIClcblxuXHRcdC8vIFJlcGxhY2UgXCLCpFwiIChcXHUwMEE0KSB3aXRoIHRoZSBhcHByb3ByaWF0ZSBzeW1ib2wgbGl0ZXJhbC5cblx0XHQuc3BsaXQoIFwiO1wiICkubWFwKGZ1bmN0aW9uKCBwYXR0ZXJuICkge1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybi5zcGxpdCggXCJcXHUwMEE0XCIgKS5tYXAoZnVuY3Rpb24oIHBhcnQsIGkgKSB7XG5cdFx0XHRcdHZhciBjdXJyZW5jeU1hdGNoID0gcmVnZXhwWyBjdXJyZW5jeVNwYWNpbmdbIGkgXS5jdXJyZW5jeU1hdGNoIF0sXG5cdFx0XHRcdFx0c3Vycm91bmRpbmdNYXRjaCA9IHJlZ2V4cFsgY3VycmVuY3lTcGFjaW5nWyBpIF0uc3Vycm91bmRpbmdNYXRjaCBdLFxuXHRcdFx0XHRcdGluc2VydEJldHdlZW4gPSBcIlwiO1xuXG5cdFx0XHRcdC8vIEZvciBjdXJyZW5jeU1hdGNoIGFuZCBzdXJyb3VuZGluZ01hdGNoIGRlZmluaXRpb25zLCByZWFkIFsxXS5cblx0XHRcdFx0Ly8gV2hlbiBpID09PSAwLCBiZWZvcmVDdXJyZW5jeSBpcyBiZWluZyBoYW5kbGVkLiBPdGhlcndpc2UsIGFmdGVyQ3VycmVuY3kuXG5cdFx0XHRcdC8vIDE6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sI0N1cnJlbmNpZXNcblx0XHRcdFx0Y3VycmVuY3lNYXRjaCA9IGN1cnJlbmN5TWF0Y2gudGVzdCggc3ltYm9sLmNoYXJBdCggaSA/IHN5bWJvbC5sZW5ndGggLSAxIDogMCApICk7XG5cdFx0XHRcdHN1cnJvdW5kaW5nTWF0Y2ggPSBzdXJyb3VuZGluZ01hdGNoLnRlc3QoXG5cdFx0XHRcdFx0cGFydC5jaGFyQXQoIGkgPyAwIDogcGFydC5sZW5ndGggLSAxICkucmVwbGFjZSggL1sjQCwuXS9nLCBcIjBcIiApXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW5jeU1hdGNoICYmIHBhcnQgJiYgc3Vycm91bmRpbmdNYXRjaCApIHtcblx0XHRcdFx0XHRpbnNlcnRCZXR3ZWVuID0gY3VycmVuY3lTcGFjaW5nWyBpIF0uaW5zZXJ0QmV0d2Vlbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAoIGkgPyBpbnNlcnRCZXR3ZWVuIDogXCJcIiApICsgcGFydCArICggaSA/IFwiXCIgOiBpbnNlcnRCZXR3ZWVuICk7XG5cdFx0XHR9KS5qb2luKCBcIidcIiArIHN5bWJvbCArIFwiJ1wiICk7XG5cdFx0fSkuam9pbiggXCI7XCIgKTtcblxuXHRyZXR1cm4ge1xuXHRcdHBhdHRlcm46IHBhdHRlcm5cblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogb2JqZWN0T21pdCggb2JqZWN0LCBrZXlzIClcbiAqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3QsIGZpbHRlcmVkIHRvIG9taXQgdGhlIGJsYWNrbGlzdGVkIGtleSBvciBhcnJheSBvZiBrZXlzLlxuICovXG52YXIgb2JqZWN0T21pdCA9IGZ1bmN0aW9uKCBvYmplY3QsIGtleXMgKSB7XG5cdHZhciBrZXksXG5cdFx0Y29weSA9IHt9O1xuXG5cdGtleXMgPSBhbHdheXNBcnJheSgga2V5cyApO1xuXG5cdGZvciAoIGtleSBpbiBvYmplY3QgKSB7XG5cdFx0aWYgKCBrZXlzLmluZGV4T2YoIGtleSApID09PSAtMSApIHtcblx0XHRcdGNvcHlbIGtleSBdID0gb2JqZWN0WyBrZXkgXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29weTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVxdWlyZWRDbGRyKCBwYXRoLCB2YWx1ZSApIHtcblx0dmFsaWRhdGVDbGRyKCBwYXRoLCB2YWx1ZSwge1xuXHRcdHNraXA6IFsgL3N1cHBsZW1lbnRhbFxcL2N1cnJlbmN5RGF0YVxcL2ZyYWN0aW9uc1xcL1tBLVphLXpdezN9JC8gXVxuXHR9KTtcbn1cblxuLyoqXG4gKiAuY3VycmVuY3lGb3JtYXR0ZXIoIGN1cnJlbmN5IFssIG9wdGlvbnNdIClcbiAqXG4gKiBAY3VycmVuY3kgW1N0cmluZ10gMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3LlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOlxuICogLSBzdHlsZTogW1N0cmluZ10gXCJzeW1ib2xcIiAoZGVmYXVsdCksIFwiYWNjb3VudGluZ1wiLCBcImNvZGVcIiBvciBcIm5hbWVcIi5cbiAqIC0gc2VlIGFsc28gbnVtYmVyL2Zvcm1hdCBvcHRpb25zLlxuICpcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIGN1cnJlbmN5IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGVmYXVsdC9pbnN0YW5jZVxuICogbG9jYWxlLlxuICovXG5HbG9iYWxpemUuY3VycmVuY3lGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5jdXJyZW5jeUZvcm1hdHRlciA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzLCByZXR1cm5Gbiwgc3R5bGU7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggY3VycmVuY3ksIFwiY3VycmVuY3lcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVDdXJyZW5jeSggY3VycmVuY3ksIFwiY3VycmVuY3lcIiApO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFyZ3MgPSBbIGN1cnJlbmN5LCBvcHRpb25zIF07XG5cdHN0eWxlID0gb3B0aW9ucy5zdHlsZSB8fCBcInN5bWJvbFwiO1xuXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdC8vIEdldCBwcm9wZXJ0aWVzIGdpdmVuIHN0eWxlIChcInN5bWJvbFwiIGRlZmF1bHQsIFwiY29kZVwiIG9yIFwibmFtZVwiKS5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcblx0cHJvcGVydGllcyA9ICh7XG5cdFx0YWNjb3VudGluZzogY3VycmVuY3lTeW1ib2xQcm9wZXJ0aWVzLFxuXHRcdGNvZGU6IGN1cnJlbmN5Q29kZVByb3BlcnRpZXMsXG5cdFx0bmFtZTogY3VycmVuY3lOYW1lUHJvcGVydGllcyxcblx0XHRzeW1ib2w6IGN1cnJlbmN5U3ltYm9sUHJvcGVydGllc1xuXHR9WyBzdHlsZSBdICkoIGN1cnJlbmN5LCBjbGRyLCBvcHRpb25zICk7XG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xuXG5cdC8vIG9wdGlvbnMgPSBvcHRpb25zIG1pbnVzIHN0eWxlLCBwbHVzIHJhdyBwYXR0ZXJuLlxuXHRvcHRpb25zID0gb2JqZWN0T21pdCggb3B0aW9ucywgXCJzdHlsZVwiICk7XG5cdG9wdGlvbnMucmF3ID0gcHJvcGVydGllcy5wYXR0ZXJuO1xuXG5cdC8vIFJldHVybiBmb3JtYXR0ZXIgd2hlbiBzdHlsZSBpcyBcInN5bWJvbFwiIG9yIFwiYWNjb3VudGluZ1wiLlxuXHRpZiAoIHN0eWxlID09PSBcInN5bWJvbFwiIHx8IHN0eWxlID09PSBcImFjY291bnRpbmdcIiApIHtcblx0XHRudW1iZXJGb3JtYXR0ZXIgPSB0aGlzLm51bWJlckZvcm1hdHRlciggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuRm4gPSBjdXJyZW5jeUZvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXIgKTtcblxuXHRcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXIgXSApO1xuXG5cdC8vIFJldHVybiBmb3JtYXR0ZXIgd2hlbiBzdHlsZSBpcyBcImNvZGVcIiBvciBcIm5hbWVcIi5cblx0fSBlbHNlIHtcblx0XHRudW1iZXJGb3JtYXR0ZXIgPSB0aGlzLm51bWJlckZvcm1hdHRlciggb3B0aW9ucyApO1xuXHRcdHBsdXJhbEdlbmVyYXRvciA9IHRoaXMucGx1cmFsR2VuZXJhdG9yKCk7XG5cblx0XHRyZXR1cm5GbiA9IGN1cnJlbmN5Rm9ybWF0dGVyRm4oIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICk7XG5cblx0XHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgXSApO1xuXHR9XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAuY3VycmVuY3lQYXJzZXIoIGN1cnJlbmN5IFssIG9wdGlvbnNdIClcbiAqXG4gKiBAY3VycmVuY3kgW1N0cmluZ10gMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3LlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBjdXJyZW5jeUZvcm1hdHRlci5cbiAqXG4gKiBSZXR1cm4gdGhlIGN1cnJlbmN5IHBhcnNlciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmN1cnJlbmN5UGFyc2VyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuY3VycmVuY3lQYXJzZXIgPSBmdW5jdGlvbiggLyogY3VycmVuY3ksIG9wdGlvbnMgKi8gKSB7XG5cblx0Ly8gVE9ETyBpbXBsZW1lbnQgcGFyc2VyLlxuXG59O1xuXG4vKipcbiAqIC5mb3JtYXRDdXJyZW5jeSggdmFsdWUsIGN1cnJlbmN5IFssIG9wdGlvbnNdIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl0gbnVtYmVyIHRvIGJlIGZvcm1hdHRlZC5cbiAqXG4gKiBAY3VycmVuY3kgW1N0cmluZ10gMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3LlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBjdXJyZW5jeUZvcm1hdHRlci5cbiAqXG4gKiBGb3JtYXQgYSBjdXJyZW5jeSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdEN1cnJlbmN5ID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0Q3VycmVuY3kgPSBmdW5jdGlvbiggdmFsdWUsIGN1cnJlbmN5LCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLmN1cnJlbmN5Rm9ybWF0dGVyKCBjdXJyZW5jeSwgb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiAucGFyc2VDdXJyZW5jeSggdmFsdWUsIGN1cnJlbmN5IFssIG9wdGlvbnNdIClcbiAqXG4gKiBAdmFsdWUgW1N0cmluZ11cbiAqXG4gKiBAY3VycmVuY3kgW1N0cmluZ10gMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3LlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOiBTZWUgY3VycmVuY3lGb3JtYXR0ZXIuXG4gKlxuICogUmV0dXJuIHRoZSBwYXJzZWQgY3VycmVuY3kgb3IgTmFOIHdoZW4gdmFsdWUgaXMgaW52YWxpZC5cbiAqL1xuR2xvYmFsaXplLnBhcnNlQ3VycmVuY3kgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5wYXJzZUN1cnJlbmN5ID0gZnVuY3Rpb24oIC8qIHZhbHVlLCBjdXJyZW5jeSwgb3B0aW9ucyAqLyApIHtcbn07XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2N1cnJlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvY3VycmVuY3kuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiLi9udW1iZXJcIixcblx0XHRcdFwiY2xkci9ldmVudFwiLFxuXHRcdFx0XCJjbGRyL3N1cHBsZW1lbnRhbFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gRXh0ZW5kIGdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgY3JlYXRlRXJyb3IgPSBHbG9iYWxpemUuX2NyZWF0ZUVycm9yLFxuXHRjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUsXG5cdGZvcm1hdE1lc3NhZ2UgPSBHbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2UsXG5cdGlzUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX2lzUGxhaW5PYmplY3QsXG5cdGxvb3NlTWF0Y2hpbmcgPSBHbG9iYWxpemUuX2xvb3NlTWF0Y2hpbmcsXG5cdG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCA9IEdsb2JhbGl6ZS5fbnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwLFxuXHRudW1iZXJTeW1ib2wgPSBHbG9iYWxpemUuX251bWJlclN5bWJvbCxcblx0cmVnZXhwRXNjYXBlID0gR2xvYmFsaXplLl9yZWdleHBFc2NhcGUsXG5cdHJlbW92ZUxpdGVyYWxRdW90ZXMgPSBHbG9iYWxpemUuX3JlbW92ZUxpdGVyYWxRdW90ZXMsXG5cdHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0c3RyaW5nUGFkID0gR2xvYmFsaXplLl9zdHJpbmdQYWQsXG5cdHZhbGlkYXRlID0gR2xvYmFsaXplLl92YWxpZGF0ZSxcblx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0LFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZztcblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlRGF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUsIFwiRGF0ZVwiICk7XG59O1xuXG5cblxuXG52YXIgY3JlYXRlRXJyb3JJbnZhbGlkUGFyYW1ldGVyVmFsdWUgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdHJldHVybiBjcmVhdGVFcnJvciggXCJFX0lOVkFMSURfUEFSX1ZBTFVFXCIsIFwiSW52YWxpZCBge25hbWV9YCB2YWx1ZSAoe3ZhbHVlfSkuXCIsIHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9KTtcbn07XG5cblxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWFwIGJldHdlZW4gdGhlIHNrZWxldG9uIGZpZWxkcyBhbmQgdGhlaXIgcG9zaXRpb25zLCBlLmcuLFxuICoge1xuICogICBHOiAwXG4gKiAgIHk6IDFcbiAqICAgLi4uXG4gKiB9XG4gKi9cbnZhciB2YWxpZGF0ZVNrZWxldG9uRmllbGRzUG9zTWFwID0gXCJHeVl1VXJRcU1MbHdXRWVjZERGZ2hIS2ttc1NBelpPdlZYeFwiLnNwbGl0KCBcIlwiICkucmVkdWNlKGZ1bmN0aW9uKCBtZW1vLCBpdGVtLCBpICkge1xuXHRtZW1vWyBpdGVtIF0gPSBpO1xuXHRyZXR1cm4gbWVtbztcbn0sIHt9KTtcblxuXG5cblxuLyoqXG4gKiB2YWxpZGF0ZVNrZWxldG9uKCBza2VsZXRvbiApXG4gKlxuICogc2tlbGV0b246IEFzc3VtZSBgamAgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgaW50byBhIGxvY2FsaXplZCBob3VyIGZpZWxkLlxuICovXG52YXIgdmFsaWRhdGVTa2VsZXRvbiA9IGZ1bmN0aW9uIHZhbGlkYXRlU2tlbGV0b24oIHNrZWxldG9uICkge1xuXHR2YXIgbGFzdCxcblxuXHRcdC8vIFVzaW5nIGVhc2llciB0byByZWFkIHZhcmlhYmxlLlxuXHRcdGZpZWxkc1Bvc01hcCA9IHZhbGlkYXRlU2tlbGV0b25GaWVsZHNQb3NNYXA7XG5cblx0Ly8gXCJUaGUgZmllbGRzIGFyZSBmcm9tIHRoZSBEYXRlIEZpZWxkIFN5bWJvbCBUYWJsZSBpbiBEYXRlIEZvcm1hdCBQYXR0ZXJuc1wiXG5cdC8vIFJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI2F2YWlsYWJsZUZvcm1hdHNfYXBwZW5kSXRlbXNcblx0Ly8gSS5lLiwgY2hlY2sgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cblx0c2tlbGV0b24ucmVwbGFjZSggL1teR3lZdVVyUXFNTGx3V0VlY2RERmdoSEtrbXNTQXpaT3ZWWHhdLywgZnVuY3Rpb24oIGZpZWxkICkge1xuXHRcdHRocm93IGNyZWF0ZUVycm9yKFxuXHRcdFx0XCJFX0lOVkFMSURfT1BUSU9OU1wiLCBcIkludmFsaWQgZmllbGQgYHtpbnZhbGlkRmllbGR9YCBvZiBza2VsZXRvbiBge3ZhbHVlfWBcIixcblx0XHRcdHtcblx0XHRcdFx0aW52YWxpZEZpZWxkOiBmaWVsZCxcblx0XHRcdFx0dHlwZTogXCJza2VsZXRvblwiLFxuXHRcdFx0XHR2YWx1ZTogc2tlbGV0b25cblx0XHRcdH1cblx0XHQpO1xuXHR9KTtcblxuXHQvLyBcIlRoZSBjYW5vbmljYWwgb3JkZXIgaXMgZnJvbSB0b3AgdG8gYm90dG9tIGluIHRoYXQgdGFibGU7IHRoYXQgaXMsIHlNIG5vdCBNeVwiLlxuXHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjYXZhaWxhYmxlRm9ybWF0c19hcHBlbmRJdGVtc1xuXHQvLyBJLmUuLCBjaGVjayBmb3IgaW52YWxpZCBvcmRlci5cblx0c2tlbGV0b24uc3BsaXQoIFwiXCIgKS5ldmVyeShmdW5jdGlvbiggZmllbGQgKSB7XG5cdFx0aWYgKCBmaWVsZHNQb3NNYXBbIGZpZWxkIF0gPCBsYXN0ICkge1xuXHRcdFx0dGhyb3cgY3JlYXRlRXJyb3IoXG5cdFx0XHRcdFwiRV9JTlZBTElEX09QVElPTlNcIiwgXCJJbnZhbGlkIG9yZGVyIGB7aW52YWxpZEZpZWxkfWAgb2Ygc2tlbGV0b24gYHt2YWx1ZX1gXCIsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbnZhbGlkRmllbGQ6IGZpZWxkLFxuXHRcdFx0XHRcdHR5cGU6IFwic2tlbGV0b25cIixcblx0XHRcdFx0XHR2YWx1ZTogc2tlbGV0b25cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0bGFzdCA9IGZpZWxkc1Bvc01hcFsgZmllbGQgXTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSk7XG59O1xuXG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IGNyZWF0ZWQgYnkgdXNpbmcgYG9iamVjdGAncyB2YWx1ZXMgYXMga2V5cywgYW5kIHRoZSBrZXlzIGFzIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdEludmVydCA9IGZ1bmN0aW9uKCBvYmplY3QsIGZuICkge1xuXHRmbiA9IGZuIHx8IGZ1bmN0aW9uKCBvYmplY3QsIGtleSwgdmFsdWUgKSB7XG5cdFx0b2JqZWN0WyB2YWx1ZSBdID0ga2V5O1xuXHRcdHJldHVybiBvYmplY3Q7XG5cdH07XG5cdHJldHVybiBPYmplY3Qua2V5cyggb2JqZWN0ICkucmVkdWNlKGZ1bmN0aW9uKCBuZXdPYmplY3QsIGtleSApIHtcblx0XHRyZXR1cm4gZm4oIG5ld09iamVjdCwga2V5LCBvYmplY3RbIGtleSBdICk7XG5cdH0sIHt9KTtcbn07XG5cblxuXG5cbi8vIEludmVydCBrZXkgYW5kIHZhbHVlcywgZS5nLiwge1wiZVwiOiBcImVFY1wifSA9PT4ge1wiZVwiOiBcImVcIiwgXCJFXCI6IFwiZVwiLCBcImNcIjogXCJlXCJ9LlxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuU2ltaWxhckZpZWxkc01hcCA9IG9iamVjdEludmVydCh7XG5cdFwiZVwiOiBcImVFY1wiLFxuXHRcIkxcIjogXCJNTFwiXG59LCBmdW5jdGlvbiggb2JqZWN0LCBrZXksIHZhbHVlICkge1xuXHR2YWx1ZS5zcGxpdCggXCJcIiApLmZvckVhY2goZnVuY3Rpb24oIGZpZWxkICkge1xuXHRcdG9iamVjdFsgZmllbGQgXSA9IGtleTtcblx0fSk7XG5cdHJldHVybiBvYmplY3Q7XG59KTtcblxuXG5cblxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuTm9ybWFsaXplUGF0dGVyblR5cGUgPSBmdW5jdGlvbiggY2hhcmFjdGVyICkge1xuXHRyZXR1cm4gZGF0ZUV4cGFuZFBhdHRlcm5TaW1pbGFyRmllbGRzTWFwWyBjaGFyYWN0ZXIgXSB8fCBjaGFyYWN0ZXI7XG59O1xuXG5cblxuXG52YXIgZGF0ZVBhdHRlcm5SZSA9ICggLyhbYS16XSlcXDEqfCcoW14nXXwnJykrJ3wnJ3wuL2lnICk7XG5cblxuXG5cbnZhciBzdHJpbmdSZXBlYXQgPSBmdW5jdGlvbiggc3RyLCBjb3VudCApIHtcblx0dmFyIGksIHJlc3VsdCA9IFwiXCI7XG5cdGZvciAoIGkgPSAwOyBpIDwgY291bnQ7IGkrKyApIHtcblx0XHRyZXN1bHQgPSByZXN1bHQgKyBzdHI7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG5cbnZhciBkYXRlRXhwYW5kUGF0dGVybkF1Z21lbnRGb3JtYXQgPSBmdW5jdGlvbiggcmVxdWVzdGVkU2tlbGV0b24sIGJlc3RNYXRjaEZvcm1hdCApIHtcblx0dmFyIGksIGosIG1hdGNoZWRUeXBlLCBtYXRjaGVkTGVuZ3RoLCByZXF1ZXN0ZWRUeXBlLCByZXF1ZXN0ZWRMZW5ndGgsXG5cblx0XHQvLyBVc2luZyBhbiBlYXNpZXIgdG8gcmVhZCB2YXJpYWJsZS5cblx0XHRub3JtYWxpemVQYXR0ZXJuVHlwZSA9IGRhdGVFeHBhbmRQYXR0ZXJuTm9ybWFsaXplUGF0dGVyblR5cGU7XG5cblx0cmVxdWVzdGVkU2tlbGV0b24gPSByZXF1ZXN0ZWRTa2VsZXRvbi5tYXRjaCggZGF0ZVBhdHRlcm5SZSApO1xuXHRiZXN0TWF0Y2hGb3JtYXQgPSBiZXN0TWF0Y2hGb3JtYXQubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKTtcblxuXHRmb3IgKCBpID0gMDsgaSA8IGJlc3RNYXRjaEZvcm1hdC5sZW5ndGg7IGkrKyApIHtcblx0XHRtYXRjaGVkVHlwZSA9IGJlc3RNYXRjaEZvcm1hdFtpXS5jaGFyQXQoIDAgKTtcblx0XHRtYXRjaGVkTGVuZ3RoID0gYmVzdE1hdGNoRm9ybWF0W2ldLmxlbmd0aDtcblx0XHRmb3IgKCBqID0gMDsgaiA8IHJlcXVlc3RlZFNrZWxldG9uLmxlbmd0aDsgaisrICkge1xuXHRcdFx0cmVxdWVzdGVkVHlwZSA9IHJlcXVlc3RlZFNrZWxldG9uW2pdLmNoYXJBdCggMCApO1xuXHRcdFx0cmVxdWVzdGVkTGVuZ3RoID0gcmVxdWVzdGVkU2tlbGV0b25bal0ubGVuZ3RoO1xuXHRcdFx0aWYgKCBub3JtYWxpemVQYXR0ZXJuVHlwZSggbWF0Y2hlZFR5cGUgKSA9PT0gbm9ybWFsaXplUGF0dGVyblR5cGUoIHJlcXVlc3RlZFR5cGUgKSAmJlxuXHRcdFx0XHRtYXRjaGVkTGVuZ3RoIDwgcmVxdWVzdGVkTGVuZ3RoXG5cdFx0XHQpIHtcblx0XHRcdFx0YmVzdE1hdGNoRm9ybWF0W2ldID0gc3RyaW5nUmVwZWF0KCBtYXRjaGVkVHlwZSwgcmVxdWVzdGVkTGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGJlc3RNYXRjaEZvcm1hdC5qb2luKCBcIlwiICk7XG59O1xuXG5cblxuXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm5Db21wYXJlRm9ybWF0cyA9IGZ1bmN0aW9uKCBmb3JtYXRBLCBmb3JtYXRCICkge1xuXHR2YXIgYSwgYiwgZGlzdGFuY2UsIGxlbkEsIGxlbkIsIHR5cGVBLCB0eXBlQiwgaSwgaixcblxuXHRcdC8vIFVzaW5nIGVhc2llciB0byByZWFkIHZhcmlhYmxlcy5cblx0XHRub3JtYWxpemVQYXR0ZXJuVHlwZSA9IGRhdGVFeHBhbmRQYXR0ZXJuTm9ybWFsaXplUGF0dGVyblR5cGU7XG5cblx0aWYgKCBmb3JtYXRBID09PSBmb3JtYXRCICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9ybWF0QSA9IGZvcm1hdEEubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKTtcblx0Zm9ybWF0QiA9IGZvcm1hdEIubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKTtcblxuXHRpZiAoIGZvcm1hdEEubGVuZ3RoICE9PSBmb3JtYXRCLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRkaXN0YW5jZSA9IDE7XG5cdGZvciAoIGkgPSAwOyBpIDwgZm9ybWF0QS5sZW5ndGg7IGkrKyApIHtcblx0XHRhID0gZm9ybWF0QVsgaSBdLmNoYXJBdCggMCApO1xuXHRcdHR5cGVBID0gbm9ybWFsaXplUGF0dGVyblR5cGUoIGEgKTtcblx0XHR0eXBlQiA9IG51bGw7XG5cdFx0Zm9yICggaiA9IDA7IGogPCBmb3JtYXRCLmxlbmd0aDsgaisrICkge1xuXHRcdFx0YiA9IGZvcm1hdEJbIGogXS5jaGFyQXQoIDAgKTtcblx0XHRcdHR5cGVCID0gbm9ybWFsaXplUGF0dGVyblR5cGUoIGIgKTtcblx0XHRcdGlmICggdHlwZUEgPT09IHR5cGVCICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGVCID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCB0eXBlQiA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0bGVuQSA9IGZvcm1hdEFbIGkgXS5sZW5ndGg7XG5cdFx0bGVuQiA9IGZvcm1hdEJbIGogXS5sZW5ndGg7XG5cdFx0ZGlzdGFuY2UgPSBkaXN0YW5jZSArIE1hdGguYWJzKCBsZW5BIC0gbGVuQiApO1xuXG5cdFx0Ly8gTW9zdCBzeW1ib2xzIGhhdmUgYSBzbWFsbCBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIsIGUuZy4sIE0g4omFIEw7IEUg4omFIGM7IGEg4omFIGIg4omFIEI7XG5cdFx0Ly8gSCDiiYUgayDiiYUgaCDiiYUgSzsgLi4uXG5cdFx0aWYgKCBhICE9PSBiICkge1xuXHRcdFx0ZGlzdGFuY2UgKz0gMTtcblx0XHR9XG5cblx0XHQvLyBOdW1lcmljIChsPDMpIGFuZCB0ZXh0IGZpZWxkcyAobD49MykgYXJlIGdpdmVuIGEgbGFyZ2VyIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci5cblx0XHRpZiAoICggbGVuQSA8IDMgJiYgbGVuQiA+PSAzICkgfHwgKCBsZW5BID49IDMgJiYgbGVuQiA8IDMgKSApIHtcblx0XHRcdGRpc3RhbmNlICs9IDIwO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGlzdGFuY2U7XG59O1xuXG5cblxuXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm5HZXRCZXN0TWF0Y2hQYXR0ZXJuID0gZnVuY3Rpb24oIGNsZHIsIGFza2VkU2tlbGV0b24gKSB7XG5cdHZhciBhdmFpbGFibGVGb3JtYXRzLCBwYXR0ZXJuLCByYXRlZEZvcm1hdHMsIHNrZWxldG9uLFxuXHRcdHBhdGggPSBcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF0ZVRpbWVGb3JtYXRzL2F2YWlsYWJsZUZvcm1hdHNcIixcblxuXHRcdC8vIFVzaW5nIGVhc2llciB0byByZWFkIHZhcmlhYmxlcy5cblx0XHRhdWdtZW50Rm9ybWF0ID0gZGF0ZUV4cGFuZFBhdHRlcm5BdWdtZW50Rm9ybWF0LFxuXHRcdGNvbXBhcmVGb3JtYXRzID0gZGF0ZUV4cGFuZFBhdHRlcm5Db21wYXJlRm9ybWF0cztcblxuXHRwYXR0ZXJuID0gY2xkci5tYWluKFsgcGF0aCwgYXNrZWRTa2VsZXRvbiBdKTtcblxuXHRpZiAoIGFza2VkU2tlbGV0b24gJiYgIXBhdHRlcm4gKSB7XG5cdFx0YXZhaWxhYmxlRm9ybWF0cyA9IGNsZHIubWFpbihbIHBhdGggXSk7XG5cdFx0cmF0ZWRGb3JtYXRzID0gW107XG5cblx0XHRmb3IgKCBza2VsZXRvbiBpbiBhdmFpbGFibGVGb3JtYXRzICkge1xuXHRcdFx0cmF0ZWRGb3JtYXRzLnB1c2goe1xuXHRcdFx0XHRza2VsZXRvbjogc2tlbGV0b24sXG5cdFx0XHRcdHBhdHRlcm46IGF2YWlsYWJsZUZvcm1hdHNbIHNrZWxldG9uIF0sXG5cdFx0XHRcdHJhdGU6IGNvbXBhcmVGb3JtYXRzKCBhc2tlZFNrZWxldG9uLCBza2VsZXRvbiApXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyYXRlZEZvcm1hdHMgPSByYXRlZEZvcm1hdHNcblx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCBmb3JtYXQgKSB7XG5cdFx0XHRcdHJldHVybiBmb3JtYXQucmF0ZSA+IC0xO1xuXHRcdFx0fSApXG5cdFx0XHQuc29ydCggZnVuY3Rpb24oIGZvcm1hdEEsIGZvcm1hdEIgKSB7XG5cdFx0XHRcdHJldHVybiBmb3JtYXRBLnJhdGUgLSBmb3JtYXRCLnJhdGU7XG5cdFx0XHR9KTtcblxuXHRcdGlmICggcmF0ZWRGb3JtYXRzLmxlbmd0aCApIHtcblx0XHRcdHBhdHRlcm4gPSBhdWdtZW50Rm9ybWF0KCBhc2tlZFNrZWxldG9uLCByYXRlZEZvcm1hdHNbMF0ucGF0dGVybiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwYXR0ZXJuO1xufTtcblxuXG5cblxuLyoqXG4gKiBleHBhbmRQYXR0ZXJuKCBvcHRpb25zLCBjbGRyIClcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBpZiBTdHJpbmcsIGl0J3MgY29uc2lkZXJlZCBhIHNrZWxldG9uLiBPYmplY3QgYWNjZXB0czpcbiAqIC0gc2tlbGV0b246IFtTdHJpbmddIGxvb2t1cCBhdmFpbGFibGVGb3JtYXQ7XG4gKiAtIGRhdGU6IFtTdHJpbmddICggXCJmdWxsXCIgfCBcImxvbmdcIiB8IFwibWVkaXVtXCIgfCBcInNob3J0XCIgKTtcbiAqIC0gdGltZTogW1N0cmluZ10gKCBcImZ1bGxcIiB8IFwibG9uZ1wiIHwgXCJtZWRpdW1cIiB8IFwic2hvcnRcIiApO1xuICogLSBkYXRldGltZTogW1N0cmluZ10gKCBcImZ1bGxcIiB8IFwibG9uZ1wiIHwgXCJtZWRpdW1cIiB8IFwic2hvcnRcIiApO1xuICogLSByYXc6IFtTdHJpbmddIEZvciBtb3JlIGluZm8gc2VlIGRhdGV0aW1lL2Zvcm1hdC5qcy5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHBhdHRlcm4uXG4gKiBFZyBmb3IgXCJlblwiOlxuICogLSBcIkd5TU1NZFwiIHJldHVybnMgXCJNTU0gZCwgeSBHXCI7XG4gKiAtIHsgc2tlbGV0b246IFwiR3lNTU1kXCIgfSByZXR1cm5zIFwiTU1NIGQsIHkgR1wiO1xuICogLSB7IGRhdGU6IFwiZnVsbFwiIH0gcmV0dXJucyBcIkVFRUUsIE1NTU0gZCwgeVwiO1xuICogLSB7IHRpbWU6IFwiZnVsbFwiIH0gcmV0dXJucyBcImg6bW06c3MgYSB6enp6XCI7XG4gKiAtIHsgZGF0ZXRpbWU6IFwiZnVsbFwiIH0gcmV0dXJucyBcIkVFRUUsIE1NTU0gZCwgeSAnYXQnIGg6bW06c3MgYSB6enp6XCI7XG4gKiAtIHsgcmF3OiBcImRkL21tXCIgfSByZXR1cm5zIFwiZGQvbW1cIjtcbiAqL1xudmFyIGRhdGVFeHBhbmRQYXR0ZXJuID0gZnVuY3Rpb24oIG9wdGlvbnMsIGNsZHIgKSB7XG5cdHZhciBkYXRlU2tlbGV0b24sIHJlc3VsdCwgc2tlbGV0b24sIHRpbWVTa2VsZXRvbiwgdHlwZSxcblxuXHRcdC8vIFVzaW5nIGVhc2llciB0byByZWFkIHZhcmlhYmxlcy5cblx0XHRnZXRCZXN0TWF0Y2hQYXR0ZXJuID0gZGF0ZUV4cGFuZFBhdHRlcm5HZXRCZXN0TWF0Y2hQYXR0ZXJuO1xuXG5cdGZ1bmN0aW9uIGNvbWJpbmVEYXRlVGltZSggdHlwZSwgZGF0ZVBhdHRlcm4sIHRpbWVQYXR0ZXJuICkge1xuXHRcdHJldHVybiBmb3JtYXRNZXNzYWdlKFxuXHRcdFx0Y2xkci5tYWluKFtcblx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RhdGVUaW1lRm9ybWF0c1wiLFxuXHRcdFx0XHR0eXBlXG5cdFx0XHRdKSxcblx0XHRcdFsgdGltZVBhdHRlcm4sIGRhdGVQYXR0ZXJuIF1cblx0XHQpO1xuXHR9XG5cblx0c3dpdGNoICggdHJ1ZSApIHtcblx0XHRjYXNlIFwic2tlbGV0b25cIiBpbiBvcHRpb25zOlxuXHRcdFx0c2tlbGV0b24gPSBvcHRpb25zLnNrZWxldG9uO1xuXG5cdFx0XHQvLyBQcmVmZXJyZWQgaG91ciAoaikuXG5cdFx0XHRza2VsZXRvbiA9IHNrZWxldG9uLnJlcGxhY2UoIC9qL2csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gY2xkci5zdXBwbGVtZW50YWwudGltZURhdGEucHJlZmVycmVkKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFsaWRhdGVTa2VsZXRvbiggc2tlbGV0b24gKTtcblxuXHRcdFx0Ly8gVHJ5IGRpcmVjdCBtYXAgKG5vdGUgdGhhdCBnZXRCZXN0TWF0Y2hQYXR0ZXJuIGhhbmRsZXMgaXQpLlxuXHRcdFx0Ly8gLi4uIG9yLCB0cnkgdG8gXCJiZXN0IG1hdGNoXCIgdGhlIHdob2xlIHNrZWxldG9uLlxuXHRcdFx0cmVzdWx0ID0gZ2V0QmVzdE1hdGNoUGF0dGVybihcblx0XHRcdFx0Y2xkcixcblx0XHRcdFx0c2tlbGV0b25cblx0XHRcdCk7XG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIC4uLiBvciwgdHJ5IHRvIFwiYmVzdCBtYXRjaFwiIHRoZSBkYXRlIGFuZCB0aW1lIHBhcnRzIGluZGl2aWR1YWxseS5cblx0XHRcdHRpbWVTa2VsZXRvbiA9IHNrZWxldG9uLnNwbGl0KCAvW15oSEtrbXNTQXpaT3ZWWHhdLyApLnNsaWNlKCAtMSApWyAwIF07XG5cdFx0XHRkYXRlU2tlbGV0b24gPSBza2VsZXRvbi5zcGxpdCggL1teR3lZdVVyUXFNTGx3V2RERmdFZWNdLyApWyAwIF07XG5cdFx0XHRkYXRlU2tlbGV0b24gPSBnZXRCZXN0TWF0Y2hQYXR0ZXJuKFxuXHRcdFx0XHRjbGRyLFxuXHRcdFx0XHRkYXRlU2tlbGV0b25cblx0XHRcdCk7XG5cdFx0XHR0aW1lU2tlbGV0b24gPSBnZXRCZXN0TWF0Y2hQYXR0ZXJuKFxuXHRcdFx0XHRjbGRyLFxuXHRcdFx0XHR0aW1lU2tlbGV0b25cblx0XHRcdCk7XG5cblx0XHRcdGlmICggLyhNTU1NfExMTEwpLipbRWNdLy50ZXN0KCBkYXRlU2tlbGV0b24gKSApIHtcblx0XHRcdFx0dHlwZSA9IFwiZnVsbFwiO1xuXHRcdFx0fSBlbHNlIGlmICggL01NTU18TExMTC8udGVzdCggZGF0ZVNrZWxldG9uICkgKSB7XG5cdFx0XHRcdHR5cGUgPSBcImxvbmdcIjtcblx0XHRcdH0gZWxzZSBpZiAoIC9NTU18TExMLy50ZXN0KCBkYXRlU2tlbGV0b24gKSApIHtcblx0XHRcdFx0dHlwZSA9IFwibWVkaXVtXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gXCJzaG9ydFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRhdGVTa2VsZXRvbiAmJiB0aW1lU2tlbGV0b24gKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGNvbWJpbmVEYXRlVGltZSggdHlwZSwgZGF0ZVNrZWxldG9uLCB0aW1lU2tlbGV0b24gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IGRhdGVTa2VsZXRvbiB8fCB0aW1lU2tlbGV0b247XG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcImRhdGVcIiBpbiBvcHRpb25zOlxuXHRcdGNhc2UgXCJ0aW1lXCIgaW4gb3B0aW9uczpcblx0XHRcdHJlc3VsdCA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhblwiLFxuXHRcdFx0XHRcImRhdGVcIiBpbiBvcHRpb25zID8gXCJkYXRlRm9ybWF0c1wiIDogXCJ0aW1lRm9ybWF0c1wiLFxuXHRcdFx0XHQoIG9wdGlvbnMuZGF0ZSB8fCBvcHRpb25zLnRpbWUgKVxuXHRcdFx0XSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJkYXRldGltZVwiIGluIG9wdGlvbnM6XG5cdFx0XHRyZXN1bHQgPSBjb21iaW5lRGF0ZVRpbWUoIG9wdGlvbnMuZGF0ZXRpbWUsXG5cdFx0XHRcdGNsZHIubWFpbihbIFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXRlRm9ybWF0c1wiLCBvcHRpb25zLmRhdGV0aW1lIF0pLFxuXHRcdFx0XHRjbGRyLm1haW4oWyBcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vdGltZUZvcm1hdHNcIiwgb3B0aW9ucy5kYXRldGltZSBdKVxuXHRcdFx0KTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcInJhd1wiIGluIG9wdGlvbnM6XG5cdFx0XHRyZXN1bHQgPSBvcHRpb25zLnJhdztcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IGNyZWF0ZUVycm9ySW52YWxpZFBhcmFtZXRlclZhbHVlKHtcblx0XHRcdFx0bmFtZTogXCJvcHRpb25zXCIsXG5cdFx0XHRcdHZhbHVlOiBvcHRpb25zXG5cdFx0XHR9KTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuXG52YXIgZGF0ZVdlZWtEYXlzID0gWyBcInN1blwiLCBcIm1vblwiLCBcInR1ZVwiLCBcIndlZFwiLCBcInRodVwiLCBcImZyaVwiLCBcInNhdFwiIF07XG5cblxuXG5cbi8qKlxuICogZmlyc3REYXlPZldlZWtcbiAqL1xudmFyIGRhdGVGaXJzdERheU9mV2VlayA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHRyZXR1cm4gZGF0ZVdlZWtEYXlzLmluZGV4T2YoIGNsZHIuc3VwcGxlbWVudGFsLndlZWtEYXRhLmZpcnN0RGF5KCkgKTtcbn07XG5cblxuXG5cbi8qKlxuICogZ2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIHR5cGUgKVxuICovXG52YXIgZGF0ZUdldFRpbWVab25lTmFtZSA9IGZ1bmN0aW9uKCBsZW5ndGgsIHR5cGUsIHRpbWVab25lLCBjbGRyICkge1xuXHR2YXIgbWV0YVpvbmUsIHJlc3VsdDtcblxuXHRpZiAoICF0aW1lWm9uZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRyZXN1bHQgPSBjbGRyLm1haW4oW1xuXHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lXCIsXG5cdFx0dGltZVpvbmUsXG5cdFx0bGVuZ3RoIDwgNCA/IFwic2hvcnRcIiA6IFwibG9uZ1wiLFxuXHRcdHR5cGVcblx0XSk7XG5cblx0aWYgKCByZXN1bHQgKSB7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8vIFRoZSBsYXRlc3QgbWV0YXpvbmUgZGF0YSBvZiB0aGUgbWV0YXpvbmUgYXJyYXkuXG5cdC8vIFRPRE8gZXhwYW5kIHRvIHN1cHBvcnQgdGhlIGhpc3RvcmljIG1ldGF6b25lcyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZGF0ZS5cblx0bWV0YVpvbmUgPSBjbGRyLnN1cHBsZW1lbnRhbChbXG5cdFx0XCJtZXRhWm9uZXMvbWV0YXpvbmVJbmZvL3RpbWV6b25lXCIsIHRpbWVab25lLCAwLFxuXHRcdFwidXNlc01ldGF6b25lL19tem9uZVwiXG5cdF0pO1xuXG5cdHJldHVybiBjbGRyLm1haW4oW1xuXHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9tZXRhem9uZVwiLFxuXHRcdG1ldGFab25lLFxuXHRcdGxlbmd0aCA8IDQgPyBcInNob3J0XCIgOiBcImxvbmdcIixcblx0XHR0eXBlXG5cdF0pO1xufTtcblxuXG5cblxuLyoqXG4gKiB0aW1lem9uZUhvdXJGb3JtYXRTaG9ydEgoIGhvdXJGb3JtYXQgKVxuICpcbiAqIEBob3VyRm9ybWF0IFtTdHJpbmddXG4gKlxuICogVW5vZmZpY2lhbCBkZWR1Y3Rpb24gb2YgdGhlIHNob3J0IGhvdXJGb3JtYXQgZ2l2ZW4gdGltZSB6b25lIGBob3VyRm9ybWF0YCBlbGVtZW50LlxuICogT2ZmaWNpYWwgc3BlYyBpcyBwZW5kaW5nIHJlc29sdXRpb246IGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzgyOTNcbiAqXG4gKiBFeGFtcGxlOlxuICogLSBcIitISC5tbTstSEgubW1cIiA9PiBcIitIOy1IXCJcbiAqIC0gXCIrSEg6bW07LUhIOm1tXCIgPT4gXCIrSDstSFwiXG4gKiAtIFwiK0hIOm1tO+KIkkhIOm1tXCIgPT4gXCIrSDviiJJIXCIgKE5vdGUgTUlOVVMgU0lHTiBcXHUyMjEyKVxuICogLSBcIitISG1tOy1ISG1tXCIgPT4gXCIrSDotSFwiXG4gKi9cbnZhciBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SCA9IGZ1bmN0aW9uKCBob3VyRm9ybWF0ICkge1xuXHRyZXR1cm4gaG91ckZvcm1hdFxuXHRcdC5zcGxpdCggXCI7XCIgKVxuXHRcdC5tYXAoZnVuY3Rpb24oIGZvcm1hdCApIHtcblx0XHRcdHJldHVybiBmb3JtYXQuc2xpY2UoIDAsIGZvcm1hdC5pbmRleE9mKCBcIkhcIiApICsgMSApO1xuXHRcdH0pXG5cdFx0LmpvaW4oIFwiO1wiICk7XG59O1xuXG5cblxuXG4vKipcbiAqIHRpbWV6b25lSG91ckZvcm1hdExvbmdIbSggaG91ckZvcm1hdCApXG4gKlxuICogQGhvdXJGb3JtYXQgW1N0cmluZ11cbiAqXG4gKiBVbm9mZmljaWFsIGRlZHVjdGlvbiBvZiB0aGUgc2hvcnQgaG91ckZvcm1hdCBnaXZlbiB0aW1lIHpvbmUgYGhvdXJGb3JtYXRgIGVsZW1lbnQuXG4gKiBPZmZpY2lhbCBzcGVjIGlzIHBlbmRpbmcgcmVzb2x1dGlvbjogaHR0cDovL3VuaWNvZGUub3JnL2NsZHIvdHJhYy90aWNrZXQvODI5M1xuICpcbiAqIEV4YW1wbGUgKGhGb3JtYXQgPT09IFwiSFwiKTogKHVzZWQgZm9yIHNob3J0IEhtKVxuICogLSBcIitISC5tbTstSEgubW1cIiA9PiBcIitILm1tOy1ILm1tXCJcbiAqIC0gXCIrSEg6bW07LUhIOm1tXCIgPT4gXCIrSDptbTstSDptbVwiXG4gKiAtIFwiK0hIOm1tO+KIkkhIOm1tXCIgPT4gXCIrSDptbTviiJJIOm1tXCIgKE5vdGUgTUlOVVMgU0lHTiBcXHUyMjEyKVxuICogLSBcIitISG1tOy1ISG1tXCIgPT4gXCIrSG1tOi1IbW1cIlxuICpcbiAqIEV4YW1wbGUgKGhGb3JtYXQgPT09IFwiSEhcIjogKHVzZWQgZm9yIGxvbmcgSG0pXG4gKiAtIFwiK0hILm1tOy1ISC5tbVwiID0+IFwiK0hILm1tOy1ISC5tbVwiXG4gKiAtIFwiK0hIOm1tOy1ISDptbVwiID0+IFwiK0hIOm1tOy1ISDptbVwiXG4gKiAtIFwiK0g6bW07LUg6bW1cIiAgID0+IFwiK0hIOm1tOy1ISDptbVwiXG4gKiAtIFwiK0hIOm1tO+KIkkhIOm1tXCIgPT4gXCIrSEg6bW074oiSSEg6bW1cIiAoTm90ZSBNSU5VUyBTSUdOIFxcdTIyMTIpXG4gKiAtIFwiK0hIbW07LUhIbW1cIiA9PiBcIitISG1tOi1ISG1tXCJcbiAqL1xudmFyIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSA9IGZ1bmN0aW9uKCBob3VyRm9ybWF0LCBoRm9ybWF0ICkge1xuXHRyZXR1cm4gaG91ckZvcm1hdFxuXHRcdC5zcGxpdCggXCI7XCIgKVxuXHRcdC5tYXAoZnVuY3Rpb24oIGZvcm1hdCApIHtcblx0XHRcdHZhciBwYXJ0cyA9IGZvcm1hdC5zcGxpdCggL0grLyApO1xuXHRcdFx0cGFydHMuc3BsaWNlKCAxLCAwLCBoRm9ybWF0ICk7XG5cdFx0XHRyZXR1cm4gcGFydHMuam9pbiggXCJcIiApO1xuXHRcdH0pXG5cdFx0LmpvaW4oIFwiO1wiICk7XG59O1xuXG5cblxuXG52YXIgcnVudGltZUNhY2hlRGF0YUJpbmQgPSBmdW5jdGlvbigga2V5LCBkYXRhICkge1xuXHR2YXIgZm4gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZGF0YTtcblx0fTtcblx0Zm4uZGF0YUNhY2hlS2V5ID0ga2V5O1xuXHRyZXR1cm4gZm47XG59O1xuXG5cblxuXG4vKipcbiAqIHByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgKVxuICpcbiAqIEBwYXR0ZXJuIFtTdHJpbmddIHJhdyBwYXR0ZXJuLlxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHRoZSBwcm9wZXJ0aWVzIGdpdmVuIHRoZSBwYXR0ZXJuIGFuZCBjbGRyLlxuICpcbiAqIFRPRE8gU3VwcG9ydCBvdGhlciBjYWxlbmRhciB0eXBlcy5cbiAqL1xudmFyIGRhdGVGb3JtYXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHBhdHRlcm4sIGNsZHIsIHRpbWVab25lICkge1xuXHR2YXIgcHJvcGVydGllcyA9IHtcblx0XHRcdG51bWJlckZvcm1hdHRlcnM6IHt9LFxuXHRcdFx0cGF0dGVybjogcGF0dGVybixcblx0XHRcdHRpbWVTZXBhcmF0b3I6IG51bWJlclN5bWJvbCggXCJ0aW1lU2VwYXJhdG9yXCIsIGNsZHIgKVxuXHRcdH0sXG5cdFx0d2lkdGhzID0gWyBcImFiYnJldmlhdGVkXCIsIFwid2lkZVwiLCBcIm5hcnJvd1wiIF07XG5cblx0ZnVuY3Rpb24gc2V0TnVtYmVyRm9ybWF0dGVyUGF0dGVybiggcGFkICkge1xuXHRcdHByb3BlcnRpZXMubnVtYmVyRm9ybWF0dGVyc1sgcGFkIF0gPSBzdHJpbmdQYWQoIFwiXCIsIHBhZCApO1xuXHR9XG5cblx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSA9IHJ1bnRpbWVDYWNoZURhdGFCaW5kKCBcImlhbmEvXCIgKyB0aW1lWm9uZSwge1xuXHRcdFx0b2Zmc2V0czogY2xkci5nZXQoWyBcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXCIsIHRpbWVab25lLCBcIm9mZnNldHNcIiBdKSxcblx0XHRcdHVudGlsczogY2xkci5nZXQoWyBcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXCIsIHRpbWVab25lLCBcInVudGlsc1wiIF0pLFxuXHRcdFx0aXNkc3RzOiBjbGRyLmdldChbIFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcIiwgdGltZVpvbmUsIFwiaXNkc3RzXCIgXSlcblx0XHR9KTtcblx0fVxuXG5cdHBhdHRlcm4ucmVwbGFjZSggZGF0ZVBhdHRlcm5SZSwgZnVuY3Rpb24oIGN1cnJlbnQgKSB7XG5cdFx0dmFyIGF1eCwgY2hyLCBkYXlsaWdodFR6TmFtZSwgZm9ybWF0TnVtYmVyLCBnZW5lcmljVHpOYW1lLCBsZW5ndGgsIHN0YW5kYXJkVHpOYW1lO1xuXG5cdFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKTtcblx0XHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcblxuXHRcdGlmICggY2hyID09PSBcImpcIiApIHtcblxuXHRcdFx0Ly8gTG9jYWxlIHByZWZlcnJlZCBoSEtrLlxuXHRcdFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI1RpbWVfRGF0YVxuXHRcdFx0cHJvcGVydGllcy5wcmVmZXJyZWRUaW1lID0gY2hyID0gY2xkci5zdXBwbGVtZW50YWwudGltZURhdGEucHJlZmVycmVkKCk7XG5cdFx0fVxuXG5cdFx0Ly8gWlpaWjogc2FtZSBhcyBcIk9PT09cIi5cblx0XHRpZiAoIGNociA9PT0gXCJaXCIgJiYgbGVuZ3RoID09PSA0ICkge1xuXHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRsZW5ndGggPSA0O1xuXHRcdH1cblxuXHRcdC8vIHouLi56eno6IFwie3Nob3J0UmVnaW9ufVwiLCBlZy4gXCJQU1RcIiBvciBcIlBEVFwiLlxuXHRcdC8vIHp6eno6IFwie3JlZ2lvbk5hbWV9IHtTdGFuZGFyZCBUaW1lfVwiIG9yIFwie3JlZ2lvbk5hbWV9IHtEYXlsaWdodCBUaW1lfVwiLFxuXHRcdC8vICAgICAgIGUuZy4sIFwiUGFjaWZpYyBTdGFuZGFyZCBUaW1lXCIgb3IgXCJQYWNpZmljIERheWxpZ2h0IFRpbWVcIi5cblx0XHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuXHRcdGlmICggY2hyID09PSBcInpcIiApIHtcblx0XHRcdHN0YW5kYXJkVHpOYW1lID0gZGF0ZUdldFRpbWVab25lTmFtZSggbGVuZ3RoLCBcInN0YW5kYXJkXCIsIHRpbWVab25lLCBjbGRyICk7XG5cdFx0XHRkYXlsaWdodFR6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXCJkYXlsaWdodFwiLCB0aW1lWm9uZSwgY2xkciApO1xuXHRcdFx0aWYgKCBzdGFuZGFyZFR6TmFtZSApIHtcblx0XHRcdFx0cHJvcGVydGllcy5zdGFuZGFyZFR6TmFtZSA9IHN0YW5kYXJkVHpOYW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkYXlsaWdodFR6TmFtZSApIHtcblx0XHRcdFx0cHJvcGVydGllcy5kYXlsaWdodFR6TmFtZSA9IGRheWxpZ2h0VHpOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIHRocm91Z2ggdGhlIFwiT1wiIGZvcm1hdCBpbiBjYXNlIG9uZSBuYW1lIGlzIG1pc3NpbmcuXG5cdFx0XHRpZiAoICFzdGFuZGFyZFR6TmFtZSB8fCAhZGF5bGlnaHRUek5hbWUgKSB7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA8IDQgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHYuLi52dnY6IFwie3Nob3J0UmVnaW9ufVwiLCBlZy4gXCJQVFwiLlxuXHRcdC8vIHZ2dnY6IFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiIG9yIFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiLFxuXHRcdC8vIGUuZy4sIFwiUGFjaWZpYyBUaW1lXCJcblx0XHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuXHRcdGlmICggY2hyID09PSBcInZcIiApIHtcblx0XHRcdGdlbmVyaWNUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFwiZ2VuZXJpY1wiLCB0aW1lWm9uZSwgY2xkciApO1xuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gXCJWXCIgZm9ybWF0LlxuXHRcdFx0aWYgKCAhZ2VuZXJpY1R6TmFtZSApIHtcblx0XHRcdFx0Y2hyID0gXCJWXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggY2hyICkge1xuXG5cdFx0XHQvLyBFcmFcblx0XHRcdGNhc2UgXCJHXCI6XG5cdFx0XHRcdHByb3BlcnRpZXMuZXJhcyA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2VyYXNcIixcblx0XHRcdFx0XHRsZW5ndGggPD0gMyA/IFwiZXJhQWJiclwiIDogKCBsZW5ndGggPT09IDQgPyBcImVyYU5hbWVzXCIgOiBcImVyYU5hcnJvd1wiIClcblx0XHRcdFx0XSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBZZWFyXG5cdFx0XHRjYXNlIFwieVwiOlxuXG5cdFx0XHRcdC8vIFBsYWluIHllYXIuXG5cdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiWVwiOlxuXG5cdFx0XHRcdC8vIFllYXIgaW4gXCJXZWVrIG9mIFllYXJcIlxuXHRcdFx0XHRwcm9wZXJ0aWVzLmZpcnN0RGF5ID0gZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyICk7XG5cdFx0XHRcdHByb3BlcnRpZXMubWluRGF5cyA9IGNsZHIuc3VwcGxlbWVudGFsLndlZWtEYXRhLm1pbkRheXMoKTtcblx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJ1XCI6IC8vIEV4dGVuZGVkIHllYXIuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXG5cdFx0XHRjYXNlIFwiVVwiOiAvLyBDeWNsaWMgeWVhciBuYW1lLiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxuXHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0ZmVhdHVyZTogXCJ5ZWFyIHBhdHRlcm4gYFwiICsgY2hyICsgXCJgXCJcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIFF1YXJ0ZXJcblx0XHRcdGNhc2UgXCJRXCI6XG5cdFx0XHRjYXNlIFwicVwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IDIgKSB7XG5cdFx0XHRcdFx0aWYgKCAhcHJvcGVydGllcy5xdWFydGVycyApIHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucXVhcnRlcnMgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhcHJvcGVydGllcy5xdWFydGVyc1sgY2hyIF0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXVsgbGVuZ3RoIF0gPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL3F1YXJ0ZXJzXCIsXG5cdFx0XHRcdFx0XHRjaHIgPT09IFwiUVwiID8gXCJmb3JtYXRcIiA6IFwic3RhbmQtYWxvbmVcIixcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRjYXNlIFwiTFwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IDIgKSB7XG5cdFx0XHRcdFx0aWYgKCAhcHJvcGVydGllcy5tb250aHMgKSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLm1vbnRocyA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFwcm9wZXJ0aWVzLm1vbnRoc1sgY2hyIF0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLm1vbnRoc1sgY2hyIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvcGVydGllcy5tb250aHNbIGNociBdWyBsZW5ndGggXSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vbW9udGhzXCIsXG5cdFx0XHRcdFx0XHRjaHIgPT09IFwiTVwiID8gXCJmb3JtYXRcIiA6IFwic3RhbmQtYWxvbmVcIixcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2VlayAtIFdlZWsgb2YgWWVhciAodykgb3IgV2VlayBvZiBNb250aCAoVykuXG5cdFx0XHRjYXNlIFwid1wiOlxuXHRcdFx0Y2FzZSBcIldcIjpcblx0XHRcdFx0cHJvcGVydGllcy5maXJzdERheSA9IGRhdGVGaXJzdERheU9mV2VlayggY2xkciApO1xuXHRcdFx0XHRwcm9wZXJ0aWVzLm1pbkRheXMgPSBjbGRyLnN1cHBsZW1lbnRhbC53ZWVrRGF0YS5taW5EYXlzKCk7XG5cdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBEYXlcblx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0Y2FzZSBcIkZcIjpcblx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJnXCI6XG5cblx0XHRcdFx0Ly8gTW9kaWZpZWQgSnVsaWFuIGRheS4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdGZlYXR1cmU6IFwiSnVsaWFuIGRheSBwYXR0ZXJuIGBnYFwiXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBXZWVrIGRheVxuXHRcdFx0Y2FzZSBcImVcIjpcblx0XHRcdGNhc2UgXCJjXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoIDw9IDIgKSB7XG5cdFx0XHRcdFx0cHJvcGVydGllcy5maXJzdERheSA9IGRhdGVGaXJzdERheU9mV2VlayggY2xkciApO1xuXHRcdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIkVcIjpcblx0XHRcdFx0aWYgKCAhcHJvcGVydGllcy5kYXlzICkge1xuXHRcdFx0XHRcdHByb3BlcnRpZXMuZGF5cyA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXByb3BlcnRpZXMuZGF5c1sgY2hyIF0gKSB7XG5cdFx0XHRcdFx0cHJvcGVydGllcy5kYXlzWyBjaHIgXSA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2hvcnQgZGF5IG5hbWVzIGFyZSBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFiYnJldmlhdGVkIGRheSBuYW1lcyBhcmVcblx0XHRcdFx0XHQvLyB1c2VkIGluc3RlYWQuXG5cdFx0XHRcdFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI21vbnRoc19kYXlzX3F1YXJ0ZXJzX2VyYXNcblx0XHRcdFx0XHQvLyBodHRwOi8vdW5pY29kZS5vcmcvY2xkci90cmFjL3RpY2tldC82NzkwXG5cdFx0XHRcdFx0cHJvcGVydGllcy5kYXlzWyBjaHIgXVsgbGVuZ3RoIF0gPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0XHRjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIixcblx0XHRcdFx0XHRcdFx0XCJzaG9ydFwiXG5cdFx0XHRcdFx0XHRdKSB8fCBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0XHRjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIixcblx0XHRcdFx0XHRcdFx0XCJhYmJyZXZpYXRlZFwiXG5cdFx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmRheXNbIGNociBdWyBsZW5ndGggXSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0Y2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIsXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCA8IDMgPyAwIDogbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFBlcmlvZCAoQU0gb3IgUE0pXG5cdFx0XHRjYXNlIFwiYVwiOlxuXHRcdFx0XHRwcm9wZXJ0aWVzLmRheVBlcmlvZHMgPSB7XG5cdFx0XHRcdFx0YW06IGNsZHIubWFpbihcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlL2FtXCJcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdHBtOiBjbGRyLm1haW4oXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZS9wbVwiXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gSG91clxuXHRcdFx0Y2FzZSBcImhcIjogLy8gMS0xMlxuXHRcdFx0Y2FzZSBcIkhcIjogLy8gMC0yM1xuXHRcdFx0Y2FzZSBcIktcIjogLy8gMC0xMVxuXHRcdFx0Y2FzZSBcImtcIjogLy8gMS0yNFxuXG5cdFx0XHQvLyBNaW51dGVcblx0XHRcdGNhc2UgXCJtXCI6XG5cblx0XHRcdC8vIFNlY29uZFxuXHRcdFx0Y2FzZSBcInNcIjpcblx0XHRcdGNhc2UgXCJTXCI6XG5cdFx0XHRjYXNlIFwiQVwiOlxuXHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWm9uZVxuXHRcdFx0Y2FzZSBcInZcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggIT09IDEgJiYgbGVuZ3RoICE9PSA0ICkge1xuXHRcdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRcdGZlYXR1cmU6IFwidGltZXpvbmUgcGF0dGVybiBgXCIgKyBwYXR0ZXJuICsgXCJgXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWUgPSBnZW5lcmljVHpOYW1lO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIlZcIjpcblxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0XHRmZWF0dXJlOiBcInRpbWV6b25lIHBhdHRlcm4gYFwiICsgcGF0dGVybiArIFwiYFwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRpbWVab25lICkge1xuXHRcdFx0XHRcdGlmICggbGVuZ3RoID09PSAyICkge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciB0aW1lWm9uZU5hbWUsXG5cdFx0XHRcdFx0XHRleGVtcGxhckNpdHkgPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZVwiLCB0aW1lWm9uZSwgXCJleGVtcGxhckNpdHlcIlxuXHRcdFx0XHRcdFx0XSk7XG5cblx0XHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMyApIHtcblx0XHRcdFx0XHRcdGlmICggIWV4ZW1wbGFyQ2l0eSApIHtcblx0XHRcdFx0XHRcdFx0ZXhlbXBsYXJDaXR5ID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZS9FdGMvVW5rbm93bi9leGVtcGxhckNpdHlcIlxuXHRcdFx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRpbWVab25lTmFtZSA9IGV4ZW1wbGFyQ2l0eTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGV4ZW1wbGFyQ2l0eSAmJiBsZW5ndGggPT09IDQgKSB7XG5cdFx0XHRcdFx0XHR0aW1lWm9uZU5hbWUgPSBmb3JtYXRNZXNzYWdlKFxuXHRcdFx0XHRcdFx0XHRjbGRyLm1haW4oXG5cdFx0XHRcdFx0XHRcdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3JlZ2lvbkZvcm1hdFwiXG5cdFx0XHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0XHRcdFsgZXhlbXBsYXJDaXR5IF1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0aW1lWm9uZU5hbWUgKSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3VycmVudCA9PT0gXCJ2XCIgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiT1wiOlxuXG5cdFx0XHRcdC8vIE86IFwie2dtdEZvcm1hdH0rSDt7Z210Rm9ybWF0fS1IXCIgb3IgXCJ7Z210WmVyb0Zvcm1hdH1cIiwgZWcuIFwiR01ULThcIiBvciBcIkdNVFwiLlxuXHRcdFx0XHQvLyBPT09POiBcIntnbXRGb3JtYXR9e2hvdXJGb3JtYXR9XCIgb3IgXCJ7Z210WmVyb0Zvcm1hdH1cIiwgZWcuIFwiR01ULTA4OjAwXCIgb3IgXCJHTVRcIi5cblx0XHRcdFx0cHJvcGVydGllcy5nbXRGb3JtYXQgPSBjbGRyLm1haW4oIFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9nbXRGb3JtYXRcIiApO1xuXHRcdFx0XHRwcm9wZXJ0aWVzLmdtdFplcm9Gb3JtYXQgPSBjbGRyLm1haW4oIFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XCIgKTtcblxuXHRcdFx0XHQvLyBVbm9mZmljaWFsIGRlZHVjdGlvbiBvZiB0aGUgaG91ckZvcm1hdCB2YXJpYXRpb25zLlxuXHRcdFx0XHQvLyBPZmZpY2lhbCBzcGVjIGlzIHBlbmRpbmcgcmVzb2x1dGlvbjogaHR0cDovL3VuaWNvZGUub3JnL2NsZHIvdHJhYy90aWNrZXQvODI5M1xuXHRcdFx0XHRhdXggPSBjbGRyLm1haW4oIFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XCIgKTtcblx0XHRcdFx0cHJvcGVydGllcy5ob3VyRm9ybWF0ID0gbGVuZ3RoIDwgNCA/XG5cdFx0XHRcdFx0WyBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SCggYXV4ICksIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSggYXV4LCBcIkhcIiApIF0gOlxuXHRcdFx0XHRcdGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSggYXV4LCBcIkhIXCIgKTtcblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIlpcIjpcblx0XHRcdGNhc2UgXCJYXCI6XG5cdFx0XHRjYXNlIFwieFwiOlxuXHRcdFx0XHRzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCAxICk7XG5cdFx0XHRcdHNldE51bWJlckZvcm1hdHRlclBhdHRlcm4oIDIgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aWYgKCBmb3JtYXROdW1iZXIgKSB7XG5cdFx0XHRzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCBsZW5ndGggKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuXG5cblxudmFyIGRhdGVGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBkYXRlVG9QYXJ0c0Zvcm1hdHRlciApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGRhdGVGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdHJldHVybiBkYXRlVG9QYXJ0c0Zvcm1hdHRlciggdmFsdWUgKS5tYXAoIGZ1bmN0aW9uKCBwYXJ0ICkge1xuXHRcdFx0cmV0dXJuIHBhcnQudmFsdWU7XG5cdFx0fSkuam9pbiggXCJcIiApO1xuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiBwYXJzZVByb3BlcnRpZXMoIGNsZHIgKVxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBAdGltZVpvbmUgW1N0cmluZ10gRklYTUUuXG4gKlxuICogUmV0dXJuIHBhcnNlciBwcm9wZXJ0aWVzLlxuICovXG52YXIgZGF0ZVBhcnNlUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBjbGRyLCB0aW1lWm9uZSApIHtcblx0dmFyIHByb3BlcnRpZXMgPSB7XG5cdFx0cHJlZmVycmVkVGltZURhdGE6IGNsZHIuc3VwcGxlbWVudGFsLnRpbWVEYXRhLnByZWZlcnJlZCgpXG5cdH07XG5cblx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSA9IHJ1bnRpbWVDYWNoZURhdGFCaW5kKCBcImlhbmEvXCIgKyB0aW1lWm9uZSwge1xuXHRcdFx0b2Zmc2V0czogY2xkci5nZXQoWyBcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXCIsIHRpbWVab25lLCBcIm9mZnNldHNcIiBdKSxcblx0XHRcdHVudGlsczogY2xkci5nZXQoWyBcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXCIsIHRpbWVab25lLCBcInVudGlsc1wiIF0pLFxuXHRcdFx0aXNkc3RzOiBjbGRyLmdldChbIFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcIiwgdGltZVpvbmUsIFwiaXNkc3RzXCIgXSlcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuXG52YXIgWm9uZWREYXRlVGltZSA9IChmdW5jdGlvbigpIHtcbmZ1bmN0aW9uIGRlZmluZVByaXZhdGVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VW50aWxzSW5kZXgob3JpZ2luYWwsIHVudGlscykge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgb3JpZ2luYWxUaW1lID0gb3JpZ2luYWwuZ2V0VGltZSgpO1xuXG4gIC8vIFRPRE8gU2hvdWxkIHdlIGRvIGJpbmFyeSBzZWFyY2ggZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlP1xuICB3aGlsZSAoaW5kZXggPCB1bnRpbHMubGVuZ3RoIC0gMSAmJiBvcmlnaW5hbFRpbWUgPj0gdW50aWxzW2luZGV4XSkge1xuICAgIGluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBzZXRXcmFwKGZuKSB7XG4gIHZhciBvZmZzZXQxID0gdGhpcy5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB2YXIgcmV0ID0gZm4oKTtcbiAgdGhpcy5vcmlnaW5hbC5zZXRUaW1lKG5ldyBEYXRlKHRoaXMuZ2V0VGltZSgpKSk7XG4gIHZhciBvZmZzZXQyID0gdGhpcy5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBpZiAob2Zmc2V0MiAtIG9mZnNldDEpIHtcbiAgICB0aGlzLm9yaWdpbmFsLnNldE1pbnV0ZXModGhpcy5vcmlnaW5hbC5nZXRNaW51dGVzKCkgKyBvZmZzZXQyIC0gb2Zmc2V0MSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxudmFyIFpvbmVkRGF0ZVRpbWUgPSBmdW5jdGlvbihkYXRlLCB0aW1lWm9uZURhdGEpIHtcbiAgZGVmaW5lUHJpdmF0ZVByb3BlcnR5KHRoaXMsIFwib3JpZ2luYWxcIiwgbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKTtcbiAgZGVmaW5lUHJpdmF0ZVByb3BlcnR5KHRoaXMsIFwibG9jYWxcIiwgbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKTtcbiAgZGVmaW5lUHJpdmF0ZVByb3BlcnR5KHRoaXMsIFwidGltZVpvbmVEYXRhXCIsIHRpbWVab25lRGF0YSk7XG4gIGRlZmluZVByaXZhdGVQcm9wZXJ0eSh0aGlzLCBcInNldFdyYXBcIiwgc2V0V3JhcCk7XG4gIGlmICghKHRpbWVab25lRGF0YS51bnRpbHMgJiYgdGltZVpvbmVEYXRhLm9mZnNldHMgJiYgdGltZVpvbmVEYXRhLmlzZHN0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElBTkEgZGF0YVwiKTtcbiAgfVxuICB0aGlzLnNldFRpbWUodGhpcy5sb2NhbC5nZXRUaW1lKCkgLSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDApO1xufTtcblxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhKTtcbn07XG5cbi8vIERhdGUgZmllbGQgZ2V0dGVycy5cbltcImdldEZ1bGxZZWFyXCIsIFwiZ2V0TW9udGhcIiwgXCJnZXREYXRlXCIsIFwiZ2V0RGF5XCIsIFwiZ2V0SG91cnNcIiwgXCJnZXRNaW51dGVzXCIsXG5cImdldFNlY29uZHNcIiwgXCJnZXRNaWxsaXNlY29uZHNcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgLy8gQ29ycmVzcG9uZGluZyBVVEMgbWV0aG9kLCBlLmcuLCBcImdldFVUQ0Z1bGxZZWFyXCIgaWYgbWV0aG9kID09PSBcImdldEZ1bGxZZWFyXCIuXG4gIHZhciB1dGNNZXRob2QgPSBcImdldFVUQ1wiICsgbWV0aG9kLnN1YnN0cigzKTtcbiAgWm9uZWREYXRlVGltZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsW3V0Y01ldGhvZF0oKTtcbiAgfTtcbn0pO1xuXG4vLyBOb3RlOiBEZWZpbmUgLnZhbHVlT2YgPSAuZ2V0VGltZSBmb3IgYXJpdGhtZXRpYyBvcGVyYXRpb25zIGxpa2UgZGF0ZTEgLSBkYXRlMi5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLnZhbHVlT2YgPVxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sb2NhbC5nZXRUaW1lKCkgKyB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG59O1xuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS5nZXRUaW1lem9uZU9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXggPSBnZXRVbnRpbHNJbmRleCh0aGlzLm9yaWdpbmFsLCB0aGlzLnRpbWVab25lRGF0YS51bnRpbHMpO1xuICByZXR1cm4gdGhpcy50aW1lWm9uZURhdGEub2Zmc2V0c1tpbmRleF07XG59O1xuXG4vLyBEYXRlIGZpZWxkIHNldHRlcnMuXG5bXCJzZXRGdWxsWWVhclwiLCBcInNldE1vbnRoXCIsIFwic2V0RGF0ZVwiLCBcInNldEhvdXJzXCIsIFwic2V0TWludXRlc1wiLCBcInNldFNlY29uZHNcIiwgXCJzZXRNaWxsaXNlY29uZHNcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgLy8gQ29ycmVzcG9uZGluZyBVVEMgbWV0aG9kLCBlLmcuLCBcInNldFVUQ0Z1bGxZZWFyXCIgaWYgbWV0aG9kID09PSBcInNldEZ1bGxZZWFyXCIuXG4gIHZhciB1dGNNZXRob2QgPSBcInNldFVUQ1wiICsgbWV0aG9kLnN1YnN0cigzKTtcbiAgWm9uZWREYXRlVGltZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAvLyBOb3RlIHNldFdyYXAgaXMgbmVlZGVkIGZvciBzZWNvbmRzIGFuZCBtaWxsaXNlY29uZHMganVzdCBiZWNhdXNlXG4gICAgLy8gYWJzKHZhbHVlKSBjb3VsZCBiZSA+PSBhIG1pbnV0ZS5cbiAgICByZXR1cm4gdGhpcy5zZXRXcmFwKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2FsW3V0Y01ldGhvZF0odmFsdWUpO1xuICAgIH0pO1xuICB9O1xufSk7XG5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLnNldFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gIHJldHVybiB0aGlzLmxvY2FsLnNldFRpbWUodGltZSk7XG59O1xuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS5pc0RTVCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXggPSBnZXRVbnRpbHNJbmRleCh0aGlzLm9yaWdpbmFsLCB0aGlzLnRpbWVab25lRGF0YS51bnRpbHMpO1xuICByZXR1cm4gQm9vbGVhbih0aGlzLnRpbWVab25lRGF0YS5pc2RzdHNbaW5kZXhdKTtcbn07XG5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZGV4ID0gZ2V0VW50aWxzSW5kZXgodGhpcy5vcmlnaW5hbCwgdGhpcy50aW1lWm9uZURhdGEudW50aWxzKTtcbiAgdmFyIGFiYnJzID0gdGhpcy50aW1lWm9uZURhdGEuYWJicnM7XG4gIHJldHVybiB0aGlzLmxvY2FsLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWiQvLCBcIlwiKSArIFwiIFwiICtcbiAgICAoYWJicnMgJiYgYWJicnNbaW5kZXhdICsgXCIgXCIgfHwgKHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xKSArIFwiIFwiKSArXG4gICAgKHRoaXMuaXNEU1QoKSA/IFwiKGRheWxpZ2h0IHNhdmluZ3MpXCIgOiBcIlwiKTtcbn07XG5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLnRvRGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERhdGUodGhpcy5nZXRUaW1lKCkpO1xufTtcblxuLy8gVHlwZSBjYXN0IGdldHRlcnMuXG5bXCJ0b0lTT1N0cmluZ1wiLCBcInRvSlNPTlwiLCBcInRvVVRDU3RyaW5nXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGUoKVttZXRob2RdKCk7XG4gIH07XG59KTtcblxucmV0dXJuIFpvbmVkRGF0ZVRpbWU7XG59KCkpO1xuXG5cbi8qKlxuICogaXNMZWFwWWVhciggeWVhciApXG4gKlxuICogQHllYXIgW051bWJlcl1cbiAqXG4gKiBSZXR1cm5zIGFuIGluZGljYXRpb24gd2hldGhlciB0aGUgc3BlY2lmaWVkIHllYXIgaXMgYSBsZWFwIHllYXIuXG4gKi9cbnZhciBkYXRlSXNMZWFwWWVhciA9IGZ1bmN0aW9uKCB5ZWFyICkge1xuXHRyZXR1cm4gbmV3IERhdGUoIHllYXIsIDEsIDI5ICkuZ2V0TW9udGgoKSA9PT0gMTtcbn07XG5cblxuXG5cbi8qKlxuICogbGFzdERheU9mTW9udGgoIGRhdGUgKVxuICpcbiAqIEBkYXRlIFtEYXRlXVxuICpcbiAqIFJldHVybiB0aGUgbGFzdCBkYXkgb2YgdGhlIGdpdmVuIGRhdGUncyBtb250aFxuICovXG52YXIgZGF0ZUxhc3REYXlPZk1vbnRoID0gZnVuY3Rpb24oIGRhdGUgKSB7XG5cdHJldHVybiBuZXcgRGF0ZSggZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAwICkuZ2V0RGF0ZSgpO1xufTtcblxuXG5cblxuLyoqXG4gKiBzdGFydE9mIGNoYW5nZXMgdGhlIGlucHV0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdpdmVuIHVuaXQuXG4gKlxuICogRm9yIGV4YW1wbGUsIHN0YXJ0aW5nIGF0IHRoZSBzdGFydCBvZiBhIGRheSwgcmVzZXRzIGhvdXJzLCBtaW51dGVzXG4gKiBzZWNvbmRzIGFuZCBtaWxsaXNlY29uZHMgdG8gMC4gU3RhcnRpbmcgYXQgdGhlIG1vbnRoIGRvZXMgdGhlIHNhbWUsIGJ1dFxuICogYWxzbyBzZXRzIHRoZSBkYXRlIHRvIDEuXG4gKlxuICogUmV0dXJucyB0aGUgbW9kaWZpZWQgZGF0ZVxuICovXG52YXIgZGF0ZVN0YXJ0T2YgPSBmdW5jdGlvbiggZGF0ZSwgdW5pdCApIHtcblx0ZGF0ZSA9IGRhdGUgaW5zdGFuY2VvZiBab25lZERhdGVUaW1lID8gZGF0ZS5jbG9uZSgpIDogbmV3IERhdGUoIGRhdGUuZ2V0VGltZSgpICk7XG5cdHN3aXRjaCAoIHVuaXQgKSB7XG5cdFx0Y2FzZSBcInllYXJcIjpcblx0XHRcdGRhdGUuc2V0TW9udGgoIDAgKTtcblx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSBcIm1vbnRoXCI6XG5cdFx0XHRkYXRlLnNldERhdGUoIDEgKTtcblx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSBcImRheVwiOlxuXHRcdFx0ZGF0ZS5zZXRIb3VycyggMCApO1xuXHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlIFwiaG91clwiOlxuXHRcdFx0ZGF0ZS5zZXRNaW51dGVzKCAwICk7XG5cdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgXCJtaW51dGVcIjpcblx0XHRcdGRhdGUuc2V0U2Vjb25kcyggMCApO1xuXHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlIFwic2Vjb25kXCI6XG5cdFx0XHRkYXRlLnNldE1pbGxpc2Vjb25kcyggMCApO1xuXHR9XG5cdHJldHVybiBkYXRlO1xufTtcblxuXG5cblxuLyoqXG4gKiBEaWZmZXJlbnRseSBmcm9tIG5hdGl2ZSBkYXRlLnNldERhdGUoKSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZGF0ZSB3aG9zZVxuICogZGF5IHJlbWFpbnMgaW5zaWRlIHRoZSBtb250aCBib3VuZGFyaWVzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBzZXREYXRlKCBGZWJEYXRlLCAzMSApOiBhIFwiRmViIDI4XCIgZGF0ZS5cbiAqIHNldERhdGUoIFNlcERhdGUsIDMxICk6IGEgXCJTZXAgMzBcIiBkYXRlLlxuICovXG52YXIgZGF0ZVNldERhdGUgPSBmdW5jdGlvbiggZGF0ZSwgZGF5ICkge1xuXHR2YXIgbGFzdERheSA9IG5ldyBEYXRlKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDAgKS5nZXREYXRlKCk7XG5cblx0ZGF0ZS5zZXREYXRlKCBkYXkgPCAxID8gMSA6IGRheSA8IGxhc3REYXkgPyBkYXkgOiBsYXN0RGF5ICk7XG59O1xuXG5cblxuXG4vKipcbiAqIERpZmZlcmVudGx5IGZyb20gbmF0aXZlIGRhdGUuc2V0TW9udGgoKSwgdGhpcyBmdW5jdGlvbiBhZGp1c3RzIGRhdGUgaWZcbiAqIG5lZWRlZCwgc28gZmluYWwgbW9udGggaXMgYWx3YXlzIHRoZSBvbmUgc2V0LlxuICpcbiAqIHNldE1vbnRoKCBKYW4zMURhdGUsIDEgKTogYSBcIkZlYiAyOFwiIGRhdGUuXG4gKiBzZXREYXRlKCBKYW4zMURhdGUsIDggKTogYSBcIlNlcCAzMFwiIGRhdGUuXG4gKi9cbnZhciBkYXRlU2V0TW9udGggPSBmdW5jdGlvbiggZGF0ZSwgbW9udGggKSB7XG5cdHZhciBvcmlnaW5hbERhdGUgPSBkYXRlLmdldERhdGUoKTtcblxuXHRkYXRlLnNldERhdGUoIDEgKTtcblx0ZGF0ZS5zZXRNb250aCggbW9udGggKTtcblx0ZGF0ZVNldERhdGUoIGRhdGUsIG9yaWdpbmFsRGF0ZSApO1xufTtcblxuXG5cblxudmFyIG91dE9mUmFuZ2UgPSBmdW5jdGlvbiggdmFsdWUsIGxvdywgaGlnaCApIHtcblx0cmV0dXJuIHZhbHVlIDwgbG93IHx8IHZhbHVlID4gaGlnaDtcbn07XG5cblxuXG5cbi8qKlxuICogcGFyc2UoIHZhbHVlLCB0b2tlbnMsIHByb3BlcnRpZXMgKVxuICpcbiAqIEB2YWx1ZSBbU3RyaW5nXSBzdHJpbmcgZGF0ZS5cbiAqXG4gKiBAdG9rZW5zIFtPYmplY3RdIHRva2VucyByZXR1cm5lZCBieSBkYXRlL3Rva2VuaXplci5cbiAqXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBvdXRwdXQgcmV0dXJuZWQgYnkgZGF0ZS90b2tlbml6ZXItcHJvcGVydGllcy5cbiAqXG4gKiByZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuICovXG52YXIgZGF0ZVBhcnNlID0gZnVuY3Rpb24oIHZhbHVlLCB0b2tlbnMsIHByb3BlcnRpZXMgKSB7XG5cdHZhciBhbVBtLCBkYXksIGRheXNPZlllYXIsIG1vbnRoLCBlcmEsIGhvdXIsIGhvdXIxMiwgdGltZXpvbmVPZmZzZXQsIHZhbGlkLFxuXHRcdFlFQVIgPSAwLFxuXHRcdE1PTlRIID0gMSxcblx0XHREQVkgPSAyLFxuXHRcdEhPVVIgPSAzLFxuXHRcdE1JTlVURSA9IDQsXG5cdFx0U0VDT05EID0gNSxcblx0XHRNSUxMSVNFQ09ORFMgPSA2LFxuXHRcdGRhdGUgPSBuZXcgRGF0ZSgpLFxuXHRcdHRydW5jYXRlQXQgPSBbXSxcblx0XHR1bml0cyA9IFsgXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRzXCIgXTtcblxuXHQvLyBDcmVhdGUgZ2xvYmFsaXplIGRhdGUgd2l0aCBnaXZlbiB0aW1lem9uZSBkYXRhLlxuXHRpZiAoIHByb3BlcnRpZXMudGltZVpvbmVEYXRhICkge1xuXHRcdGRhdGUgPSBuZXcgWm9uZWREYXRlVGltZSggZGF0ZSwgcHJvcGVydGllcy50aW1lWm9uZURhdGEoKSApO1xuXHR9XG5cblx0aWYgKCAhdG9rZW5zLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhbGlkID0gdG9rZW5zLmV2ZXJ5KGZ1bmN0aW9uKCB0b2tlbiApIHtcblx0XHR2YXIgY2VudHVyeSwgY2hyLCB2YWx1ZSwgbGVuZ3RoO1xuXG5cdFx0aWYgKCB0b2tlbi50eXBlID09PSBcImxpdGVyYWxcIiApIHtcblxuXHRcdFx0Ly8gY29udGludWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGNociA9IHRva2VuLnR5cGUuY2hhckF0KCAwICk7XG5cdFx0bGVuZ3RoID0gdG9rZW4udHlwZS5sZW5ndGg7XG5cblx0XHRpZiAoIGNociA9PT0gXCJqXCIgKSB7XG5cblx0XHRcdC8vIExvY2FsZSBwcmVmZXJyZWQgaEhLay5cblx0XHRcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNUaW1lX0RhdGFcblx0XHRcdGNociA9IHByb3BlcnRpZXMucHJlZmVycmVkVGltZURhdGE7XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggY2hyICkge1xuXG5cdFx0XHQvLyBFcmFcblx0XHRcdGNhc2UgXCJHXCI6XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggWUVBUiApO1xuXHRcdFx0XHRlcmEgPSArdG9rZW4udmFsdWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBZZWFyXG5cdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcblx0XHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAwLCA5OSApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG1pbWljIGRvam8vZGF0ZS9sb2NhbGU6IGNob29zZSBjZW50dXJ5IHRvIGFwcGx5LCBhY2NvcmRpbmcgdG8gYSBzbGlkaW5nXG5cdFx0XHRcdFx0Ly8gd2luZG93IG9mIDgwIHllYXJzIGJlZm9yZSBhbmQgMjAgeWVhcnMgYWZ0ZXIgcHJlc2VudCB5ZWFyLlxuXHRcdFx0XHRcdGNlbnR1cnkgPSBNYXRoLmZsb29yKCBkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDAgKSAqIDEwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBjZW50dXJ5O1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPiBkYXRlLmdldEZ1bGxZZWFyKCkgKyAyMCApIHtcblx0XHRcdFx0XHRcdHZhbHVlIC09IDEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0ZS5zZXRGdWxsWWVhciggdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBZRUFSICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiWVwiOiAvLyBZZWFyIGluIFwiV2VlayBvZiBZZWFyXCJcblx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdGZlYXR1cmU6IFwieWVhciBwYXR0ZXJuIGBcIiArIGNociArIFwiYFwiXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBRdWFydGVyIChza2lwKVxuXHRcdFx0Y2FzZSBcIlFcIjpcblx0XHRcdGNhc2UgXCJxXCI6XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNb250aFxuXHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdGNhc2UgXCJMXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoIDw9IDIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9ICt0b2tlbi52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAxLCAxMiApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldHRpbmcgdGhlIG1vbnRoIGxhdGVyIHNvIHRoYXQgd2UgaGF2ZSB0aGUgY29ycmVjdCB5ZWFyIGFuZCBjYW4gZGV0ZXJtaW5lXG5cdFx0XHRcdC8vIHRoZSBjb3JyZWN0IGxhc3QgZGF5IG9mIEZlYnJ1YXJ5IGluIGNhc2Ugb2YgbGVhcCB5ZWFyLlxuXHRcdFx0XHRtb250aCA9IHZhbHVlO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIE1PTlRIICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrIChza2lwKVxuXHRcdFx0Y2FzZSBcIndcIjogLy8gV2VlayBvZiBZZWFyLlxuXHRcdFx0Y2FzZSBcIldcIjogLy8gV2VlayBvZiBNb250aC5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIERheVxuXHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0ZGF5ID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggREFZICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRkYXlzT2ZZZWFyID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggREFZICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiRlwiOlxuXG5cdFx0XHRcdC8vIERheSBvZiBXZWVrIGluIG1vbnRoLiBlZy4gMm5kIFdlZCBpbiBKdWx5LlxuXHRcdFx0XHQvLyBTa2lwXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrIGRheVxuXHRcdFx0Y2FzZSBcImVcIjpcblx0XHRcdGNhc2UgXCJjXCI6XG5cdFx0XHRjYXNlIFwiRVwiOlxuXG5cdFx0XHRcdC8vIFNraXAuXG5cdFx0XHRcdC8vIHZhbHVlID0gYXJyYXlJbmRleE9mKCBkYXRlV2Vla0RheXMsIHRva2VuLnZhbHVlICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBQZXJpb2QgKEFNIG9yIFBNKVxuXHRcdFx0Y2FzZSBcImFcIjpcblx0XHRcdFx0YW1QbSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gSG91clxuXHRcdFx0Y2FzZSBcImhcIjogLy8gMS0xMlxuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAxLCAxMiApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob3VyID0gaG91cjEyID0gdHJ1ZTtcblx0XHRcdFx0ZGF0ZS5zZXRIb3VycyggdmFsdWUgPT09IDEyID8gMCA6IHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggSE9VUiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIktcIjogLy8gMC0xMVxuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAwLCAxMSApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob3VyID0gaG91cjEyID0gdHJ1ZTtcblx0XHRcdFx0ZGF0ZS5zZXRIb3VycyggdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBIT1VSICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwia1wiOiAvLyAxLTI0XG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDEsIDI0ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvdXIgPSB0cnVlO1xuXHRcdFx0XHRkYXRlLnNldEhvdXJzKCB2YWx1ZSA9PT0gMjQgPyAwIDogdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBIT1VSICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiSFwiOiAvLyAwLTIzXG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDIzICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvdXIgPSB0cnVlO1xuXHRcdFx0XHRkYXRlLnNldEhvdXJzKCB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIEhPVVIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1pbnV0ZVxuXHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgNTkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0ZS5zZXRNaW51dGVzKCB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIE1JTlVURSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gU2Vjb25kXG5cdFx0XHRjYXNlIFwic1wiOlxuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAwLCA1OSApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRlLnNldFNlY29uZHMoIHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggU0VDT05EICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiQVwiOlxuXHRcdFx0XHRkYXRlLnNldEhvdXJzKCAwICk7XG5cdFx0XHRcdGRhdGUuc2V0TWludXRlcyggMCApO1xuXHRcdFx0XHRkYXRlLnNldFNlY29uZHMoIDAgKTtcblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIlNcIjpcblx0XHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKCB0b2tlbi52YWx1ZSAqIE1hdGgucG93KCAxMCwgMyAtIGxlbmd0aCApICk7XG5cdFx0XHRcdGRhdGUuc2V0TWlsbGlzZWNvbmRzKCB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIE1JTExJU0VDT05EUyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWm9uZVxuXHRcdFx0Y2FzZSBcInpcIjpcblx0XHRcdGNhc2UgXCJaXCI6XG5cdFx0XHRjYXNlIFwiT1wiOlxuXHRcdFx0Y2FzZSBcInZcIjpcblx0XHRcdGNhc2UgXCJWXCI6XG5cdFx0XHRjYXNlIFwiWFwiOlxuXHRcdFx0Y2FzZSBcInhcIjpcblx0XHRcdFx0aWYgKCB0eXBlb2YgdG9rZW4udmFsdWUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0dGltZXpvbmVPZmZzZXQgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSk7XG5cblx0aWYgKCAhdmFsaWQgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyAxMi1ob3VyIGZvcm1hdCBuZWVkcyBBTSBvciBQTSwgMjQtaG91ciBmb3JtYXQgZG9lc24ndCwgaWUuIHJldHVybiBudWxsXG5cdC8vIGlmIGFtUG0gJiYgIWhvdXIxMiB8fCAhYW1QbSAmJiBob3VyMTIuXG5cdGlmICggaG91ciAmJiAhKCAhYW1QbSBeIGhvdXIxMiApICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKCBlcmEgPT09IDAgKSB7XG5cblx0XHQvLyAxIEJDID0geWVhciAwXG5cdFx0ZGF0ZS5zZXRGdWxsWWVhciggZGF0ZS5nZXRGdWxsWWVhcigpICogLTEgKyAxICk7XG5cdH1cblxuXHRpZiAoIG1vbnRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0ZGF0ZVNldE1vbnRoKCBkYXRlLCBtb250aCAtIDEgKTtcblx0fVxuXG5cdGlmICggZGF5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0aWYgKCBvdXRPZlJhbmdlKCBkYXksIDEsIGRhdGVMYXN0RGF5T2ZNb250aCggZGF0ZSApICkgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0ZGF0ZS5zZXREYXRlKCBkYXkgKTtcblx0fSBlbHNlIGlmICggZGF5c09mWWVhciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGlmICggb3V0T2ZSYW5nZSggZGF5c09mWWVhciwgMSwgZGF0ZUlzTGVhcFllYXIoIGRhdGUuZ2V0RnVsbFllYXIoKSApID8gMzY2IDogMzY1ICkgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0ZGF0ZS5zZXRNb250aCggMCApO1xuXHRcdGRhdGUuc2V0RGF0ZSggZGF5c09mWWVhciApO1xuXHR9XG5cblx0aWYgKCBob3VyMTIgJiYgYW1QbSA9PT0gXCJwbVwiICkge1xuXHRcdGRhdGUuc2V0SG91cnMoIGRhdGUuZ2V0SG91cnMoKSArIDEyICk7XG5cdH1cblxuXHRpZiAoIHRpbWV6b25lT2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0ZGF0ZS5zZXRNaW51dGVzKCBkYXRlLmdldE1pbnV0ZXMoKSArIHRpbWV6b25lT2Zmc2V0IC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICk7XG5cdH1cblxuXHQvLyBUcnVuY2F0ZSBkYXRlIGF0IHRoZSBtb3N0IHByZWNpc2UgdW5pdCBkZWZpbmVkLiBFZy5cblx0Ly8gSWYgdmFsdWUgaXMgXCIxMi8zMVwiLCBhbmQgcGF0dGVybiBpcyBcIk1NL2RkXCI6XG5cdC8vID0+IG5ldyBEYXRlKCA8Y3VycmVudCBZZWFyPiwgMTIsIDMxLCAwLCAwLCAwLCAwICk7XG5cdHRydW5jYXRlQXQgPSBNYXRoLm1heC5hcHBseSggbnVsbCwgdHJ1bmNhdGVBdCApO1xuXHRkYXRlID0gZGF0ZVN0YXJ0T2YoIGRhdGUsIHVuaXRzWyB0cnVuY2F0ZUF0IF0gKTtcblxuXHQvLyBHZXQgZGF0ZSBiYWNrIGZyb20gZ2xvYmFsaXplIGRhdGUuXG5cdGlmICggZGF0ZSBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUgKSB7XG5cdFx0ZGF0ZSA9IGRhdGUudG9EYXRlKCk7XG5cdH1cblxuXHRyZXR1cm4gZGF0ZTtcbn07XG5cblxuXG5cbi8qKlxuICogdG9rZW5pemVyKCB2YWx1ZSwgbnVtYmVyUGFyc2VyLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBAdmFsdWUgW1N0cmluZ10gc3RyaW5nIGRhdGUuXG4gKlxuICogQG51bWJlclBhcnNlciBbRnVuY3Rpb25dXG4gKlxuICogQHByb3BlcnRpZXMgW09iamVjdF0gb3V0cHV0IHJldHVybmVkIGJ5IGRhdGUvdG9rZW5pemVyLXByb3BlcnRpZXMuXG4gKlxuICogUmV0dXJucyBhbiBBcnJheSBvZiB0b2tlbnMsIGVnLiB2YWx1ZSBcIjUgbydjbG9jayBQTVwiLCBwYXR0ZXJuIFwiaCAnbycnY2xvY2snIGFcIjpcbiAqIFt7XG4gKiAgIHR5cGU6IFwiaFwiLFxuICogICBsZXhlbWU6IFwiNVwiXG4gKiB9LCB7XG4gKiAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICogICBsZXhlbWU6IFwiIFwiXG4gKiB9LCB7XG4gKiAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICogICBsZXhlbWU6IFwibydjbG9ja1wiXG4gKiB9LCB7XG4gKiAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICogICBsZXhlbWU6IFwiIFwiXG4gKiB9LCB7XG4gKiAgIHR5cGU6IFwiYVwiLFxuICogICBsZXhlbWU6IFwiUE1cIixcbiAqICAgdmFsdWU6IFwicG1cIlxuICogfV1cbiAqXG4gKiBPQlM6IGxleGVtZSdzIGFyZSBhbHdheXMgU3RyaW5nIGFuZCBtYXkgcmV0dXJuIGludmFsaWQgcmFuZ2VzIGRlcGVuZGluZyBvZiB0aGUgdG9rZW4gdHlwZS5cbiAqIEVnLiBcIjk5XCIgZm9yIG1vbnRoIG51bWJlci5cbiAqXG4gKiBSZXR1cm4gYW4gZW1wdHkgQXJyYXkgd2hlbiBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlZC5cbiAqL1xudmFyIGRhdGVUb2tlbml6ZXIgPSBmdW5jdGlvbiggdmFsdWUsIG51bWJlclBhcnNlciwgcHJvcGVydGllcyApIHtcblx0dmFyIGRpZ2l0c1JlLCB2YWxpZCxcblx0XHR0b2tlbnMgPSBbXSxcblx0XHR3aWR0aHMgPSBbIFwiYWJicmV2aWF0ZWRcIiwgXCJ3aWRlXCIsIFwibmFycm93XCIgXTtcblxuXHRkaWdpdHNSZSA9IHByb3BlcnRpZXMuZGlnaXRzUmU7XG5cdHZhbHVlID0gbG9vc2VNYXRjaGluZyggdmFsdWUgKTtcblxuXHR2YWxpZCA9IHByb3BlcnRpZXMucGF0dGVybi5tYXRjaCggZGF0ZVBhdHRlcm5SZSApLmV2ZXJ5KGZ1bmN0aW9uKCBjdXJyZW50ICkge1xuXHRcdHZhciBhdXgsIGNociwgbGVuZ3RoLCBudW1lcmljLCB0b2tlblJlLFxuXHRcdFx0dG9rZW4gPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGhvdXJGb3JtYXRQYXJzZSggdG9rZW5SZSwgbnVtYmVyUGFyc2VyICkge1xuXHRcdFx0dmFyIGF1eCwgaXNQb3NpdGl2ZSxcblx0XHRcdFx0bWF0Y2ggPSB2YWx1ZS5tYXRjaCggdG9rZW5SZSApO1xuXHRcdFx0bnVtYmVyUGFyc2VyID0gbnVtYmVyUGFyc2VyIHx8IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuICt2YWx1ZTtcblx0XHRcdH07XG5cblx0XHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlzUG9zaXRpdmUgPSBtYXRjaFsgMSBdO1xuXG5cdFx0XHQvLyBob3VyRm9ybWF0IGNvbnRhaW5pbmcgSCBvbmx5LCBlLmcuLCBgK0g7LUhgXG5cdFx0XHRpZiAoIG1hdGNoLmxlbmd0aCA8IDYgKSB7XG5cdFx0XHRcdGF1eCA9IGlzUG9zaXRpdmUgPyAxIDogMztcblx0XHRcdFx0dG9rZW4udmFsdWUgPSBudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXggXSApICogNjA7XG5cblx0XHRcdC8vIGhvdXJGb3JtYXQgY29udGFpbmluZyBIIGFuZCBtLCBlLmcuLCBgK0hIbW07LUhIbW1gXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaC5sZW5ndGggPCAxMCApIHtcblx0XHRcdFx0YXV4ID0gaXNQb3NpdGl2ZSA/IFsgMSwgMyBdIDogWyA1LCA3IF07XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gbnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4WyAwIF0gXSApICogNjAgK1xuXHRcdFx0XHRcdG51bWJlclBhcnNlciggbWF0Y2hbIGF1eFsgMSBdIF0gKTtcblxuXHRcdFx0Ly8gaG91ckZvcm1hdCBjb250YWluaW5nIEgsIG0sIGFuZCBzIGUuZy4sIGArSEhtbXNzOy1ISG1tc3NgXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdXggPSBpc1Bvc2l0aXZlID8gWyAxLCAzLCA1IF0gOiBbIDcsIDksIDExIF07XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gbnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4WyAwIF0gXSApICogNjAgK1xuXHRcdFx0XHRcdG51bWJlclBhcnNlciggbWF0Y2hbIGF1eFsgMSBdIF0gKSArXG5cdFx0XHRcdFx0bnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4WyAyIF0gXSApIC8gNjA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNQb3NpdGl2ZSApIHtcblx0XHRcdFx0dG9rZW4udmFsdWUgKj0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uZURpZ2l0SWZMZW5ndGhPbmUoKSB7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZC9cblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0b2tlblJlID0gZGlnaXRzUmU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZSgpIHtcblx0XHRcdGlmICggbGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxkXFxkPy9cblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpezEsMn1cIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmVPclR3bygpIHtcblx0XHRcdGlmICggbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiApIHtcblxuXHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZFxcZD8vXG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXsxLDJ9XCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0d29EaWdpdHNJZkxlbmd0aFR3bygpIHtcblx0XHRcdGlmICggbGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxkXFxkL1xuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7Mn1cIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEJydXRlLWZvcmNlIHRlc3QgZXZlcnkgbG9jYWxlIGVudHJ5IGluIGFuIGF0dGVtcHQgdG8gbWF0Y2ggdGhlIGdpdmVuIHZhbHVlLlxuXHRcdC8vIFJldHVybiB0aGUgZmlyc3QgZm91bmQgb25lIChhbmQgc2V0IHRva2VuIGFjY29yZGluZ2x5KSwgb3IgbnVsbC5cblx0XHRmdW5jdGlvbiBsb29rdXAoIHBhdGggKSB7XG5cdFx0XHR2YXIgYXJyYXkgPSBwcm9wZXJ0aWVzWyBwYXRoLmpvaW4oIFwiL1wiICkgXTtcblxuXHRcdFx0aWYgKCAhYXJyYXkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcnJheSBvZiBwYWlycyBba2V5LCB2YWx1ZV0gc29ydGVkIGJ5IGRlc2MgdmFsdWUgbGVuZ3RoLlxuXHRcdFx0YXJyYXkuc29tZShmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlUmUgPSBpdGVtWyAxIF07XG5cdFx0XHRcdGlmICggdmFsdWVSZS50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gaXRlbVsgMCBdO1xuXHRcdFx0XHRcdHRva2VuUmUgPSBpdGVtWyAxIF07XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dG9rZW4udHlwZSA9IGN1cnJlbnQ7XG5cdFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKTtcblx0XHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcblxuXHRcdGlmICggY2hyID09PSBcIlpcIiApIHtcblxuXHRcdFx0Ly8gWi4uWlpaOiBzYW1lIGFzIFwieHh4eFwiLlxuXHRcdFx0aWYgKCBsZW5ndGggPCA0ICkge1xuXHRcdFx0XHRjaHIgPSBcInhcIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblxuXHRcdFx0Ly8gWlpaWjogc2FtZSBhcyBcIk9PT09cIi5cblx0XHRcdH0gZWxzZSBpZiAoIGxlbmd0aCA8IDUgKSB7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXG5cdFx0XHQvLyBaWlpaWjogc2FtZSBhcyBcIlhYWFhYXCJcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNociA9IFwiWFwiO1xuXHRcdFx0XHRsZW5ndGggPSA1O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggY2hyID09PSBcInpcIiApIHtcblx0XHRcdGlmICggcHJvcGVydGllcy5zdGFuZGFyZE9yRGF5bGlnaHRUek5hbWUgKSB7XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gbnVsbDtcblx0XHRcdFx0dG9rZW5SZSA9IHByb3BlcnRpZXMuc3RhbmRhcmRPckRheWxpZ2h0VHpOYW1lO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHYuLi52dnY6IFwie3Nob3J0UmVnaW9ufVwiLCBlZy4gXCJQVFwiLlxuXHRcdC8vIHZ2dnY6IFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiIG9yIFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiLFxuXHRcdC8vIGUuZy4sIFwiUGFjaWZpYyBUaW1lXCJcblx0XHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuXHRcdGlmICggY2hyID09PSBcInZcIiApIHtcblx0XHRcdGlmICggcHJvcGVydGllcy5nZW5lcmljVHpOYW1lICkge1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IG51bGw7XG5cdFx0XHRcdHRva2VuUmUgPSBwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWU7XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBcIlZcIiBmb3JtYXQuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHIgPSBcIlZcIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGNociA9PT0gXCJWXCIgJiYgcHJvcGVydGllcy50aW1lWm9uZU5hbWUgKSB7XG5cdFx0XHR0b2tlbi52YWx1ZSA9IGxlbmd0aCA9PT0gMiA/IHByb3BlcnRpZXMudGltZVpvbmVOYW1lIDogbnVsbDtcblx0XHRcdHRva2VuUmUgPSBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZVJlO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGNociApIHtcblxuXHRcdFx0Ly8gRXJhXG5cdFx0XHRjYXNlIFwiR1wiOlxuXHRcdFx0XHRsb29rdXAoW1xuXHRcdFx0XHRcdFwiZ3JlZ29yaWFuL2VyYXNcIixcblx0XHRcdFx0XHRsZW5ndGggPD0gMyA/IFwiZXJhQWJiclwiIDogKCBsZW5ndGggPT09IDQgPyBcImVyYU5hbWVzXCIgOiBcImVyYU5hcnJvd1wiIClcblx0XHRcdFx0XSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBZZWFyXG5cdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0Y2FzZSBcIllcIjpcblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGw9MTorLCBsPTI6ezJ9LCBsPTM6ezMsfSwgbD00Ons0LH0sIC4uLlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxkKy8uXG5cdFx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKStcIiApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBsZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdFx0XHQvLyBMZW5pZW50IHBhcnNpbmc6IHRoZXJlJ3Mgbm8geWVhciBwYXR0ZXJuIHRvIGluZGljYXRlIG5vbi16ZXJvLXBhZGRlZCAyLWRpZ2l0c1xuXHRcdFx0XHRcdC8vIHllYXIsIHNvIHBhcnNlciBhY2NlcHRzIGJvdGggemVyby1wYWRkZWQgYW5kIG5vbi16ZXJvLXBhZGRlZCBmb3IgYHl5YC5cblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxkXFxkPy9cblx0XHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpezEsMn1cIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGR7bGVuZ3RoLH0vXG5cdFx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXtcIiArIGxlbmd0aCArIFwiLH1cIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBRdWFydGVyXG5cdFx0XHRjYXNlIFwiUVwiOlxuXHRcdFx0Y2FzZSBcInFcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbD0xOnsxfSwgbD0yOnsyfS5cblx0XHRcdFx0Ly8gbG9va3VwIGw9My4uLlxuXHRcdFx0XHRvbmVEaWdpdElmTGVuZ3RoT25lKCkgfHwgdHdvRGlnaXRzSWZMZW5ndGhUd28oKSB8fFxuXHRcdFx0XHRcdGxvb2t1cChbXG5cdFx0XHRcdFx0XHRcImdyZWdvcmlhbi9xdWFydGVyc1wiLFxuXHRcdFx0XHRcdFx0Y2hyID09PSBcIlFcIiA/IFwiZm9ybWF0XCIgOiBcInN0YW5kLWFsb25lXCIsXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRjYXNlIFwiTFwiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsPTE6ezEsMn0sIGw9Mjp7Mn0uXG5cdFx0XHRcdC8vIGxvb2t1cCBsPTMuLi5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gTGVuaWVudCBwYXJzaW5nOiBza2VsZXRvbiBcInlNZFwiIChpLmUuLCBvbmUgTSkgbWF5IGluY2x1ZGUgTU0gZm9yIHRoZSBwYXR0ZXJuLFxuXHRcdFx0XHQvLyB0aGVyZWZvcmUgcGFyc2VyIGFjY2VwdHMgYm90aCB6ZXJvLXBhZGRlZCBhbmQgbm9uLXplcm8tcGFkZGVkIGZvciBNIGFuZCBNTS5cblx0XHRcdFx0Ly8gU2ltaWxhciBmb3IgTC5cblx0XHRcdFx0b25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZU9yVHdvKCkgfHwgbG9va3VwKFtcblx0XHRcdFx0XHRcImdyZWdvcmlhbi9tb250aHNcIixcblx0XHRcdFx0XHRjaHIgPT09IFwiTVwiID8gXCJmb3JtYXRcIiA6IFwic3RhbmQtYWxvbmVcIixcblx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIERheVxuXHRcdFx0Y2FzZSBcIkRcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIge2wsM30uXG5cdFx0XHRcdGlmICggbGVuZ3RoIDw9IDMgKSB7XG5cblx0XHRcdFx0XHQvLyBFcXVpdmFsZW50IHRvIC9cXGR7bGVuZ3RoLDN9L1xuXHRcdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7XCIgKyBsZW5ndGggKyBcIiwzfVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJXXCI6XG5cdFx0XHRjYXNlIFwiRlwiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsPTE6ezF9LlxuXHRcdFx0XHRvbmVEaWdpdElmTGVuZ3RoT25lKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrIGRheVxuXHRcdFx0Y2FzZSBcImVcIjpcblx0XHRcdGNhc2UgXCJjXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGw9MTp7MX0sIGw9Mjp7Mn0uXG5cdFx0XHRcdC8vIGxvb2t1cCBmb3IgbGVuZ3RoID49My5cblx0XHRcdFx0aWYgKCBsZW5ndGggPD0gMiApIHtcblx0XHRcdFx0XHRvbmVEaWdpdElmTGVuZ3RoT25lKCkgfHwgdHdvRGlnaXRzSWZMZW5ndGhUd28oKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiRVwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdC8vIE5vdGU6IGlmIHNob3J0IGRheSBuYW1lcyBhcmUgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhYmJyZXZpYXRlZCBkYXlcblx0XHRcdFx0XHQvLyBuYW1lcyBhcmUgdXNlZCBpbnN0ZWFkIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNtb250aHNfZGF5c19xdWFydGVyc19lcmFzXG5cdFx0XHRcdFx0bG9va3VwKFtcblx0XHRcdFx0XHRcdFwiZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFsgY2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIgXSxcblx0XHRcdFx0XHRcdFwic2hvcnRcIlxuXHRcdFx0XHRcdF0pIHx8IGxvb2t1cChbXG5cdFx0XHRcdFx0XHRcImdyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRbIGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiIF0sXG5cdFx0XHRcdFx0XHRcImFiYnJldmlhdGVkXCJcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb29rdXAoW1xuXHRcdFx0XHRcdFx0XCJncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0WyBjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIiBdLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggPCAzID8gMCA6IGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBQZXJpb2QgKEFNIG9yIFBNKVxuXHRcdFx0Y2FzZSBcImFcIjpcblx0XHRcdFx0bG9va3VwKFtcblx0XHRcdFx0XHRcImdyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlXCJcblx0XHRcdFx0XSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrXG5cdFx0XHRjYXNlIFwid1wiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsMTp7MSwyfSwgbDI6ezJ9LlxuXHRcdFx0XHRvbmVPclR3b0RpZ2l0c0lmTGVuZ3RoT25lKCkgfHwgdHdvRGlnaXRzSWZMZW5ndGhUd28oKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIERheSwgSG91ciwgTWludXRlLCBvciBTZWNvbmRcblx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRjYXNlIFwiaFwiOlxuXHRcdFx0Y2FzZSBcIkhcIjpcblx0XHRcdGNhc2UgXCJLXCI6XG5cdFx0XHRjYXNlIFwia1wiOlxuXHRcdFx0Y2FzZSBcImpcIjpcblx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRjYXNlIFwic1wiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsMTp7MSwyfSwgbDI6ezJ9LlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBMZW5pZW50IHBhcnNpbmc6XG5cdFx0XHRcdC8vIC0gc2tlbGV0b24gXCJobXNcIiAoaS5lLiwgb25lIG0pIGFsd2F5cyBpbmNsdWRlcyBtbSBmb3IgdGhlIHBhdHRlcm4sIGkuZS4sIGl0J3Ncblx0XHRcdFx0Ly8gICBpbXBvc3NpYmxlIHRvIHVzZSBhIGRpZmZlcmVudCBza2VsZXRvbiB0byBwYXJzZSBub24temVyby1wYWRkZWQgbWludXRlcyxcblx0XHRcdFx0Ly8gICB0aGVyZWZvcmUgcGFyc2VyIGFjY2VwdHMgYm90aCB6ZXJvLXBhZGRlZCBhbmQgbm9uLXplcm8tcGFkZGVkIGZvciBtLiBTaW1pbGFyXG5cdFx0XHRcdC8vICAgZm9yIHNlY29uZHMgcy5cblx0XHRcdFx0Ly8gLSBza2VsZXRvbiBcImhtc1wiIChpLmUuLCBvbmUgaCkgbWF5IGluY2x1ZGUgaCBvciBoaCBmb3IgdGhlIHBhdHRlcm4sIGkuZS4sIGl0J3Ncblx0XHRcdFx0Ly8gICBpbXBvc3NpYmxlIHRvIHVzZSBhIGRpZmZlcmVudCBza2VsZXRvbiB0byBwYXJzZXIgbm9uLXplcm8tcGFkZGVkIGhvdXJzIGZvciBzb21lXG5cdFx0XHRcdC8vICAgbG9jYWxlcywgdGhlcmVmb3JlIHBhcnNlciBhY2NlcHRzIGJvdGggemVyby1wYWRkZWQgYW5kIG5vbi16ZXJvLXBhZGRlZCBmb3IgaC5cblx0XHRcdFx0Ly8gICBTaW1pbGFyIGZvciBkIChpbiBza2VsZXRvbiB5TWQpLlxuXHRcdFx0XHRvbmVPclR3b0RpZ2l0c0lmTGVuZ3RoT25lT3JUd28oKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJTXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIHtsfS5cblxuXHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZHtsZW5ndGh9L1xuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXtcIiArIGxlbmd0aCArIFwifVwiICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiQVwiOlxuXG5cdFx0XHRcdC8vIG51bWJlciB7bCs1fS5cblxuXHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZHtsZW5ndGgrNX0vXG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpe1wiICsgKCBsZW5ndGggKyA1ICkgKyBcIn1cIiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWm9uZVxuXHRcdFx0Y2FzZSBcInZcIjpcblx0XHRcdGNhc2UgXCJWXCI6XG5cdFx0XHRjYXNlIFwielwiOlxuXHRcdFx0XHRpZiAoIHRva2VuUmUgJiYgdG9rZW5SZS50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hyID09PSBcIlZcIiAmJiBsZW5ndGggPT09IDIgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIk9cIjpcblxuXHRcdFx0XHQvLyBPOiBcIntnbXRGb3JtYXR9K0g7e2dtdEZvcm1hdH0tSFwiIG9yIFwie2dtdFplcm9Gb3JtYXR9XCIsIGVnLiBcIkdNVC04XCIgb3IgXCJHTVRcIi5cblx0XHRcdFx0Ly8gT09PTzogXCJ7Z210Rm9ybWF0fXtob3VyRm9ybWF0fVwiIG9yIFwie2dtdFplcm9Gb3JtYXR9XCIsIGVnLiBcIkdNVC0wODowMFwiIG9yIFwiR01UXCIuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XCIgXSApIHtcblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IDA7XG5cdFx0XHRcdFx0dG9rZW5SZSA9IHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0UmVcIiBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGF1eCA9IHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XCIgXS5zb21lKGZ1bmN0aW9uKCBob3VyRm9ybWF0UmUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGhvdXJGb3JtYXRQYXJzZSggaG91ckZvcm1hdFJlLCBudW1iZXJQYXJzZXIgKSApIHtcblx0XHRcdFx0XHRcdFx0dG9rZW5SZSA9IGhvdXJGb3JtYXRSZTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKCAhYXV4ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiWFwiOlxuXG5cdFx0XHRcdC8vIFNhbWUgYXMgeCosIGV4Y2VwdCBpdCB1c2VzIFwiWlwiIGZvciB6ZXJvIG9mZnNldC5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJaXCIgKSB7XG5cdFx0XHRcdFx0dG9rZW4udmFsdWUgPSAwO1xuXHRcdFx0XHRcdHRva2VuUmUgPSAvXlovO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJ4XCI6XG5cblx0XHRcdFx0Ly8geDogaG91ckZvcm1hdChcIitISFttbV07LUhIW21tXVwiKVxuXHRcdFx0XHQvLyB4eDogaG91ckZvcm1hdChcIitISG1tOy1ISG1tXCIpXG5cdFx0XHRcdC8vIHh4eDogaG91ckZvcm1hdChcIitISDptbTstSEg6bW1cIilcblx0XHRcdFx0Ly8geHh4eDogaG91ckZvcm1hdChcIitISG1tW3NzXTstSEhtbVtzc11cIilcblx0XHRcdFx0Ly8geHh4eHg6IGhvdXJGb3JtYXQoXCIrSEg6bW1bOnNzXTstSEg6bW1bOnNzXVwiKVxuXHRcdFx0XHRhdXggPSBwcm9wZXJ0aWVzLnguc29tZShmdW5jdGlvbiggaG91ckZvcm1hdFJlICkge1xuXHRcdFx0XHRcdGlmICggaG91ckZvcm1hdFBhcnNlKCBob3VyRm9ybWF0UmUgKSApIHtcblx0XHRcdFx0XHRcdHRva2VuUmUgPSBob3VyRm9ybWF0UmU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoICFhdXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdHRva2VuLnR5cGUgPSBcImxpdGVyYWxcIjtcblx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCByZW1vdmVMaXRlcmFsUXVvdGVzKCBjdXJyZW50ICkgKSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dG9rZW4udHlwZSA9IFwibGl0ZXJhbFwiO1xuXHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIGN1cnJlbnQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggIXRva2VuUmUgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGxleGVtZSBhbmQgY29uc3VtZSBpdC5cblx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHRva2VuUmUsIGZ1bmN0aW9uKCBsZXhlbWUgKSB7XG5cdFx0XHR0b2tlbi5sZXhlbWUgPSBsZXhlbWU7XG5cdFx0XHRpZiAoIG51bWVyaWMgKSB7XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gbnVtYmVyUGFyc2VyKCBsZXhlbWUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCAhdG9rZW4ubGV4ZW1lICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggbnVtZXJpYyAmJiBpc05hTiggdG9rZW4udmFsdWUgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSk7XG5cblx0aWYgKCB2YWx1ZSAhPT0gXCJcIiApIHtcblx0XHR2YWxpZCA9IGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHZhbGlkID8gdG9rZW5zIDogW107XG59O1xuXG5cblxuXG52YXIgZGF0ZVBhcnNlckZuID0gZnVuY3Rpb24oIG51bWJlclBhcnNlciwgcGFyc2VQcm9wZXJ0aWVzLCB0b2tlbml6ZXJQcm9wZXJ0aWVzICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gZGF0ZVBhcnNlciggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucztcblxuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHRva2VucyA9IGRhdGVUb2tlbml6ZXIoIHZhbHVlLCBudW1iZXJQYXJzZXIsIHRva2VuaXplclByb3BlcnRpZXMgKTtcblx0XHRyZXR1cm4gZGF0ZVBhcnNlKCB2YWx1ZSwgdG9rZW5zLCBwYXJzZVByb3BlcnRpZXMgKSB8fCBudWxsO1xuXHR9O1xufTtcblxuXG5cblxudmFyIG9iamVjdEZpbHRlciA9IGZ1bmN0aW9uKCBvYmplY3QsIHRlc3RSZSApIHtcblx0dmFyIGtleSxcblx0XHRjb3B5ID0ge307XG5cblx0Zm9yICgga2V5IGluIG9iamVjdCApIHtcblx0XHRpZiAoIHRlc3RSZS50ZXN0KCBrZXkgKSApIHtcblx0XHRcdGNvcHlbIGtleSBdID0gb2JqZWN0WyBrZXkgXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29weTtcbn07XG5cblxuXG5cbi8qKlxuICogdG9rZW5pemVyUHJvcGVydGllcyggcGF0dGVybiwgY2xkciApXG4gKlxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4uXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiBPYmplY3Qgd2l0aCBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRva2VuaXplci5cbiAqL1xudmFyIGRhdGVUb2tlbml6ZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHBhdHRlcm4sIGNsZHIsIHRpbWVab25lICkge1xuXHR2YXIgZGlnaXRzUmVTb3VyY2UsXG5cdFx0cHJvcGVydGllcyA9IHtcblx0XHRcdHBhdHRlcm46IGxvb3NlTWF0Y2hpbmcoIHBhdHRlcm4gKVxuXHRcdH0sXG5cdFx0dGltZVNlcGFyYXRvciA9IG51bWJlclN5bWJvbCggXCJ0aW1lU2VwYXJhdG9yXCIsIGNsZHIgKSxcblx0XHR3aWR0aHMgPSBbIFwiYWJicmV2aWF0ZWRcIiwgXCJ3aWRlXCIsIFwibmFycm93XCIgXTtcblxuXHRkaWdpdHNSZVNvdXJjZSA9IG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCggY2xkciApO1xuXHRkaWdpdHNSZVNvdXJjZSA9IGRpZ2l0c1JlU291cmNlID8gXCJbXCIgKyBkaWdpdHNSZVNvdXJjZSArIFwiXVwiIDogXCJcXFxcZFwiO1xuXHRwcm9wZXJ0aWVzLmRpZ2l0c1JlID0gbmV3IFJlZ0V4cCggZGlnaXRzUmVTb3VyY2UgKTtcblxuXHQvLyBUcmFuc2Zvcm06XG5cdC8vIC0gXCIrSDstSFwiIC0+IC9cXCsoXFxkXFxkPyl8LShcXGRcXGQ/KS9cblx0Ly8gLSBcIitISDstSEhcIiAtPiAvXFwrKFxcZFxcZCl8LShcXGRcXGQpL1xuXHQvLyAtIFwiK0hIbW07LUhIbW1cIiAtPiAvXFwrKFxcZFxcZCkoXFxkXFxkKXwtKFxcZFxcZCkoXFxkXFxkKS9cblx0Ly8gLSBcIitISDptbTstSEg6bW1cIiAtPiAvXFwrKFxcZFxcZCk6KFxcZFxcZCl8LShcXGRcXGQpOihcXGRcXGQpL1xuXHQvL1xuXHQvLyBJZiBnbXRGb3JtYXQgaXMgR01UezB9LCB0aGUgcmVnZXhwIG11c3QgZmlsbCB7MH0gaW4gZWFjaCBzaWRlLCBlLmcuOlxuXHQvLyAtIFwiK0g7LUhcIiAtPiAvR01UXFwrKFxcZFxcZD8pfEdNVC0oXFxkXFxkPykvXG5cdGZ1bmN0aW9uIGhvdXJGb3JtYXRSZSggaG91ckZvcm1hdCwgZ210Rm9ybWF0LCBkaWdpdHNSZVNvdXJjZSwgdGltZVNlcGFyYXRvciApIHtcblx0XHR2YXIgcmU7XG5cblx0XHRpZiAoICFkaWdpdHNSZVNvdXJjZSApIHtcblx0XHRcdGRpZ2l0c1JlU291cmNlID0gXCJcXFxcZFwiO1xuXHRcdH1cblx0XHRpZiAoICFnbXRGb3JtYXQgKSB7XG5cdFx0XHRnbXRGb3JtYXQgPSBcInswfVwiO1xuXHRcdH1cblxuXHRcdHJlID0gaG91ckZvcm1hdFxuXHRcdFx0LnJlcGxhY2UoIFwiK1wiLCBcIlxcXFwrXCIgKVxuXG5cdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gKFxcXFxkXFxcXGQpXG5cdFx0XHQucmVwbGFjZSggL0hIfG1tfHNzL2csIFwiKChcIiArIGRpZ2l0c1JlU291cmNlICsgXCIpezJ9KVwiIClcblxuXHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIChcXFxcZFxcXFxkPylcblx0XHRcdC5yZXBsYWNlKCAvSHxtL2csIFwiKChcIiArIGRpZ2l0c1JlU291cmNlICsgXCIpezEsMn0pXCIgKTtcblxuXHRcdGlmICggdGltZVNlcGFyYXRvciApIHtcblx0XHRcdHJlID0gcmUucmVwbGFjZSggLzovZywgdGltZVNlcGFyYXRvciApO1xuXHRcdH1cblxuXHRcdHJlID0gcmUuc3BsaXQoIFwiO1wiICkubWFwKGZ1bmN0aW9uKCBwYXJ0ICkge1xuXHRcdFx0cmV0dXJuIGdtdEZvcm1hdC5yZXBsYWNlKCBcInswfVwiLCBwYXJ0ICk7XG5cdFx0fSkuam9pbiggXCJ8XCIgKTtcblxuXHRcdHJldHVybiBuZXcgUmVnRXhwKCBcIl5cIiArIHJlICk7XG5cdH1cblxuXHRmdW5jdGlvbiBwb3B1bGF0ZVByb3BlcnRpZXMoIHBhdGgsIHZhbHVlICkge1xuXG5cdFx0Ly8gU2tpcFxuXHRcdHZhciBza2lwUmUgPSAvKHRpbWVab25lTmFtZXNcXC96b25lfHN1cHBsZW1lbnRhbFxcL21ldGFab25lc3x0aW1lWm9uZU5hbWVzXFwvbWV0YXpvbmV8dGltZVpvbmVOYW1lc1xcL3JlZ2lvbkZvcm1hdHx0aW1lWm9uZU5hbWVzXFwvZ210Rm9ybWF0KS87XG5cdFx0aWYgKCBza2lwUmUudGVzdCggcGF0aCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBgZGF0ZXNgIGFuZCBgY2FsZW5kYXJzYCB0cmltJ3MgcHVycG9zZSBpcyB0byByZWR1Y2UgcHJvcGVydGllcycga2V5IHNpemUgb25seS5cblx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCAvXi4qXFwvZGF0ZXNcXC8vLCBcIlwiICkucmVwbGFjZSggL2NhbGVuZGFyc1xcLy8sIFwiXCIgKTtcblxuXHRcdC8vIFNwZWNpZmljIGZpbHRlciBmb3IgXCJncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZVwiLlxuXHRcdGlmICggcGF0aCA9PT0gXCJncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZVwiICkge1xuXHRcdFx0dmFsdWUgPSBvYmplY3RGaWx0ZXIoIHZhbHVlLCAvXmFtfF5wbS8gKTtcblx0XHR9XG5cblx0XHQvLyBUcmFuc2Zvcm0gb2JqZWN0IGludG8gYXJyYXkgb2YgcGFpcnMgW2tleSwgL3ZhbHVlL10sIHNvcnQgYnkgZGVzYyB2YWx1ZSBsZW5ndGguXG5cdFx0aWYgKCBpc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0dmFsdWUgPSBPYmplY3Qua2V5cyggdmFsdWUgKS5tYXAoZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIFsga2V5LCBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggbG9vc2VNYXRjaGluZyggdmFsdWVbIGtleSBdICkgKSApIF07XG5cdFx0XHR9KS5zb3J0KGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRyZXR1cm4gYlsgMSBdLnNvdXJjZS5sZW5ndGggLSBhWyAxIF0uc291cmNlLmxlbmd0aDtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gSWYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IGxvb3NlTWF0Y2hpbmcoIHZhbHVlICk7XG5cdFx0fVxuXHRcdHByb3BlcnRpZXNbIHBhdGggXSA9IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVnZXhwU291cmNlU29tZVRlcm0oIHRlcm1zICkge1xuXHRcdHJldHVybiBcIihcIiArIHRlcm1zLmZpbHRlcihmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0pLnJlZHVjZShmdW5jdGlvbiggbWVtbywgaXRlbSApIHtcblx0XHRcdHJldHVybiBtZW1vICsgXCJ8XCIgKyBpdGVtO1xuXHRcdH0pICsgXCIpXCI7XG5cdH1cblxuXHRjbGRyLm9uKCBcImdldFwiLCBwb3B1bGF0ZVByb3BlcnRpZXMgKTtcblxuXHRwYXR0ZXJuLm1hdGNoKCBkYXRlUGF0dGVyblJlICkuZm9yRWFjaChmdW5jdGlvbiggY3VycmVudCApIHtcblx0XHR2YXIgYXV4LCBjaHIsIGRheWxpZ2h0VHpOYW1lLCBnbXRGb3JtYXQsIGxlbmd0aCwgc3RhbmRhcmRUek5hbWU7XG5cblx0XHRjaHIgPSBjdXJyZW50LmNoYXJBdCggMCApO1xuXHRcdGxlbmd0aCA9IGN1cnJlbnQubGVuZ3RoO1xuXG5cdFx0aWYgKCBjaHIgPT09IFwiWlwiICkge1xuXHRcdFx0aWYgKCBsZW5ndGggPCA1ICkge1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNociA9IFwiWFwiO1xuXHRcdFx0XHRsZW5ndGggPSA1O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHouLi56eno6IFwie3Nob3J0UmVnaW9ufVwiLCBlZy4gXCJQU1RcIiBvciBcIlBEVFwiLlxuXHRcdC8vIHp6eno6IFwie3JlZ2lvbk5hbWV9IHtTdGFuZGFyZCBUaW1lfVwiIG9yIFwie3JlZ2lvbk5hbWV9IHtEYXlsaWdodCBUaW1lfVwiLFxuXHRcdC8vICAgICAgIGUuZy4sIFwiUGFjaWZpYyBTdGFuZGFyZCBUaW1lXCIgb3IgXCJQYWNpZmljIERheWxpZ2h0IFRpbWVcIi5cblx0XHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuXHRcdGlmICggY2hyID09PSBcInpcIiApIHtcblx0XHRcdHN0YW5kYXJkVHpOYW1lID0gZGF0ZUdldFRpbWVab25lTmFtZSggbGVuZ3RoLCBcInN0YW5kYXJkXCIsIHRpbWVab25lLCBjbGRyICk7XG5cdFx0XHRkYXlsaWdodFR6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXCJkYXlsaWdodFwiLCB0aW1lWm9uZSwgY2xkciApO1xuXHRcdFx0aWYgKCBzdGFuZGFyZFR6TmFtZSApIHtcblx0XHRcdFx0c3RhbmRhcmRUek5hbWUgPSByZWdleHBFc2NhcGUoIGxvb3NlTWF0Y2hpbmcoIHN0YW5kYXJkVHpOYW1lICkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggZGF5bGlnaHRUek5hbWUgKSB7XG5cdFx0XHRcdGRheWxpZ2h0VHpOYW1lID0gcmVnZXhwRXNjYXBlKCBsb29zZU1hdGNoaW5nKCBkYXlsaWdodFR6TmFtZSApICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHN0YW5kYXJkVHpOYW1lIHx8IGRheWxpZ2h0VHpOYW1lICkge1xuXHRcdFx0XHRwcm9wZXJ0aWVzLnN0YW5kYXJkT3JEYXlsaWdodFR6TmFtZSA9IG5ldyBSZWdFeHAoXG5cdFx0XHRcdFx0XCJeXCIgKyByZWdleHBTb3VyY2VTb21lVGVybShbIHN0YW5kYXJkVHpOYW1lLCBkYXlsaWdodFR6TmFtZSBdKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIHRocm91Z2ggdGhlIFwiT1wiIGZvcm1hdCBpbiBjYXNlIG9uZSBuYW1lIGlzIG1pc3NpbmcuXG5cdFx0XHRpZiAoICFzdGFuZGFyZFR6TmFtZSB8fCAhZGF5bGlnaHRUek5hbWUgKSB7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA8IDQgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHYuLi52dnY6IFwie3Nob3J0UmVnaW9ufVwiLCBlZy4gXCJQVFwiLlxuXHRcdC8vIHZ2dnY6IFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiIG9yIFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiLFxuXHRcdC8vIGUuZy4sIFwiUGFjaWZpYyBUaW1lXCJcblx0XHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuXHRcdGlmICggY2hyID09PSBcInZcIiApIHtcblx0XHRcdGlmICggbGVuZ3RoICE9PSAxICYmIGxlbmd0aCAhPT0gNCApIHtcblx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdGZlYXR1cmU6IFwidGltZXpvbmUgcGF0dGVybiBgXCIgKyBwYXR0ZXJuICsgXCJgXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZ2VuZXJpY1R6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXCJnZW5lcmljXCIsIHRpbWVab25lLCBjbGRyICk7XG5cdFx0XHRpZiAoIGdlbmVyaWNUek5hbWUgKSB7XG5cdFx0XHRcdHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZSA9IG5ldyBSZWdFeHAoXG5cdFx0XHRcdFx0XCJeXCIgKyByZWdleHBFc2NhcGUoIGxvb3NlTWF0Y2hpbmcoIGdlbmVyaWNUek5hbWUgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gXCJWXCIgZm9ybWF0LlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hyID0gXCJWXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggY2hyICkge1xuXG5cdFx0XHQvLyBFcmFcblx0XHRcdGNhc2UgXCJHXCI6XG5cdFx0XHRcdGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2VyYXNcIixcblx0XHRcdFx0XHRsZW5ndGggPD0gMyA/IFwiZXJhQWJiclwiIDogKCBsZW5ndGggPT09IDQgPyBcImVyYU5hbWVzXCIgOiBcImVyYU5hcnJvd1wiIClcblx0XHRcdFx0XSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBZZWFyXG5cdFx0XHRjYXNlIFwidVwiOiAvLyBFeHRlbmRlZCB5ZWFyLiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxuXHRcdFx0Y2FzZSBcIlVcIjogLy8gQ3ljbGljIHllYXIgbmFtZS4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdGZlYXR1cmU6IFwieWVhciBwYXR0ZXJuIGBcIiArIGNociArIFwiYFwiXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBRdWFydGVyXG5cdFx0XHRjYXNlIFwiUVwiOlxuXHRcdFx0Y2FzZSBcInFcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPiAyICkge1xuXHRcdFx0XHRcdGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vcXVhcnRlcnNcIixcblx0XHRcdFx0XHRcdGNociA9PT0gXCJRXCIgPyBcImZvcm1hdFwiIDogXCJzdGFuZC1hbG9uZVwiLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRjYXNlIFwiTFwiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsPTE6ezEsMn0sIGw9Mjp7Mn0uXG5cdFx0XHRcdC8vIGxvb2t1cCBsPTMuLi5cblx0XHRcdFx0aWYgKCBsZW5ndGggPiAyICkge1xuXHRcdFx0XHRcdGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vbW9udGhzXCIsXG5cdFx0XHRcdFx0XHRjaHIgPT09IFwiTVwiID8gXCJmb3JtYXRcIiA6IFwic3RhbmQtYWxvbmVcIixcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIERheVxuXHRcdFx0Y2FzZSBcImdcIjpcblxuXHRcdFx0XHQvLyBNb2RpZmllZCBKdWxpYW4gZGF5LiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxuXHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0ZmVhdHVyZTogXCJKdWxpYW4gZGF5IHBhdHRlcm4gYGdgXCJcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIFdlZWsgZGF5XG5cdFx0XHRjYXNlIFwiZVwiOlxuXHRcdFx0Y2FzZSBcImNcIjpcblxuXHRcdFx0XHQvLyBsb29rdXAgZm9yIGxlbmd0aCA+PTMuXG5cdFx0XHRcdGlmICggbGVuZ3RoIDw9IDIgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIkVcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHQvLyBOb3RlOiBpZiBzaG9ydCBkYXkgbmFtZXMgYXJlIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgYWJicmV2aWF0ZWQgZGF5XG5cdFx0XHRcdFx0Ly8gbmFtZXMgYXJlIHVzZWQgaW5zdGVhZCBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjbW9udGhzX2RheXNfcXVhcnRlcnNfZXJhc1xuXHRcdFx0XHRcdGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0WyBjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIiBdLFxuXHRcdFx0XHRcdFx0XCJzaG9ydFwiXG5cdFx0XHRcdFx0XSkgfHwgY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRbIGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiIF0sXG5cdFx0XHRcdFx0XHRcImFiYnJldmlhdGVkXCJcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFsgY2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIgXSxcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIDwgMyA/IDAgOiBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcblx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdGNsZHIubWFpbihcblx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZVwiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBab25lXG5cdFx0XHRjYXNlIFwiVlwiOlxuXG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRcdGZlYXR1cmU6IFwidGltZXpvbmUgcGF0dGVybiBgXCIgKyBwYXR0ZXJuICsgXCJgXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGltZVpvbmUgKSB7XG5cdFx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFNraXAgbG9vc2VNYXRjaGluZyBwcm9jZXNzaW5nIHNpbmNlIHRpbWVab25lIGlzIGEgY2Fub25pY2FsIHBvc2l4IHZhbHVlLlxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZTtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lUmUgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggdGltZVpvbmUgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHRpbWVab25lTmFtZSxcblx0XHRcdFx0XHRcdGV4ZW1wbGFyQ2l0eSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lXCIsIHRpbWVab25lLCBcImV4ZW1wbGFyQ2l0eVwiXG5cdFx0XHRcdFx0XHRdKTtcblxuXHRcdFx0XHRcdGlmICggbGVuZ3RoID09PSAzICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZXhlbXBsYXJDaXR5ICkge1xuXHRcdFx0XHRcdFx0XHRleGVtcGxhckNpdHkgPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lL0V0Yy9Vbmtub3duL2V4ZW1wbGFyQ2l0eVwiXG5cdFx0XHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGltZVpvbmVOYW1lID0gZXhlbXBsYXJDaXR5O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZXhlbXBsYXJDaXR5ICYmIGxlbmd0aCA9PT0gNCApIHtcblx0XHRcdFx0XHRcdHRpbWVab25lTmFtZSA9IGZvcm1hdE1lc3NhZ2UoXG5cdFx0XHRcdFx0XHRcdGNsZHIubWFpbihcblx0XHRcdFx0XHRcdFx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvcmVnaW9uRm9ybWF0XCJcblx0XHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdFx0WyBleGVtcGxhckNpdHkgXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRpbWVab25lTmFtZSApIHtcblx0XHRcdFx0XHRcdHRpbWVab25lTmFtZSA9IGxvb3NlTWF0Y2hpbmcoIHRpbWVab25lTmFtZSApO1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZU5hbWU7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZVJlID0gbmV3IFJlZ0V4cChcblx0XHRcdFx0XHRcdFx0XCJeXCIgKyByZWdleHBFc2NhcGUoIHRpbWVab25lTmFtZSApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3VycmVudCA9PT0gXCJ2XCIgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwielwiOlxuXHRcdFx0Y2FzZSBcIk9cIjpcblx0XHRcdFx0Z210Rm9ybWF0ID0gY2xkci5tYWluKCBcImRhdGVzL3RpbWVab25lTmFtZXMvZ210Rm9ybWF0XCIgKTtcblx0XHRcdFx0Y2xkci5tYWluKCBcImRhdGVzL3RpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFwiICk7XG5cdFx0XHRcdGNsZHIubWFpbiggXCJkYXRlcy90aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcIiApO1xuXHRcdFx0XHRwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFJlXCIgXSA9XG5cdFx0XHRcdFx0bmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XCIgXSApICk7XG5cdFx0XHRcdGF1eCA9IHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XCIgXTtcblx0XHRcdFx0cHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcIiBdID0gKFxuXHRcdFx0XHRcdGxlbmd0aCA8IDQgP1xuXHRcdFx0XHRcdFx0WyBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0oIGF1eCwgXCJIXCIgKSwgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEgoIGF1eCApIF0gOlxuXHRcdFx0XHRcdFx0WyBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0oIGF1eCwgXCJISFwiICkgXVxuXHRcdFx0XHQpLm1hcChmdW5jdGlvbiggaG91ckZvcm1hdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaG91ckZvcm1hdFJlKFxuXHRcdFx0XHRcdFx0aG91ckZvcm1hdCxcblx0XHRcdFx0XHRcdGdtdEZvcm1hdCxcblx0XHRcdFx0XHRcdGRpZ2l0c1JlU291cmNlLFxuXHRcdFx0XHRcdFx0dGltZVNlcGFyYXRvclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiWFwiOlxuXHRcdFx0Y2FzZSBcInhcIjpcblxuXHRcdFx0XHQvLyB4OiBob3VyRm9ybWF0KFwiK0hIW21tXTstSEhbbW1dXCIpXG5cdFx0XHRcdC8vIHh4OiBob3VyRm9ybWF0KFwiK0hIbW07LUhIbW1cIilcblx0XHRcdFx0Ly8geHh4OiBob3VyRm9ybWF0KFwiK0hIOm1tOy1ISDptbVwiKVxuXHRcdFx0XHQvLyB4eHh4OiBob3VyRm9ybWF0KFwiK0hIbW1bc3NdOy1ISG1tW3NzXVwiKVxuXHRcdFx0XHQvLyB4eHh4eDogaG91ckZvcm1hdChcIitISDptbVs6c3NdOy1ISDptbVs6c3NdXCIpXG5cdFx0XHRcdHByb3BlcnRpZXMueCA9IFtcblx0XHRcdFx0XHRbIFwiK0hIbW07LUhIbW1cIiwgXCIrSEg7LUhIXCIgXSxcblx0XHRcdFx0XHRbIFwiK0hIbW07LUhIbW1cIiBdLFxuXHRcdFx0XHRcdFsgXCIrSEg6bW07LUhIOm1tXCIgXSxcblx0XHRcdFx0XHRbIFwiK0hIbW1zczstSEhtbXNzXCIsIFwiK0hIbW07LUhIbW1cIiBdLFxuXHRcdFx0XHRcdFsgXCIrSEg6bW06c3M7LUhIOm1tOnNzXCIsIFwiK0hIOm1tOy1ISDptbVwiIF1cblx0XHRcdFx0XVsgbGVuZ3RoIC0gMSBdLm1hcChmdW5jdGlvbiggaG91ckZvcm1hdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaG91ckZvcm1hdFJlKCBob3VyRm9ybWF0ICk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHBvcHVsYXRlUHJvcGVydGllcyApO1xuXG5cdHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuXG5cblxuLyoqXG4gKiBkYXlPZldlZWsoIGRhdGUsIGZpcnN0RGF5IClcbiAqXG4gKiBAZGF0ZVxuICpcbiAqIEBmaXJzdERheSB0aGUgcmVzdWx0IG9mIGBkYXRlRmlyc3REYXlPZldlZWsoIGNsZHIgKWBcbiAqXG4gKiBSZXR1cm4gdGhlIGRheSBvZiB0aGUgd2VlayBub3JtYWxpemVkIGJ5IHRoZSB0ZXJyaXRvcnkncyBmaXJzdERheSBbMC02XS5cbiAqIEVnIGZvciBcIm1vblwiOlxuICogLSByZXR1cm4gMCBpZiB0ZXJyaXRvcnkgaXMgR0IsIG9yIEJSLCBvciBERSwgb3IgRlIgKHdlZWsgc3RhcnRzIG9uIFwibW9uXCIpO1xuICogLSByZXR1cm4gMSBpZiB0ZXJyaXRvcnkgaXMgVVMgKHdlZWsgc3RhcnRzIG9uIFwic3VuXCIpO1xuICogLSByZXR1cm4gMiBpZiB0ZXJyaXRvcnkgaXMgRUcgKHdlZWsgc3RhcnRzIG9uIFwic2F0XCIpO1xuICovXG52YXIgZGF0ZURheU9mV2VlayA9IGZ1bmN0aW9uKCBkYXRlLCBmaXJzdERheSApIHtcblx0cmV0dXJuICggZGF0ZS5nZXREYXkoKSAtIGZpcnN0RGF5ICsgNyApICUgNztcbn07XG5cblxuXG5cbi8qKlxuICogZGlzdGFuY2VJbkRheXMoIGZyb20sIHRvIClcbiAqXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIGRheXMgYmV0d2VlbiBmcm9tIGFuZCB0byBEYXRlcy5cbiAqL1xudmFyIGRhdGVEaXN0YW5jZUluRGF5cyA9IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0dmFyIGluRGF5cyA9IDg2NGU1O1xuXHRyZXR1cm4gKCB0by5nZXRUaW1lKCkgLSBmcm9tLmdldFRpbWUoKSApIC8gaW5EYXlzO1xufTtcblxuXG5cblxuLyoqXG4gKiBkYXlPZlllYXJcbiAqXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIGRheXMgb2YgdGhlIGRhdGUgdG8gdGhlIGJlZ2luIG9mIHRoZSB5ZWFyIFswLWRdLlxuICovXG52YXIgZGF0ZURheU9mWWVhciA9IGZ1bmN0aW9uKCBkYXRlICkge1xuXHRyZXR1cm4gTWF0aC5mbG9vciggZGF0ZURpc3RhbmNlSW5EYXlzKCBkYXRlU3RhcnRPZiggZGF0ZSwgXCJ5ZWFyXCIgKSwgZGF0ZSApICk7XG59O1xuXG5cblxuXG4vLyBJbnZlcnQga2V5IGFuZCB2YWx1ZXMsIGUuZy4sIHtcInllYXJcIjogXCJ5WVwifSA9PT4ge1wieVwiOiBcInllYXJcIiwgXCJZXCI6IFwieWVhclwifVxudmFyIGRhdGVGaWVsZHNNYXAgPSBvYmplY3RJbnZlcnQoe1xuXHRcImVyYVwiOiBcIkdcIixcblx0XCJ5ZWFyXCI6IFwieVlcIixcblx0XCJxdWFydGVyXCI6IFwicVFcIixcblx0XCJtb250aFwiOiBcIk1MXCIsXG5cdFwid2Vla1wiOiBcIndXXCIsXG5cdFwiZGF5XCI6IFwiZERGXCIsXG5cdFwid2Vla2RheVwiOiBcImVjRVwiLFxuXHRcImRheXBlcmlvZFwiOiBcImFcIixcblx0XCJob3VyXCI6IFwiaEhrS1wiLFxuXHRcIm1pbnV0ZVwiOiBcIm1cIixcblx0XCJzZWNvbmRcIjogXCJzU0FcIixcblx0XCJ6b25lXCI6IFwienZWT3hYXCJcbn0sIGZ1bmN0aW9uKCBvYmplY3QsIGtleSwgdmFsdWUgKSB7XG5cdHZhbHVlLnNwbGl0KCBcIlwiICkuZm9yRWFjaChmdW5jdGlvbiggc3ltYm9sICkge1xuXHRcdG9iamVjdFsgc3ltYm9sIF0gPSBrZXk7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufSk7XG5cblxuXG5cbi8qKlxuICogbWlsbGlzZWNvbmRzSW5EYXlcbiAqL1xudmFyIGRhdGVNaWxsaXNlY29uZHNJbkRheSA9IGZ1bmN0aW9uKCBkYXRlICkge1xuXG5cdC8vIFRPRE8gSGFuZGxlIGRheWxpZ2h0IHNhdmluZ3MgZGlzY29udGludWl0aWVzXG5cdHJldHVybiBkYXRlIC0gZGF0ZVN0YXJ0T2YoIGRhdGUsIFwiZGF5XCIgKTtcbn07XG5cblxuXG5cbi8qKlxuICogaG91ckZvcm1hdCggZGF0ZSwgZm9ybWF0LCB0aW1lU2VwYXJhdG9yLCBmb3JtYXROdW1iZXIgKVxuICpcbiAqIFJldHVybiBkYXRlJ3MgdGltZXpvbmUgb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgZm9ybWF0IHBhc3NlZC5cbiAqIEVnIGZvciBmb3JtYXQgd2hlbiB0aW1lem9uZSBvZmZzZXQgaXMgMTgwOlxuICogLSBcIitIOy1IXCI6IC0zXG4gKiAtIFwiK0hIbW07LUhIbW1cIjogLTAzMDBcbiAqIC0gXCIrSEg6bW07LUhIOm1tXCI6IC0wMzowMFxuICogLSBcIitISDptbTpzczstSEg6bW06c3NcIjogLTAzOjAwOjAwXG4gKi9cbnZhciBkYXRlVGltZXpvbmVIb3VyRm9ybWF0ID0gZnVuY3Rpb24oIGRhdGUsIGZvcm1hdCwgdGltZVNlcGFyYXRvciwgZm9ybWF0TnVtYmVyICkge1xuXHR2YXIgYWJzT2Zmc2V0LFxuXHRcdG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuXHRhYnNPZmZzZXQgPSBNYXRoLmFicyggb2Zmc2V0ICk7XG5cdGZvcm1hdE51bWJlciA9IGZvcm1hdE51bWJlciB8fCB7XG5cdFx0MTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ1BhZCggdmFsdWUsIDEgKTtcblx0XHR9LFxuXHRcdDI6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBzdHJpbmdQYWQoIHZhbHVlLCAyICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBmb3JtYXRcblxuXHRcdC8vIFBpY2sgdGhlIGNvcnJlY3Qgc2lnbiBzaWRlICgrIG9yIC0pLlxuXHRcdC5zcGxpdCggXCI7XCIgKVsgb2Zmc2V0ID4gMCA/IDEgOiAwIF1cblxuXHRcdC8vIExvY2FsaXplIHRpbWUgc2VwYXJhdG9yXG5cdFx0LnJlcGxhY2UoIFwiOlwiLCB0aW1lU2VwYXJhdG9yIClcblxuXHRcdC8vIFVwZGF0ZSBob3VycyBvZmZzZXQuXG5cdFx0LnJlcGxhY2UoIC9ISD8vLCBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gZm9ybWF0TnVtYmVyWyBtYXRjaC5sZW5ndGggXSggTWF0aC5mbG9vciggYWJzT2Zmc2V0IC8gNjAgKSApO1xuXHRcdH0pXG5cblx0XHQvLyBVcGRhdGUgbWludXRlcyBvZmZzZXQgYW5kIHJldHVybi5cblx0XHQucmVwbGFjZSggL21tLywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm9ybWF0TnVtYmVyWyAyIF0oIE1hdGguZmxvb3IoIGFic09mZnNldCAlIDYwICkgKTtcblx0XHR9KVxuXG5cdFx0Ly8gVXBkYXRlIG1pbnV0ZXMgb2Zmc2V0IGFuZCByZXR1cm4uXG5cdFx0LnJlcGxhY2UoIC9zcy8sIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZvcm1hdE51bWJlclsgMiBdKCBNYXRoLmZsb29yKCBhYnNPZmZzZXQgJSAxICogNjAgKSApO1xuXHRcdH0pO1xufTtcblxuXG5cblxuLyoqXG4gKiBmb3JtYXQoIGRhdGUsIHByb3BlcnRpZXMgKVxuICpcbiAqIEBkYXRlIFtEYXRlIGluc3RhbmNlXS5cbiAqXG4gKiBAcHJvcGVydGllc1xuICpcbiAqIFRPRE8gU3VwcG9ydCBvdGhlciBjYWxlbmRhciB0eXBlcy5cbiAqXG4gKiBEaXNjbG9zdXJlOiB0aGlzIGZ1bmN0aW9uIGJvcnJvd3MgZXhjZXJwdHMgb2YgZG9qby9kYXRlL2xvY2FsZS5cbiAqL1xudmFyIGRhdGVGb3JtYXQgPSBmdW5jdGlvbiggZGF0ZSwgbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApIHtcblx0dmFyIHBhcnRzID0gW107XG5cblx0dmFyIHRpbWVTZXBhcmF0b3IgPSBwcm9wZXJ0aWVzLnRpbWVTZXBhcmF0b3I7XG5cblx0Ly8gY3JlYXRlIGdsb2JhbGl6ZSBkYXRlIHdpdGggZ2l2ZW4gdGltZXpvbmUgZGF0YVxuXHRpZiAoIHByb3BlcnRpZXMudGltZVpvbmVEYXRhICkge1xuXHRcdGRhdGUgPSBuZXcgWm9uZWREYXRlVGltZSggZGF0ZSwgcHJvcGVydGllcy50aW1lWm9uZURhdGEoKSApO1xuXHR9XG5cblx0cHJvcGVydGllcy5wYXR0ZXJuLnJlcGxhY2UoIGRhdGVQYXR0ZXJuUmUsIGZ1bmN0aW9uKCBjdXJyZW50ICkge1xuXHRcdHZhciBhdXgsIGRhdGVGaWVsZCwgdHlwZSwgdmFsdWUsXG5cdFx0XHRjaHIgPSBjdXJyZW50LmNoYXJBdCggMCApLFxuXHRcdFx0bGVuZ3RoID0gY3VycmVudC5sZW5ndGg7XG5cblx0XHRpZiAoIGNociA9PT0gXCJqXCIgKSB7XG5cblx0XHRcdC8vIExvY2FsZSBwcmVmZXJyZWQgaEhLay5cblx0XHRcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNUaW1lX0RhdGFcblx0XHRcdGNociA9IHByb3BlcnRpZXMucHJlZmVycmVkVGltZTtcblx0XHR9XG5cblx0XHRpZiAoIGNociA9PT0gXCJaXCIgKSB7XG5cblx0XHRcdC8vIFouLlpaWjogc2FtZSBhcyBcInh4eHhcIi5cblx0XHRcdGlmICggbGVuZ3RoIDwgNCApIHtcblx0XHRcdFx0Y2hyID0gXCJ4XCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cblx0XHRcdC8vIFpaWlo6IHNhbWUgYXMgXCJPT09PXCIuXG5cdFx0XHR9IGVsc2UgaWYgKCBsZW5ndGggPCA1ICkge1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblxuXHRcdFx0Ly8gWlpaWlo6IHNhbWUgYXMgXCJYWFhYWFwiXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHIgPSBcIlhcIjtcblx0XHRcdFx0bGVuZ3RoID0gNTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB6Li4uenp6OiBcIntzaG9ydFJlZ2lvbn1cIiwgZS5nLiwgXCJQU1RcIiBvciBcIlBEVFwiLlxuXHRcdC8vIHp6eno6IFwie3JlZ2lvbk5hbWV9IHtTdGFuZGFyZCBUaW1lfVwiIG9yIFwie3JlZ2lvbk5hbWV9IHtEYXlsaWdodCBUaW1lfVwiLFxuXHRcdC8vICAgICAgIGUuZy4sIFwiUGFjaWZpYyBTdGFuZGFyZCBUaW1lXCIgb3IgXCJQYWNpZmljIERheWxpZ2h0IFRpbWVcIi5cblx0XHRpZiAoIGNociA9PT0gXCJ6XCIgKSB7XG5cdFx0XHRpZiAoIGRhdGUuaXNEU1QgKSB7XG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5pc0RTVCgpID8gcHJvcGVydGllcy5kYXlsaWdodFR6TmFtZSA6IHByb3BlcnRpZXMuc3RhbmRhcmRUek5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBcIk9cIiBmb3JtYXQuXG5cdFx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRcdGlmICggbGVuZ3RoIDwgNCApIHtcblx0XHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggY2hyICkge1xuXG5cdFx0XHQvLyBFcmFcblx0XHRcdGNhc2UgXCJHXCI6XG5cdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5lcmFzWyBkYXRlLmdldEZ1bGxZZWFyKCkgPCAwID8gMCA6IDEgXTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFllYXJcblx0XHRcdGNhc2UgXCJ5XCI6XG5cblx0XHRcdFx0Ly8gUGxhaW4geWVhci5cblx0XHRcdFx0Ly8gVGhlIGxlbmd0aCBzcGVjaWZpZXMgdGhlIHBhZGRpbmcsIGJ1dCBmb3IgdHdvIGxldHRlcnMgaXQgYWxzbyBzcGVjaWZpZXMgdGhlXG5cdFx0XHRcdC8vIG1heGltdW0gbGVuZ3RoLlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBTdHJpbmcoIHZhbHVlICk7XG5cdFx0XHRcdFx0dmFsdWUgPSArdmFsdWUuc3Vic3RyKCB2YWx1ZS5sZW5ndGggLSAyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJZXCI6XG5cblx0XHRcdFx0Ly8gWWVhciBpbiBcIldlZWsgb2YgWWVhclwiXG5cdFx0XHRcdC8vIFRoZSBsZW5ndGggc3BlY2lmaWVzIHRoZSBwYWRkaW5nLCBidXQgZm9yIHR3byBsZXR0ZXJzIGl0IGFsc28gc3BlY2lmaWVzIHRoZVxuXHRcdFx0XHQvLyBtYXhpbXVtIGxlbmd0aC5cblx0XHRcdFx0Ly8geWVhckluV2Vla29mWWVhciA9IGRhdGUgKyBEYXlzSW5BV2VlayAtIChkYXlPZldlZWsgLSBmaXJzdERheSkgLSBtaW5EYXlzXG5cdFx0XHRcdHZhbHVlID0gbmV3IERhdGUoIGRhdGUuZ2V0VGltZSgpICk7XG5cdFx0XHRcdHZhbHVlLnNldERhdGUoXG5cdFx0XHRcdFx0dmFsdWUuZ2V0RGF0ZSgpICsgNyAtXG5cdFx0XHRcdFx0ZGF0ZURheU9mV2VlayggZGF0ZSwgcHJvcGVydGllcy5maXJzdERheSApIC1cblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmZpcnN0RGF5IC1cblx0XHRcdFx0XHRwcm9wZXJ0aWVzLm1pbkRheXNcblx0XHRcdFx0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFN0cmluZyggdmFsdWUgKTtcblx0XHRcdFx0XHR2YWx1ZSA9ICt2YWx1ZS5zdWJzdHIoIHZhbHVlLmxlbmd0aCAtIDIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUXVhcnRlclxuXHRcdFx0Y2FzZSBcIlFcIjpcblx0XHRcdGNhc2UgXCJxXCI6XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5jZWlsKCAoIGRhdGUuZ2V0TW9udGgoKSArIDEgKSAvIDMgKTtcblx0XHRcdFx0aWYgKCBsZW5ndGggPiAyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5xdWFydGVyc1sgY2hyIF1bIGxlbmd0aCBdWyB2YWx1ZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNb250aFxuXHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdGNhc2UgXCJMXCI6XG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0aWYgKCBsZW5ndGggPiAyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5tb250aHNbIGNociBdWyBsZW5ndGggXVsgdmFsdWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2Vla1xuXHRcdFx0Y2FzZSBcIndcIjpcblxuXHRcdFx0XHQvLyBXZWVrIG9mIFllYXIuXG5cdFx0XHRcdC8vIHdveSA9IGNlaWwoICggZG95ICsgZG93IG9mIDEvMSApIC8gNyApIC0gbWluRGF5c1N0dWZmID8gMSA6IDAuXG5cdFx0XHRcdC8vIFRPRE8gc2hvdWxkIHBhZCBvbiB3dz8gTm90IGRvY3VtZW50ZWQsIGJ1dCBJIGd1ZXNzIHNvLlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGVEYXlPZldlZWsoIGRhdGVTdGFydE9mKCBkYXRlLCBcInllYXJcIiApLCBwcm9wZXJ0aWVzLmZpcnN0RGF5ICk7XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5jZWlsKCAoIGRhdGVEYXlPZlllYXIoIGRhdGUgKSArIHZhbHVlICkgLyA3ICkgLVxuXHRcdFx0XHRcdCggNyAtIHZhbHVlID49IHByb3BlcnRpZXMubWluRGF5cyA/IDAgOiAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiV1wiOlxuXG5cdFx0XHRcdC8vIFdlZWsgb2YgTW9udGguXG5cdFx0XHRcdC8vIHdvbSA9IGNlaWwoICggZG9tICsgZG93IG9mIGAxL21vbnRoYCApIC8gNyApIC0gbWluRGF5c1N0dWZmID8gMSA6IDAuXG5cdFx0XHRcdHZhbHVlID0gZGF0ZURheU9mV2VlayggZGF0ZVN0YXJ0T2YoIGRhdGUsIFwibW9udGhcIiApLCBwcm9wZXJ0aWVzLmZpcnN0RGF5ICk7XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5jZWlsKCAoIGRhdGUuZ2V0RGF0ZSgpICsgdmFsdWUgKSAvIDcgKSAtXG5cdFx0XHRcdFx0KCA3IC0gdmFsdWUgPj0gcHJvcGVydGllcy5taW5EYXlzID8gMCA6IDEgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIERheVxuXHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJEXCI6XG5cdFx0XHRcdHZhbHVlID0gZGF0ZURheU9mWWVhciggZGF0ZSApICsgMTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJGXCI6XG5cblx0XHRcdFx0Ly8gRGF5IG9mIFdlZWsgaW4gbW9udGguIGVnLiAybmQgV2VkIGluIEp1bHkuXG5cdFx0XHRcdHZhbHVlID0gTWF0aC5mbG9vciggZGF0ZS5nZXREYXRlKCkgLyA3ICkgKyAxO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gV2VlayBkYXlcblx0XHRcdGNhc2UgXCJlXCI6XG5cdFx0XHRjYXNlIFwiY1wiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA8PSAyICkge1xuXG5cdFx0XHRcdFx0Ly8gUmFuZ2UgaXMgWzEtN10gKGRlZHVjZWQgYnkgZXhhbXBsZSBwcm92aWRlZCBvbiBkb2N1bWVudGF0aW9uKVxuXHRcdFx0XHRcdC8vIFRPRE8gU2hvdWxkIHBhZCB3aXRoIHplcm9zIChub3Qgc3BlY2lmaWVkIGluIHRoZSBkb2NzKT9cblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGVEYXlPZldlZWsoIGRhdGUsIHByb3BlcnRpZXMuZmlyc3REYXkgKSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIkVcIjpcblx0XHRcdFx0dmFsdWUgPSBkYXRlV2Vla0RheXNbIGRhdGUuZ2V0RGF5KCkgXTtcblx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmRheXNbIGNociBdWyBsZW5ndGggXVsgdmFsdWUgXTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFBlcmlvZCAoQU0gb3IgUE0pXG5cdFx0XHRjYXNlIFwiYVwiOlxuXHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMuZGF5UGVyaW9kc1sgZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBcImFtXCIgOiBcInBtXCIgXTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIEhvdXJcblx0XHRcdGNhc2UgXCJoXCI6IC8vIDEtMTJcblx0XHRcdFx0dmFsdWUgPSAoIGRhdGUuZ2V0SG91cnMoKSAlIDEyICkgfHwgMTI7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiSFwiOiAvLyAwLTIzXG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRIb3VycygpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIktcIjogLy8gMC0xMVxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcImtcIjogLy8gMS0yNFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0SG91cnMoKSB8fCAyNDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1pbnV0ZVxuXHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFNlY29uZFxuXHRcdFx0Y2FzZSBcInNcIjpcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldFNlY29uZHMoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJTXCI6XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZCggZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIE1hdGgucG93KCAxMCwgbGVuZ3RoIC0gMyApICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiQVwiOlxuXHRcdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQoIGRhdGVNaWxsaXNlY29uZHNJbkRheSggZGF0ZSApICogTWF0aC5wb3coIDEwLCBsZW5ndGggLSAzICkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFpvbmVcblx0XHRcdGNhc2UgXCJ6XCI6XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwidlwiOlxuXG5cdFx0XHRcdC8vIHYuLi52dnY6IFwie3Nob3J0UmVnaW9ufVwiLCBlZy4gXCJQVFwiLlxuXHRcdFx0XHQvLyB2dnZ2OiBcIntyZWdpb25OYW1lfSB7VGltZX1cIixcblx0XHRcdFx0Ly8gICAgICAgZS5nLiwgXCJQYWNpZmljIFRpbWVcIi5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWUgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIlZcIjpcblxuXHRcdFx0XHQvL1ZWVlY6IFwie2V4cGxhckNpdHl9IHtUaW1lfVwiLCBlLmcuLCBcIkxvcyBBbmdlbGVzIFRpbWVcIlxuXHRcdFx0XHRpZiAoIHByb3BlcnRpZXMudGltZVpvbmVOYW1lICkge1xuXHRcdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy50aW1lWm9uZU5hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwidlwiICkge1xuXHRcdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcIk9cIjpcblxuXHRcdFx0XHQvLyBPOiBcIntnbXRGb3JtYXR9K0g7e2dtdEZvcm1hdH0tSFwiIG9yIFwie2dtdFplcm9Gb3JtYXR9XCIsIGVnLiBcIkdNVC04XCIgb3IgXCJHTVRcIi5cblx0XHRcdFx0Ly8gT09PTzogXCJ7Z210Rm9ybWF0fXtob3VyRm9ybWF0fVwiIG9yIFwie2dtdFplcm9Gb3JtYXR9XCIsIGVnLiBcIkdNVC0wODowMFwiIG9yIFwiR01UXCIuXG5cdFx0XHRcdGlmICggZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09PSAwICkge1xuXHRcdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5nbXRaZXJvRm9ybWF0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSWYgTy4uT09PIGFuZCB0aW1lem9uZSBvZmZzZXQgaGFzIG5vbi16ZXJvIG1pbnV0ZXMsIHNob3cgbWludXRlcy5cblx0XHRcdFx0XHRpZiAoIGxlbmd0aCA8IDQgKSB7XG5cdFx0XHRcdFx0XHRhdXggPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHRhdXggPSBwcm9wZXJ0aWVzLmhvdXJGb3JtYXRbIGF1eCAlIDYwIC0gYXV4ICUgMSA9PT0gMCA/IDAgOiAxIF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF1eCA9IHByb3BlcnRpZXMuaG91ckZvcm1hdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGVUaW1lem9uZUhvdXJGb3JtYXQoXG5cdFx0XHRcdFx0XHRkYXRlLFxuXHRcdFx0XHRcdFx0YXV4LFxuXHRcdFx0XHRcdFx0dGltZVNlcGFyYXRvcixcblx0XHRcdFx0XHRcdG51bWJlckZvcm1hdHRlcnNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5nbXRGb3JtYXQucmVwbGFjZSggL1xcezBcXH0vLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiWFwiOlxuXG5cdFx0XHRcdC8vIFNhbWUgYXMgeCosIGV4Y2VwdCBpdCB1c2VzIFwiWlwiIGZvciB6ZXJvIG9mZnNldC5cblx0XHRcdFx0aWYgKCBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT09IDAgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBcIlpcIjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwieFwiOlxuXG5cdFx0XHRcdC8vIHg6IGhvdXJGb3JtYXQoXCIrSEhbbW1dOy1ISFttbV1cIilcblx0XHRcdFx0Ly8geHg6IGhvdXJGb3JtYXQoXCIrSEhtbTstSEhtbVwiKVxuXHRcdFx0XHQvLyB4eHg6IGhvdXJGb3JtYXQoXCIrSEg6bW07LUhIOm1tXCIpXG5cdFx0XHRcdC8vIHh4eHg6IGhvdXJGb3JtYXQoXCIrSEhtbVtzc107LUhIbW1bc3NdXCIpXG5cdFx0XHRcdC8vIHh4eHh4OiBob3VyRm9ybWF0KFwiK0hIOm1tWzpzc107LUhIOm1tWzpzc11cIilcblx0XHRcdFx0YXV4ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG5cdFx0XHRcdC8vIElmIHggYW5kIHRpbWV6b25lIG9mZnNldCBoYXMgbm9uLXplcm8gbWludXRlcywgdXNlIHh4IChpLmUuLCBzaG93IG1pbnV0ZXMpLlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMSAmJiBhdXggJSA2MCAtIGF1eCAlIDEgIT09IDAgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoICs9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiAoeHh4eCBvciB4eHh4eCkgYW5kIHRpbWV6b25lIG9mZnNldCBoYXMgemVybyBzZWNvbmRzLCB1c2UgeHggb3IgeHh4XG5cdFx0XHRcdC8vIHJlc3BlY3RpdmVseSAoaS5lLiwgZG9uJ3Qgc2hvdyBvcHRpb25hbCBzZWNvbmRzKS5cblx0XHRcdFx0aWYgKCAoIGxlbmd0aCA9PT0gNCB8fCBsZW5ndGggPT09IDUgKSAmJiBhdXggJSAxID09PSAwICkge1xuXHRcdFx0XHRcdGxlbmd0aCAtPSAyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFsdWUgPSBbXG5cdFx0XHRcdFx0XCIrSEg7LUhIXCIsXG5cdFx0XHRcdFx0XCIrSEhtbTstSEhtbVwiLFxuXHRcdFx0XHRcdFwiK0hIOm1tOy1ISDptbVwiLFxuXHRcdFx0XHRcdFwiK0hIbW1zczstSEhtbXNzXCIsXG5cdFx0XHRcdFx0XCIrSEg6bW06c3M7LUhIOm1tOnNzXCJcblx0XHRcdFx0XVsgbGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdHZhbHVlID0gZGF0ZVRpbWV6b25lSG91ckZvcm1hdCggZGF0ZSwgdmFsdWUsIFwiOlwiICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyB0aW1lU2VwYXJhdG9yXG5cdFx0XHRjYXNlIFwiOlwiOlxuXHRcdFx0XHR2YWx1ZSA9IHRpbWVTZXBhcmF0b3I7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyAnIGxpdGVyYWxzLlxuXHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0dmFsdWUgPSByZW1vdmVMaXRlcmFsUXVvdGVzKCBjdXJyZW50ICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBBbnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgYSBsaXRlcmFsLCBpbmNsdWRpbmcgWyAsOi8uQCNdLCBjaGluZXNlLCBqYXBvbmVzZSwgYW5kXG5cdFx0XHQvLyBhcmFiaWMgY2hhcmFjdGVycy5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHZhbHVlID0gY3VycmVudDtcblxuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdHZhbHVlID0gbnVtYmVyRm9ybWF0dGVyc1sgbGVuZ3RoIF0oIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0ZGF0ZUZpZWxkID0gZGF0ZUZpZWxkc01hcFsgY2hyIF07XG5cdFx0dHlwZSA9IGRhdGVGaWVsZCA/IGRhdGVGaWVsZCA6IFwibGl0ZXJhbFwiO1xuXG5cdFx0Ly8gQ29uY2F0IHR3byBjb25zZWN1dGl2ZSBsaXRlcmFsc1xuXHRcdGlmICggdHlwZSA9PT0gXCJsaXRlcmFsXCIgJiYgcGFydHMubGVuZ3RoICYmIHBhcnRzWyBwYXJ0cy5sZW5ndGggLSAxIF0udHlwZSA9PT0gXCJsaXRlcmFsXCIgKSB7XG5cdFx0XHRwYXJ0c1sgcGFydHMubGVuZ3RoIC0gMSBdLnZhbHVlICs9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHBhcnRzLnB1c2goIHsgdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlIH0gKTtcblxuXHR9KTtcblxuXHRyZXR1cm4gcGFydHM7XG5cbn07XG5cblxuXG5cbnZhciBkYXRlVG9QYXJ0c0Zvcm1hdHRlckZuID0gZnVuY3Rpb24oIG51bWJlckZvcm1hdHRlcnMsIHByb3BlcnRpZXMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBkYXRlVG9QYXJ0c0Zvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZURhdGUoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHJldHVybiBkYXRlRm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApO1xuXHR9O1xuXG59O1xuXG5cblxuXG5mdW5jdGlvbiBvcHRpb25zSGFzU3R5bGUoIG9wdGlvbnMgKSB7XG5cdHJldHVybiBvcHRpb25zLnNrZWxldG9uICE9PSB1bmRlZmluZWQgfHxcblx0XHRvcHRpb25zLmRhdGUgIT09IHVuZGVmaW5lZCB8fFxuXHRcdG9wdGlvbnMudGltZSAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0b3B0aW9ucy5kYXRldGltZSAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0b3B0aW9ucy5yYXcgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZENsZHIoIHBhdGgsIHZhbHVlICkge1xuXHR2YWxpZGF0ZUNsZHIoIHBhdGgsIHZhbHVlLCB7XG5cdFx0c2tpcDogW1xuXHRcdFx0L2RhdGVzXFwvY2FsZW5kYXJzXFwvZ3JlZ29yaWFuXFwvZGF0ZVRpbWVGb3JtYXRzXFwvYXZhaWxhYmxlRm9ybWF0cy8sXG5cdFx0XHQvZGF0ZXNcXC9jYWxlbmRhcnNcXC9ncmVnb3JpYW5cXC9kYXlzXFwvLipcXC9zaG9ydC8sXG5cdFx0XHQvZGF0ZXNcXC90aW1lWm9uZU5hbWVzXFwvem9uZS8sXG5cdFx0XHQvZGF0ZXNcXC90aW1lWm9uZU5hbWVzXFwvbWV0YXpvbmUvLFxuXHRcdFx0L2dsb2JhbGl6ZS1pYW5hLyxcblx0XHRcdC9zdXBwbGVtZW50YWxcXC9tZXRhWm9uZXMvLFxuXHRcdFx0L3N1cHBsZW1lbnRhbFxcL3RpbWVEYXRhXFwvKD8hMDAxKS8sXG5cdFx0XHQvc3VwcGxlbWVudGFsXFwvd2Vla0RhdGFcXC8oPyEwMDEpL1xuXHRcdF1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc1ByZXNldCggb3B0aW9ucyApIHtcblx0dmFsaWRhdGVPcHRpb25zUHJlc2V0RWFjaCggXCJkYXRlXCIsIG9wdGlvbnMgKTtcblx0dmFsaWRhdGVPcHRpb25zUHJlc2V0RWFjaCggXCJ0aW1lXCIsIG9wdGlvbnMgKTtcblx0dmFsaWRhdGVPcHRpb25zUHJlc2V0RWFjaCggXCJkYXRldGltZVwiLCBvcHRpb25zICk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc1ByZXNldEVhY2goIHR5cGUsIG9wdGlvbnMgKSB7XG5cdHZhciB2YWx1ZSA9IG9wdGlvbnNbIHR5cGUgXTtcblx0dmFsaWRhdGUoXG5cdFx0XCJFX0lOVkFMSURfT1BUSU9OU1wiLFxuXHRcdFwiSW52YWxpZCBge3t0eXBlfTogXFxcInt2YWx1ZX1cXFwifWAuXCIsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCBbIFwic2hvcnRcIiwgXCJtZWRpdW1cIiwgXCJsb25nXCIsIFwiZnVsbFwiIF0uaW5kZXhPZiggdmFsdWUgKSAhPT0gLTEsXG5cdFx0eyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUgfVxuXHQpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNTa2VsZXRvbiggcGF0dGVybiwgc2tlbGV0b24gKSB7XG5cdHZhbGlkYXRlKFxuXHRcdFwiRV9JTlZBTElEX09QVElPTlNcIixcblx0XHRcIkludmFsaWQgYHtza2VsZXRvbjogXFxcInt2YWx1ZX1cXFwifWAgYmFzZWQgb24gcHJvdmlkZWQgQ0xEUi5cIixcblx0XHRza2VsZXRvbiA9PT0gdW5kZWZpbmVkIHx8ICggdHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIgJiYgcGF0dGVybiApLFxuXHRcdHsgdHlwZTogXCJza2VsZXRvblwiLCB2YWx1ZTogc2tlbGV0b24gfVxuXHQpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkSWFuYSggdGltZVpvbmUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggcGF0aCwgdmFsdWUgKSB7XG5cblx0XHRpZiAoICEvZ2xvYmFsaXplLWlhbmEvLnRlc3QoIHBhdGggKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWxpZGF0ZShcblx0XHRcdFwiRV9NSVNTSU5HX0lBTkFfVFpcIixcblx0XHRcdFwiTWlzc2luZyByZXF1aXJlZCBJQU5BIHRpbWV6b25lIGNvbnRlbnQgZm9yIGB7dGltZVpvbmV9YDogYHtwYXRofWAuXCIsXG5cdFx0XHR2YWx1ZSxcblx0XHRcdHtcblx0XHRcdFx0cGF0aDogcGF0aC5yZXBsYWNlKCAvZ2xvYmFsaXplLWlhbmFcXC8vLCBcIlwiICksXG5cdFx0XHRcdHRpbWVab25lOiB0aW1lWm9uZVxuXHRcdFx0fVxuXHRcdCk7XG5cdH07XG59XG5cbi8qKlxuICogLmxvYWRUaW1lWm9uZSgganNvbiApXG4gKlxuICogQGpzb24gW0pTT05dXG4gKlxuICogTG9hZCBJQU5BIHRpbWV6b25lIGRhdGEuXG4gKi9cbkdsb2JhbGl6ZS5sb2FkVGltZVpvbmUgPSBmdW5jdGlvbigganNvbiApIHtcblx0dmFyIGN1c3RvbURhdGEgPSB7XG5cdFx0XHRcImdsb2JhbGl6ZS1pYW5hXCI6IGpzb25cblx0XHR9O1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIGpzb24sIFwianNvblwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBqc29uLCBcImpzb25cIiApO1xuXG5cdENsZHIubG9hZCggY3VzdG9tRGF0YSApO1xufTtcblxuLyoqXG4gKiAuZGF0ZUZvcm1hdHRlciggb3B0aW9ucyApXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBSZXR1cm4gYSBkYXRlIGZvcm1hdHRlciBmdW5jdGlvbiAob2YgdGhlIGZvcm0gYmVsb3cpIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqXG4gKiBmbiggdmFsdWUgKVxuICpcbiAqIEB2YWx1ZSBbRGF0ZV1cbiAqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBkYXRlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYGZvcm1hdGAgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlXG4gKiBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5kYXRlRm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZGF0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgZGF0ZVRvUGFydHNGb3JtYXR0ZXIsIHJldHVybkZuO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRpZiAoICFvcHRpb25zSGFzU3R5bGUoIG9wdGlvbnMgKSApIHtcblx0XHRvcHRpb25zLnNrZWxldG9uID0gXCJ5TWRcIjtcblx0fVxuXHRhcmdzID0gWyBvcHRpb25zIF07XG5cblx0ZGF0ZVRvUGFydHNGb3JtYXR0ZXIgPSB0aGlzLmRhdGVUb1BhcnRzRm9ybWF0dGVyKCBvcHRpb25zICk7XG5cdHJldHVybkZuID0gZGF0ZUZvcm1hdHRlckZuKCBkYXRlVG9QYXJ0c0Zvcm1hdHRlciApO1xuXHRydW50aW1lQmluZCggYXJncywgdGhpcy5jbGRyLCByZXR1cm5GbiwgWyBkYXRlVG9QYXJ0c0Zvcm1hdHRlciBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAuZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIG9wdGlvbnMgKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXG4gKlxuICogUmV0dXJuIGEgZGF0ZSBmb3JtYXR0ZXIgZnVuY3Rpb24gKG9mIHRoZSBmb3JtIGJlbG93KSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZVxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKlxuICogZm4oIHZhbHVlIClcbiAqXG4gKiBAdmFsdWUgW0RhdGVdXG4gKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgZGF0ZSB0byBwYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGBmb3JtYXRgXG4gKiBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2VcbiAqIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmRhdGVUb1BhcnRzRm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZGF0ZVRvUGFydHNGb3JtYXR0ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIG51bWJlckZvcm1hdHRlcnMsIHBhZCwgcGF0dGVybiwgcHJvcGVydGllcywgcmV0dXJuRm4sXG5cdFx0dGltZVpvbmU7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0Y2xkciA9IHRoaXMuY2xkcjtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdGlmICggIW9wdGlvbnNIYXNTdHlsZSggb3B0aW9ucyApICkge1xuXHRcdG9wdGlvbnMuc2tlbGV0b24gPSBcInlNZFwiO1xuXHR9XG5cblx0dmFsaWRhdGVPcHRpb25zUHJlc2V0KCBvcHRpb25zICk7XG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdHRpbWVab25lID0gb3B0aW9ucy50aW1lWm9uZTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB0aW1lWm9uZSwgXCJvcHRpb25zLnRpbWVab25lXCIgKTtcblxuXHRhcmdzID0gWyBvcHRpb25zIF07XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcblx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkSWFuYSggdGltZVpvbmUgKSApO1xuXHR9XG5cdHBhdHRlcm4gPSBkYXRlRXhwYW5kUGF0dGVybiggb3B0aW9ucywgY2xkciApO1xuXHR2YWxpZGF0ZU9wdGlvbnNTa2VsZXRvbiggcGF0dGVybiwgb3B0aW9ucy5za2VsZXRvbiApO1xuXHRwcm9wZXJ0aWVzID0gZGF0ZUZvcm1hdFByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIsIHRpbWVab25lICk7XG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xuXHRpZiAoIHRpbWVab25lICkge1xuXHRcdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkSWFuYSggdGltZVpvbmUgKSApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIG5lZWRlZCBudW1iZXIgZm9ybWF0dGVycy5cblx0bnVtYmVyRm9ybWF0dGVycyA9IHByb3BlcnRpZXMubnVtYmVyRm9ybWF0dGVycztcblx0ZGVsZXRlIHByb3BlcnRpZXMubnVtYmVyRm9ybWF0dGVycztcblx0Zm9yICggcGFkIGluIG51bWJlckZvcm1hdHRlcnMgKSB7XG5cdFx0bnVtYmVyRm9ybWF0dGVyc1sgcGFkIF0gPSB0aGlzLm51bWJlckZvcm1hdHRlcih7XG5cdFx0XHRyYXc6IG51bWJlckZvcm1hdHRlcnNbIHBhZCBdXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm5GbiA9IGRhdGVUb1BhcnRzRm9ybWF0dGVyRm4oIG51bWJlckZvcm1hdHRlcnMsIHByb3BlcnRpZXMgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAuZGF0ZVBhcnNlciggb3B0aW9ucyApXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBhIHN0cmluZyBkYXRlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYGZvcm1hdHNgIGFuZCB0aGVcbiAqIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZGF0ZVBhcnNlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLmRhdGVQYXJzZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIG51bWJlclBhcnNlciwgcGFyc2VQcm9wZXJ0aWVzLCBwYXR0ZXJuLCByZXR1cm5GbiwgdGltZVpvbmUsXG5cdFx0dG9rZW5pemVyUHJvcGVydGllcztcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRjbGRyID0gdGhpcy5jbGRyO1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0aWYgKCAhb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkgKSB7XG5cdFx0b3B0aW9ucy5za2VsZXRvbiA9IFwieU1kXCI7XG5cdH1cblxuXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXQoIG9wdGlvbnMgKTtcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0dGltZVpvbmUgPSBvcHRpb25zLnRpbWVab25lO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHRpbWVab25lLCBcIm9wdGlvbnMudGltZVpvbmVcIiApO1xuXG5cdGFyZ3MgPSBbIG9wdGlvbnMgXTtcblxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xuXHRpZiAoIHRpbWVab25lICkge1xuXHRcdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRJYW5hKCB0aW1lWm9uZSApICk7XG5cdH1cblx0cGF0dGVybiA9IGRhdGVFeHBhbmRQYXR0ZXJuKCBvcHRpb25zLCBjbGRyICk7XG5cdHZhbGlkYXRlT3B0aW9uc1NrZWxldG9uKCBwYXR0ZXJuLCBvcHRpb25zLnNrZWxldG9uICk7XG5cdHRva2VuaXplclByb3BlcnRpZXMgPSBkYXRlVG9rZW5pemVyUHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgdGltZVpvbmUgKTtcblx0cGFyc2VQcm9wZXJ0aWVzID0gZGF0ZVBhcnNlUHJvcGVydGllcyggY2xkciwgdGltZVpvbmUgKTtcblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XG5cdGlmICggdGltZVpvbmUgKSB7XG5cdFx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRJYW5hKCB0aW1lWm9uZSApICk7XG5cdH1cblxuXHRudW1iZXJQYXJzZXIgPSB0aGlzLm51bWJlclBhcnNlcih7IHJhdzogXCIwXCIgfSk7XG5cblx0cmV0dXJuRm4gPSBkYXRlUGFyc2VyRm4oIG51bWJlclBhcnNlciwgcGFyc2VQcm9wZXJ0aWVzLCB0b2tlbml6ZXJQcm9wZXJ0aWVzICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlclBhcnNlciwgcGFyc2VQcm9wZXJ0aWVzLCB0b2tlbml6ZXJQcm9wZXJ0aWVzIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5mb3JtYXREYXRlKCB2YWx1ZSwgb3B0aW9ucyApXG4gKlxuICogQHZhbHVlIFtEYXRlXVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXG4gKlxuICogRm9ybWF0cyBhIGRhdGUgb3IgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdERhdGUgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXREYXRlID0gZnVuY3Rpb24oIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZURhdGUoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5kYXRlRm9ybWF0dGVyKCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIC5mb3JtYXREYXRlVG9QYXJ0cyggdmFsdWUsIG9wdGlvbnMgKVxuICpcbiAqIEB2YWx1ZSBbRGF0ZV1cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIEZvcm1hdHMgYSBkYXRlIG9yIG51bWJlciB0byBwYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdERhdGVUb1BhcnRzID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0RGF0ZVRvUGFydHMgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlRGF0ZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLmRhdGVUb1BhcnRzRm9ybWF0dGVyKCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIC5wYXJzZURhdGUoIHZhbHVlLCBvcHRpb25zIClcbiAqXG4gKiBAdmFsdWUgW1N0cmluZ11cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIFJldHVybiBhIERhdGUgaW5zdGFuY2Ugb3IgbnVsbC5cbiAqL1xuR2xvYmFsaXplLnBhcnNlRGF0ZSA9XG5HbG9iYWxpemUucHJvdG90eXBlLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5kYXRlUGFyc2VyKCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9kYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvZGF0ZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBFeHRlbmQgZ2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBhbHdheXNBcnJheSA9IEdsb2JhbGl6ZS5fYWx3YXlzQXJyYXksXG5cdGNyZWF0ZUVycm9yID0gR2xvYmFsaXplLl9jcmVhdGVFcnJvcixcblx0aXNQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5faXNQbGFpbk9iamVjdCxcblx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcblx0dmFsaWRhdGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xudmFyIE1lc3NhZ2VGb3JtYXQ7XG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5NZXNzYWdlRm9ybWF0ID0gKGZ1bmN0aW9uKCkge1xuTWVzc2FnZUZvcm1hdC5fcGFyc2UgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLypcbiAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjguMC5cbiAgICpcbiAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICAgKi9cblxuICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICAgIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLmZvdW5kICAgID0gZm91bmQ7XG4gICAgdGhpcy5vZmZzZXQgICA9IG9mZnNldDtcbiAgICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xuXG4gICAgdGhpcy5uYW1lICAgICA9IFwiU3ludGF4RXJyb3JcIjtcbiAgfVxuXG4gIHBlZyRzdWJjbGFzcyhTeW50YXhFcnJvciwgRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXG4gICAgICAgIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBzdGFydDogcGVnJHBhcnNlc3RhcnQgfSxcbiAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXN0YXJ0LFxuXG4gICAgICAgIHBlZyRjMCA9IFtdLFxuICAgICAgICBwZWckYzEgPSBmdW5jdGlvbihzdCkge1xuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbWVzc2FnZUZvcm1hdFBhdHRlcm4nLCBzdGF0ZW1lbnRzOiBzdCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMyID0gcGVnJEZBSUxFRCxcbiAgICAgICAgcGVnJGMzID0gXCJ7XCIsXG4gICAgICAgIHBlZyRjNCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIntcIiwgZGVzY3JpcHRpb246IFwiXFxcIntcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1ID0gbnVsbCxcbiAgICAgICAgcGVnJGM2ID0gXCIsXCIsXG4gICAgICAgIHBlZyRjNyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIixcIiwgZGVzY3JpcHRpb246IFwiXFxcIixcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM4ID0gXCJ9XCIsXG4gICAgICAgIHBlZyRjOSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIn1cIiwgZGVzY3JpcHRpb246IFwiXFxcIn1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMCA9IGZ1bmN0aW9uKGFyZ0lkeCwgZWZtdCkge1xuICAgICAgICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZUZvcm1hdEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBhcmd1bWVudEluZGV4OiBhcmdJZHhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGVmbXQgJiYgZWZtdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXMuZWxlbWVudEZvcm1hdCA9IGVmbXRbMV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzLm91dHB1dCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTEgPSBcInBsdXJhbFwiLFxuICAgICAgICBwZWckYzEyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicGx1cmFsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJwbHVyYWxcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMyA9IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbGVtZW50Rm9ybWF0XCIsIGtleTogdCwgdmFsOiBzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzE0ID0gXCJzZWxlY3RvcmRpbmFsXCIsXG4gICAgICAgIHBlZyRjMTUgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzZWxlY3RvcmRpbmFsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzZWxlY3RvcmRpbmFsXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTYgPSBcInNlbGVjdFwiLFxuICAgICAgICBwZWckYzE3ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2VsZWN0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzZWxlY3RcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxOCA9IGZ1bmN0aW9uKHQsIHApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbGVtZW50Rm9ybWF0XCIsIGtleTogdCwgdmFsOiBwIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzE5ID0gZnVuY3Rpb24ob3AsIHBmKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwicGx1cmFsRm9ybWF0UGF0dGVyblwiLCBwbHVyYWxGb3JtczogcGYsIG9mZnNldDogb3AgfHwgMCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMyMCA9IFwib2Zmc2V0XCIsXG4gICAgICAgIHBlZyRjMjEgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJvZmZzZXRcIiwgZGVzY3JpcHRpb246IFwiXFxcIm9mZnNldFxcXCJcIiB9LFxuICAgICAgICBwZWckYzIyID0gXCI6XCIsXG4gICAgICAgIHBlZyRjMjMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMjQgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9LFxuICAgICAgICBwZWckYzI1ID0gZnVuY3Rpb24oaywgbWZwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsOiBtZnAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMjYgPSBmdW5jdGlvbihpKSB7IHJldHVybiBpOyB9LFxuICAgICAgICBwZWckYzI3ID0gXCI9XCIsXG4gICAgICAgIHBlZyRjMjggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI9XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMjkgPSBmdW5jdGlvbihwZikgeyByZXR1cm4geyB0eXBlOiBcInNlbGVjdEZvcm1hdFBhdHRlcm5cIiwgcGx1cmFsRm9ybXM6IHBmIH07IH0sXG4gICAgICAgIHBlZyRjMzAgPSBmdW5jdGlvbihwKSB7IHJldHVybiBwOyB9LFxuICAgICAgICBwZWckYzMxID0gXCIjXCIsXG4gICAgICAgIHBlZyRjMzIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIjXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIjXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMzMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHt0eXBlOiAnb2N0b3Rob3JwZSd9OyB9LFxuICAgICAgICBwZWckYzM0ID0gZnVuY3Rpb24ocykgeyByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiLCB2YWw6IHMuam9pbignJykgfTsgfSxcbiAgICAgICAgcGVnJGMzNSA9IHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogXCJpZGVudGlmaWVyXCIgfSxcbiAgICAgICAgcGVnJGMzNiA9IC9eWzAtOWEtekEtWiRfXS8sXG4gICAgICAgIHBlZyRjMzcgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOWEtekEtWiRfXVwiLCBkZXNjcmlwdGlvbjogXCJbMC05YS16QS1aJF9dXCIgfSxcbiAgICAgICAgcGVnJGMzOCA9IC9eW14gXFx0XFxuXFxyLC4rPXt9XS8sXG4gICAgICAgIHBlZyRjMzkgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW14gXFxcXHRcXFxcblxcXFxyLC4rPXt9XVwiLCBkZXNjcmlwdGlvbjogXCJbXiBcXFxcdFxcXFxuXFxcXHIsLis9e31dXCIgfSxcbiAgICAgICAgcGVnJGM0MCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHM7IH0sXG4gICAgICAgIHBlZyRjNDEgPSBmdW5jdGlvbihjaGFycykgeyByZXR1cm4gY2hhcnMuam9pbignJyk7IH0sXG4gICAgICAgIHBlZyRjNDIgPSAvXltee30jXFxcXFxcMC1cXHgxRn8gXFx0XFxuXFxyXS8sXG4gICAgICAgIHBlZyRjNDMgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW157fSNcXFxcXFxcXFxcXFwwLVxcXFx4MUZ/IFxcXFx0XFxcXG5cXFxccl1cIiwgZGVzY3JpcHRpb246IFwiW157fSNcXFxcXFxcXFxcXFwwLVxcXFx4MUZ/IFxcXFx0XFxcXG5cXFxccl1cIiB9LFxuICAgICAgICBwZWckYzQ0ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfSxcbiAgICAgICAgcGVnJGM0NSA9IFwiXFxcXFxcXFxcIixcbiAgICAgICAgcGVnJGM0NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFxcXFxcXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFxcXFwiOyB9LFxuICAgICAgICBwZWckYzQ4ID0gXCJcXFxcI1wiLFxuICAgICAgICBwZWckYzQ5ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXCNcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcI1xcXCJcIiB9LFxuICAgICAgICBwZWckYzUwID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIiNcIjsgfSxcbiAgICAgICAgcGVnJGM1MSA9IFwiXFxcXHtcIixcbiAgICAgICAgcGVnJGM1MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFx7XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXHtcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1MyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXHUwMDdCXCI7IH0sXG4gICAgICAgIHBlZyRjNTQgPSBcIlxcXFx9XCIsXG4gICAgICAgIHBlZyRjNTUgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcfVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFx9XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFx1MDA3RFwiOyB9LFxuICAgICAgICBwZWckYzU3ID0gXCJcXFxcdVwiLFxuICAgICAgICBwZWckYzU4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXHVcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcdVxcXCJcIiB9LFxuICAgICAgICBwZWckYzU5ID0gZnVuY3Rpb24oaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoXCIweFwiICsgaDEgKyBoMiArIGgzICsgaDQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjNjAgPSAvXlswLTldLyxcbiAgICAgICAgcGVnJGM2MSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05XVwiLCBkZXNjcmlwdGlvbjogXCJbMC05XVwiIH0sXG4gICAgICAgIHBlZyRjNjIgPSBmdW5jdGlvbihkcykge1xuICAgICAgICAgICAgLy90aGUgbnVtYmVyIG1pZ2h0IHN0YXJ0IHdpdGggMCBidXQgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gb2N0YWwgbnVtYmVyXG4gICAgICAgICAgICAvL0hlbmNlLCB0aGUgYmFzZSBpcyBwYXNzZWQgdG8gcGFyc2VJbnQgZXhwbGljaXRlbHlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCgoZHMuam9pbignJykpLCAxMCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgcGVnJGM2MyA9IC9eWzAtOWEtZkEtRl0vLFxuICAgICAgICBwZWckYzY0ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTlhLWZBLUZdXCIsIGRlc2NyaXB0aW9uOiBcIlswLTlhLWZBLUZdXCIgfSxcbiAgICAgICAgcGVnJGM2NSA9IHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogXCJ3aGl0ZXNwYWNlXCIgfSxcbiAgICAgICAgcGVnJGM2NiA9IGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHcuam9pbignJyk7IH0sXG4gICAgICAgIHBlZyRjNjcgPSAvXlsgXFx0XFxuXFxyXS8sXG4gICAgICAgIHBlZyRjNjggPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyBcXFxcdFxcXFxuXFxcXHJdXCIsIGRlc2NyaXB0aW9uOiBcIlsgXFxcXHRcXFxcblxcXFxyXVwiIH0sXG5cbiAgICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3MgICAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LFxuICAgICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgICBwZWckcmVzdWx0O1xuXG4gICAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgICAgfVxuXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckcmVwb3J0ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlcG9ydGVkUG9zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykubGluZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2x1bW4oKSB7XG4gICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykuY29sdW1uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICAgIG51bGwsXG4gICAgICAgIFt7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIG51bGwsIHBlZyRyZXBvcnRlZFBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgICAgZnVuY3Rpb24gYWR2YW5jZShkZXRhaWxzLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBwLCBjaDtcblxuICAgICAgICBmb3IgKHAgPSBzdGFydFBvczsgcCA8IGVuZFBvczsgcCsrKSB7XG4gICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMuc2VlbkNSKSB7IGRldGFpbHMubGluZSsrOyB9XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7XG4gICAgICAgIGlmIChwZWckY2FjaGVkUG9zID4gcG9zKSB7XG4gICAgICAgICAgcGVnJGNhY2hlZFBvcyA9IDA7XG4gICAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2UocGVnJGNhY2hlZFBvc0RldGFpbHMsIHBlZyRjYWNoZWRQb3MsIHBvcyk7XG4gICAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlscztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgZXhwZWN0ZWQsIHBvcykge1xuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciBpID0gMTtcblxuICAgICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYS5kZXNjcmlwdGlvbiA8IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChleHBlY3RlZFtpIC0gMV0gPT09IGV4cGVjdGVkW2ldKSB7XG4gICAgICAgICAgICBleHBlY3RlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykge1xuICAgICAgICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuXG4gICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICAgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAgICAnXFxcXFwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAgICdcXFxcdCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICAgJ1xcXFxuJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywgICAnXFxcXGYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAgICdcXFxccicpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRVxceDBGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDgwLVxceEZGXS9nLCAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMTgwLVxcdTBGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdTAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MTA4MC1cXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUnICArIGhleChjaCk7IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRGVzY3MgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcbiAgICAgICAgICAgIGV4cGVjdGVkRGVzYywgZm91bmREZXNjLCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGV4cGVjdGVkRGVzY3NbaV0gPSBleHBlY3RlZFtpXS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdGVkRGVzYyA9IGV4cGVjdGVkLmxlbmd0aCA+IDFcbiAgICAgICAgICA/IGV4cGVjdGVkRGVzY3Muc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXVxuICAgICAgICAgIDogZXhwZWN0ZWREZXNjc1swXTtcblxuICAgICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFwiXFxcIlwiICsgc3RyaW5nRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcblxuICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkRGVzYyArIFwiIGJ1dCBcIiArIGZvdW5kRGVzYyArIFwiIGZvdW5kLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpLFxuICAgICAgICAgIGZvdW5kICAgICAgPSBwb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocG9zKSA6IG51bGw7XG5cbiAgICAgIGlmIChleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcG9zRGV0YWlscy5saW5lLFxuICAgICAgICBwb3NEZXRhaWxzLmNvbHVtblxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzdGFydCgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgczAgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdFBhdHRlcm4oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBzMiA9IHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRFbGVtZW50KCk7XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VzdHJpbmcoKTtcbiAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VvY3RvdGhvcnBlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0RWxlbWVudCgpO1xuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZXN0cmluZygpO1xuICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VvY3RvdGhvcnBlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxKHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtZXNzYWdlRm9ybWF0RWxlbWVudCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XG4gICAgICAgIHMxID0gcGVnJGMzO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VpZCgpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckYzY7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlZWxlbWVudEZvcm1hdCgpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNSA9IFtzNSwgczZdO1xuICAgICAgICAgICAgICAgIHM0ID0gczU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICAgICAgICBzNiA9IHBlZyRjODtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5KTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzEwKHMzLCBzNCk7XG4gICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZWxlbWVudEZvcm1hdCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczc7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGMxMSkge1xuICAgICAgICAgIHMyID0gcGVnJGMxMTtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VwbHVyYWxGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzEzKHMyLCBzNik7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTMpID09PSBwZWckYzE0KSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjMTQ7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE1KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRjNjtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlcGx1cmFsRm9ybWF0UGF0dGVybigpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTMoczIsIHM2KTtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzE2KSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJGMxNjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE3KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgICBzNCA9IHBlZyRjNjtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlc2VsZWN0Rm9ybWF0UGF0dGVybigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzEzKHMyLCBzNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlaWQoKTtcbiAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWFyZ1N0eWxlUGF0dGVybigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWFyZ1N0eWxlUGF0dGVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzE4KHMyLCBzMyk7XG4gICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcGx1cmFsRm9ybWF0UGF0dGVybigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlb2Zmc2V0UGF0dGVybigpO1xuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlcGx1cmFsRm9ybSgpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VwbHVyYWxGb3JtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMxOShzMSwgczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VvZmZzZXRQYXR0ZXJuKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzIwKSB7XG4gICAgICAgICAgczIgPSBwZWckYzIwO1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzIyO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlZGlnaXRzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzI0KHM2KTtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcGx1cmFsRm9ybSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VwbHVyYWxLZXkoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjMztcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdFBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckYzg7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzI1KHMyLCBzNik7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXBsdXJhbEtleSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VpZCgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMjYoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYxKSB7XG4gICAgICAgICAgczEgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZWRpZ2l0cygpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMjQoczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzZWxlY3RGb3JtYXRQYXR0ZXJuKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VzZWxlY3RGb3JtKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VzZWxlY3RGb3JtKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMjkoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXNlbGVjdEZvcm0oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzODtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlaWQoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjMztcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdFBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckYzg7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzI1KHMyLCBzNik7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWFyZ1N0eWxlUGF0dGVybigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgIHMyID0gcGVnJGM2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VpZCgpO1xuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMzAoczQpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VvY3RvdGhvcnBlKCkge1xuICAgICAgdmFyIHMwLCBzMTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzUpIHtcbiAgICAgICAgczEgPSBwZWckYzMxO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzIpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMzMygpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0cmluZygpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIHMyID0gcGVnJHBhcnNlY2hhcnMoKTtcbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZWNoYXJzKCk7XG4gICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMzQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWlkKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAocGVnJGMzNi50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNyk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNSA9IFtdO1xuICAgICAgICAgIGlmIChwZWckYzM4LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzOSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNS5wdXNoKHM2KTtcbiAgICAgICAgICAgIGlmIChwZWckYzM4LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzkpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBbczQsIHM1XTtcbiAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHMyID0gczM7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNDAoczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cbiAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM1KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlY2hhcnMoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBzMiA9IHBlZyRwYXJzZWNoYXIoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZWNoYXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM0MShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlY2hhcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKHBlZyRjNDIudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Myk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzQ0KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNDUpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjNDU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ2KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM0NygpO1xuICAgICAgICB9XG4gICAgICAgIHMwID0gczE7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNDgpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJGM0ODtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM1MCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzUxKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGM1MTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjNTMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNTQpIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNTQ7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU1KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1NigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNTcpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1NztcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1OCk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzMiA9IHBlZyRwYXJzZWhleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWhleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZWhleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1OShzMiwgczMsIHM0LCBzNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZGlnaXRzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjNjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBpZiAocGVnJGM2MC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjEpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMjtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzYyKHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VoZXhEaWdpdCgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKHBlZyRjNjMudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZV8oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIHMyID0gcGVnJHBhcnNld2hpdGVzcGFjZSgpO1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzY2KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NSk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXdoaXRlc3BhY2UoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChwZWckYzY3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjgpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgICBwYXJzZTogICAgICAgcGFyc2VcbiAgfTtcbn0oKSkucGFyc2U7XG5cblxuLyoqIEBmaWxlIG1lc3NhZ2Vmb3JtYXQuanMgLSBJQ1UgUGx1cmFsRm9ybWF0ICsgU2VsZWN0Rm9ybWF0IGZvciBKYXZhU2NyaXB0XG4gKiAgQGF1dGhvciBBbGV4IFNleHRvbiAtIEBTbGV4QXh0b25cbiAqICBAdmVyc2lvbiAwLjMuMC0xXG4gKiAgQGNvcHlyaWdodCAyMDEyLTIwMTUgQWxleCBTZXh0b24sIEVlbWVsaSBBcm8sIGFuZCBDb250cmlidXRvcnNcbiAqICBAbGljZW5zZSBUbyB1c2Ugb3IgZm9yaywgTUlULiBUbyBjb250cmlidXRlIGJhY2ssIERvam8gQ0xBICAqL1xuXG5cbi8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBxdW90aW5nIGFuIE9iamVjdCdzIGtleSB2YWx1ZSBpZmYgcmVxdWlyZWRcbiAqICBAcHJpdmF0ZSAgKi9cbmZ1bmN0aW9uIHByb3BuYW1lKGtleSwgb2JqKSB7XG4gIGlmICgvXltBLVpfJF1bMC05QS1aXyRdKiQvaS50ZXN0KGtleSkpIHtcbiAgICByZXR1cm4gb2JqID8gb2JqICsgJy4nICsga2V5IDoga2V5O1xuICB9IGVsc2Uge1xuICAgIHZhciBqa2V5ID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICByZXR1cm4gb2JqID8gb2JqICsgJ1snICsgamtleSArICddJyA6IGprZXk7XG4gIH1cbn07XG5cblxuLyoqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIGZvcm1hdHRlclxuICpcbiAqICBAY2xhc3NcbiAqICBAZ2xvYmFsXG4gKiAgQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtsb2NhbGU9XCJlblwiXSAtIFRoZSBsb2NhbGUgdG8gdXNlLCB3aXRoIGZhbGxiYWNrc1xuICogIEBwYXJhbSB7ZnVuY3Rpb259IFtwbHVyYWxGdW5jXSAtIE9wdGlvbmFsIGN1c3RvbSBwbHVyYWxpemF0aW9uIGZ1bmN0aW9uXG4gKiAgQHBhcmFtIHtmdW5jdGlvbltdfSBbZm9ybWF0dGVyc10gLSBPcHRpb25hbCBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbnMgICovXG5mdW5jdGlvbiBNZXNzYWdlRm9ybWF0KGxvY2FsZSwgcGx1cmFsRnVuYywgZm9ybWF0dGVycykge1xuICB0aGlzLmxjID0gW2xvY2FsZV07ICBcbiAgdGhpcy5ydW50aW1lLnBsdXJhbEZ1bmNzID0ge307XG4gIHRoaXMucnVudGltZS5wbHVyYWxGdW5jc1t0aGlzLmxjWzBdXSA9IHBsdXJhbEZ1bmM7XG4gIHRoaXMucnVudGltZS5mbXQgPSB7fTtcbiAgaWYgKGZvcm1hdHRlcnMpIGZvciAodmFyIGYgaW4gZm9ybWF0dGVycykge1xuICAgIHRoaXMucnVudGltZS5mbXRbZl0gPSBmb3JtYXR0ZXJzW2ZdO1xuICB9XG59XG5cblxuXG5cbi8qKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgdG8gaXRzIEFTVFxuICpcbiAqICBQcmVjb21waWxlZCBmcm9tIGBsaWIvbWVzc2FnZWZvcm1hdC1wYXJzZXIucGVnanNgIGJ5XG4gKiAge0BsaW5rIGh0dHA6Ly9wZWdqcy5vcmcvIFBFRy5qc30uIEluY2x1ZGVkIGluIE1lc3NhZ2VGb3JtYXQgb2JqZWN0XG4gKiAgdG8gZW5hYmxlIHRlc3RpbmcuXG4gKlxuICogIEBwcml2YXRlICAqL1xuXG5cblxuLyoqIFBsdXJhbGl6YXRpb24gZnVuY3Rpb25zIGZyb21cbiAqICB7QGxpbmsgaHR0cDovL2dpdGh1Yi5jb20vZWVtZWxpL21ha2UtcGx1cmFsLmpzIG1ha2UtcGx1cmFsfVxuICpcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdFxuICogIEB0eXBlIE9iamVjdC48c3RyaW5nLGZ1bmN0aW9uPiAgKi9cbk1lc3NhZ2VGb3JtYXQucGx1cmFscyA9IHt9O1xuXG5cbi8qKiBEZWZhdWx0IG51bWJlciBmb3JtYXR0aW5nIGZ1bmN0aW9ucyBpbiB0aGUgc3R5bGUgb2YgSUNVJ3NcbiAqICB7QGxpbmsgaHR0cDovL2ljdS1wcm9qZWN0Lm9yZy9hcGlyZWYvaWN1NGovY29tL2libS9pY3UvdGV4dC9NZXNzYWdlRm9ybWF0Lmh0bWwgc2ltcGxlQXJnIHN5bnRheH1cbiAqICBpbXBsZW1lbnRlZCB1c2luZyB0aGVcbiAqICB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCBJbnRsfVxuICogIG9iamVjdCBkZWZpbmVkIGJ5IEVDTUEtNDAyLlxuICpcbiAqICAqKk5vdGUqKjogSW50bCBpcyBub3QgZGVmaW5lZCBpbiBkZWZhdWx0IE5vZGUgdW50aWwgMC4xMS4xNSAvIDAuMTIuMCwgc29cbiAqICBlYXJsaWVyIHZlcnNpb25zIHJlcXVpcmUgYSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW50bCBwb2x5ZmlsbH0uXG4gKiAgVGhlcmVmb3JlIHtAbGluayBNZXNzYWdlRm9ybWF0LndpdGhJbnRsU3VwcG9ydH0gbmVlZHMgdG8gYmUgdHJ1ZSBmb3IgdGhlc2VcbiAqICBmdW5jdGlvbnMgdG8gYmUgYXZhaWxhYmxlIGZvciBpbmNsdXNpb24gaW4gdGhlIG91dHB1dC5cbiAqXG4gKiAgQHNlZSBNZXNzYWdlRm9ybWF0I3NldEludGxTdXBwb3J0XG4gKlxuICogIEBuYW1lc3BhY2VcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdFxuICogIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG51bWJlciAtIFJlcHJlc2VudCBhIG51bWJlciBhcyBhbiBpbnRlZ2VyLCBwZXJjZW50IG9yIGN1cnJlbmN5IHZhbHVlXG4gKiAgQHByb3BlcnR5IHtmdW5jdGlvbn0gZGF0ZSAtIFJlcHJlc2VudCBhIGRhdGUgYXMgYSBmdWxsL2xvbmcvZGVmYXVsdC9zaG9ydCBzdHJpbmdcbiAqICBAcHJvcGVydHkge2Z1bmN0aW9ufSB0aW1lIC0gUmVwcmVzZW50IGEgdGltZSBhcyBhIGZ1bGwvbG9uZy9kZWZhdWx0L3Nob3J0IHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZVxuICogID4gdmFyIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0Jyk7XG4gKiAgPiB2YXIgbWYgPSAobmV3IE1lc3NhZ2VGb3JtYXQoJ2VuJykpLnNldEludGxTdXBwb3J0KHRydWUpO1xuICogID4gbWYuY3VycmVuY3kgPSAnRVVSJztcbiAqICA+IHZhciBtZnVuYyA9IG1mLmNvbXBpbGUoXCJUaGUgdG90YWwgaXMge1YsbnVtYmVyLGN1cnJlbmN5fS5cIik7XG4gKiAgPiBtZnVuYyh7Vjo1LjV9KVxuICogIFwiVGhlIHRvdGFsIGlzIOKCrDUuNTAuXCJcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICA+IHZhciBNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnbWVzc2FnZWZvcm1hdCcpO1xuICogID4gdmFyIG1mID0gbmV3IE1lc3NhZ2VGb3JtYXQoJ2VuJywgbnVsbCwge251bWJlcjogTWVzc2FnZUZvcm1hdC5udW1iZXJ9KTtcbiAqICA+IG1mLmN1cnJlbmN5ID0gJ0VVUic7XG4gKiAgPiB2YXIgbWZ1bmMgPSBtZi5jb21waWxlKFwiVGhlIHRvdGFsIGlzIHtWLG51bWJlcixjdXJyZW5jeX0uXCIpO1xuICogID4gbWZ1bmMoe1Y6NS41fSlcbiAqICBcIlRoZSB0b3RhbCBpcyDigqw1LjUwLlwiICAqL1xuTWVzc2FnZUZvcm1hdC5mb3JtYXR0ZXJzID0ge307XG5cbi8qKiBFbmFibGUgb3IgZGlzYWJsZSBzdXBwb3J0IGZvciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXJzLCB3aGljaCByZXF1aXJlIHRoZVxuICogIGBJbnRsYCBvYmplY3QuIE5vdGUgdGhhdCB0aGlzIGNhbid0IGJlIGF1dG9kZXRlY3RlZCwgYXMgdGhlIGVudmlyb25tZW50XG4gKiAgaW4gd2hpY2ggdGhlIGZvcm1hdHRlZCB0ZXh0IGlzIGNvbXBpbGVkIGludG8gSmF2YXNjcmlwdCBmdW5jdGlvbnMgaXMgbm90XG4gKiAgbmVjZXNzYXJpbHkgdGhlIHNhbWUgZW52aXJvbm1lbnQgaW4gd2hpY2ggdGhleSB3aWxsIGdldCBleGVjdXRlZC5cbiAqXG4gKiAgQHNlZSBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnNcbiAqXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFtlbmFibGU9dHJ1ZV1cbiAqICBAcmV0dXJucyB7T2JqZWN0fSBUaGUgTWVzc2FnZUZvcm1hdCBpbnN0YW5jZSwgdG8gYWxsb3cgZm9yIGNoYWluaW5nXG4gKiAgQGV4YW1wbGVcbiAqICA+IHZhciBJbnRsID0gcmVxdWlyZSgnaW50bCcpO1xuICogID4gdmFyIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0Jyk7XG4gKiAgPiB2YXIgbWYgPSAobmV3IE1lc3NhZ2VGb3JtYXQoJ2VuJykpLnNldEludGxTdXBwb3J0KHRydWUpO1xuICogID4gbWYuY3VycmVuY3kgPSAnRVVSJztcbiAqICA+IG1mLmNvbXBpbGUoXCJUaGUgdG90YWwgaXMge1YsbnVtYmVyLGN1cnJlbmN5fS5cIikoe1Y6NS41fSk7XG4gKiAgXCJUaGUgdG90YWwgaXMg4oKsNS41MC5cIiAgKi9cblxuXG5cbi8qKiBBIHNldCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGFyZSBjYWxsZWQgYnkgdGhlIGNvbXBpbGVkIEphdmFzY3JpcHRcbiAqICBmdW5jdGlvbnMsIHRoZXNlIGFyZSBpbmNsdWRlZCBsb2NhbGx5IGluIHRoZSBvdXRwdXQgb2Yge0BsaW5rXG4gKiAgTWVzc2FnZUZvcm1hdCNjb21waWxlIGNvbXBpbGUoKX0uXG4gKlxuICogIEBuYW1lc3BhY2VcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdCAgKi9cbk1lc3NhZ2VGb3JtYXQucHJvdG90eXBlLnJ1bnRpbWUgPSB7XG5cbiAgLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGAjYCBpbiBwbHVyYWwgcnVsZXNcbiAgICpcbiAgICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBvcGVyYXRlIG9uXG4gICAqICBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIEFuIG9wdGlvbmFsIG9mZnNldCwgc2V0IGJ5IHRoZSBzdXJyb3VuZGluZyBjb250ZXh0ICAqL1xuICBudW1iZXI6IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyB2YWx1ZSArIFwiJyBpc24ndCBhIG51bWJlci5cIik7XG4gICAgcmV0dXJuIHZhbHVlIC0gKG9mZnNldCB8fCAwKTtcbiAgfSxcblxuICAvKiogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYHtOLCBwbHVyYWx8c2VsZWN0b3JkaW5hbCwgLi4ufWBcbiAgICpcbiAgICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYSBwbHVyYWxpemF0aW9uIHJ1bGVcbiAgICogIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBBbiBvZmZzZXQgdG8gYXBwbHkgdG8gYHZhbHVlYFxuICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gbGNmdW5jIC0gQSBsb2NhbGUgZnVuY3Rpb24gZnJvbSBgcGx1cmFsRnVuY3NgXG4gICAqICBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IGRhdGEgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggcmVzdWx0cyBhcmUgbG9va2VkIHVwXG4gICAqICBAcGFyYW0gez9ib29sZWFufSBpc09yZGluYWwgLSBJZiB0cnVlLCB1c2Ugb3JkaW5hbCByYXRoZXIgdGhhbiBjYXJkaW5hbCBydWxlc1xuICAgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBvZiB0aGUgcGx1cmFsaXphdGlvbiAgKi9cbiAgcGx1cmFsOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBsY2Z1bmMsIGRhdGEsIGlzT3JkaW5hbCkge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHZhbHVlKSkgcmV0dXJuIGRhdGFbdmFsdWVdKCk7XG4gICAgaWYgKG9mZnNldCkgdmFsdWUgLT0gb2Zmc2V0O1xuICAgIHZhciBrZXkgPSBsY2Z1bmModmFsdWUsIGlzT3JkaW5hbCk7XG4gICAgaWYgKGtleSBpbiBkYXRhKSByZXR1cm4gZGF0YVtrZXldKCk7XG4gICAgcmV0dXJuIGRhdGEub3RoZXIoKTtcbiAgfSxcblxuICAvKiogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYHtOLCBzZWxlY3QsIC4uLn1gXG4gICAqXG4gICAqICBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUga2V5IHRvIHVzZSB0byBmaW5kIGEgc2VsZWN0aW9uXG4gICAqICBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IGRhdGEgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggcmVzdWx0cyBhcmUgbG9va2VkIHVwXG4gICAqICBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IG9mIHRoZSBzZWxlY3Qgc3RhdGVtZW50ICAqL1xuICBzZWxlY3Q6IGZ1bmN0aW9uKHZhbHVlLCBkYXRhKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcbiAgICByZXR1cm4gZGF0YS5vdGhlcigpXG4gIH0sXG5cbiAgLyoqIFBsdXJhbGl6YXRpb24gZnVuY3Rpb25zIGluY2x1ZGVkIGluIGNvbXBpbGVkIG91dHB1dFxuICAgKiAgQGluc3RhbmNlXG4gICAqICBAdHlwZSBPYmplY3QuPHN0cmluZyxmdW5jdGlvbj4gICovXG4gIHBsdXJhbEZ1bmNzOiB7fSxcblxuICAvKiogQ3VzdG9tIGZvcm1hdHRpbmcgZnVuY3Rpb25zIGNhbGxlZCBieSBge3ZhciwgZm5bLCBhcmdzXSp9YCBzeW50YXhcbiAgICpcbiAgICogIEZvciBleGFtcGxlcywgc2VlIHtAbGluayBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnN9XG4gICAqXG4gICAqICBAaW5zdGFuY2VcbiAgICogIEBzZWUgTWVzc2FnZUZvcm1hdC5mb3JtYXR0ZXJzXG4gICAqICBAdHlwZSBPYmplY3QuPHN0cmluZyxmdW5jdGlvbj4gICovXG4gIGZtdDoge30sXG5cbiAgLyoqIEN1c3RvbSBzdHJpbmdpZmllciB0byBjbGVhbiB1cCBicm93c2VyIGluY29uc2lzdGVuY2llc1xuICAgKiAgQGluc3RhbmNlICAqL1xuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfc3RyaW5naWZ5ID0gZnVuY3Rpb24obywgbGV2ZWwpIHtcbiAgICAgIGlmICh0eXBlb2YgbyAhPSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgZnVuY1N0ciA9IG8udG9TdHJpbmcoKS5yZXBsYWNlKC9eKGZ1bmN0aW9uIClcXHcqLywgJyQxJyk7XG4gICAgICAgIHZhciBpbmRlbnQgPSAvKFsgXFx0XSopXFxTLiokLy5leGVjKGZ1bmNTdHIpO1xuICAgICAgICByZXR1cm4gaW5kZW50ID8gZnVuY1N0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgaW5kZW50WzFdLCAnbWcnKSwgJycpIDogZnVuY1N0cjtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gW107XG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChpICE9ICd0b1N0cmluZycpIHtcbiAgICAgICAgaWYgKGxldmVsID09IDApIHMucHVzaCgndmFyICcgKyBpICsgJyA9ICcgKyBfc3RyaW5naWZ5KG9baV0sIGxldmVsICsgMSkgKyAnO1xcbicpO1xuICAgICAgICBlbHNlIHMucHVzaChwcm9wbmFtZShpKSArICc6ICcgKyBfc3RyaW5naWZ5KG9baV0sIGxldmVsICsgMSkpO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsID09IDApIHJldHVybiBzLmpvaW4oJycpO1xuICAgICAgaWYgKHMubGVuZ3RoID09IDApIHJldHVybiAne30nO1xuICAgICAgdmFyIGluZGVudCA9ICcgICc7IHdoaWxlICgtLWxldmVsKSBpbmRlbnQgKz0gJyAgJztcbiAgICAgIHJldHVybiAne1xcbicgKyBzLmpvaW4oJyxcXG4nKS5yZXBsYWNlKC9eL2dtLCBpbmRlbnQpICsgJ1xcbn0nO1xuICAgIH07XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkodGhpcywgMCk7XG4gIH1cbn07XG5cblxuLyoqIFJlY3Vyc2l2ZWx5IG1hcCBhbiBBU1QgdG8gaXRzIHJlc3VsdGluZyBzdHJpbmdcbiAqXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcbiAqXG4gKiAgQHBhcmFtIGFzdCAtIHRoZSBBc3Qgbm9kZSBmb3Igd2hpY2ggdGhlIEpTIGNvZGUgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICpcbiAqICBAcHJpdmF0ZSAgKi9cbk1lc3NhZ2VGb3JtYXQucHJvdG90eXBlLl9wcmVjb21waWxlID0gZnVuY3Rpb24oYXN0LCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHsga2V5czoge30sIG9mZnNldDoge30gfTtcbiAgdmFyIHIgPSBbXSwgaSwgdG1wLCBhcmdzID0gW107XG5cbiAgc3dpdGNoICggYXN0LnR5cGUgKSB7XG4gICAgY2FzZSAnbWVzc2FnZUZvcm1hdFBhdHRlcm4nOlxuICAgICAgZm9yICggaSA9IDA7IGkgPCBhc3Quc3RhdGVtZW50cy5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgci5wdXNoKHRoaXMuX3ByZWNvbXBpbGUoIGFzdC5zdGF0ZW1lbnRzW2ldLCBkYXRhICkpO1xuICAgICAgfVxuICAgICAgdG1wID0gci5qb2luKCcgKyAnKSB8fCAnXCJcIic7XG4gICAgICByZXR1cm4gZGF0YS5wZl9jb3VudCA/IHRtcCA6ICdmdW5jdGlvbihkKSB7IHJldHVybiAnICsgdG1wICsgJzsgfSc7XG5cbiAgICBjYXNlICdtZXNzYWdlRm9ybWF0RWxlbWVudCc6XG4gICAgICBkYXRhLnBmX2NvdW50ID0gZGF0YS5wZl9jb3VudCB8fCAwO1xuICAgICAgaWYgKCBhc3Qub3V0cHV0ICkge1xuICAgICAgICByZXR1cm4gcHJvcG5hbWUoYXN0LmFyZ3VtZW50SW5kZXgsICdkJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGF0YS5rZXlzW2RhdGEucGZfY291bnRdID0gYXN0LmFyZ3VtZW50SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVjb21waWxlKCBhc3QuZWxlbWVudEZvcm1hdCwgZGF0YSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgY2FzZSAnZWxlbWVudEZvcm1hdCc6XG4gICAgICBhcmdzID0gWyBwcm9wbmFtZShkYXRhLmtleXNbZGF0YS5wZl9jb3VudF0sICdkJykgXTtcbiAgICAgIHN3aXRjaCAoYXN0LmtleSkge1xuICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLl9wcmVjb21waWxlKGFzdC52YWwsIGRhdGEpKTtcbiAgICAgICAgICByZXR1cm4gJ3NlbGVjdCgnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuICAgICAgICBjYXNlICdzZWxlY3RvcmRpbmFsJzpcbiAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoWyAwLCBwcm9wbmFtZSh0aGlzLmxjWzBdLCAncGx1cmFsRnVuY3MnKSwgdGhpcy5fcHJlY29tcGlsZShhc3QudmFsLCBkYXRhKSwgMSBdKTtcbiAgICAgICAgICByZXR1cm4gJ3BsdXJhbCgnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuICAgICAgICBjYXNlICdwbHVyYWwnOlxuICAgICAgICAgIGRhdGEub2Zmc2V0W2RhdGEucGZfY291bnQgfHwgMF0gPSBhc3QudmFsLm9mZnNldCB8fCAwO1xuICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbIGRhdGEub2Zmc2V0W2RhdGEucGZfY291bnRdIHx8IDAsIHByb3BuYW1lKHRoaXMubGNbMF0sICdwbHVyYWxGdW5jcycpLCB0aGlzLl9wcmVjb21waWxlKGFzdC52YWwsIGRhdGEpIF0pO1xuICAgICAgICAgIHJldHVybiAncGx1cmFsKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHRoaXMud2l0aEludGxTdXBwb3J0ICYmICEoYXN0LmtleSBpbiB0aGlzLnJ1bnRpbWUuZm10KSAmJiAoYXN0LmtleSBpbiBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnMpKSB7XG4gICAgICAgICAgICB0bXAgPSBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnNbYXN0LmtleV07XG4gICAgICAgICAgICB0aGlzLnJ1bnRpbWUuZm10W2FzdC5rZXldID0gKHR5cGVvZiB0bXAodGhpcykgPT0gJ2Z1bmN0aW9uJykgPyB0bXAodGhpcykgOiB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3MucHVzaChKU09OLnN0cmluZ2lmeSh0aGlzLmxjKSk7XG4gICAgICAgICAgaWYgKGFzdC52YWwgJiYgYXN0LnZhbC5sZW5ndGgpIGFyZ3MucHVzaChKU09OLnN0cmluZ2lmeShhc3QudmFsLmxlbmd0aCA9PSAxID8gYXN0LnZhbFswXSA6IGFzdC52YWwpKTtcbiAgICAgICAgICByZXR1cm4gJ2ZtdC4nICsgYXN0LmtleSArICcoJyArIGFyZ3Muam9pbignLCAnKSArICcpJztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3BsdXJhbEZvcm1hdFBhdHRlcm4nOlxuICAgIGNhc2UgJ3NlbGVjdEZvcm1hdFBhdHRlcm4nOlxuICAgICAgZGF0YS5wZl9jb3VudCA9IGRhdGEucGZfY291bnQgfHwgMDtcbiAgICAgIGlmIChhc3QudHlwZSA9PSAnc2VsZWN0Rm9ybWF0UGF0dGVybicpIGRhdGEub2Zmc2V0W2RhdGEucGZfY291bnRdID0gMDtcbiAgICAgIHZhciBuZWVkT3RoZXIgPSB0cnVlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFzdC5wbHVyYWxGb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gYXN0LnBsdXJhbEZvcm1zW2ldLmtleTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ290aGVyJykgbmVlZE90aGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhX2NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgZGF0YV9jb3B5LnBmX2NvdW50Kys7XG4gICAgICAgIHIucHVzaChwcm9wbmFtZShrZXkpICsgJzogZnVuY3Rpb24oKSB7IHJldHVybiAnICsgdGhpcy5fcHJlY29tcGlsZShhc3QucGx1cmFsRm9ybXNbaV0udmFsLCBkYXRhX2NvcHkpICsgJzt9Jyk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZE90aGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyAnb3RoZXInIGZvcm0gZm91bmQgaW4gXCIgKyBhc3QudHlwZSArIFwiIFwiICsgZGF0YS5wZl9jb3VudCk7XG4gICAgICByZXR1cm4gJ3sgJyArIHIuam9pbignLCAnKSArICcgfSc7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFzdC52YWwgfHwgXCJcIik7XG5cbiAgICBjYXNlICdvY3RvdGhvcnBlJzpcbiAgICAgIGlmICghZGF0YS5wZl9jb3VudCkgcmV0dXJuICdcIiNcIic7XG4gICAgICBhcmdzID0gWyBwcm9wbmFtZShkYXRhLmtleXNbZGF0YS5wZl9jb3VudC0xXSwgJ2QnKSBdO1xuICAgICAgaWYgKGRhdGEub2Zmc2V0W2RhdGEucGZfY291bnQtMV0pIGFyZ3MucHVzaChkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50LTFdKTtcbiAgICAgIHJldHVybiAnbnVtYmVyKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCAnQmFkIEFTVCB0eXBlOiAnICsgYXN0LnR5cGUgKTtcbiAgfVxufTtcblxuLyoqIENvbXBpbGUgbWVzc2FnZXMgaW50byBhbiBleGVjdXRhYmxlIGZ1bmN0aW9uIHdpdGggY2xlYW4gc3RyaW5nXG4gKiAgcmVwcmVzZW50YXRpb24uXG4gKlxuICogIElmIGBtZXNzYWdlc2AgaXMgYSBzaW5nbGUgc3RyaW5nIGluY2x1ZGluZyBJQ1UgTWVzc2FnZUZvcm1hdCBkZWNsYXJhdGlvbnMsXG4gKiAgYG9wdGAgaXMgaWdub3JlZCBhbmQgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIE9iamVjdCBwYXJhbWV0ZXJcbiAqICBgZGAgcmVwcmVzZW50aW5nIGVhY2ggb2YgdGhlIGlucHV0J3MgZGVmaW5lZCB2YXJpYWJsZXMuIFRoZSByZXR1cm5lZFxuICogIGZ1bmN0aW9uIHdpbGwgYmUgZGVmaW5lZCBpbiBhIGxvY2FsIHNjb3BlIHRoYXQgaW5jbHVkZXMgYWxsIHRoZSByZXF1aXJlZFxuICogIHJ1bnRpbWUgdmFyaWFibGVzLlxuICpcbiAqICBJZiBgbWVzc2FnZXNgIGlzIGEgbWFwIG9mIGtleXMgdG8gc3RyaW5ncywgb3IgYSBtYXAgb2YgbmFtZXNwYWNlIGtleXMgdG9cbiAqICBzdWNoIGtleS9zdHJpbmcgbWFwcywgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgZmlsbCB0aGUgc3BlY2lmaWVkIGdsb2JhbFxuICogIHdpdGggamF2YXNjcmlwdCBmdW5jdGlvbnMgbWF0Y2hpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgaW5wdXQuIEluIHN1Y2ggdXNlLFxuICogIHRoZSBvdXRwdXQgb2YgYGNvbXBpbGUoKWAgaXMgZXhwZWN0ZWQgdG8gYmUgc2VyaWFsaXplZCB1c2luZyBgLnRvU3RyaW5nKClgLFxuICogIGFuZCB3aWxsIGluY2x1ZGUgZGVmaW5pdGlvbnMgb2YgdGhlIHJ1bnRpbWUgZnVuY3Rpb25zLiBJZiBgb3B0Lmdsb2JhbGAgaXNcbiAqICBudWxsLCBjYWxsaW5nIHRoZSBvdXRwdXQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIG9iamVjdCBpdHNlbGYuXG4gKlxuICogIFRvZ2V0aGVyLCB0aGUgaW5wdXQgcGFyYW1ldGVycyBzaG91bGQgbWF0Y2ggdGhlIGZvbGxvd2luZyBwYXR0ZXJuczpcbiAqICBgYGBqc1xuICogIG1lc3NhZ2VzID0gXCJzdHJpbmdcIiB8fCB7IGtleTA6IFwic3RyaW5nMFwiLCBrZXkxOiBcInN0cmluZzFcIiwgLi4uIH0gfHwge1xuICogICAgbnMwOiB7IGtleTA6IFwic3RyaW5nMFwiLCBrZXkxOiBcInN0cmluZzFcIiwgLi4uICB9LFxuICogICAgbnMxOiB7IGtleTA6IFwic3RyaW5nMFwiLCBrZXkxOiBcInN0cmluZzFcIiwgLi4uICB9LFxuICogICAgLi4uXG4gKiAgfVxuICpcbiAqICBvcHQgPSBudWxsIHx8IHtcbiAqICAgIGxvY2FsZTogbnVsbCB8fCB7XG4gKiAgICAgIG5zMDogXCJsYzBcIiB8fCBbIFwibGMwXCIsIC4uLiBdLFxuICogICAgICBuczE6IFwibGMxXCIgfHwgWyBcImxjMVwiLCAuLi4gXSxcbiAqICAgICAgLi4uXG4gKiAgICB9LFxuICogICAgZ2xvYmFsOiBudWxsIHx8IFwibW9kdWxlLmV4cG9ydHNcIiB8fCBcImV4cG9ydHNcIiB8fCBcImkxOG5cIiB8fCAuLi5cbiAqICB9XG4gKiAgYGBgXG4gKlxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XG4gKiAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fVxuICogICAgICBtZXNzYWdlcyAtIFRoZSBpbnB1dCBtZXNzYWdlKHMpIHRvIGJlIGNvbXBpbGVkLCBpbiBJQ1UgTWVzc2FnZUZvcm1hdFxuICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0PXt9XSAtIE9wdGlvbnMgY29udHJvbGxpbmcgb3V0cHV0IGZvciBub24tc2ltcGxlIGludHB1dFxuICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0LmxvY2FsZV0gLSBUaGUgbG9jYWxlcyB0byB1c2UgZm9yIHRoZSBtZXNzYWdlcywgd2l0aCBhXG4gKiAgICAgIHN0cnVjdHVyZSBtYXRjaGluZyB0aGF0IG9mIGBtZXNzYWdlc2BcbiAqICBAcGFyYW0ge3N0cmluZ30gW29wdC5nbG9iYWw9XCJcIl0gLSBUaGUgZ2xvYmFsIHZhcmlhYmxlIHRoYXQgdGhlIG91dHB1dFxuICogICAgICBmdW5jdGlvbiBzaG91bGQgdXNlLCBvciBhIG51bGwgc3RyaW5nIGZvciBub25lLiBcImV4cG9ydHNcIiBhbmRcbiAqICAgICAgXCJtb2R1bGUuZXhwb3J0c1wiIGFyZSByZWNvZ25pc2VkIGFzIHNwZWNpYWwgY2FzZXMuXG4gKiAgQHJldHVybnMge2Z1bmN0aW9ufSBUaGUgZmlyc3QgbWF0Y2ggZm91bmQgZm9yIHRoZSBnaXZlbiBsb2NhbGUocylcbiAqXG4gKiAgQGV4YW1wbGVcbiAqID4gdmFyIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0JyksXG4gKiAuLi4gICBtZiA9IG5ldyBNZXNzYWdlRm9ybWF0KCdlbicpLFxuICogLi4uICAgbWZ1bmMwID0gbWYuY29tcGlsZSgnQSB7VFlQRX0gZXhhbXBsZS4nKTtcbiAqID4gbWZ1bmMwKHtUWVBFOidzaW1wbGUnfSlcbiAqICdBIHNpbXBsZSBleGFtcGxlLidcbiAqID4gbWZ1bmMwLnRvU3RyaW5nKClcbiAqICdmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJBIFwiICsgZC5UWVBFICsgXCIgZXhhbXBsZS5cIjsgfSdcbiAqXG4gKiAgQGV4YW1wbGVcbiAqID4gdmFyIG1zZ1NldCA9IHsgYTogJ0Ege1RZUEV9IGV4YW1wbGUuJyxcbiAqIC4uLiAgICAgICAgICAgICAgYjogJ1RoaXMgaGFzIHtDT1VOVCwgcGx1cmFsLCBvbmV7b25lIG1lbWJlcn0gb3RoZXJ7IyBtZW1iZXJzfX0uJyB9LFxuICogLi4uICAgbWZ1bmNTZXQgPSBtZi5jb21waWxlKG1zZ1NldCk7XG4gKiA+IG1mdW5jU2V0KCkuYSh7VFlQRTonbW9yZSBjb21wbGV4J30pXG4gKiAnQSBtb3JlIGNvbXBsZXggZXhhbXBsZS4nXG4gKiA+IG1mdW5jU2V0KCkuYih7Q09VTlQ6Mn0pXG4gKiAnVGhpcyBoYXMgMiBtZW1iZXJzLidcbiAqXG4gKiA+IGNvbnNvbGUubG9nKG1mdW5jU2V0LnRvU3RyaW5nKCkpXG4gKiBmdW5jdGlvbiBhbm9ueW1vdXMoKSB7XG4gKiB2YXIgbnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQpIHtcbiAqICAgaWYgKGlzTmFOKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgdmFsdWUgKyBcIicgaXNuJ3QgYSBudW1iZXIuXCIpO1xuICogICByZXR1cm4gdmFsdWUgLSAob2Zmc2V0IHx8IDApO1xuICogfTtcbiAqIHZhciBwbHVyYWwgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbGNmdW5jLCBkYXRhLCBpc09yZGluYWwpIHtcbiAqICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcbiAqICAgaWYgKG9mZnNldCkgdmFsdWUgLT0gb2Zmc2V0O1xuICogICB2YXIga2V5ID0gbGNmdW5jKHZhbHVlLCBpc09yZGluYWwpO1xuICogICBpZiAoa2V5IGluIGRhdGEpIHJldHVybiBkYXRhW2tleV0oKTtcbiAqICAgcmV0dXJuIGRhdGEub3RoZXIoKTtcbiAqIH07XG4gKiB2YXIgc2VsZWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBkYXRhKSB7XG4gKiAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHZhbHVlKSkgcmV0dXJuIGRhdGFbdmFsdWVdKCk7XG4gKiAgIHJldHVybiBkYXRhLm90aGVyKClcbiAqIH07XG4gKiB2YXIgcGx1cmFsRnVuY3MgPSB7XG4gKiAgIGVuOiBmdW5jdGlvbiAobiwgb3JkKSB7XG4gKiAgICAgdmFyIHMgPSBTdHJpbmcobikuc3BsaXQoJy4nKSwgdjAgPSAhc1sxXSwgdDAgPSBOdW1iZXIoc1swXSkgPT0gbixcbiAqICAgICAgICAgbjEwID0gdDAgJiYgc1swXS5zbGljZSgtMSksIG4xMDAgPSB0MCAmJiBzWzBdLnNsaWNlKC0yKTtcbiAqICAgICBpZiAob3JkKSByZXR1cm4gKG4xMCA9PSAxICYmIG4xMDAgIT0gMTEpID8gJ29uZSdcbiAqICAgICAgICAgOiAobjEwID09IDIgJiYgbjEwMCAhPSAxMikgPyAndHdvJ1xuICogICAgICAgICA6IChuMTAgPT0gMyAmJiBuMTAwICE9IDEzKSA/ICdmZXcnXG4gKiAgICAgICAgIDogJ290aGVyJztcbiAqICAgICByZXR1cm4gKG4gPT0gMSAmJiB2MCkgPyAnb25lJyA6ICdvdGhlcic7XG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgZm10ID0ge307XG4gKlxuICogcmV0dXJuIHtcbiAqICAgYTogZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJBIFwiICsgZC5UWVBFICsgXCIgZXhhbXBsZS5cIjsgfSxcbiAqICAgYjogZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJUaGlzIGhhcyBcIiArIHBsdXJhbChkLkNPVU5ULCAwLCBwbHVyYWxGdW5jcy5lbiwgeyBvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJvbmUgbWVtYmVyXCI7fSwgb3RoZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVtYmVyKGQuQ09VTlQpK1wiIG1lbWJlcnNcIjt9IH0pICsgXCIuXCI7IH1cbiAqIH1cbiAqIH1cbiAqXG4gKiAgQGV4YW1wbGVcbiAqID4gbWYucnVudGltZS5wbHVyYWxGdW5jcy5maSA9IE1lc3NhZ2VGb3JtYXQucGx1cmFscy5maTtcbiAqID4gdmFyIG11bHRpU2V0ID0geyBlbjogeyBhOiAnQSB7VFlQRX0gZXhhbXBsZS4nLFxuICogLi4uICAgICAgICAgICAgICAgICAgICAgIGI6ICdUaGlzIGlzIHRoZSB7Q09VTlQsIHNlbGVjdG9yZGluYWwsIG9uZXsjc3R9IHR3b3sjbmR9IGZld3sjcmR9IG90aGVyeyN0aH19IGV4YW1wbGUuJyB9LFxuICogLi4uICAgICAgICAgICAgICAgIGZpOiB7IGE6ICd7VFlQRX0gZXNpbWVya2tpLicsXG4gKiAuLi4gICAgICAgICAgICAgICAgICAgICAgYjogJ1TDpG3DpCBvbiB7Q09VTlQsIHNlbGVjdG9yZGluYWwsIG90aGVyeyMufX0gZXNpbWVya2tpLicgfSB9LFxuICogLi4uICAgbXVsdGlTZXRMb2NhbGVzID0geyBlbjogJ2VuJywgZmk6ICdmaScgfSxcbiAqIC4uLiAgIG1mdW5jU2V0ID0gbWYuY29tcGlsZShtdWx0aVNldCwgeyBsb2NhbGU6IG11bHRpU2V0TG9jYWxlcywgZ2xvYmFsOiAnaTE4bicgfSk7XG4gKiA+IG1mdW5jU2V0KHRoaXMpO1xuICogPiBpMThuLmVuLmIoe0NPVU5UOjN9KVxuICogJ1RoaXMgaXMgdGhlIDNyZCBleGFtcGxlLidcbiAqID4gaTE4bi5maS5iKHtDT1VOVDozfSlcbiAqICdUw6Rtw6Qgb24gMy4gZXNpbWVya2tpLicgICovXG5NZXNzYWdlRm9ybWF0LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKCBtZXNzYWdlcywgb3B0ICkge1xuICB2YXIgciA9IHt9LCBsYzAgPSB0aGlzLmxjLFxuICAgICAgY29tcGlsZU1zZyA9IGZ1bmN0aW9uKHNlbGYsIG1zZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBhc3QgPSBNZXNzYWdlRm9ybWF0Ll9wYXJzZShtc2cpO1xuICAgICAgICAgIHJldHVybiBzZWxmLl9wcmVjb21waWxlKGFzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGFzdCA/ICdQcmVjb21waWxlcicgOiAnUGFyc2VyJykgKyAnIGVycm9yOiAnICsgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0cmluZ2lmeSA9IGZ1bmN0aW9uKHIsIGxldmVsKSB7XG4gICAgICAgIGlmICghbGV2ZWwpIGxldmVsID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiByICE9ICdvYmplY3QnKSByZXR1cm4gcjtcbiAgICAgICAgdmFyIG8gPSBbXSwgaW5kZW50ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWw7ICsraSkgaW5kZW50ICs9ICcgICc7XG4gICAgICAgIGZvciAodmFyIGsgaW4gcikgby5wdXNoKCdcXG4nICsgaW5kZW50ICsgJyAgJyArIHByb3BuYW1lKGspICsgJzogJyArIHN0cmluZ2lmeShyW2tdLCBsZXZlbCArIDEpKTtcbiAgICAgICAgcmV0dXJuICd7JyArIG8uam9pbignLCcpICsgJ1xcbicgKyBpbmRlbnQgKyAnfSc7XG4gICAgICB9O1xuXG4gIGlmICh0eXBlb2YgbWVzc2FnZXMgPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZiA9IG5ldyBGdW5jdGlvbihcbiAgICAgICAgJ251bWJlciwgcGx1cmFsLCBzZWxlY3QsIHBsdXJhbEZ1bmNzLCBmbXQnLFxuICAgICAgICAncmV0dXJuICcgKyBjb21waWxlTXNnKHRoaXMsIG1lc3NhZ2VzKSk7XG4gICAgcmV0dXJuIGYodGhpcy5ydW50aW1lLm51bWJlciwgdGhpcy5ydW50aW1lLnBsdXJhbCwgdGhpcy5ydW50aW1lLnNlbGVjdCxcbiAgICAgICAgdGhpcy5ydW50aW1lLnBsdXJhbEZ1bmNzLCB0aGlzLnJ1bnRpbWUuZm10KTtcbiAgfVxuXG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICBmb3IgKHZhciBucyBpbiBtZXNzYWdlcykge1xuICAgIGlmIChvcHQubG9jYWxlKSB0aGlzLmxjID0gb3B0LmxvY2FsZVtuc10gJiYgW10uY29uY2F0KG9wdC5sb2NhbGVbbnNdKSB8fCBsYzA7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlc1tuc10gPT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7IHJbbnNdID0gY29tcGlsZU1zZyh0aGlzLCBtZXNzYWdlc1tuc10pOyB9XG4gICAgICBjYXRjaCAoZSkgeyBlLm1lc3NhZ2UgPSBlLm1lc3NhZ2UucmVwbGFjZSgnOicsICcgd2l0aCBgJyArIG5zICsgJ2A6Jyk7IHRocm93IGU7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgcltuc10gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXNzYWdlc1tuc10pIHtcbiAgICAgICAgdHJ5IHsgcltuc11ba2V5XSA9IGNvbXBpbGVNc2codGhpcywgbWVzc2FnZXNbbnNdW2tleV0pOyB9XG4gICAgICAgIGNhdGNoIChlKSB7IGUubWVzc2FnZSA9IGUubWVzc2FnZS5yZXBsYWNlKCc6JywgJyB3aXRoIGAnICsga2V5ICsgJ2AgaW4gYCcgKyBucyArICdgOicpOyB0aHJvdyBlOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sYyA9IGxjMDtcbiAgdmFyIHMgPSB0aGlzLnJ1bnRpbWUudG9TdHJpbmcoKSArICdcXG4nO1xuICBzd2l0Y2ggKG9wdC5nbG9iYWwgfHwgJycpIHtcbiAgICBjYXNlICdleHBvcnRzJzpcbiAgICAgIHZhciBvID0gW107XG4gICAgICBmb3IgKHZhciBrIGluIHIpIG8ucHVzaChwcm9wbmFtZShrLCAnZXhwb3J0cycpICsgJyA9ICcgKyBzdHJpbmdpZnkocltrXSkpO1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzICsgby5qb2luKCc7XFxuJykpO1xuICAgIGNhc2UgJ21vZHVsZS5leHBvcnRzJzpcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocyArICdtb2R1bGUuZXhwb3J0cyA9ICcgKyBzdHJpbmdpZnkocikpO1xuICAgIGNhc2UgJyc6XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHMgKyAncmV0dXJuICcgKyBzdHJpbmdpZnkocikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdHJywgcyArIHByb3BuYW1lKG9wdC5nbG9iYWwsICdHJykgKyAnID0gJyArIHN0cmluZ2lmeShyKSk7XG4gIH1cbn07XG5cblxucmV0dXJuIE1lc3NhZ2VGb3JtYXQ7XG59KCkpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG52YXIgY3JlYXRlRXJyb3JQbHVyYWxNb2R1bGVQcmVzZW5jZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gY3JlYXRlRXJyb3IoIFwiRV9NSVNTSU5HX1BMVVJBTF9NT0RVTEVcIiwgXCJQbHVyYWwgbW9kdWxlIG5vdCBsb2FkZWQuXCIgKTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZU1lc3NhZ2VCdW5kbGUgPSBmdW5jdGlvbiggY2xkciApIHtcblx0dmFsaWRhdGUoXG5cdFx0XCJFX01JU1NJTkdfTUVTU0FHRV9CVU5ETEVcIixcblx0XHRcIk1pc3NpbmcgbWVzc2FnZSBidW5kbGUgZm9yIGxvY2FsZSBge2xvY2FsZX1gLlwiLFxuXHRcdGNsZHIuYXR0cmlidXRlcy5idW5kbGUgJiYgY2xkci5nZXQoIFwiZ2xvYmFsaXplLW1lc3NhZ2VzL3tidW5kbGV9XCIgKSAhPT0gdW5kZWZpbmVkLFxuXHRcdHtcblx0XHRcdGxvY2FsZTogY2xkci5sb2NhbGVcblx0XHR9XG5cdCk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVNZXNzYWdlUHJlc2VuY2UgPSBmdW5jdGlvbiggcGF0aCwgdmFsdWUgKSB7XG5cdHBhdGggPSBwYXRoLmpvaW4oIFwiL1wiICk7XG5cdHZhbGlkYXRlKCBcIkVfTUlTU0lOR19NRVNTQUdFXCIsIFwiTWlzc2luZyByZXF1aXJlZCBtZXNzYWdlIGNvbnRlbnQgYHtwYXRofWAuXCIsXG5cdFx0dmFsdWUgIT09IHVuZGVmaW5lZCwgeyBwYXRoOiBwYXRoIH0gKTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZU1lc3NhZ2VUeXBlID0gZnVuY3Rpb24oIHBhdGgsIHZhbHVlICkge1xuXHRwYXRoID0gcGF0aC5qb2luKCBcIi9cIiApO1xuXHR2YWxpZGF0ZShcblx0XHRcIkVfSU5WQUxJRF9NRVNTQUdFXCIsXG5cdFx0XCJJbnZhbGlkIG1lc3NhZ2UgY29udGVudCBge3BhdGh9YC4ge2V4cGVjdGVkfSBleHBlY3RlZC5cIixcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIsXG5cdFx0e1xuXHRcdFx0ZXhwZWN0ZWQ6IFwiYSBzdHJpbmdcIixcblx0XHRcdHBhdGg6IHBhdGhcblx0XHR9XG5cdCk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTWVzc2FnZVZhcmlhYmxlcyA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc1BsYWluT2JqZWN0KCB2YWx1ZSApIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICksXG5cdFx0XCJBcnJheSBvciBQbGFpbiBPYmplY3RcIlxuXHQpO1xufTtcblxuXG5cblxudmFyIG1lc3NhZ2VGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBmb3JtYXR0ZXIgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBtZXNzYWdlRm9ybWF0dGVyKCB2YXJpYWJsZXMgKSB7XG5cdFx0aWYgKCB0eXBlb2YgdmFyaWFibGVzID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YXJpYWJsZXMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR2YXJpYWJsZXMgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblx0XHR9XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTWVzc2FnZVZhcmlhYmxlcyggdmFyaWFibGVzLCBcInZhcmlhYmxlc1wiICk7XG5cdFx0cmV0dXJuIGZvcm1hdHRlciggdmFyaWFibGVzICk7XG5cdH07XG59O1xuXG5cblxuXG52YXIgbWVzc2FnZUZvcm1hdHRlclJ1bnRpbWVCaW5kID0gZnVuY3Rpb24oIGNsZHIsIG1lc3NhZ2Vmb3JtYXR0ZXIgKSB7XG5cdHZhciBsb2NhbGUgPSBjbGRyLmxvY2FsZSxcblx0XHRvcmlnVG9TdHJpbmcgPSBtZXNzYWdlZm9ybWF0dGVyLnRvU3RyaW5nO1xuXG5cdG1lc3NhZ2Vmb3JtYXR0ZXIudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnTmFtZXMsIGFyZ1ZhbHVlcywgb3V0cHV0LFxuXHRcdFx0YXJncyA9IHt9O1xuXG5cdFx0Ly8gUHJvcGVybHkgYWRqdXN0IFNsZXhBeHRvbi9tZXNzYWdlZm9ybWF0LmpzIGNvbXBpbGVkIHZhcmlhYmxlcyB3aXRoIEdsb2JhbGl6ZSB2YXJpYWJsZXM6XG5cdFx0b3V0cHV0ID0gb3JpZ1RvU3RyaW5nLmNhbGwoIG1lc3NhZ2Vmb3JtYXR0ZXIgKTtcblxuXHRcdGlmICggL251bWJlclxcKC8udGVzdCggb3V0cHV0ICkgKSB7XG5cdFx0XHRhcmdzLm51bWJlciA9IFwibWVzc2FnZUZvcm1hdC5udW1iZXJcIjtcblx0XHR9XG5cblx0XHRpZiAoIC9wbHVyYWxcXCgvLnRlc3QoIG91dHB1dCApICkge1xuXHRcdFx0YXJncy5wbHVyYWwgPSBcIm1lc3NhZ2VGb3JtYXQucGx1cmFsXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCAvc2VsZWN0XFwoLy50ZXN0KCBvdXRwdXQgKSApIHtcblx0XHRcdGFyZ3Muc2VsZWN0ID0gXCJtZXNzYWdlRm9ybWF0LnNlbGVjdFwiO1xuXHRcdH1cblxuXHRcdG91dHB1dC5yZXBsYWNlKCAvcGx1cmFsRnVuY3MoXFxbKFteXFxdXSspXFxdfFxcLihbYS16QS1aXSspKS8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdGFyZ3MucGx1cmFsRnVuY3MgPSBcIntcIiArXG5cdFx0XHRcdFwiXFxcIlwiICsgbG9jYWxlICsgXCJcXFwiOiBHbG9iYWxpemUoXFxcIlwiICsgbG9jYWxlICsgXCJcXFwiKS5wbHVyYWxHZW5lcmF0b3IoKVwiICtcblx0XHRcdFx0XCJ9XCI7XG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSk7XG5cblx0XHRhcmdOYW1lcyA9IE9iamVjdC5rZXlzKCBhcmdzICkuam9pbiggXCIsIFwiICk7XG5cdFx0YXJnVmFsdWVzID0gT2JqZWN0LmtleXMoIGFyZ3MgKS5tYXAoZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBhcmdzWyBrZXkgXTtcblx0XHR9KS5qb2luKCBcIiwgXCIgKTtcblxuXHRcdHJldHVybiBcIihmdW5jdGlvbiggXCIgKyBhcmdOYW1lcyArIFwiICkge1xcblwiICtcblx0XHRcdFwiICByZXR1cm4gXCIgKyBvdXRwdXQgKyBcIlxcblwiICtcblx0XHRcdFwifSkoXCIgKyBhcmdWYWx1ZXMgKyBcIilcIjtcblx0fTtcblxuXHRyZXR1cm4gbWVzc2FnZWZvcm1hdHRlcjtcbn07XG5cblxuXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIC5sb2FkTWVzc2FnZXMoIGpzb24gKVxuICpcbiAqIEBqc29uIFtKU09OXVxuICpcbiAqIExvYWQgdHJhbnNsYXRpb24gZGF0YS5cbiAqL1xuR2xvYmFsaXplLmxvYWRNZXNzYWdlcyA9IGZ1bmN0aW9uKCBqc29uICkge1xuXHR2YXIgbG9jYWxlLFxuXHRcdGN1c3RvbURhdGEgPSB7XG5cdFx0XHRcImdsb2JhbGl6ZS1tZXNzYWdlc1wiOiBqc29uLFxuXHRcdFx0XCJtYWluXCI6IHt9XG5cdFx0fTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBqc29uLCBcImpzb25cIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCgganNvbiwgXCJqc29uXCIgKTtcblxuXHQvLyBTZXQgYXZhaWxhYmxlIGJ1bmRsZXMgYnkgcG9wdWxhdGluZyBjdXN0b21EYXRhIG1haW4gZGF0YXNldC5cblx0Zm9yICggbG9jYWxlIGluIGpzb24gKSB7XG5cdFx0aWYgKCBqc29uLmhhc093blByb3BlcnR5KCBsb2NhbGUgKSApIHtcblx0XHRcdGN1c3RvbURhdGEubWFpblsgbG9jYWxlIF0gPSB7fTtcblx0XHR9XG5cdH1cblxuXHRDbGRyLmxvYWQoIGN1c3RvbURhdGEgKTtcbn07XG5cbi8qKlxuICogLm1lc3NhZ2VGb3JtYXR0ZXIoIHBhdGggKVxuICpcbiAqIEBwYXRoIFtTdHJpbmcgb3IgQXJyYXldXG4gKlxuICogRm9ybWF0IGEgbWVzc2FnZSBnaXZlbiBpdHMgcGF0aC5cbiAqL1xuR2xvYmFsaXplLm1lc3NhZ2VGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5tZXNzYWdlRm9ybWF0dGVyID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdHZhciBjbGRyLCBmb3JtYXR0ZXIsIG1lc3NhZ2UsIHBsdXJhbEdlbmVyYXRvciwgcmV0dXJuRm4sXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHBhdGgsIFwicGF0aFwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSggcGF0aCwgXCJwYXRoXCIsIHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHBhdGggKSxcblx0XHRcImEgU3RyaW5nIG5vciBhbiBBcnJheVwiICk7XG5cblx0cGF0aCA9IGFsd2F5c0FycmF5KCBwYXRoICk7XG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cdHZhbGlkYXRlTWVzc2FnZUJ1bmRsZSggY2xkciApO1xuXG5cdG1lc3NhZ2UgPSBjbGRyLmdldCggWyBcImdsb2JhbGl6ZS1tZXNzYWdlcy97YnVuZGxlfVwiIF0uY29uY2F0KCBwYXRoICkgKTtcblx0dmFsaWRhdGVNZXNzYWdlUHJlc2VuY2UoIHBhdGgsIG1lc3NhZ2UgKTtcblxuXHQvLyBJZiBtZXNzYWdlIGlzIGFuIEFycmF5LCBjb25jYXRlbmF0ZSBpdC5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBtZXNzYWdlICkgKSB7XG5cdFx0bWVzc2FnZSA9IG1lc3NhZ2Uuam9pbiggXCIgXCIgKTtcblx0fVxuXHR2YWxpZGF0ZU1lc3NhZ2VUeXBlKCBwYXRoLCBtZXNzYWdlICk7XG5cblx0Ly8gSXMgcGx1cmFsIG1vZHVsZSBwcmVzZW50PyBZZXMsIHVzZSBpdHMgZ2VuZXJhdG9yLiBOb3BlLCB1c2UgYW4gZXJyb3IgZ2VuZXJhdG9yLlxuXHRwbHVyYWxHZW5lcmF0b3IgPSB0aGlzLnBsdXJhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR0aGlzLnBsdXJhbEdlbmVyYXRvcigpIDpcblx0XHRjcmVhdGVFcnJvclBsdXJhbE1vZHVsZVByZXNlbmNlO1xuXG5cdGZvcm1hdHRlciA9IG5ldyBNZXNzYWdlRm9ybWF0KCBjbGRyLmxvY2FsZSwgcGx1cmFsR2VuZXJhdG9yICkuY29tcGlsZSggbWVzc2FnZSApO1xuXG5cdHJldHVybkZuID0gbWVzc2FnZUZvcm1hdHRlckZuKCBmb3JtYXR0ZXIgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sXG5cdFx0WyBtZXNzYWdlRm9ybWF0dGVyUnVudGltZUJpbmQoIGNsZHIsIGZvcm1hdHRlciApLCBwbHVyYWxHZW5lcmF0b3IgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLmZvcm1hdE1lc3NhZ2UoIHBhdGggWywgdmFyaWFibGVzXSApXG4gKlxuICogQHBhdGggW1N0cmluZyBvciBBcnJheV1cbiAqXG4gKiBAdmFyaWFibGVzIFtOdW1iZXIsIFN0cmluZywgQXJyYXkgb3IgT2JqZWN0XVxuICpcbiAqIEZvcm1hdCBhIG1lc3NhZ2UgZ2l2ZW4gaXRzIHBhdGguXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXRNZXNzYWdlID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uKCBwYXRoIC8qICwgdmFyaWFibGVzICovICkge1xuXHRyZXR1cm4gdGhpcy5tZXNzYWdlRm9ybWF0dGVyKCBwYXRoICkuYXBwbHkoIHt9LCBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSApO1xufTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL21lc3NhZ2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiY2xkci9ldmVudFwiLFxuXHRcdFx0XCJjbGRyL3N1cHBsZW1lbnRhbFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gR2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBjcmVhdGVFcnJvciA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IsXG5cdHJlZ2V4cEVzY2FwZSA9IEdsb2JhbGl6ZS5fcmVnZXhwRXNjYXBlLFxuXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHN0cmluZ1BhZCA9IEdsb2JhbGl6ZS5fc3RyaW5nUGFkLFxuXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3Q7XG5cblxudmFyIGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlID0gZnVuY3Rpb24oIGZlYXR1cmUgKSB7XG5cdHJldHVybiBjcmVhdGVFcnJvciggXCJFX1VOU1VQUE9SVEVEXCIsIFwiVW5zdXBwb3J0ZWQge2ZlYXR1cmV9LlwiLCB7XG5cdFx0ZmVhdHVyZTogZmVhdHVyZVxuXHR9KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiLFxuXHRcdFwiTnVtYmVyXCJcblx0KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLFxuXHRcdFwiYSBzdHJpbmdcIlxuXHQpO1xufTtcblxuXG5cblxuLyoqXG4gKiBnb3VwaW5nU2VwYXJhdG9yKCBudW1iZXIsIHByaW1hcnlHcm91cGluZ1NpemUsIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSApXG4gKlxuICogQG51bWJlciBbTnVtYmVyXS5cbiAqXG4gKiBAcHJpbWFyeUdyb3VwaW5nU2l6ZSBbTnVtYmVyXVxuICpcbiAqIEBzZWNvbmRhcnlHcm91cGluZ1NpemUgW051bWJlcl1cbiAqXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBudW1iZXIgd2l0aCBncm91cCBzZXBhcmF0b3IuXG4gKi9cbnZhciBudW1iZXJGb3JtYXRHcm91cGluZ1NlcGFyYXRvciA9IGZ1bmN0aW9uKCBudW1iZXIsIHByaW1hcnlHcm91cGluZ1NpemUsIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSApIHtcblx0dmFyIGluZGV4LFxuXHRcdGN1cnJlbnRHcm91cGluZ1NpemUgPSBwcmltYXJ5R3JvdXBpbmdTaXplLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0c2VwID0gXCIsXCIsXG5cdFx0c3dpdGNoVG9TZWNvbmRhcnkgPSBzZWNvbmRhcnlHcm91cGluZ1NpemUgPyB0cnVlIDogZmFsc2U7XG5cblx0bnVtYmVyID0gU3RyaW5nKCBudW1iZXIgKS5zcGxpdCggXCIuXCIgKTtcblx0aW5kZXggPSBudW1iZXJbIDAgXS5sZW5ndGg7XG5cblx0d2hpbGUgKCBpbmRleCA+IGN1cnJlbnRHcm91cGluZ1NpemUgKSB7XG5cdFx0cmV0ID0gbnVtYmVyWyAwIF0uc2xpY2UoIGluZGV4IC0gY3VycmVudEdyb3VwaW5nU2l6ZSwgaW5kZXggKSArXG5cdFx0XHQoIHJldC5sZW5ndGggPyBzZXAgOiBcIlwiICkgKyByZXQ7XG5cdFx0aW5kZXggLT0gY3VycmVudEdyb3VwaW5nU2l6ZTtcblx0XHRpZiAoIHN3aXRjaFRvU2Vjb25kYXJ5ICkge1xuXHRcdFx0Y3VycmVudEdyb3VwaW5nU2l6ZSA9IHNlY29uZGFyeUdyb3VwaW5nU2l6ZTtcblx0XHRcdHN3aXRjaFRvU2Vjb25kYXJ5ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0bnVtYmVyWyAwIF0gPSBudW1iZXJbIDAgXS5zbGljZSggMCwgaW5kZXggKSArICggcmV0Lmxlbmd0aCA/IHNlcCA6IFwiXCIgKSArIHJldDtcblx0cmV0dXJuIG51bWJlci5qb2luKCBcIi5cIiApO1xufTtcblxuXG5cblxuLyoqXG4gKiBpbnRlZ2VyRnJhY3Rpb25EaWdpdHMoIG51bWJlciwgbWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcbiAqIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgcm91bmQsIHJvdW5kSW5jcmVtZW50IClcbiAqXG4gKiBAbnVtYmVyIFtOdW1iZXJdXG4gKlxuICogQG1pbmltdW1JbnRlZ2VyRGlnaXRzIFtOdW1iZXJdXG4gKlxuICogQG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBbTnVtYmVyXVxuICpcbiAqIEBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgW051bWJlcl1cbiAqXG4gKiBAcm91bmQgW0Z1bmN0aW9uXVxuICpcbiAqIEByb3VuZEluY3JlbWVudCBbRnVuY3Rpb25dXG4gKlxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgaW50ZWdlciBhbmQgZnJhY3Rpb24gZGlnaXRzLlxuICovXG52YXIgbnVtYmVyRm9ybWF0SW50ZWdlckZyYWN0aW9uRGlnaXRzID0gZnVuY3Rpb24oIG51bWJlciwgbWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzLCByb3VuZCxcblx0cm91bmRJbmNyZW1lbnQgKSB7XG5cblx0Ly8gRnJhY3Rpb25cblx0aWYgKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKSB7XG5cblx0XHQvLyBSb3VuZGluZ1xuXHRcdGlmICggcm91bmRJbmNyZW1lbnQgKSB7XG5cdFx0XHRudW1iZXIgPSByb3VuZCggbnVtYmVyLCByb3VuZEluY3JlbWVudCApO1xuXG5cdFx0Ly8gTWF4aW11bSBmcmFjdGlvbiBkaWdpdHNcblx0XHR9IGVsc2Uge1xuXHRcdFx0bnVtYmVyID0gcm91bmQoIG51bWJlciwgeyBleHBvbmVudDogLW1heGltdW1GcmFjdGlvbkRpZ2l0cyB9ICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0bnVtYmVyID0gcm91bmQoIG51bWJlciApO1xuXHR9XG5cblx0bnVtYmVyID0gU3RyaW5nKCBudW1iZXIgKTtcblxuXHQvLyBNYXhpbXVtIGludGVnZXIgZGlnaXRzIChwb3N0IHN0cmluZyBwaGFzZSlcblx0aWYgKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgJiYgL2UtLy50ZXN0KCBudW1iZXIgKSApIHtcblxuXHRcdC8vIFVzZSB0b0ZpeGVkKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKSB0byBtYWtlIHN1cmUgc21hbGwgbnVtYmVycyBsaWtlIDFlLTcgYXJlXG5cdFx0Ly8gZGlzcGxheWVkIHVzaW5nIHBsYWluIGRpZ2l0cyBpbnN0ZWFkIG9mIHNjaWVudGlmaWMgbm90YXRpb24uXG5cdFx0Ly8gMTogUmVtb3ZlIGxlYWRpbmcgZGVjaW1hbCB6ZXJvcy5cblx0XHQvLyAyOiBSZW1vdmUgbGVhZGluZyBkZWNpbWFsIHNlcGFyYXRvci5cblx0XHQvLyBOb3RlOiBTdHJpbmcoKSBpcyBzdGlsbCBwcmVmZXJyZWQgc28gaXQgZG9lc24ndCBtZXNzIHVwIHdpdGggYSBudW1iZXIgcHJlY2lzaW9uXG5cdFx0Ly8gdW5uZWNlc3NhcmlseSwgZS5nLiwgKDEyMzQ1Njc4OS4xMjMpLnRvRml4ZWQoMTApID09PSBcIjEyMzQ1Njc4OS4xMjI5OTk5OTU5XCIsXG5cdFx0Ly8gU3RyaW5nKDEyMzQ1Njc4OS4xMjMpID09PSBcIjEyMzQ1Njc4OS4xMjNcIi5cblx0XHRudW1iZXIgPSAoICtudW1iZXIgKS50b0ZpeGVkKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKVxuXHRcdFx0LnJlcGxhY2UoIC8wKyQvLCBcIlwiICkgLyogMSAqL1xuXHRcdFx0LnJlcGxhY2UoIC9cXC4kLywgXCJcIiApIC8qIDIgKi87XG5cdH1cblxuXHQvLyBNaW5pbXVtIGZyYWN0aW9uIGRpZ2l0cyAocG9zdCBzdHJpbmcgcGhhc2UpXG5cdGlmICggbWluaW11bUZyYWN0aW9uRGlnaXRzICkge1xuXHRcdG51bWJlciA9IG51bWJlci5zcGxpdCggXCIuXCIgKTtcblx0XHRudW1iZXJbIDEgXSA9IHN0cmluZ1BhZCggbnVtYmVyWyAxIF0gfHwgXCJcIiwgbWluaW11bUZyYWN0aW9uRGlnaXRzLCB0cnVlICk7XG5cdFx0bnVtYmVyID0gbnVtYmVyLmpvaW4oIFwiLlwiICk7XG5cdH1cblxuXHQvLyBNaW5pbXVtIGludGVnZXIgZGlnaXRzXG5cdGlmICggbWluaW11bUludGVnZXJEaWdpdHMgKSB7XG5cdFx0bnVtYmVyID0gbnVtYmVyLnNwbGl0KCBcIi5cIiApO1xuXHRcdG51bWJlclsgMCBdID0gc3RyaW5nUGFkKCBudW1iZXJbIDAgXSwgbWluaW11bUludGVnZXJEaWdpdHMgKTtcblx0XHRudW1iZXIgPSBudW1iZXIuam9pbiggXCIuXCIgKTtcblx0fVxuXG5cdHJldHVybiBudW1iZXI7XG59O1xuXG5cblxuXG4vKipcbiAqIHRvUHJlY2lzaW9uKCBudW1iZXIsIHByZWNpc2lvbiwgcm91bmQgKVxuICpcbiAqIEBudW1iZXIgKE51bWJlcilcbiAqXG4gKiBAcHJlY2lzaW9uIChOdW1iZXIpIHNpZ25pZmljYW50IGZpZ3VyZXMgcHJlY2lzaW9uIChub3QgZGVjaW1hbCBwcmVjaXNpb24pLlxuICpcbiAqIEByb3VuZCAoRnVuY3Rpb24pXG4gKlxuICogUmV0dXJuIG51bWJlci50b1ByZWNpc2lvbiggcHJlY2lzaW9uICkgdXNpbmcgdGhlIGdpdmVuIHJvdW5kIGZ1bmN0aW9uLlxuICovXG52YXIgbnVtYmVyVG9QcmVjaXNpb24gPSBmdW5jdGlvbiggbnVtYmVyLCBwcmVjaXNpb24sIHJvdW5kICkge1xuXHR2YXIgcm91bmRPcmRlcjtcblxuXHQvLyBHZXQgbnVtYmVyIGF0IHR3byBleHRyYSBzaWduaWZpY2FudCBmaWd1cmUgcHJlY2lzaW9uLlxuXHRudW1iZXIgPSBudW1iZXIudG9QcmVjaXNpb24oIHByZWNpc2lvbiArIDIgKTtcblxuXHQvLyBUaGVuLCByb3VuZCBpdCB0byB0aGUgcmVxdWlyZWQgc2lnbmlmaWNhbnQgZmlndXJlIHByZWNpc2lvbi5cblx0cm91bmRPcmRlciA9IE1hdGguY2VpbCggTWF0aC5sb2coIE1hdGguYWJzKCBudW1iZXIgKSApIC8gTWF0aC5sb2coIDEwICkgKTtcblx0cm91bmRPcmRlciAtPSBwcmVjaXNpb247XG5cblx0cmV0dXJuIHJvdW5kKCBudW1iZXIsIHsgZXhwb25lbnQ6IHJvdW5kT3JkZXIgfSApO1xufTtcblxuXG5cblxuLyoqXG4gKiB0b1ByZWNpc2lvbiggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgcm91bmQgKVxuICpcbiAqIEBudW1iZXIgW051bWJlcl1cbiAqXG4gKiBAbWluaW11bVNpZ25pZmljYW50RGlnaXRzIFtOdW1iZXJdXG4gKlxuICogQG1heGltdW1TaWduaWZpY2FudERpZ2l0cyBbTnVtYmVyXVxuICpcbiAqIEByb3VuZCBbRnVuY3Rpb25dXG4gKlxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzIG51bWJlci5cbiAqL1xudmFyIG51bWJlckZvcm1hdFNpZ25pZmljYW50RGlnaXRzID0gZnVuY3Rpb24oIG51bWJlciwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kICkge1xuXHR2YXIgYXRNaW5pbXVtLCBhdE1heGltdW07XG5cblx0Ly8gU2FuaXR5IGNoZWNrLlxuXHRpZiAoIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA+IG1heGltdW1TaWduaWZpY2FudERpZ2l0cyApIHtcblx0XHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHM7XG5cdH1cblxuXHRhdE1pbmltdW0gPSBudW1iZXJUb1ByZWNpc2lvbiggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kICk7XG5cdGF0TWF4aW11bSA9IG51bWJlclRvUHJlY2lzaW9uKCBudW1iZXIsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgcm91bmQgKTtcblxuXHQvLyBVc2UgYXRNYXhpbXVtIG9ubHkgaWYgaXQgaGFzIG1vcmUgc2lnbmlmaWNhbnQgZGlnaXRzIHRoYW4gYXRNaW5pbXVtLlxuXHRudW1iZXIgPSArYXRNaW5pbXVtID09PSArYXRNYXhpbXVtID8gYXRNaW5pbXVtIDogYXRNYXhpbXVtO1xuXG5cdC8vIEV4cGFuZCBpbnRlZ2VyIG51bWJlcnMsIGVnLiAxMjNlNSB0byAxMjMwMC5cblx0bnVtYmVyID0gKCArbnVtYmVyICkudG9TdHJpbmcoIDEwICk7XG5cblx0aWYgKCAoIC9lLyApLnRlc3QoIG51bWJlciApICkge1xuXHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdGZlYXR1cmU6IFwiaW50ZWdlcnMgb3V0IG9mICgxZTIxLCAxZS03KVwiXG5cdFx0fSk7XG5cdH1cblxuXHQvLyBBZGQgdHJhaWxpbmcgemVyb3MgaWYgbmVjZXNzYXJ5LlxuXHRpZiAoIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAtIG51bWJlci5yZXBsYWNlKCAvXjArfFxcLi9nLCBcIlwiICkubGVuZ3RoID4gMCApIHtcblx0XHRudW1iZXIgPSBudW1iZXIuc3BsaXQoIFwiLlwiICk7XG5cdFx0bnVtYmVyWyAxIF0gPSBzdHJpbmdQYWQoIG51bWJlclsgMSBdIHx8IFwiXCIsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAtIG51bWJlclsgMCBdLnJlcGxhY2UoIC9eMCsvLCBcIlwiICkubGVuZ3RoLCB0cnVlICk7XG5cdFx0bnVtYmVyID0gbnVtYmVyLmpvaW4oIFwiLlwiICk7XG5cdH1cblxuXHRyZXR1cm4gbnVtYmVyO1xufTtcblxuXG5cblxuLyoqXG4gKiByZW1vdmVMaXRlcmFsUXVvdGVzKCBzdHJpbmcgKVxuICpcbiAqIFJldHVybjpcbiAqIC0gYGAgaWYgaW5wdXQgc3RyaW5nIGlzIGAnJ2AuXG4gKiAtIGBvJ2Nsb2NrYCBpZiBpbnB1dCBzdHJpbmcgaXMgYCdvJydjbG9jaydgLlxuICogLSBgZm9vYCBpZiBpbnB1dCBzdHJpbmcgaXMgYGZvb2AsIGkuZS4sIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBpbiBjYXNlIGl0IGlzbid0IGEgc2luZ2xlLXF1b3RlZFxuICogICBzdHJpbmcuXG4gKi9cbnZhciByZW1vdmVMaXRlcmFsUXVvdGVzID0gZnVuY3Rpb24oIHN0cmluZyApIHtcblx0aWYgKCBzdHJpbmdbIDAgXSArIHN0cmluZ1sgc3RyaW5nLmxlbmd0aCAtIDEgXSAhPT0gXCInJ1wiICkge1xuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblx0aWYgKCBzdHJpbmcgPT09IFwiJydcIiApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIC8nJy9nLCBcIidcIiApLnNsaWNlKCAxLCAtMSApO1xufTtcblxuXG5cblxuLyoqXG4gKiBmb3JtYXQoIG51bWJlciwgcHJvcGVydGllcyApXG4gKlxuICogQG51bWJlciBbTnVtYmVyXS5cbiAqXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBPdXRwdXQgb2YgbnVtYmVyL2Zvcm1hdC1wcm9wZXJ0aWVzLlxuICpcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIG51bWJlci5cbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWxcbiAqL1xudmFyIG51bWJlckZvcm1hdCA9IGZ1bmN0aW9uKCBudW1iZXIsIHByb3BlcnRpZXMgKSB7XG5cdHZhciBpbmZpbml0eVN5bWJvbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcblx0bWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgbmFuU3ltYm9sLCBudURpZ2l0c01hcCwgcGFkZGluZywgcHJlZml4LFxuXHRwcmltYXJ5R3JvdXBpbmdTaXplLCBwYXR0ZXJuLCByZXQsIHJvdW5kLCByb3VuZEluY3JlbWVudCwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplLCBzdWZmaXgsXG5cdHN5bWJvbE1hcDtcblxuXHRwYWRkaW5nID0gcHJvcGVydGllc1sgMSBdO1xuXHRtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IHByb3BlcnRpZXNbIDIgXTtcblx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gcHJvcGVydGllc1sgMyBdO1xuXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBwcm9wZXJ0aWVzWyA0IF07XG5cdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA9IHByb3BlcnRpZXNbIDUgXTtcblx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gcHJvcGVydGllc1sgNiBdO1xuXHRyb3VuZEluY3JlbWVudCA9IHByb3BlcnRpZXNbIDcgXTtcblx0cHJpbWFyeUdyb3VwaW5nU2l6ZSA9IHByb3BlcnRpZXNbIDggXTtcblx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplID0gcHJvcGVydGllc1sgOSBdO1xuXHRyb3VuZCA9IHByb3BlcnRpZXNbIDE1IF07XG5cdGluZmluaXR5U3ltYm9sID0gcHJvcGVydGllc1sgMTYgXTtcblx0bmFuU3ltYm9sID0gcHJvcGVydGllc1sgMTcgXTtcblx0c3ltYm9sTWFwID0gcHJvcGVydGllc1sgMTggXTtcblx0bnVEaWdpdHNNYXAgPSBwcm9wZXJ0aWVzWyAxOSBdO1xuXG5cdC8vIE5hTlxuXHRpZiAoIGlzTmFOKCBudW1iZXIgKSApIHtcblx0XHRyZXR1cm4gbmFuU3ltYm9sO1xuXHR9XG5cblx0aWYgKCBudW1iZXIgPCAwICkge1xuXHRcdHBhdHRlcm4gPSBwcm9wZXJ0aWVzWyAxMiBdO1xuXHRcdHByZWZpeCA9IHByb3BlcnRpZXNbIDEzIF07XG5cdFx0c3VmZml4ID0gcHJvcGVydGllc1sgMTQgXTtcblx0fSBlbHNlIHtcblx0XHRwYXR0ZXJuID0gcHJvcGVydGllc1sgMTEgXTtcblx0XHRwcmVmaXggPSBwcm9wZXJ0aWVzWyAwIF07XG5cdFx0c3VmZml4ID0gcHJvcGVydGllc1sgMTAgXTtcblx0fVxuXG5cdC8vIEluZmluaXR5XG5cdGlmICggIWlzRmluaXRlKCBudW1iZXIgKSApIHtcblx0XHRyZXR1cm4gcHJlZml4ICsgaW5maW5pdHlTeW1ib2wgKyBzdWZmaXg7XG5cdH1cblxuXHRyZXQgPSBwcmVmaXg7XG5cblx0Ly8gUGVyY2VudFxuXHRpZiAoIHBhdHRlcm4uaW5kZXhPZiggXCIlXCIgKSAhPT0gLTEgKSB7XG5cdFx0bnVtYmVyICo9IDEwMDtcblxuXHQvLyBQZXIgbWlsbGVcblx0fSBlbHNlIGlmICggcGF0dGVybi5pbmRleE9mKCBcIlxcdTIwMzBcIiApICE9PSAtMSApIHtcblx0XHRudW1iZXIgKj0gMTAwMDtcblx0fVxuXG5cdC8vIFNpZ25pZmljYW50IGRpZ2l0IGZvcm1hdFxuXHRpZiAoICFpc05hTiggbWluaW11bVNpZ25pZmljYW50RGlnaXRzICogbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkgKSB7XG5cdFx0bnVtYmVyID0gbnVtYmVyRm9ybWF0U2lnbmlmaWNhbnREaWdpdHMoIG51bWJlciwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLFxuXHRcdFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApO1xuXG5cdC8vIEludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0XG5cdH0gZWxzZSB7XG5cdFx0bnVtYmVyID0gbnVtYmVyRm9ybWF0SW50ZWdlckZyYWN0aW9uRGlnaXRzKCBudW1iZXIsIG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxuXHRcdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIHJvdW5kLCByb3VuZEluY3JlbWVudCApO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIHRoZSBwb3NzaWJsZSBudW1iZXIgbWludXMgc2lnblxuXHRudW1iZXIgPSBudW1iZXIucmVwbGFjZSggL14tLywgXCJcIiApO1xuXG5cdC8vIEdyb3VwaW5nIHNlcGFyYXRvcnNcblx0aWYgKCBwcmltYXJ5R3JvdXBpbmdTaXplICkge1xuXHRcdG51bWJlciA9IG51bWJlckZvcm1hdEdyb3VwaW5nU2VwYXJhdG9yKCBudW1iZXIsIHByaW1hcnlHcm91cGluZ1NpemUsXG5cdFx0XHRzZWNvbmRhcnlHcm91cGluZ1NpemUgKTtcblx0fVxuXG5cdHJldCArPSBudW1iZXI7XG5cblx0Ly8gU2NpZW50aWZpYyBub3RhdGlvblxuXHQvLyBUT0RPIGltcGxlbWVudCBoZXJlXG5cblx0Ly8gUGFkZGluZy8nKFteJ118JycpKyd8Jyd8Wy4sXFwtK0UlXFx1MjAzMF0vZ1xuXHQvLyBUT0RPIGltcGxlbWVudCBoZXJlXG5cblx0cmV0ICs9IHN1ZmZpeDtcblxuXHRyZXR1cm4gcmV0LnJlcGxhY2UoIC8oJyhbXiddfCcnKSsnfCcnKXwuL2csIGZ1bmN0aW9uKCBjaGFyYWN0ZXIsIGxpdGVyYWwgKSB7XG5cblx0XHQvLyBMaXRlcmFsc1xuXHRcdGlmICggbGl0ZXJhbCApIHtcblx0XHRcdHJldHVybiByZW1vdmVMaXRlcmFsUXVvdGVzKCBsaXRlcmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3ltYm9sc1xuXHRcdGNoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKCAvWy4sXFwtK0UlXFx1MjAzMF0vLCBmdW5jdGlvbiggc3ltYm9sICkge1xuXHRcdFx0cmV0dXJuIHN5bWJvbE1hcFsgc3ltYm9sIF07XG5cdFx0fSk7XG5cblx0XHQvLyBOdW1iZXJpbmcgc3lzdGVtXG5cdFx0aWYgKCBudURpZ2l0c01hcCApIHtcblx0XHRcdGNoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKCAvWzAtOV0vLCBmdW5jdGlvbiggZGlnaXQgKSB7XG5cdFx0XHRcdHJldHVybiBudURpZ2l0c01hcFsgK2RpZ2l0IF07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2hhcmFjdGVyO1xuXHR9KTtcbn07XG5cblxuXG5cbnZhciBudW1iZXJGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBwcm9wZXJ0aWVzICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gbnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHRyZXR1cm4gbnVtYmVyRm9ybWF0KCB2YWx1ZSwgcHJvcGVydGllcyApO1xuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiBOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKVxuICpcbiAqIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWwjb3RoZXJOdW1iZXJpbmdTeXN0ZW1zXG4gKiAtIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2JjcDQ3LWV4dGVuc2lvblxuICogLSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jdV9FeHRlbnNpb25cbiAqL1xudmFyIG51bWJlck51bWJlcmluZ1N5c3RlbSA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHR2YXIgbnUgPSBjbGRyLmF0dHJpYnV0ZXNbIFwidS1udVwiIF07XG5cblx0aWYgKCBudSApIHtcblx0XHRpZiAoIG51ID09PSBcInRyYWRpdGlvXCIgKSB7XG5cdFx0XHRudSA9IFwidHJhZGl0aW9uYWxcIjtcblx0XHR9XG5cdFx0aWYgKCBbIFwibmF0aXZlXCIsIFwidHJhZGl0aW9uYWxcIiwgXCJmaW5hbmNlXCIgXS5pbmRleE9mKCBudSApICE9PSAtMSApIHtcblxuXHRcdFx0Ly8gVW5pY29kZSBsb2NhbGUgZXh0ZW5zaW9uIGB1LW51YCBpcyBzZXQgdXNpbmcgZWl0aGVyIChuYXRpdmUsIHRyYWRpdGlvbmFsIG9yXG5cdFx0XHQvLyBmaW5hbmNlKS4gU28sIGxvb2t1cCB0aGUgcmVzcGVjdGl2ZSBsb2NhbGUncyBudW1iZXJpbmdTeXN0ZW0gYW5kIHJldHVybiBpdC5cblx0XHRcdHJldHVybiBjbGRyLm1haW4oWyBcIm51bWJlcnMvb3RoZXJOdW1iZXJpbmdTeXN0ZW1zXCIsIG51IF0pO1xuXHRcdH1cblxuXHRcdC8vIFVuaWNvZGUgbG9jYWxlIGV4dGVuc2lvbiBgdS1udWAgaXMgc2V0IHdpdGggYW4gZXhwbGljaXQgbnVtYmVyaW5nU3lzdGVtLiBSZXR1cm4gaXQuXG5cdFx0cmV0dXJuIG51O1xuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBkZWZhdWx0IG51bWJlcmluZ1N5c3RlbS5cblx0cmV0dXJuIGNsZHIubWFpbiggXCJudW1iZXJzL2RlZmF1bHROdW1iZXJpbmdTeXN0ZW1cIiApO1xufTtcblxuXG5cblxuLyoqXG4gKiBudU1hcCggY2xkciApXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiBkaWdpdHMgbWFwIGlmIG51bWJlcmluZyBzeXN0ZW0gaXMgZGlmZmVyZW50IHRoYW4gYGxhdG5gLlxuICovXG52YXIgbnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHZhciBhdXgsXG5cdFx0bnUgPSBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKTtcblxuXHRpZiAoIG51ID09PSBcImxhdG5cIiApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRhdXggPSBjbGRyLnN1cHBsZW1lbnRhbChbIFwibnVtYmVyaW5nU3lzdGVtc1wiLCBudSBdKTtcblxuXHRpZiAoIGF1eC5fdHlwZSAhPT0gXCJudW1lcmljXCIgKSB7XG5cdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoIFwiYFwiICsgYXV4Ll90eXBlICsgXCJgIG51bWJlcmluZyBzeXN0ZW1cIiApO1xuXHR9XG5cblx0cmV0dXJuIGF1eC5fZGlnaXRzO1xufTtcblxuXG5cblxuLyoqXG4gKiBFQk5GIHJlcHJlc2VudGF0aW9uOlxuICpcbiAqIG51bWJlcl9wYXR0ZXJuX3JlID0gICAgICAgIHByZWZpeD9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuIHwgc2lnbmlmaWNhbnRfcGF0dGVybilcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaWVudGlmaWNfbm90YXRpb24/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXg/XG4gKlxuICogcHJlZml4ID0gICAgICAgICAgICAgICAgICAgbm9uX251bWJlcl9zdHVmZlxuICpcbiAqIHBhZGRpbmcgPSAgICAgICAgICAgICAgICAgIFwiKlwiIHJlZ2V4cCguKVxuICpcbiAqIGludGVnZXJfZnJhY3Rpb25fcGF0dGVybiA9IGludGVnZXJfcGF0dGVyblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25fcGF0dGVybj9cbiAqXG4gKiBpbnRlZ2VyX3BhdHRlcm4gPSAgICAgICAgICByZWdleHAoWyMsXSpbMCxdKjArKVxuICpcbiAqIGZyYWN0aW9uX3BhdHRlcm4gPSAgICAgICAgIFwiLlwiIHJlZ2V4cCgwKlswLTldKiMqKVxuICpcbiAqIHNpZ25pZmljYW50X3BhdHRlcm4gPSAgICAgIHJlZ2V4cChbIyxdKkArIyopXG4gKlxuICogc2NpZW50aWZpY19ub3RhdGlvbiA9ICAgICAgcmVnZXhwKEVcXCs/MCspXG4gKlxuICogc3VmZml4ID0gICAgICAgICAgICAgICAgICAgbm9uX251bWJlcl9zdHVmZlxuICpcbiAqIG5vbl9udW1iZXJfc3R1ZmYgPSAgICAgICAgIHJlZ2V4cCgoJ1teJ10rJ3wnJ3xbXiojQDAsLkVdKSopXG4gKlxuICpcbiAqIFJlZ2V4cCBncm91cHM6XG4gKlxuICogIDA6IG51bWJlcl9wYXR0ZXJuX3JlXG4gKiAgMTogcHJlZml4XG4gKiAgMjogLVxuICogIDM6IC1cbiAqICA0OiBwYWRkaW5nXG4gKiAgNTogKGludGVnZXJfZnJhY3Rpb25fcGF0dGVybiB8IHNpZ25pZmljYW50X3BhdHRlcm4pXG4gKiAgNjogaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuXG4gKiAgNzogaW50ZWdlcl9wYXR0ZXJuXG4gKiAgODogZnJhY3Rpb25fcGF0dGVyblxuICogIDk6IHNpZ25pZmljYW50X3BhdHRlcm5cbiAqIDEwOiBzY2llbnRpZmljX25vdGF0aW9uXG4gKiAxMTogc3VmZml4XG4gKiAxMjogLVxuICovXG52YXIgbnVtYmVyUGF0dGVyblJlID0gKCAvXigoJyhbXiddfCcnKSonfFteKiNAMCwuRV0pKikoXFwqLik/KCgoWyMsXSpbMCxdKjArKShcXC4wKlswLTldKiMqKT8pfChbIyxdKkArIyopKShFXFwrPzArKT8oKCdbXiddKyd8Jyd8W14qI0AwLC5FXSkqKSQvICk7XG5cblxuXG5cbi8qKlxuICogZm9ybWF0KCBudW1iZXIsIHBhdHRlcm4gKVxuICpcbiAqIEBudW1iZXIgW051bWJlcl0uXG4gKlxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4gZm9yIG51bWJlcnMuXG4gKlxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxuICovXG52YXIgbnVtYmVyUGF0dGVyblByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiApIHtcblx0dmFyIGF1eDEsIGF1eDIsIGZyYWN0aW9uUGF0dGVybiwgaW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4sIGludGVnZXJQYXR0ZXJuLFxuXHRcdG1heGltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsXG5cdFx0bWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgcGFkZGluZywgcHJlZml4LCBwcmltYXJ5R3JvdXBpbmdTaXplLFxuXHRcdHJvdW5kSW5jcmVtZW50LCBzY2llbnRpZmljTm90YXRpb24sIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSwgc2lnbmlmaWNhbnRQYXR0ZXJuLCBzdWZmaXg7XG5cblx0cGF0dGVybiA9IHBhdHRlcm4ubWF0Y2goIG51bWJlclBhdHRlcm5SZSApO1xuXHRpZiAoICFwYXR0ZXJuICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggXCJJbnZhbGlkIHBhdHRlcm46IFwiICsgcGF0dGVybiApO1xuXHR9XG5cblx0cHJlZml4ID0gcGF0dGVyblsgMSBdO1xuXHRwYWRkaW5nID0gcGF0dGVyblsgNCBdO1xuXHRpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybiA9IHBhdHRlcm5bIDUgXTtcblx0c2lnbmlmaWNhbnRQYXR0ZXJuID0gcGF0dGVyblsgOSBdO1xuXHRzY2llbnRpZmljTm90YXRpb24gPSBwYXR0ZXJuWyAxMCBdO1xuXHRzdWZmaXggPSBwYXR0ZXJuWyAxMSBdO1xuXG5cdC8vIFNpZ25pZmljYW50IGRpZ2l0IGZvcm1hdFxuXHRpZiAoIHNpZ25pZmljYW50UGF0dGVybiApIHtcblx0XHRzaWduaWZpY2FudFBhdHRlcm4ucmVwbGFjZSggLyhAKykoIyopLywgZnVuY3Rpb24oIG1hdGNoLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHNNYXRjaCwgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2ggKSB7XG5cdFx0XHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHNNYXRjaC5sZW5ndGg7XG5cdFx0XHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgK1xuXHRcdFx0XHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHNNYXRjaC5sZW5ndGg7XG5cdFx0fSk7XG5cblx0Ly8gSW50ZWdlciBhbmQgZnJhY3Rpb25hbCBmb3JtYXRcblx0fSBlbHNlIHtcblx0XHRmcmFjdGlvblBhdHRlcm4gPSBwYXR0ZXJuWyA4IF07XG5cdFx0aW50ZWdlclBhdHRlcm4gPSBwYXR0ZXJuWyA3IF07XG5cblx0XHRpZiAoIGZyYWN0aW9uUGF0dGVybiApIHtcblxuXHRcdFx0Ly8gTWluaW11bSBmcmFjdGlvbiBkaWdpdHMsIGFuZCByb3VuZGluZy5cblx0XHRcdGZyYWN0aW9uUGF0dGVybi5yZXBsYWNlKCAvWzAtOV0rLywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBtYXRjaDtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgKSB7XG5cdFx0XHRcdHJvdW5kSW5jcmVtZW50ID0gKyggXCIwLlwiICsgbWluaW11bUZyYWN0aW9uRGlnaXRzICk7XG5cdFx0XHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IG1pbmltdW1GcmFjdGlvbkRpZ2l0cy5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXhpbXVtIGZyYWN0aW9uIGRpZ2l0c1xuXHRcdFx0Ly8gMTogaWdub3JlIGRlY2ltYWwgY2hhcmFjdGVyXG5cdFx0XHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBmcmFjdGlvblBhdHRlcm4ubGVuZ3RoIC0gMSAvKiAxICovO1xuXHRcdH1cblxuXHRcdC8vIE1pbmltdW0gaW50ZWdlciBkaWdpdHNcblx0XHRpbnRlZ2VyUGF0dGVybi5yZXBsYWNlKCAvMCskLywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWluaW11bUludGVnZXJEaWdpdHMgPSBtYXRjaC5sZW5ndGg7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBTY2llbnRpZmljIG5vdGF0aW9uXG5cdGlmICggc2NpZW50aWZpY05vdGF0aW9uICkge1xuXHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdGZlYXR1cmU6IFwic2NpZW50aWZpYyBub3RhdGlvbiAobm90IGltcGxlbWVudGVkKVwiXG5cdFx0fSk7XG5cdH1cblxuXHQvLyBQYWRkaW5nXG5cdGlmICggcGFkZGluZyApIHtcblx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRmZWF0dXJlOiBcInBhZGRpbmcgKG5vdCBpbXBsZW1lbnRlZClcIlxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gR3JvdXBpbmdcblx0aWYgKCAoIGF1eDEgPSBpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybi5sYXN0SW5kZXhPZiggXCIsXCIgKSApICE9PSAtMSApIHtcblxuXHRcdC8vIFByaW1hcnkgZ3JvdXBpbmcgc2l6ZSBpcyB0aGUgaW50ZXJ2YWwgYmV0d2VlbiB0aGUgbGFzdCBncm91cCBzZXBhcmF0b3IgYW5kIHRoZSBlbmQgb2Zcblx0XHQvLyB0aGUgaW50ZWdlciAob3IgdGhlIGVuZCBvZiB0aGUgc2lnbmlmaWNhbnQgcGF0dGVybikuXG5cdFx0YXV4MiA9IGludGVnZXJGcmFjdGlvbk9yU2lnbmlmaWNhbnRQYXR0ZXJuLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cdFx0cHJpbWFyeUdyb3VwaW5nU2l6ZSA9IGF1eDIubGVuZ3RoIC0gYXV4MSAtIDE7XG5cblx0XHQvLyBTZWNvbmRhcnkgZ3JvdXBpbmcgc2l6ZSBpcyB0aGUgaW50ZXJ2YWwgYmV0d2VlbiB0aGUgbGFzdCB0d28gZ3JvdXAgc2VwYXJhdG9ycy5cblx0XHRpZiAoICggYXV4MiA9IGludGVnZXJGcmFjdGlvbk9yU2lnbmlmaWNhbnRQYXR0ZXJuLmxhc3RJbmRleE9mKCBcIixcIiwgYXV4MSAtIDEgKSApICE9PSAtMSApIHtcblx0XHRcdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA9IGF1eDEgLSAxIC0gYXV4Mjtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm46XG5cdC8vICAwOiBAcHJlZml4IFN0cmluZ1xuXHQvLyAgMTogQHBhZGRpbmcgQXJyYXkgWyA8Y2hhcmFjdGVyPiwgPGNvdW50PiBdIFRPRE9cblx0Ly8gIDI6IEBtaW5pbXVtSW50ZWdlckRpZ2l0cyBub24tbmVnYXRpdmUgaW50ZWdlciBOdW1iZXIgdmFsdWUgaW5kaWNhdGluZyB0aGUgbWluaW11bSBpbnRlZ2VyXG5cdC8vICAgICAgICBkaWdpdHMgdG8gYmUgdXNlZC4gTnVtYmVycyB3aWxsIGJlIHBhZGRlZCB3aXRoIGxlYWRpbmcgemVyb2VzIGlmIG5lY2Vzc2FyeS5cblx0Ly8gIDM6IEBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgYW5kXG5cdC8vICA0OiBAbWF4aW11bUZyYWN0aW9uRGlnaXRzIGFyZSBub24tbmVnYXRpdmUgaW50ZWdlciBOdW1iZXIgdmFsdWVzIGluZGljYXRpbmcgdGhlIG1pbmltdW0gYW5kXG5cdC8vICAgICAgICBtYXhpbXVtIGZyYWN0aW9uIGRpZ2l0cyB0byBiZSB1c2VkLiBOdW1iZXJzIHdpbGwgYmUgcm91bmRlZCBvciBwYWRkZWQgd2l0aCB0cmFpbGluZ1xuXHQvLyAgICAgICAgemVyb2VzIGlmIG5lY2Vzc2FyeS5cblx0Ly8gIDU6IEBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgYW5kXG5cdC8vICA2OiBAbWF4aW11bVNpZ25pZmljYW50RGlnaXRzIGFyZSBwb3NpdGl2ZSBpbnRlZ2VyIE51bWJlciB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgbWluaW11bSBhbmRcblx0Ly8gICAgICAgIG1heGltdW0gZnJhY3Rpb24gZGlnaXRzIHRvIGJlIHNob3duLiBFaXRoZXIgbm9uZSBvciBib3RoIG9mIHRoZXNlIHByb3BlcnRpZXMgYXJlXG5cdC8vICAgICAgICBwcmVzZW50OyBpZiB0aGV5IGFyZSwgdGhleSBvdmVycmlkZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGludGVnZXIgYW5kIGZyYWN0aW9uIGRpZ2l0c1xuXHQvLyAgICAgICAg4oCTIHRoZSBmb3JtYXR0ZXIgdXNlcyBob3dldmVyIG1hbnkgaW50ZWdlciBhbmQgZnJhY3Rpb24gZGlnaXRzIGFyZSByZXF1aXJlZCB0byBkaXNwbGF5XG5cdC8vICAgICAgICB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMuXG5cdC8vICA3OiBAcm91bmRJbmNyZW1lbnQgRGVjaW1hbCByb3VuZCBpbmNyZW1lbnQgb3IgbnVsbFxuXHQvLyAgODogQHByaW1hcnlHcm91cGluZ1NpemVcblx0Ly8gIDk6IEBzZWNvbmRhcnlHcm91cGluZ1NpemVcblx0Ly8gMTA6IEBzdWZmaXggU3RyaW5nXG5cdHJldHVybiBbXG5cdFx0cHJlZml4LFxuXHRcdHBhZGRpbmcsXG5cdFx0bWluaW11bUludGVnZXJEaWdpdHMsXG5cdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzLFxuXHRcdG1heGltdW1GcmFjdGlvbkRpZ2l0cyxcblx0XHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsXG5cdFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzLFxuXHRcdHJvdW5kSW5jcmVtZW50LFxuXHRcdHByaW1hcnlHcm91cGluZ1NpemUsXG5cdFx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplLFxuXHRcdHN1ZmZpeFxuXHRdO1xufTtcblxuXG5cblxuLyoqXG4gKiBTeW1ib2woIG5hbWUsIGNsZHIgKVxuICpcbiAqIEBuYW1lIFtTdHJpbmddIFN5bWJvbCBuYW1lLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gdGhlIGxvY2FsaXplZCBzeW1ib2wgZ2l2ZW4gaXRzIG5hbWUuXG4gKi9cbnZhciBudW1iZXJTeW1ib2wgPSBmdW5jdGlvbiggbmFtZSwgY2xkciApIHtcblx0cmV0dXJuIGNsZHIubWFpbihbXG5cdFx0XCJudW1iZXJzL3N5bWJvbHMtbnVtYmVyU3lzdGVtLVwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICksXG5cdFx0bmFtZVxuXHRdKTtcbn07XG5cblxuXG5cbnZhciBudW1iZXJTeW1ib2xOYW1lID0ge1xuXHRcIi5cIjogXCJkZWNpbWFsXCIsXG5cdFwiLFwiOiBcImdyb3VwXCIsXG5cdFwiJVwiOiBcInBlcmNlbnRTaWduXCIsXG5cdFwiK1wiOiBcInBsdXNTaWduXCIsXG5cdFwiLVwiOiBcIm1pbnVzU2lnblwiLFxuXHRcIkVcIjogXCJleHBvbmVudGlhbFwiLFxuXHRcIlxcdTIwMzBcIjogXCJwZXJNaWxsZVwiXG59O1xuXG5cblxuXG4vKipcbiAqIHN5bWJvbE1hcCggY2xkciApXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiB0aGUgKGxvY2FsaXplZCBzeW1ib2wsIHBhdHRlcm4gc3ltYm9sKSBrZXkgdmFsdWUgcGFpciwgZWcuIHtcbiAqICAgXCIuXCI6IFwi2atcIixcbiAqICAgXCIsXCI6IFwi2axcIixcbiAqICAgXCIlXCI6IFwi2apcIixcbiAqICAgLi4uXG4gKiB9O1xuICovXG52YXIgbnVtYmVyU3ltYm9sTWFwID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHZhciBzeW1ib2wsXG5cdFx0c3ltYm9sTWFwID0ge307XG5cblx0Zm9yICggc3ltYm9sIGluIG51bWJlclN5bWJvbE5hbWUgKSB7XG5cdFx0c3ltYm9sTWFwWyBzeW1ib2wgXSA9IG51bWJlclN5bWJvbCggbnVtYmVyU3ltYm9sTmFtZVsgc3ltYm9sIF0sIGNsZHIgKTtcblx0fVxuXG5cdHJldHVybiBzeW1ib2xNYXA7XG59O1xuXG5cblxuXG52YXIgbnVtYmVyVHJ1bmNhdGUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIE5hTjtcblx0fVxuXHRyZXR1cm4gTWF0aFsgdmFsdWUgPCAwID8gXCJjZWlsXCIgOiBcImZsb29yXCIgXSggdmFsdWUgKTtcbn07XG5cblxuXG5cbi8qKlxuICogcm91bmQoIG1ldGhvZCApXG4gKlxuICogQG1ldGhvZCBbU3RyaW5nXSB3aXRoIGVpdGhlciBcInJvdW5kXCIsIFwiY2VpbFwiLCBcImZsb29yXCIsIG9yIFwidHJ1bmNhdGVcIi5cbiAqXG4gKiBSZXR1cm4gZnVuY3Rpb24oIHZhbHVlLCBpbmNyZW1lbnRPckV4cCApOlxuICpcbiAqICAgQHZhbHVlIFtOdW1iZXJdIGVnLiAxMjMuNDUuXG4gKlxuICogICBAaW5jcmVtZW50T3JFeHAgW051bWJlcl0gb3B0aW9uYWwsIGVnLiAwLjE7IG9yXG4gKiAgICAgW09iamVjdF0gRWl0aGVyIHsgaW5jcmVtZW50OiA8dmFsdWU+IH0gb3IgeyBleHBvbmVudDogPHZhbHVlPiB9XG4gKlxuICogICBSZXR1cm4gdGhlIHJvdW5kZWQgbnVtYmVyLCBlZzpcbiAqICAgLSByb3VuZCggXCJyb3VuZFwiICkoIDEyMy40NSApOiAxMjM7XG4gKiAgIC0gcm91bmQoIFwiY2VpbFwiICkoIDEyMy40NSApOiAxMjQ7XG4gKiAgIC0gcm91bmQoIFwiZmxvb3JcIiApKCAxMjMuNDUgKTogMTIzO1xuICogICAtIHJvdW5kKCBcInRydW5jYXRlXCIgKSggMTIzLjQ1ICk6IDEyMztcbiAqICAgLSByb3VuZCggXCJyb3VuZFwiICkoIDEyMy40NSwgMC4xICk6IDEyMy41O1xuICogICAtIHJvdW5kKCBcInJvdW5kXCIgKSggMTIzLjQ1LCAxMCApOiAxMjA7XG4gKlxuICogICBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4gKiAgIFJlZjogIzM3NlxuICovXG52YXIgbnVtYmVyUm91bmQgPSBmdW5jdGlvbiggbWV0aG9kICkge1xuXHRtZXRob2QgPSBtZXRob2QgfHwgXCJyb3VuZFwiO1xuXHRtZXRob2QgPSBtZXRob2QgPT09IFwidHJ1bmNhdGVcIiA/IG51bWJlclRydW5jYXRlIDogTWF0aFsgbWV0aG9kIF07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSwgaW5jcmVtZW50T3JFeHAgKSB7XG5cdFx0dmFyIGV4cCwgaW5jcmVtZW50O1xuXG5cdFx0dmFsdWUgPSArdmFsdWU7XG5cblx0XHQvLyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLCByZXR1cm4gTmFOLlxuXHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH1cblxuXHRcdC8vIEV4cG9uZW50IGdpdmVuLlxuXHRcdGlmICggdHlwZW9mIGluY3JlbWVudE9yRXhwID09PSBcIm9iamVjdFwiICYmIGluY3JlbWVudE9yRXhwLmV4cG9uZW50ICkge1xuXHRcdFx0ZXhwID0gK2luY3JlbWVudE9yRXhwLmV4cG9uZW50O1xuXHRcdFx0aW5jcmVtZW50ID0gMTtcblxuXHRcdFx0aWYgKCBleHAgPT09IDAgKSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2QoIHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBleHAgaXMgbm90IGFuIGludGVnZXIsIHJldHVybiBOYU4uXG5cdFx0XHRpZiAoICEoIHR5cGVvZiBleHAgPT09IFwibnVtYmVyXCIgJiYgZXhwICUgMSA9PT0gMCApICkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSW5jcmVtZW50IGdpdmVuLlxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbmNyZW1lbnQgPSAraW5jcmVtZW50T3JFeHAgfHwgMTtcblxuXHRcdFx0aWYgKCBpbmNyZW1lbnQgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2QoIHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBpbmNyZW1lbnQgaXMgbm90IGEgbnVtYmVyLCByZXR1cm4gTmFOLlxuXHRcdFx0aWYgKCBpc05hTiggaW5jcmVtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9XG5cblx0XHRcdGluY3JlbWVudCA9IGluY3JlbWVudC50b0V4cG9uZW50aWFsKCkuc3BsaXQoIFwiZVwiICk7XG5cdFx0XHRleHAgPSAraW5jcmVtZW50WyAxIF07XG5cdFx0XHRpbmNyZW1lbnQgPSAraW5jcmVtZW50WyAwIF07XG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgJiBSb3VuZFxuXHRcdHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCggXCJlXCIgKTtcblx0XHR2YWx1ZVsgMCBdID0gK3ZhbHVlWyAwIF0gLyBpbmNyZW1lbnQ7XG5cdFx0dmFsdWVbIDEgXSA9IHZhbHVlWyAxIF0gPyAoICt2YWx1ZVsgMSBdIC0gZXhwICkgOiAtZXhwO1xuXHRcdHZhbHVlID0gbWV0aG9kKCArKCB2YWx1ZVsgMCBdICsgXCJlXCIgKyB2YWx1ZVsgMSBdICkgKTtcblxuXHRcdC8vIFNoaWZ0IGJhY2tcblx0XHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoIFwiZVwiICk7XG5cdFx0dmFsdWVbIDAgXSA9ICt2YWx1ZVsgMCBdICogaW5jcmVtZW50O1xuXHRcdHZhbHVlWyAxIF0gPSB2YWx1ZVsgMSBdID8gKCArdmFsdWVbIDEgXSArIGV4cCApIDogZXhwO1xuXHRcdHJldHVybiArKCB2YWx1ZVsgMCBdICsgXCJlXCIgKyB2YWx1ZVsgMSBdICk7XG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIGZvcm1hdFByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgWywgb3B0aW9uc10gKVxuICpcbiAqIEBwYXR0ZXJuIFtTdHJpbmddIHJhdyBwYXR0ZXJuIGZvciBudW1iZXJzLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTpcbiAqIC0gbWluaW11bUludGVnZXJEaWdpdHMgW051bWJlcl1cbiAqIC0gbWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgW051bWJlcl1cbiAqIC0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgW051bWJlcl1cbiAqIC0gcm91bmQgW1N0cmluZ10gXCJjZWlsXCIsIFwiZmxvb3JcIiwgXCJyb3VuZFwiIChkZWZhdWx0KSwgb3IgXCJ0cnVuY2F0ZVwiLlxuICogLSB1c2VHcm91cGluZyBbQm9vbGVhbl0gZGVmYXVsdCB0cnVlLlxuICpcbiAqIFJldHVybiB0aGUgcHJvY2Vzc2VkIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHVzZWQgaW4gbnVtYmVyL2Zvcm1hdC5cbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWxcbiAqL1xudmFyIG51bWJlckZvcm1hdFByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApIHtcblx0dmFyIG5lZ2F0aXZlUGF0dGVybiwgbmVnYXRpdmVQcmVmaXgsIG5lZ2F0aXZlUHJvcGVydGllcywgbmVnYXRpdmVTdWZmaXgsIHBvc2l0aXZlUGF0dGVybixcblx0XHRyb3VuZEZuLCBwcm9wZXJ0aWVzO1xuXG5cdGZ1bmN0aW9uIGdldE9wdGlvbnMoIGF0dHJpYnV0ZSwgcHJvcGVydHlJbmRleCApIHtcblx0XHRpZiAoIGF0dHJpYnV0ZSBpbiBvcHRpb25zICkge1xuXHRcdFx0cHJvcGVydGllc1sgcHJvcGVydHlJbmRleCBdID0gb3B0aW9uc1sgYXR0cmlidXRlIF07XG5cdFx0fVxuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KCBcIjtcIiApO1xuXG5cdHBvc2l0aXZlUGF0dGVybiA9IHBhdHRlcm5bIDAgXTtcblxuXHRuZWdhdGl2ZVBhdHRlcm4gPSBwYXR0ZXJuWyAxIF0gfHwgXCItXCIgKyBwb3NpdGl2ZVBhdHRlcm47XG5cdG5lZ2F0aXZlUHJvcGVydGllcyA9IG51bWJlclBhdHRlcm5Qcm9wZXJ0aWVzKCBuZWdhdGl2ZVBhdHRlcm4gKTtcblx0bmVnYXRpdmVQcmVmaXggPSBuZWdhdGl2ZVByb3BlcnRpZXNbIDAgXTtcblx0bmVnYXRpdmVTdWZmaXggPSBuZWdhdGl2ZVByb3BlcnRpZXNbIDEwIF07XG5cblx0Ly8gSGF2ZSBydW50aW1lIGNvZGUgdG8gcmVmZXIgdG8gbnVtYmVyUm91bmQoKSBpbnN0ZWFkIG9mIGluY2x1ZGluZyBpdCBleHBsaWNpdGx5LlxuXHRyb3VuZEZuID0gbnVtYmVyUm91bmQoIG9wdGlvbnMucm91bmQgKTtcblx0cm91bmRGbi5nZW5lcmF0b3JTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJudW1iZXJSb3VuZChcIiArICggb3B0aW9ucy5yb3VuZCA/IFwiXFxcIlwiICsgb3B0aW9ucy5yb3VuZCArIFwiXFxcIlwiIDogXCJcIiApICsgXCIpXCI7XG5cdH07XG5cblx0cHJvcGVydGllcyA9IG51bWJlclBhdHRlcm5Qcm9wZXJ0aWVzKCBwb3NpdGl2ZVBhdHRlcm4gKS5jb25jYXQoW1xuXHRcdHBvc2l0aXZlUGF0dGVybixcblx0XHRuZWdhdGl2ZVByZWZpeCArIHBvc2l0aXZlUGF0dGVybiArIG5lZ2F0aXZlU3VmZml4LFxuXHRcdG5lZ2F0aXZlUHJlZml4LFxuXHRcdG5lZ2F0aXZlU3VmZml4LFxuXHRcdHJvdW5kRm4sXG5cdFx0bnVtYmVyU3ltYm9sKCBcImluZmluaXR5XCIsIGNsZHIgKSxcblx0XHRudW1iZXJTeW1ib2woIFwibmFuXCIsIGNsZHIgKSxcblx0XHRudW1iZXJTeW1ib2xNYXAoIGNsZHIgKSxcblx0XHRudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAoIGNsZHIgKVxuXHRdKTtcblxuXHRnZXRPcHRpb25zKCBcIm1pbmltdW1JbnRlZ2VyRGlnaXRzXCIsIDIgKTtcblx0Z2V0T3B0aW9ucyggXCJtaW5pbXVtRnJhY3Rpb25EaWdpdHNcIiwgMyApO1xuXHRnZXRPcHRpb25zKCBcIm1heGltdW1GcmFjdGlvbkRpZ2l0c1wiLCA0ICk7XG5cdGdldE9wdGlvbnMoIFwibWluaW11bVNpZ25pZmljYW50RGlnaXRzXCIsIDUgKTtcblx0Z2V0T3B0aW9ucyggXCJtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHNcIiwgNiApO1xuXG5cdC8vIEdyb3VwaW5nIHNlcGFyYXRvcnNcblx0aWYgKCBvcHRpb25zLnVzZUdyb3VwaW5nID09PSBmYWxzZSApIHtcblx0XHRwcm9wZXJ0aWVzWyA4IF0gPSBudWxsO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG51bWJlciBvZiBkaWdpdHMgaWYgb25seSBvbmUgb2YgZWl0aGVyIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBvclxuXHQvLyBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgaXMgcGFzc2VkIGluIGFzIGFuIG9wdGlvblxuXHRpZiAoIFwibWluaW11bUZyYWN0aW9uRGlnaXRzXCIgaW4gb3B0aW9ucyAmJiAhKCBcIm1heGltdW1GcmFjdGlvbkRpZ2l0c1wiIGluIG9wdGlvbnMgKSApIHtcblxuXHRcdC8vIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IE1hdGgubWF4KCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyApO1xuXHRcdHByb3BlcnRpZXNbIDQgXSA9IE1hdGgubWF4KCBwcm9wZXJ0aWVzWyAzIF0sIHByb3BlcnRpZXNbIDQgXSApO1xuXHR9IGVsc2UgaWYgKCAhKCBcIm1pbmltdW1GcmFjdGlvbkRpZ2l0c1wiIGluIG9wdGlvbnMgKSAmJlxuXHRcdFx0XCJtYXhpbXVtRnJhY3Rpb25EaWdpdHNcIiBpbiBvcHRpb25zICkge1xuXG5cdFx0Ly8gbWluaW11bUZyYWN0aW9uRGlnaXRzID0gTWF0aC5taW4oIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzICk7XG5cdFx0cHJvcGVydGllc1sgMyBdID0gTWF0aC5taW4oIHByb3BlcnRpZXNbIDMgXSwgcHJvcGVydGllc1sgNCBdICk7XG5cdH1cblxuXHQvLyBSZXR1cm46XG5cdC8vIDAtMTA6IHNlZSBudW1iZXIvcGF0dGVybi1wcm9wZXJ0aWVzLlxuXHQvLyAxMTogQHBvc2l0aXZlUGF0dGVybiBbU3RyaW5nXSBQb3NpdGl2ZSBwYXR0ZXJuLlxuXHQvLyAxMjogQG5lZ2F0aXZlUGF0dGVybiBbU3RyaW5nXSBOZWdhdGl2ZSBwYXR0ZXJuLlxuXHQvLyAxMzogQG5lZ2F0aXZlUHJlZml4IFtTdHJpbmddIE5lZ2F0aXZlIHByZWZpeC5cblx0Ly8gMTQ6IEBuZWdhdGl2ZVN1ZmZpeCBbU3RyaW5nXSBOZWdhdGl2ZSBzdWZmaXguXG5cdC8vIDE1OiBAcm91bmQgW0Z1bmN0aW9uXSBSb3VuZCBmdW5jdGlvbi5cblx0Ly8gMTY6IEBpbmZpbml0eVN5bWJvbCBbU3RyaW5nXSBJbmZpbml0eSBzeW1ib2wuXG5cdC8vIDE3OiBAbmFuU3ltYm9sIFtTdHJpbmddIE5hTiBzeW1ib2wuXG5cdC8vIDE4OiBAc3ltYm9sTWFwIFtPYmplY3RdIEEgYnVuY2ggb2Ygb3RoZXIgc3ltYm9scy5cblx0Ly8gMTk6IEBudURpZ2l0c01hcCBbQXJyYXldIERpZ2l0cyBtYXAgaWYgbnVtYmVyaW5nIHN5c3RlbSBpcyBkaWZmZXJlbnQgdGhhbiBgbGF0bmAuXG5cdHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnk6XG4gKlxuICogdmFyIHJlZ2VuZXJhdGUgPSByZXF1aXJlKCBcInJlZ2VuZXJhdGVcIiApO1xuICogdmFyIGZvcm1hdFN5bWJvbHMgPSByZXF1aXJlKCAqIFwidW5pY29kZS04LjAuMC9HZW5lcmFsX0NhdGVnb3J5L0Zvcm1hdC9zeW1ib2xzXCIgKTtcbiAqIHJlZ2VuZXJhdGUoKS5hZGQoIGZvcm1hdFN5bWJvbHMgKS50b1N0cmluZygpO1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOC4wLjBcbiAqL1xudmFyIHJlZ2V4cENmRyA9IC9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFxcdURDQkR8XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdL2c7XG5cblxuXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ5OlxuICpcbiAqIHZhciByZWdlbmVyYXRlID0gcmVxdWlyZSggXCJyZWdlbmVyYXRlXCIgKTtcbiAqIHZhciBkYXNoU3ltYm9scyA9IHJlcXVpcmUoICogXCJ1bmljb2RlLTguMC4wL0dlbmVyYWxfQ2F0ZWdvcnkvRGFzaF9QdW5jdHVhdGlvbi9zeW1ib2xzXCIgKTtcbiAqIHJlZ2VuZXJhdGUoKS5hZGQoIGRhc2hTeW1ib2xzICkudG9TdHJpbmcoKTtcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9yZWdlbmVyYXRlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTguMC4wXG4gKlxuICogTk9URTogSW4gYWRkaXRpb24gdG8gWzpkYXNoOl0sICB0aGUgYmVsb3cgaW5jbHVkZXMgTUlOVVMgU0lHTiBVKzIyMTIuXG4gKi9cbnZhciByZWdleHBEYXNoRyA9IC9bXFwtXFx1MDU4QVxcdTA1QkVcXHUxNDAwXFx1MTgwNlxcdTIwMTAtXFx1MjAxNVxcdTJFMTdcXHUyRTFBXFx1MkUzQVxcdTJFM0JcXHUyRTQwXFx1MzAxQ1xcdTMwMzBcXHUzMEEwXFx1RkUzMVxcdUZFMzJcXHVGRTU4XFx1RkU2M1xcdUZGMERcXHUyMjEyXS9nO1xuXG5cblxuXG4vKipcbiAqIEdlbmVyYXRlZCBieTpcbiAqXG4gKiB2YXIgcmVnZW5lcmF0ZSA9IHJlcXVpcmUoIFwicmVnZW5lcmF0ZVwiICk7XG4gKiB2YXIgc3BhY2VTZXBhcmF0b3JTeW1ib2xzID0gcmVxdWlyZSggXCJ1bmljb2RlLTguMC4wL0dlbmVyYWxfQ2F0ZWdvcnkvU3BhY2VfU2VwYXJhdG9yL3N5bWJvbHNcIiApO1xuICogcmVnZW5lcmF0ZSgpLmFkZCggc3BhY2VTZXBhcmF0b3JTeW1ib2xzICkudG9TdHJpbmcoKTtcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9yZWdlbmVyYXRlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTguMC4wXG4gKi9cbnZhciByZWdleHBac0cgPSAvWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdL2c7XG5cblxuXG5cbi8qKlxuICogTG9vc2UgTWF0Y2hpbmc6XG4gKiAtIElnbm9yZSBhbGwgZm9ybWF0IGNoYXJhY3RlcnMsIHdoaWNoIGluY2x1ZGVzIFJMTSwgTFJNIG9yIEFMTSB1c2VkIHRvIGNvbnRyb2wgQklESVxuICogICBmb3JtYXR0aW5nLlxuICogLSBNYXAgYWxsIGNoYXJhY3RlcnMgaW4gWzpaczpdIHRvIFUrMDAyMCBTUEFDRTtcbiAqIC0gTWFwIGFsbCBjaGFyYWN0ZXJzIGluIFs6RGFzaDpdIHRvIFUrMDAyRCBIWVBIRU4tTUlOVVM7XG4gKi9cbnZhciBsb29zZU1hdGNoaW5nID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRyZXR1cm4gdmFsdWVcblx0XHQucmVwbGFjZSggcmVnZXhwQ2ZHLCBcIlwiIClcblx0XHQucmVwbGFjZSggcmVnZXhwRGFzaEcsIFwiLVwiIClcblx0XHQucmVwbGFjZSggcmVnZXhwWnNHLCBcIiBcIiApO1xufTtcblxuXG5cblxuLyoqXG4gKiBwYXJzZSggdmFsdWUsIHByb3BlcnRpZXMgKVxuICpcbiAqIEB2YWx1ZSBbU3RyaW5nXS5cbiAqXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBQYXJzZXIgcHJvcGVydGllcyBpcyBhIHJlZHVjZWQgcHJlLXByb2Nlc3NlZCBjbGRyXG4gKiBkYXRhIHNldCByZXR1cm5lZCBieSBudW1iZXJQYXJzZXJQcm9wZXJ0aWVzKCkuXG4gKlxuICogUmV0dXJuIHRoZSBwYXJzZWQgTnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkpIG9yIE5hTiB3aGVuIHZhbHVlIGlzIGludmFsaWQuXG4gKiByZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sXG4gKi9cbnZhciBudW1iZXJQYXJzZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgcHJvcGVydGllcyApIHtcblx0dmFyIGdyYW1tYXIsIGludmVydGVkTnVEaWdpdHNNYXAsIGludmVydGVkU3ltYm9sTWFwLCBuZWdhdGl2ZSwgbnVtYmVyLCBwcmVmaXgsIHByZWZpeE5TdWZmaXgsXG5cdFx0c3VmZml4LCB0b2tlbml6ZXIsIHZhbGlkO1xuXG5cdC8vIEdyYW1tYXI6XG5cdC8vIC0gVmFsdWUgPD0gICAgICAgICAgIE5hTiB8IFBvc2l0aXZlTnVtYmVyIHwgTmVnYXRpdmVOdW1iZXJcblx0Ly8gLSBQb3NpdGl2ZU51bWJlciA8PSAgUG9zaXRpdmVQcmVmaXggTnVtYmVyT3JJbmYgUG9zaXRpdmVTdWZpeFxuXHQvLyAtIE5lZ2F0aXZlTnVtYmVyIDw9ICBOZWdhdGl2ZVByZWZpeCBOdW1iZXJPckluZlxuXHQvLyAtIE51bWJlck9ySW5mIDw9ICAgICBOdW1iZXIgfCBJbmZcblx0Z3JhbW1hciA9IFtcblx0XHRbIFwibmFuXCIgXSxcblx0XHRbIFwicHJlZml4XCIsIFwiaW5maW5pdHlcIiwgXCJzdWZmaXhcIiBdLFxuXHRcdFsgXCJwcmVmaXhcIiwgXCJudW1iZXJcIiwgXCJzdWZmaXhcIiBdLFxuXHRcdFsgXCJuZWdhdGl2ZVByZWZpeFwiLCBcImluZmluaXR5XCIsIFwibmVnYXRpdmVTdWZmaXhcIiBdLFxuXHRcdFsgXCJuZWdhdGl2ZVByZWZpeFwiLCBcIm51bWJlclwiLCBcIm5lZ2F0aXZlU3VmZml4XCIgXVxuXHRdO1xuXG5cdGludmVydGVkU3ltYm9sTWFwID0gcHJvcGVydGllc1sgMCBdO1xuXHRpbnZlcnRlZE51RGlnaXRzTWFwID0gcHJvcGVydGllc1sgMSBdIHx8IHt9O1xuXHR0b2tlbml6ZXIgPSBwcm9wZXJ0aWVzWyAyIF07XG5cblx0dmFsdWUgPSBsb29zZU1hdGNoaW5nKCB2YWx1ZSApO1xuXG5cdGZ1bmN0aW9uIHBhcnNlKCB0eXBlICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggbGV4ZW1lICkge1xuXG5cdFx0XHQvLyBSZXZlcnNlIGxvY2FsaXplZCBzeW1ib2xzIGFuZCBudW1iZXJpbmcgc3lzdGVtLlxuXHRcdFx0bGV4ZW1lID0gbGV4ZW1lLnNwbGl0KCBcIlwiICkubWFwKGZ1bmN0aW9uKCBjaGFyYWN0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBpbnZlcnRlZFN5bWJvbE1hcFsgY2hhcmFjdGVyIF0gfHxcblx0XHRcdFx0XHRpbnZlcnRlZE51RGlnaXRzTWFwWyBjaGFyYWN0ZXIgXSB8fFxuXHRcdFx0XHRcdGNoYXJhY3Rlcjtcblx0XHRcdH0pLmpvaW4oIFwiXCIgKTtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblx0XHRcdFx0Y2FzZSBcImluZmluaXR5XCI6XG5cdFx0XHRcdFx0bnVtYmVyID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIm5hblwiOlxuXHRcdFx0XHRcdG51bWJlciA9IE5hTjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwibnVtYmVyXCI6XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgZ3JvdXBpbmcgc2VwYXJhdG9ycy5cblx0XHRcdFx0XHRsZXhlbWUgPSBsZXhlbWUucmVwbGFjZSggLywvZywgXCJcIiApO1xuXG5cdFx0XHRcdFx0bnVtYmVyID0gK2xleGVtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwicHJlZml4XCI6XG5cdFx0XHRcdGNhc2UgXCJuZWdhdGl2ZVByZWZpeFwiOlxuXHRcdFx0XHRcdHByZWZpeCA9IGxleGVtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwic3VmZml4XCI6XG5cdFx0XHRcdFx0c3VmZml4ID0gbGV4ZW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJuZWdhdGl2ZVN1ZmZpeFwiOlxuXHRcdFx0XHRcdHN1ZmZpeCA9IGxleGVtZTtcblx0XHRcdFx0XHRuZWdhdGl2ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgcmVhY2hlZC5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiSW50ZXJuYWwgZXJyb3JcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRva2VuaXplTlBhcnNlKCBfdmFsdWUsIGdyYW1tYXIgKSB7XG5cdFx0cmV0dXJuIGdyYW1tYXIuc29tZShmdW5jdGlvbiggc3RhdGVtZW50ICkge1xuXHRcdFx0dmFyIHZhbHVlID0gX3ZhbHVlO1xuXG5cdFx0XHQvLyBUaGUgd2hvbGUgZ3JhbW1hciBzdGF0ZW1lbnQgc2hvdWxkIGJlIHVzZWQgKGkuZS4sIC5ldmVyeSgpIHJldHVybiB0cnVlKSBhbmQgdmFsdWUgYmVcblx0XHRcdC8vIGVudGlyZWx5IGNvbnN1bWVkIChpLmUuLCAhdmFsdWUubGVuZ3RoKS5cblx0XHRcdHJldHVybiBzdGF0ZW1lbnQuZXZlcnkoZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUubWF0Y2goIHRva2VuaXplclsgdHlwZSBdICkgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29uc3VtZSBhbmQgcGFyc2UgaXQuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggdG9rZW5pemVyWyB0eXBlIF0sIHBhcnNlKCB0eXBlICkgKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9KSAmJiAhdmFsdWUubGVuZ3RoO1xuXHRcdH0pO1xuXHR9XG5cblx0dmFsaWQgPSB0b2tlbml6ZU5QYXJzZSggdmFsdWUsIGdyYW1tYXIgKTtcblxuXHQvLyBOYU5cblx0aWYgKCAhdmFsaWQgfHwgaXNOYU4oIG51bWJlciApICkge1xuXHRcdHJldHVybiBOYU47XG5cdH1cblxuXHRwcmVmaXhOU3VmZml4ID0gXCJcIiArIHByZWZpeCArIHN1ZmZpeDtcblxuXHQvLyBQZXJjZW50XG5cdGlmICggcHJlZml4TlN1ZmZpeC5pbmRleE9mKCBcIiVcIiApICE9PSAtMSApIHtcblx0XHRudW1iZXIgLz0gMTAwO1xuXG5cdC8vIFBlciBtaWxsZVxuXHR9IGVsc2UgaWYgKCBwcmVmaXhOU3VmZml4LmluZGV4T2YoIFwiXFx1MjAzMFwiICkgIT09IC0xICkge1xuXHRcdG51bWJlciAvPSAxMDAwO1xuXHR9XG5cblx0Ly8gTmVnYXRpdmUgbnVtYmVyXG5cdGlmICggbmVnYXRpdmUgKSB7XG5cdFx0bnVtYmVyICo9IC0xO1xuXHR9XG5cblx0cmV0dXJuIG51bWJlcjtcbn07XG5cblxuXG5cbnZhciBudW1iZXJQYXJzZXJGbiA9IGZ1bmN0aW9uKCBwcm9wZXJ0aWVzICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gbnVtYmVyUGFyc2VyKCB2YWx1ZSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHRyZXR1cm4gbnVtYmVyUGFyc2UoIHZhbHVlLCBwcm9wZXJ0aWVzICk7XG5cdH07XG5cbn07XG5cblxuXG5cbi8qKlxuICogc3ltYm9sTWFwKCBjbGRyIClcbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHRoZSAobG9jYWxpemVkIHN5bWJvbCwgcGF0dGVybiBzeW1ib2wpIGtleSB2YWx1ZSBwYWlyLCBlZy4ge1xuICogICBcItmrXCI6IFwiLlwiLFxuICogICBcItmsXCI6IFwiLFwiLFxuICogICBcItmqXCI6IFwiJVwiLFxuICogICAuLi5cbiAqIH07XG4gKi9cbnZhciBudW1iZXJTeW1ib2xJbnZlcnRlZE1hcCA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHR2YXIgc3ltYm9sLFxuXHRcdHN5bWJvbE1hcCA9IHt9O1xuXG5cdGZvciAoIHN5bWJvbCBpbiBudW1iZXJTeW1ib2xOYW1lICkge1xuXHRcdHN5bWJvbE1hcFsgbnVtYmVyU3ltYm9sKCBudW1iZXJTeW1ib2xOYW1lWyBzeW1ib2wgXSwgY2xkciApIF0gPSBzeW1ib2w7XG5cdH1cblxuXHRyZXR1cm4gc3ltYm9sTWFwO1xufTtcblxuXG5cblxuLyoqXG4gKiBvYmplY3RNYXAoIG9iamVjdCwgZm4pXG4gKlxuICogLSBvYmplY3RcbiAqXG4gKiAtIGZuKCBwYWlyICkgPT4gcGFpclxuICovXG52YXIgb2JqZWN0TWFwID0gZnVuY3Rpb24oIG9iamVjdCwgZm4gKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyggb2JqZWN0ICkubWFwKGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIGZuKFsga2V5LCBvYmplY3RbIGtleSBdIF0pO1xuXHR9KS5yZWR1Y2UoZnVuY3Rpb24oIG9iamVjdCwgcGFpciApIHtcblx0XHRvYmplY3RbIHBhaXJbIDAgXSBdID0gcGFpclsgMSBdO1xuXHRcdHJldHVybiBvYmplY3Q7XG5cdH0sIHt9KTtcbn07XG5cblxuXG5cbi8qKlxuICogcGFyc2VQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyIClcbiAqXG4gKiBAcGF0dGVybiBbU3RyaW5nXSByYXcgcGF0dGVybiBmb3IgbnVtYmVycy5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHBhcnNlciBwcm9wZXJ0aWVzLCB1c2VkIHRvIGZlZWQgcGFyc2VyIGZ1bmN0aW9uLlxuICpcbiAqIFRPRE86XG4gKiAtIFNjaWVudGlmaWNfbm90YXRpb247XG4gKiAtIFBhZGRpbmc7XG4gKi9cbnZhciBudW1iZXJQYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApIHtcblx0dmFyIGF1eCwgZGVjaW1hbFN5bWJvbFJlLCBkaWdpdHNSZSwgZ3JvdXBpbmdTZXBhcmF0b3JSZSwgaW5maW5pdHlTeW1ib2wsIGludmVydGVkTnVEaWdpdHNNYXAsXG5cdFx0aW52ZXJ0ZWRTeW1ib2xNYXAsIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLFxuXHRcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgbmFuU3ltYm9sLCBuZWdhdGl2ZVByZWZpeCwgbmVnYXRpdmVTdWZmaXgsIG51RGlnaXRzTWFwLFxuXHRcdG51bWJlclRva2VuaXplciwgcHJlZml4LCBwcmltYXJ5R3JvdXBpbmdTaXplLCBzZWNvbmRhcnlHcm91cGluZ1NpemUsIHN1ZmZpeCwgc3ltYm9sTWFwLFxuXHRcdGZvcm1hdFByb3BlcnRpZXMgPSBudW1iZXJGb3JtYXRQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICk7XG5cblx0cHJlZml4ID0gbG9vc2VNYXRjaGluZyggZm9ybWF0UHJvcGVydGllc1sgMCBdICk7XG5cdG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IGZvcm1hdFByb3BlcnRpZXNbIDQgXTtcblx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzID0gZm9ybWF0UHJvcGVydGllc1sgNSBdO1xuXHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBmb3JtYXRQcm9wZXJ0aWVzWyA2IF07XG5cdHByaW1hcnlHcm91cGluZ1NpemUgPSBmb3JtYXRQcm9wZXJ0aWVzWyA4IF07XG5cdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA9IGZvcm1hdFByb3BlcnRpZXNbIDkgXTtcblx0c3VmZml4ID0gbG9vc2VNYXRjaGluZyggZm9ybWF0UHJvcGVydGllc1sgMTAgXSApO1xuXHRuZWdhdGl2ZVByZWZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDEzIF0gKTtcblx0bmVnYXRpdmVTdWZmaXggPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAxNCBdICk7XG5cdGluZmluaXR5U3ltYm9sID0gbG9vc2VNYXRjaGluZyggZm9ybWF0UHJvcGVydGllc1sgMTYgXSApO1xuXHRuYW5TeW1ib2wgPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAxNyBdICk7XG5cdHN5bWJvbE1hcCA9IG9iamVjdE1hcCggZm9ybWF0UHJvcGVydGllc1sgMTggXSwgZnVuY3Rpb24oIHBhaXIgKSB7XG5cdFx0cmV0dXJuIFsgcGFpclsgMCBdLCBsb29zZU1hdGNoaW5nKCBwYWlyWyAxIF0gKSBdO1xuXHR9KTtcblx0bnVEaWdpdHNNYXAgPSBmb3JtYXRQcm9wZXJ0aWVzWyAxOSBdO1xuXG5cdGludmVydGVkU3ltYm9sTWFwID0gb2JqZWN0TWFwKCBudW1iZXJTeW1ib2xJbnZlcnRlZE1hcCggY2xkciApLCBmdW5jdGlvbiggcGFpciApIHtcblx0XHRyZXR1cm4gWyBsb29zZU1hdGNoaW5nKCBwYWlyWyAwIF0gKSwgcGFpclsgMSBdIF07XG5cdH0pO1xuXG5cdGRpZ2l0c1JlID0gbnVEaWdpdHNNYXAgPyBcIltcIiArIG51RGlnaXRzTWFwICsgXCJdXCIgOiBcIlxcXFxkXCI7XG5cdGdyb3VwaW5nU2VwYXJhdG9yUmUgPSByZWdleHBFc2NhcGUoIHN5bWJvbE1hcFsgXCIsXCIgXSApO1xuXHRkZWNpbWFsU3ltYm9sUmUgPSByZWdleHBFc2NhcGUoIHN5bWJvbE1hcFsgXCIuXCIgXSApO1xuXG5cdGlmICggbnVEaWdpdHNNYXAgKSB7XG5cdFx0aW52ZXJ0ZWROdURpZ2l0c01hcCA9IG51RGlnaXRzTWFwLnNwbGl0KCBcIlwiICkucmVkdWNlKGZ1bmN0aW9uKCBvYmplY3QsIGxvY2FsaXplZERpZ2l0LCBpICkge1xuXHRcdFx0b2JqZWN0WyBsb2NhbGl6ZWREaWdpdCBdID0gU3RyaW5nKCBpICk7XG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXHRcdH0sIHt9ICk7XG5cdH1cblxuXHRhdXggPSBbIHByZWZpeCwgc3VmZml4LCBuZWdhdGl2ZVByZWZpeCwgbmVnYXRpdmVTdWZmaXggXS5tYXAoZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvKCcoW14nXXwnJykrJ3wnJyl8Li9nLCBmdW5jdGlvbiggY2hhcmFjdGVyLCBsaXRlcmFsICkge1xuXG5cdFx0XHQvLyBMaXRlcmFsc1xuXHRcdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlTGl0ZXJhbFF1b3RlcyggbGl0ZXJhbCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTeW1ib2xzXG5cdFx0XHRjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIucmVwbGFjZSggL1tcXC0rRSVcXHUyMDMwXS8sIGZ1bmN0aW9uKCBzeW1ib2wgKSB7XG5cdFx0XHRcdHJldHVybiBzeW1ib2xNYXBbIHN5bWJvbCBdO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBjaGFyYWN0ZXI7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHByZWZpeCA9IGF1eFsgMCBdO1xuXHRzdWZmaXggPSBhdXhbIDEgXTtcblx0bmVnYXRpdmVQcmVmaXggPSBhdXhbIDIgXTtcblx0bmVnYXRpdmVTdWZmaXggPSBhdXhbIDMgXTtcblxuXHQvLyBOdW1iZXJcblx0Ly9cblx0Ly8gbnVtYmVyX3JlID0gICAgICAgICAgICAgICAgICAgICAgIGludGVnZXIgZnJhY3Rpb24/XG5cdC8vXG5cdC8vIGludGVnZXIgPSAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHMgfCBkaWdpdHNfdXNpbmdfZ3JvdXBpbmdfc2VwYXJhdG9yc1xuXHQvL1xuXHQvLyBmcmFjdGlvbiA9ICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwKCguXFxkKyk/KVxuXHQvL1xuXHQvLyBkaWdpdHMgPSAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwKFxcZCspXG5cdC8vXG5cdC8vIGRpZ2l0c193X2dyb3VwaW5nX3NlcGFyYXRvcnMgPSAgICBkaWdpdHNfd18xX2dyb3VwaW5nX3NlcGFyYXRvcnMgfFxuXHQvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzX3dfMl9ncm91cGluZ19zZXBhcmF0b3JzXG5cdC8vXG5cdC8vIGRpZ2l0c193XzFfZ3JvdXBpbmdfc2VwYXJhdG9ycyA9ICByZWdleHAoXFxkezEsM30oLFxcZHszfSkrKVxuXHQvL1xuXHQvLyBkaWdpdHNfd18yX2dyb3VwaW5nX3NlcGFyYXRvcnMgPSAgcmVnZXhwKFxcZHsxLDJ9KCgsXFxkezJ9KSooLFxcZHszfSkpKVxuXG5cdC8vIEludGVnZXIgcGFydFxuXHRudW1iZXJUb2tlbml6ZXIgPSBkaWdpdHNSZSArIFwiK1wiO1xuXG5cdC8vIEdyb3VwaW5nIHNlcGFyYXRvcnNcblx0aWYgKCBwcmltYXJ5R3JvdXBpbmdTaXplICkge1xuXHRcdGlmICggc2Vjb25kYXJ5R3JvdXBpbmdTaXplICkge1xuXHRcdFx0YXV4ID0gZGlnaXRzUmUgKyBcInsxLFwiICsgc2Vjb25kYXJ5R3JvdXBpbmdTaXplICsgXCJ9KChcIiArIGdyb3VwaW5nU2VwYXJhdG9yUmUgK1xuXHRcdFx0XHRkaWdpdHNSZSArIFwie1wiICsgc2Vjb25kYXJ5R3JvdXBpbmdTaXplICsgXCJ9KSooXCIgKyBncm91cGluZ1NlcGFyYXRvclJlICtcblx0XHRcdFx0ZGlnaXRzUmUgKyBcIntcIiArIHByaW1hcnlHcm91cGluZ1NpemUgKyBcIn0pKVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdXggPSBkaWdpdHNSZSArIFwiezEsXCIgKyBwcmltYXJ5R3JvdXBpbmdTaXplICsgXCJ9KFwiICsgZ3JvdXBpbmdTZXBhcmF0b3JSZSArXG5cdFx0XHRcdGRpZ2l0c1JlICsgXCJ7XCIgKyBwcmltYXJ5R3JvdXBpbmdTaXplICsgXCJ9KStcIjtcblx0XHR9XG5cdFx0bnVtYmVyVG9rZW5pemVyID0gXCIoXCIgKyBhdXggKyBcInxcIiArIG51bWJlclRva2VuaXplciArIFwiKVwiO1xuXHR9XG5cblx0Ly8gRnJhY3Rpb24gcGFydD8gT25seSBpbmNsdWRlZCBpZiAxIG9yIDIuXG5cdC8vIDE6IFVzaW5nIHNpZ25pZmljYW50IGRpZ2l0IGZvcm1hdC5cblx0Ly8gMjogVXNpbmcgaW50ZWdlciBhbmQgZnJhY3Rpb25hbCBmb3JtYXQgJiYgaXQgaGFzIGEgbWF4aW11bUZyYWN0aW9uRGlnaXRzLlxuXHRpZiAoICFpc05hTiggbWluaW11bVNpZ25pZmljYW50RGlnaXRzICogbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkgfHwgLyogMSAqL1xuXHRcdFx0XHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgLyogMiAqLyApIHtcblxuXHRcdC8vIDE6IEhhbmRsZSB0cmFpbGluZyBkZWNpbWFsIHNlcGFyYXRvciwgZS5nLiwgYFwiMS5cIiA9PiBgMWBgLlxuXHRcdGF1eCA9IGRlY2ltYWxTeW1ib2xSZSArIGRpZ2l0c1JlICsgXCIrXCI7XG5cdFx0bnVtYmVyVG9rZW5pemVyID0gbnVtYmVyVG9rZW5pemVyICsgXCIoXCIgKyBhdXggKyBcInxcIiArIGRlY2ltYWxTeW1ib2xSZSAvKiAxICovICsgXCIpP1wiICtcblxuXHRcdFx0Ly8gSGFuZGxlIG5vbi1wYWRkZWQgZGVjaW1hbHMsIGUuZy4sIGBcIi4xMlwiYCA9PiBgMC4xMmAgYnkgbWFraW5nIHRoZSBpbnRlZ2VyIHBhcnRcblx0XHRcdC8vIG9wdGlvbmFsLlxuXHRcdFx0XCJ8KFwiICsgbnVtYmVyVG9rZW5pemVyICsgXCIpP1wiICsgYXV4O1xuXG5cdFx0bnVtYmVyVG9rZW5pemVyID0gXCIoXCIgKyBudW1iZXJUb2tlbml6ZXIgKyBcIilcIjtcblx0fVxuXG5cdC8vIDA6IEBpbnZlcnRlZFN5bWJvbE1hcCBbT2JqZWN0XSBJbnZlcnRlZCBzeW1ib2wgbWFwLlxuXHQvLyAxOiBAaW52ZXJ0ZWROdURpZ2l0c01hcCBbT2JqZWN0XSBJbnZlcnRlZCBkaWdpdHMgbWFwIGlmIG51bWJlcmluZyBzeXN0ZW0gaXMgZGlmZmVyZW50IHRoYW5cblx0Ly8gICAgYGxhdG5gLlxuXHQvLyAyOiBAdG9rZW5pemVyIFtPYmplY3RdIFRva2VuaXplciBtYXAsIHVzZWQgYnkgcGFyc2VyIHRvIGNvbnN1bWUgaW5wdXQuXG5cdHJldHVybiBbXG5cdFx0aW52ZXJ0ZWRTeW1ib2xNYXAsXG5cdFx0aW52ZXJ0ZWROdURpZ2l0c01hcCxcblx0XHR7XG5cdFx0XHRpbmZpbml0eTogbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIGluZmluaXR5U3ltYm9sICkgKSxcblx0XHRcdG5hbjogIG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBuYW5TeW1ib2wgKSApLFxuXHRcdFx0bmVnYXRpdmVQcmVmaXg6IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBuZWdhdGl2ZVByZWZpeCApICksXG5cdFx0XHRuZWdhdGl2ZVN1ZmZpeDogbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIG5lZ2F0aXZlU3VmZml4ICkgKSxcblx0XHRcdG51bWJlcjogbmV3IFJlZ0V4cCggXCJeXCIgKyBudW1iZXJUb2tlbml6ZXIgKSxcblx0XHRcdHByZWZpeDogbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIHByZWZpeCApICksXG5cdFx0XHRzdWZmaXg6IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBzdWZmaXggKSApXG5cdFx0fVxuXHRdO1xuXG59O1xuXG5cblxuXG4vKipcbiAqIFBhdHRlcm4oIHN0eWxlIClcbiAqXG4gKiBAc3R5bGUgW1N0cmluZ10gXCJkZWNpbWFsXCIgKGRlZmF1bHQpIG9yIFwicGVyY2VudFwiLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqL1xudmFyIG51bWJlclBhdHRlcm4gPSBmdW5jdGlvbiggc3R5bGUsIGNsZHIgKSB7XG5cdGlmICggc3R5bGUgIT09IFwiZGVjaW1hbFwiICYmIHN0eWxlICE9PSBcInBlcmNlbnRcIiApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiSW52YWxpZCBzdHlsZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gY2xkci5tYWluKFtcblx0XHRcIm51bWJlcnNcIixcblx0XHRzdHlsZSArIFwiRm9ybWF0cy1udW1iZXJTeXN0ZW0tXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKSxcblx0XHRcInN0YW5kYXJkXCJcblx0XSk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpZ2l0cyggcHJvcGVydGllcyApIHtcblx0dmFyIG1pbmltdW1JbnRlZ2VyRGlnaXRzID0gcHJvcGVydGllc1sgMiBdLFxuXHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IHByb3BlcnRpZXNbIDMgXSxcblx0XHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBwcm9wZXJ0aWVzWyA0IF0sXG5cdFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzID0gcHJvcGVydGllc1sgNSBdLFxuXHRcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IHByb3BlcnRpZXNbIDYgXTtcblxuXHQvLyBWYWxpZGF0ZSBzaWduaWZpY2FudCBkaWdpdCBmb3JtYXQgcHJvcGVydGllc1xuXHRpZiAoICFpc05hTiggbWluaW11bVNpZ25pZmljYW50RGlnaXRzICogbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSggbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBcIm1pbmltdW1TaWduaWZpY2FudERpZ2l0c1wiLCAxLCAyMSApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UoIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgXCJtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHNcIixcblx0XHRcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgMjEgKTtcblxuXHR9IGVsc2UgaWYgKCAhaXNOYU4oIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyApIHx8ICFpc05hTiggbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIk5laXRoZXIgb3IgYm90aCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBzaWduaWZpY2FudCBkaWdpdHMgbXVzdCBiZSBcIiArXG5cdFx0XHRcInByZXNlbnRcIiApO1xuXG5cdC8vIFZhbGlkYXRlIGludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0XG5cdH0gZWxzZSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSggbWluaW11bUludGVnZXJEaWdpdHMsIFwibWluaW11bUludGVnZXJEaWdpdHNcIiwgMSwgMjEgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIFwibWluaW11bUZyYWN0aW9uRGlnaXRzXCIsIDAsIDIwICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSggbWF4aW11bUZyYWN0aW9uRGlnaXRzLCBcIm1heGltdW1GcmFjdGlvbkRpZ2l0c1wiLFxuXHRcdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzLCAyMCApO1xuXHR9XG59XG5cbi8qKlxuICogLm51bWJlckZvcm1hdHRlciggW29wdGlvbnNdIClcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTpcbiAqIC0gc3R5bGU6IFtTdHJpbmddIFwiZGVjaW1hbFwiIChkZWZhdWx0KSBvciBcInBlcmNlbnRcIi5cbiAqIC0gc2VlIGFsc28gbnVtYmVyL2Zvcm1hdCBvcHRpb25zLlxuICpcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIG51bWJlciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIGRlZmF1bHQvaW5zdGFuY2VcbiAqIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLm51bWJlckZvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLm51bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgcGF0dGVybiwgcHJvcGVydGllcywgcmV0dXJuRm47XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cblx0YXJncyA9IFsgb3B0aW9ucyBdO1xuXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXG5cdGlmICggb3B0aW9ucy5yYXcgKSB7XG5cdFx0cGF0dGVybiA9IG9wdGlvbnMucmF3O1xuXHR9IGVsc2Uge1xuXHRcdHBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuKCBvcHRpb25zLnN0eWxlIHx8IFwiZGVjaW1hbFwiLCBjbGRyICk7XG5cdH1cblxuXHRwcm9wZXJ0aWVzID0gbnVtYmVyRm9ybWF0UHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApO1xuXG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblxuXHR2YWxpZGF0ZURpZ2l0cyggcHJvcGVydGllcyApO1xuXG5cdHJldHVybkZuID0gbnVtYmVyRm9ybWF0dGVyRm4oIHByb3BlcnRpZXMgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgcHJvcGVydGllcyBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAubnVtYmVyUGFyc2VyKCBbb3B0aW9uc10gKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOlxuICogLSBzdHlsZTogW1N0cmluZ10gXCJkZWNpbWFsXCIgKGRlZmF1bHQpIG9yIFwicGVyY2VudFwiLlxuICpcbiAqIFJldHVybiB0aGUgbnVtYmVyIHBhcnNlciBhY2NvcmRpbmcgdG8gdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUubnVtYmVyUGFyc2VyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUubnVtYmVyUGFyc2VyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBwYXR0ZXJuLCBwcm9wZXJ0aWVzLCByZXR1cm5GbjtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Y2xkciA9IHRoaXMuY2xkcjtcblxuXHRhcmdzID0gWyBvcHRpb25zIF07XG5cblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cblx0aWYgKCBvcHRpb25zLnJhdyApIHtcblx0XHRwYXR0ZXJuID0gb3B0aW9ucy5yYXc7XG5cdH0gZWxzZSB7XG5cdFx0cGF0dGVybiA9IG51bWJlclBhdHRlcm4oIG9wdGlvbnMuc3R5bGUgfHwgXCJkZWNpbWFsXCIsIGNsZHIgKTtcblx0fVxuXG5cdHByb3BlcnRpZXMgPSBudW1iZXJQYXJzZVByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIsIG9wdGlvbnMgKTtcblxuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cblx0cmV0dXJuRm4gPSBudW1iZXJQYXJzZXJGbiggcHJvcGVydGllcyApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBwcm9wZXJ0aWVzIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5mb3JtYXROdW1iZXIoIHZhbHVlIFssIG9wdGlvbnNdIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl0gbnVtYmVyIHRvIGJlIGZvcm1hdHRlZC5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTogc2VlIG51bWJlci9mb3JtYXQtcHJvcGVydGllcy5cbiAqXG4gKiBGb3JtYXQgYSBudW1iZXIgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdE51bWJlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5udW1iZXJGb3JtYXR0ZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogLnBhcnNlTnVtYmVyKCB2YWx1ZSBbLCBvcHRpb25zXSApXG4gKlxuICogQHZhbHVlIFtTdHJpbmddXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06IFNlZSBudW1iZXJQYXJzZXIoKS5cbiAqXG4gKiBSZXR1cm4gdGhlIHBhcnNlZCBOdW1iZXIgKGluY2x1ZGluZyBJbmZpbml0eSkgb3IgTmFOIHdoZW4gdmFsdWUgaXMgaW52YWxpZC5cbiAqL1xuR2xvYmFsaXplLnBhcnNlTnVtYmVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUucGFyc2VOdW1iZXIgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMubnVtYmVyUGFyc2VyKCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIE9wdGltaXphdGlvbiB0byBhdm9pZCBkdXBsaWNhdGluZyBzb21lIGludGVybmFsIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cbiAqL1xuR2xvYmFsaXplLl9jcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSA9IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlO1xuR2xvYmFsaXplLl9udW1iZXJOdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJOdW1iZXJpbmdTeXN0ZW07XG5HbG9iYWxpemUuX251bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCA9IG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcDtcbkdsb2JhbGl6ZS5fbnVtYmVyUGF0dGVybiA9IG51bWJlclBhdHRlcm47XG5HbG9iYWxpemUuX251bWJlclN5bWJvbCA9IG51bWJlclN5bWJvbDtcbkdsb2JhbGl6ZS5fbG9vc2VNYXRjaGluZyA9IGxvb3NlTWF0Y2hpbmc7XG5HbG9iYWxpemUuX3JlbW92ZUxpdGVyYWxRdW90ZXMgPSByZW1vdmVMaXRlcmFsUXVvdGVzO1xuR2xvYmFsaXplLl9zdHJpbmdQYWQgPSBzdHJpbmdQYWQ7XG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlcjtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nID0gdmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nO1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9udW1iZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9udW1iZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiY2xkci9ldmVudFwiLFxuXHRcdFx0XCJjbGRyL3N1cHBsZW1lbnRhbFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gR2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHZhbGlkYXRlQ2xkciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyLFxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcbnZhciBNYWtlUGx1cmFsO1xuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuTWFrZVBsdXJhbCA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90b0FycmF5ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpID8gYXJyIDogQXJyYXkuZnJvbShhcnIpOyB9O1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH07XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cblxuLyoqXG4gKiBtYWtlLXBsdXJhbC5qcyAtLSBodHRwczovL2dpdGh1Yi5jb20vZWVtZWxpL21ha2UtcGx1cmFsLmpzL1xuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUgYnkgRWVtZWxpIEFybyA8ZWVtZWxpQGdtYWlsLmNvbT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVGhlIHNvZnR3YXJlIGlzIHByb3ZpZGVkIFwiYXMgaXNcIiBhbmQgdGhlIGF1dGhvciBkaXNjbGFpbXMgYWxsIHdhcnJhbnRpZXNcbiAqIHdpdGggcmVnYXJkIHRvIHRoaXMgc29mdHdhcmUgaW5jbHVkaW5nIGFsbCBpbXBsaWVkIHdhcnJhbnRpZXMgb2ZcbiAqIG1lcmNoYW50YWJpbGl0eSBhbmQgZml0bmVzcy4gSW4gbm8gZXZlbnQgc2hhbGwgdGhlIGF1dGhvciBiZSBsaWFibGUgZm9yXG4gKiBhbnkgc3BlY2lhbCwgZGlyZWN0LCBpbmRpcmVjdCwgb3IgY29uc2VxdWVudGlhbCBkYW1hZ2VzIG9yIGFueSBkYW1hZ2VzXG4gKiB3aGF0c29ldmVyIHJlc3VsdGluZyBmcm9tIGxvc3Mgb2YgdXNlLCBkYXRhIG9yIHByb2ZpdHMsIHdoZXRoZXIgaW4gYW5cbiAqIGFjdGlvbiBvZiBjb250cmFjdCwgbmVnbGlnZW5jZSBvciBvdGhlciB0b3J0aW91cyBhY3Rpb24sIGFyaXNpbmcgb3V0IG9mXG4gKiBvciBpbiBjb25uZWN0aW9uIHdpdGggdGhlIHVzZSBvciBwZXJmb3JtYW5jZSBvZiB0aGlzIHNvZnR3YXJlLlxuICovXG5cbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNlcik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBhcnNlciwgW3tcbiAgICAgICAga2V5OiAncGFyc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29uZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKGNvbmQgPT09ICdpID0gMCBvciBuID0gMScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ24gPj0gMCAmJiBuIDw9IDEnO1xuICAgICAgICAgICAgfWlmIChjb25kID09PSAnaSA9IDAsMScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ24gPj0gMCAmJiBuIDwgMic7XG4gICAgICAgICAgICB9aWYgKGNvbmQgPT09ICdpID0gMSBhbmQgdiA9IDAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52MCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduID09IDEgJiYgdjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmQucmVwbGFjZSgvKFt0dl0pICghPyk9IDAvZywgZnVuY3Rpb24gKG0sIHN5bSwgbm90ZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc24gPSBzeW0gKyAnMCc7XG4gICAgICAgICAgICAgICAgX3RoaXNbc25dID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90ZXEgPyAnIScgKyBzbiA6IHNuO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvXFxiW2ZpbnR2XVxcYi9nLCBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIF90aGlzW21dID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLyhbZmluXSkgJSAoMTArKS9nLCBmdW5jdGlvbiAobSwgc3ltLCBudW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc24gPSBzeW0gKyBudW07XG4gICAgICAgICAgICAgICAgX3RoaXNbc25dID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc247XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC9uMTArID0gMC9nLCAndDAgJiYgJCYnKS5yZXBsYWNlKC8oXFx3KyAoIT8pPSApKFswLTkuXSssWzAtOS4sXSspL2csIGZ1bmN0aW9uIChtLCBzZSwgbm90ZXEsIHgpIHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PT0gJ24gPSAwLDEnKSByZXR1cm4gJyhuID09IDAgfHwgbiA9PSAxKSc7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGVxKSByZXR1cm4gc2UgKyB4LnNwbGl0KCcsJykuam9pbignICYmICcgKyBzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIHNlICsgeC5zcGxpdCgnLCcpLmpvaW4oJyB8fCAnICsgc2UpICsgJyknO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvKFxcdyspICghPyk9IChbMC05XSspXFwuXFwuKFswLTldKykvZywgZnVuY3Rpb24gKG0sIHN5bSwgbm90ZXEsIHgwLCB4MSkge1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIoeDApICsgMSA9PT0gTnVtYmVyKHgxKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90ZXEpIHJldHVybiAnJyArIHN5bSArICcgIT0gJyArIHgwICsgJyAmJiAnICsgc3ltICsgJyAhPSAnICsgeDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBzeW0gKyAnID09ICcgKyB4MCArICcgfHwgJyArIHN5bSArICcgPT0gJyArIHgxICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm90ZXEpIHJldHVybiAnKCcgKyBzeW0gKyAnIDwgJyArIHgwICsgJyB8fCAnICsgc3ltICsgJyA+ICcgKyB4MSArICcpJztcbiAgICAgICAgICAgICAgICBpZiAoc3ltID09PSAnbicpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudDAgPSAxO3JldHVybiAnKHQwICYmIG4gPj0gJyArIHgwICsgJyAmJiBuIDw9ICcgKyB4MSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIHN5bSArICcgPj0gJyArIHgwICsgJyAmJiAnICsgc3ltICsgJyA8PSAnICsgeDEgKyAnKSc7XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC8gYW5kIC9nLCAnICYmICcpLnJlcGxhY2UoLyBvciAvZywgJyB8fCAnKS5yZXBsYWNlKC8gPSAvZywgJyA9PSAnKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndmFycycsXG4gICAgICAgIHZhbHVlOiAoZnVuY3Rpb24gKF92YXJzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB2YXJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdmFycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXJzLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdmFycy50b1N0cmluZygpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHZhcnM7XG4gICAgICAgIH0pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YXJzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5pKSB2YXJzLnB1c2goJ2kgPSBzWzBdJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5mIHx8IHRoaXMudikgdmFycy5wdXNoKCdmID0gc1sxXSB8fCBcXCdcXCcnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnQpIHZhcnMucHVzaCgndCA9IChzWzFdIHx8IFxcJ1xcJykucmVwbGFjZSgvMCskLywgXFwnXFwnKScpO1xuICAgICAgICAgICAgaWYgKHRoaXMudikgdmFycy5wdXNoKCd2ID0gZi5sZW5ndGgnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnYwKSB2YXJzLnB1c2goJ3YwID0gIXNbMV0nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnQwIHx8IHRoaXMubjEwIHx8IHRoaXMubjEwMCkgdmFycy5wdXNoKCd0MCA9IE51bWJlcihzWzBdKSA9PSBuJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoL14uMTArJC8udGVzdChrKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgazAgPSBrWzBdID09PSAnbicgPyAndDAgJiYgc1swXScgOiBrWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXJzLnB1c2goJycgKyBrICsgJyA9ICcgKyBrMCArICcuc2xpY2UoLScgKyBrLnN1YnN0cigyKS5sZW5ndGggKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1pZiAoIXZhcnMubGVuZ3RoKSByZXR1cm4gJyc7XG4gICAgICAgICAgICByZXR1cm4gJ3ZhciAnICsgWydzID0gU3RyaW5nKG4pLnNwbGl0KFxcJy5cXCcpJ10uY29uY2F0KHZhcnMpLmpvaW4oJywgJyk7XG4gICAgICAgIH0pXG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcbn0pKCk7XG5cblxuXG52YXIgTWFrZVBsdXJhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFrZVBsdXJhbChsYykge1xuICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gTWFrZVBsdXJhbCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgY2FyZGluYWxzID0gX3JlZi5jYXJkaW5hbHM7XG4gICAgICAgIHZhciBvcmRpbmFscyA9IF9yZWYub3JkaW5hbHM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1ha2VQbHVyYWwpO1xuXG4gICAgICAgIGlmICghY2FyZGluYWxzICYmICFvcmRpbmFscykgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdHlwZSBvZiBwbHVyYWwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgdGhpcy5sYyA9IGxjO1xuICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSB7IGNhcmRpbmFsOiBbXSwgb3JkaW5hbDogW10gfTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmZuID0gdGhpcy5idWlsZEZ1bmN0aW9uKGNhcmRpbmFscywgb3JkaW5hbHMpO1xuICAgICAgICB0aGlzLmZuLl9vYmogPSB0aGlzO1xuICAgICAgICB0aGlzLmZuLmNhdGVnb3JpZXMgPSB0aGlzLmNhdGVnb3JpZXM7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmZuLnRvU3RyaW5nID0gdGhpcy5mblRvU3RyaW5nLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZuO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhNYWtlUGx1cmFsLCBbe1xuICAgICAgICBrZXk6ICdjb21waWxlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUodHlwZSwgcmVxKSB7XG4gICAgICAgICAgICB2YXIgY2FzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBydWxlcyA9IE1ha2VQbHVyYWwucnVsZXNbdHlwZV1bdGhpcy5sY107XG4gICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcSkgdGhyb3cgbmV3IEVycm9yKCdMb2NhbGUgXCInICsgdGhpcy5sYyArICdcIiAnICsgdHlwZSArICcgcnVsZXMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVzW3R5cGVdID0gWydvdGhlciddO1xuICAgICAgICAgICAgICAgIHJldHVybiAnXFwnb3RoZXJcXCcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBfcnVsZXMkciR0cmltJHNwbGl0ID0gcnVsZXNbcl0udHJpbSgpLnNwbGl0KC9cXHMqQFxcdyovKTtcblxuICAgICAgICAgICAgICAgIHZhciBfcnVsZXMkciR0cmltJHNwbGl0MiA9IF90b0FycmF5KF9ydWxlcyRyJHRyaW0kc3BsaXQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBfcnVsZXMkciR0cmltJHNwbGl0MlswXTtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZXMgPSBfcnVsZXMkciR0cmltJHNwbGl0Mi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ID0gci5yZXBsYWNlKCdwbHVyYWxSdWxlLWNvdW50LScsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZCkgY2FzZXMucHVzaChbdGhpcy5wYXJzZXIucGFyc2UoY29uZCksIGNhdF0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVzW3R5cGVdID0gY2FzZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNbMV07XG4gICAgICAgICAgICB9KS5jb25jYXQoJ290aGVyJyk7XG4gICAgICAgICAgICBpZiAoY2FzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIGNhc2VzWzBdWzBdICsgJykgPyBcXCcnICsgY2FzZXNbMF1bMV0gKyAnXFwnIDogXFwnb3RoZXJcXCcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIGNbMF0gKyAnKSA/IFxcJycgKyBjWzFdICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfSkpLCBbJ1xcJ290aGVyXFwnJ10pLmpvaW4oJ1xcbiAgICAgIDogJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2J1aWxkRnVuY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRGdW5jdGlvbihjYXJkaW5hbHMsIG9yZGluYWxzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGNvbXBpbGUgPSBmdW5jdGlvbiBjb21waWxlKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyA/IChjWzFdID8gJ3JldHVybiAnIDogJ2lmIChvcmQpIHJldHVybiAnKSArIF90aGlzMy5jb21waWxlLmFwcGx5KF90aGlzMywgX3RvQ29uc3VtYWJsZUFycmF5KGMpKSA6ICcnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb2xkID0geyB2YXJzOiBmdW5jdGlvbiB2YXJzKHN0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcgICcgKyBzdHIgKyAnOycpLnJlcGxhY2UoLyguezEsNzh9KSgsfCQpID8vZywgJyQxJDJcXG4gICAgICAnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmQ6IGZ1bmN0aW9uIGNvbmQoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJyAgJyArIHN0ciArICc7JykucmVwbGFjZSgvKC57MSw3OH0pIChcXHxcXHwgfCQpID8vZ20sICckMVxcbiAgICAgICAgICAkMicpO1xuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBjb25kID0gW29yZGluYWxzICYmIFsnb3JkaW5hbCcsICFjYXJkaW5hbHNdLCBjYXJkaW5hbHMgJiYgWydjYXJkaW5hbCcsIHRydWVdXS5tYXAoY29tcGlsZSkubWFwKGZvbGQuY29uZCksXG4gICAgICAgICAgICAgICAgYm9keSA9IFtmb2xkLnZhcnModGhpcy5wYXJzZXIudmFycygpKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjb25kKSkuam9pbignXFxuJykucmVwbGFjZSgvXFxzKyQvZ20sICcnKS5yZXBsYWNlKC9eW1xccztdKltcXHJcXG5dKy9nbSwgJycpLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBvcmRpbmFscyAmJiBjYXJkaW5hbHMgPyAnbiwgb3JkJyA6ICduJztcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oYXJncywgYm9keSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZuVG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm5Ub1N0cmluZyhuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5mbikucmVwbGFjZSgvXmZ1bmN0aW9uKCBcXHcrKT8vLCBuYW1lID8gJ2Z1bmN0aW9uICcgKyBuYW1lIDogJ2Z1bmN0aW9uJykucmVwbGFjZSgnXFxuLyoqLycsICcnKTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdsb2FkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY2xkcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY2xkciAmJiBjbGRyLnN1cHBsZW1lbnRhbCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGRvZXMgbm90IGFwcGVhciB0byBiZSBDTERSIGRhdGEnKTtcbiAgICAgICAgICAgICAgICBNYWtlUGx1cmFsLnJ1bGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBjYXJkaW5hbDogZGF0YVsncGx1cmFscy10eXBlLWNhcmRpbmFsJ10gfHwgTWFrZVBsdXJhbC5ydWxlcy5jYXJkaW5hbCxcbiAgICAgICAgICAgICAgICAgICAgb3JkaW5hbDogZGF0YVsncGx1cmFscy10eXBlLW9yZGluYWwnXSB8fCBNYWtlUGx1cmFsLnJ1bGVzLm9yZGluYWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gTWFrZVBsdXJhbDtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNYWtlUGx1cmFsO1xufSkoKTtcblxuXG5cbk1ha2VQbHVyYWwuY2FyZGluYWxzID0gdHJ1ZTtcbk1ha2VQbHVyYWwub3JkaW5hbHMgPSBmYWxzZTtcbk1ha2VQbHVyYWwucnVsZXMgPSB7IGNhcmRpbmFsOiB7fSwgb3JkaW5hbDoge30gfTtcblxuXG5yZXR1cm4gTWFrZVBsdXJhbDtcbn0oKSk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiLFxuXHRcdFwiTnVtYmVyXCJcblx0KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbHVyYWxUeXBlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBcImNhcmRpbmFsXCIgfHwgdmFsdWUgPT09IFwib3JkaW5hbFwiLFxuXHRcdFwiU3RyaW5nIFxcXCJjYXJkaW5hbFxcXCIgb3IgXFxcIm9yZGluYWxcXFwiXCJcblx0KTtcbn07XG5cblxuXG5cbnZhciBwbHVyYWxHZW5lcmF0b3JGbiA9IGZ1bmN0aW9uKCBwbHVyYWwgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBwbHVyYWxHZW5lcmF0b3IoIHZhbHVlICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHJldHVybiBwbHVyYWwoIHZhbHVlICk7XG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIC5wbHVyYWwoIHZhbHVlIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl1cbiAqXG4gKiBSZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgZm9ybSAoemVybyB8IG9uZSB8IHR3byB8IGZldyB8IG1hbnkgfCBvdGhlcikgb2YgYVxuICogdmFsdWUgZ2l2ZW4gbG9jYWxlLlxuICovXG5HbG9iYWxpemUucGx1cmFsID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUucGx1cmFsID0gZnVuY3Rpb24oIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRyZXR1cm4gdGhpcy5wbHVyYWxHZW5lcmF0b3IoIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogLnBsdXJhbEdlbmVyYXRvciggW29wdGlvbnNdIClcbiAqXG4gKiBSZXR1cm4gYSBwbHVyYWwgZnVuY3Rpb24gKG9mIHRoZSBmb3JtIGJlbG93KS5cbiAqXG4gKiBmbiggdmFsdWUgKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXVxuICpcbiAqIFJldHVybiB0aGUgY29ycmVzcG9uZGluZyBmb3JtICh6ZXJvIHwgb25lIHwgdHdvIHwgZmV3IHwgbWFueSB8IG90aGVyKSBvZiBhIHZhbHVlIGdpdmVuIHRoZVxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5wbHVyYWxHZW5lcmF0b3IgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5wbHVyYWxHZW5lcmF0b3IgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIGlzT3JkaW5hbCwgcGx1cmFsLCByZXR1cm5GbiwgdHlwZTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Y2xkciA9IHRoaXMuY2xkcjtcblxuXHRhcmdzID0gWyBvcHRpb25zIF07XG5cdHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgXCJjYXJkaW5hbFwiO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsdXJhbFR5cGUoIG9wdGlvbnMudHlwZSwgXCJvcHRpb25zLnR5cGVcIiApO1xuXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdGlzT3JkaW5hbCA9IHR5cGUgPT09IFwib3JkaW5hbFwiO1xuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXHRjbGRyLnN1cHBsZW1lbnRhbChbIFwicGx1cmFscy10eXBlLVwiICsgdHlwZSwgXCJ7bGFuZ3VhZ2V9XCIgXSk7XG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblxuXHRNYWtlUGx1cmFsLnJ1bGVzID0ge307XG5cdE1ha2VQbHVyYWwucnVsZXNbIHR5cGUgXSA9IGNsZHIuc3VwcGxlbWVudGFsKCBcInBsdXJhbHMtdHlwZS1cIiArIHR5cGUgKTtcblxuXHRwbHVyYWwgPSBuZXcgTWFrZVBsdXJhbCggY2xkci5hdHRyaWJ1dGVzLmxhbmd1YWdlLCB7XG5cdFx0XCJvcmRpbmFsc1wiOiBpc09yZGluYWwsXG5cdFx0XCJjYXJkaW5hbHNcIjogIWlzT3JkaW5hbFxuXHR9KTtcblxuXHRyZXR1cm5GbiA9IHBsdXJhbEdlbmVyYXRvckZuKCBwbHVyYWwgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgcGx1cmFsIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9wbHVyYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9wbHVyYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IDIwMTAsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCIuL251bWJlclwiLFxuXHRcdFx0XCIuL3BsdXJhbFwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCIsXG5cdFx0XHRcImNsZHIvc3VwcGxlbWVudGFsXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBFeHRlbmQgZ2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBmb3JtYXRNZXNzYWdlID0gR2xvYmFsaXplLl9mb3JtYXRNZXNzYWdlLFxuXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHZhbGlkYXRlQ2xkciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyLFxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyO1xuXG5cbi8qKlxuICogZm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXSBUaGUgbnVtYmVyIHRvIGZvcm1hdFxuICpcbiAqIEBudW1iZXJGb3JtYXR0ZXIgW1N0cmluZ10gQSBudW1iZXJGb3JtYXR0ZXIgZnJvbSBHbG9iYWxpemUubnVtYmVyRm9ybWF0dGVyXG4gKlxuICogQHBsdXJhbEdlbmVyYXRvciBbU3RyaW5nXSBBIHBsdXJhbEdlbmVyYXRvciBmcm9tIEdsb2JhbGl6ZS5wbHVyYWxHZW5lcmF0b3JcbiAqXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBjb250YWluaW5nIHJlbGF0aXZlIHRpbWUgcGx1cmFsIG1lc3NhZ2UuXG4gKlxuICogRm9ybWF0IHJlbGF0aXZlIHRpbWUuXG4gKi9cbnZhciByZWxhdGl2ZVRpbWVGb3JtYXQgPSBmdW5jdGlvbiggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICkge1xuXG5cdHZhciByZWxhdGl2ZVRpbWUsXG5cdFx0bWVzc2FnZSA9IHByb3BlcnRpZXNbIFwicmVsYXRpdmUtdHlwZS1cIiArIHZhbHVlIF07XG5cblx0aWYgKCBtZXNzYWdlICkge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9XG5cblx0cmVsYXRpdmVUaW1lID0gdmFsdWUgPD0gMCA/IHByb3BlcnRpZXNbIFwicmVsYXRpdmVUaW1lLXR5cGUtcGFzdFwiIF1cblx0XHQ6IHByb3BlcnRpZXNbIFwicmVsYXRpdmVUaW1lLXR5cGUtZnV0dXJlXCIgXTtcblxuXHR2YWx1ZSA9IE1hdGguYWJzKCB2YWx1ZSApO1xuXG5cdG1lc3NhZ2UgPSByZWxhdGl2ZVRpbWVbIFwicmVsYXRpdmVUaW1lUGF0dGVybi1jb3VudC1cIiArIHBsdXJhbEdlbmVyYXRvciggdmFsdWUgKSBdO1xuXHRyZXR1cm4gZm9ybWF0TWVzc2FnZSggbWVzc2FnZSwgWyBudW1iZXJGb3JtYXR0ZXIoIHZhbHVlICkgXSApO1xufTtcblxuXG5cblxudmFyIHJlbGF0aXZlVGltZUZvcm1hdHRlckZuID0gZnVuY3Rpb24oIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gcmVsYXRpdmVUaW1lRm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHRyZXR1cm4gcmVsYXRpdmVUaW1lRm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKTtcblx0fTtcblxufTtcblxuXG5cblxuLyoqXG4gKiBwcm9wZXJ0aWVzKCB1bml0LCBjbGRyLCBvcHRpb25zIClcbiAqXG4gKiBAdW5pdCBbU3RyaW5nXSBlZy4gXCJkYXlcIiwgXCJ3ZWVrXCIsIFwibW9udGhcIiwgZXRjLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XVxuICogLSBmb3JtOiBbU3RyaW5nXSBlZy4gXCJzaG9ydFwiIG9yIFwibmFycm93XCIuIE9yIGZhbHN5IGZvciBkZWZhdWx0IGxvbmcgZm9ybS5cbiAqXG4gKiBSZXR1cm4gcmVsYXRpdmUgdGltZSBwcm9wZXJ0aWVzLlxuICovXG52YXIgcmVsYXRpdmVUaW1lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCB1bml0LCBjbGRyLCBvcHRpb25zICkge1xuXG5cdHZhciBmb3JtID0gb3B0aW9ucy5mb3JtLFxuXHRcdHJhdywgcHJvcGVydGllcywga2V5LCBtYXRjaDtcblxuXHRpZiAoIGZvcm0gKSB7XG5cdFx0dW5pdCA9IHVuaXQgKyBcIi1cIiArIGZvcm07XG5cdH1cblxuXHRyYXcgPSBjbGRyLm1haW4oIFsgXCJkYXRlc1wiLCBcImZpZWxkc1wiLCB1bml0IF0gKTtcblx0cHJvcGVydGllcyA9IHtcblx0XHRcInJlbGF0aXZlVGltZS10eXBlLWZ1dHVyZVwiOiByYXdbIFwicmVsYXRpdmVUaW1lLXR5cGUtZnV0dXJlXCIgXSxcblx0XHRcInJlbGF0aXZlVGltZS10eXBlLXBhc3RcIjogcmF3WyBcInJlbGF0aXZlVGltZS10eXBlLXBhc3RcIiBdXG5cdH07XG5cdGZvciAoIGtleSBpbiByYXcgKSB7XG5cdFx0aWYgKCByYXcuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0bWF0Y2ggPSAvcmVsYXRpdmUtdHlwZS0oLT9bMC05XSspLy5leGVjKCBrZXkgKTtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdHByb3BlcnRpZXNbIGtleSBdID0gcmF3WyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcHJvcGVydGllcztcbn07XG5cblxuXG5cbi8qKlxuICogLmZvcm1hdFJlbGF0aXZlVGltZSggdmFsdWUsIHVuaXQgWywgb3B0aW9uc10gKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXSBUaGUgbnVtYmVyIG9mIHVuaXQgdG8gZm9ybWF0LlxuICpcbiAqIEB1bml0IFtTdHJpbmddIHNlZSAucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCkgZm9yIGRldGFpbHMuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIC5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIoKSBmb3IgZGV0YWlscy5cbiAqXG4gKiBGb3JtYXRzIGEgcmVsYXRpdmUgdGltZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHVuaXQsIG9wdGlvbnMsIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXRSZWxhdGl2ZVRpbWUgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXRSZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiggdmFsdWUsIHVuaXQsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCB1bml0LCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIC5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIoIHVuaXQgWywgb3B0aW9ucyBdKVxuICpcbiAqIEB1bml0IFtTdHJpbmddIFN0cmluZyB2YWx1ZSBpbmRpY2F0aW5nIHRoZSB1bml0IHRvIGJlIGZvcm1hdHRlZC4gZWcuIFwiZGF5XCIsIFwid2Vla1wiLCBcIm1vbnRoXCIsIGV0Yy5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XVxuICogLSBmb3JtOiBbU3RyaW5nXSBlZy4gXCJzaG9ydFwiIG9yIFwibmFycm93XCIuIE9yIGZhbHN5IGZvciBkZWZhdWx0IGxvbmcgZm9ybS5cbiAqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgcmVsYXRpdmUgdGltZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHVuaXQsIG9wdGlvbnMsIGFuZCB0aGVcbiAqIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUucmVsYXRpdmVUaW1lRm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUucmVsYXRpdmVUaW1lRm9ybWF0dGVyID0gZnVuY3Rpb24oIHVuaXQsIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcywgcmV0dXJuRm47XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdW5pdCwgXCJ1bml0XCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB1bml0LCBcInVuaXRcIiApO1xuXG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFyZ3MgPSBbIHVuaXQsIG9wdGlvbnMgXTtcblxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblx0cHJvcGVydGllcyA9IHJlbGF0aXZlVGltZVByb3BlcnRpZXMoIHVuaXQsIGNsZHIsIG9wdGlvbnMgKTtcblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXG5cdG51bWJlckZvcm1hdHRlciA9IHRoaXMubnVtYmVyRm9ybWF0dGVyKCBvcHRpb25zICk7XG5cdHBsdXJhbEdlbmVyYXRvciA9IHRoaXMucGx1cmFsR2VuZXJhdG9yKCk7XG5cblx0cmV0dXJuRm4gPSByZWxhdGl2ZVRpbWVGb3JtYXR0ZXJGbiggbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9yZWxhdGl2ZS10aW1lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCAyMDEwLCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbi8qIVxuICogR2xvYmFsaXplIHYxLjMuMCAyMDE3LTA3LTAzVDIxOjM3WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiLi9udW1iZXJcIixcblx0XHRcdFwiLi9wbHVyYWxcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEV4dGVuZCBnbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIGZvcm1hdE1lc3NhZ2UgPSBHbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2UsXG5cdHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0LFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlcixcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmc7XG5cblxuLyoqXG4gKiBmb3JtYXQoIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgdW5pdFByb3BlcmllcyApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdXG4gKlxuICogQG51bWJlckZvcm1hdHRlciBbT2JqZWN0XTogQSBudW1iZXJGb3JtYXR0ZXIgZnJvbSBHbG9iYWxpemUubnVtYmVyRm9ybWF0dGVyLlxuICpcbiAqIEBwbHVyYWxHZW5lcmF0b3IgW09iamVjdF06IEEgcGx1cmFsR2VuZXJhdG9yIGZyb20gR2xvYmFsaXplLnBsdXJhbEdlbmVyYXRvci5cbiAqXG4gKiBAdW5pdFByb3BlcmllcyBbT2JqZWN0XTogbG9jYWxpemVkIHVuaXQgZGF0YSBmcm9tIGNsZHIuXG4gKlxuICogRm9ybWF0IHVuaXRzIHN1Y2ggYXMgc2Vjb25kcywgbWludXRlcywgZGF5cywgd2Vla3MsIGV0Yy5cbiAqXG4gKiBPQlM6XG4gKlxuICogVW5pdCBTZXF1ZW5jZXMgYXJlIG5vdCBpbXBsZW1lbnRlZC5cbiAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzUvdHIzNS1nZW5lcmFsLmh0bWwjVW5pdF9TZXF1ZW5jZXNcbiAqXG4gKiBEdXJhdGlvbiBVbml0IChmb3IgY29tcG9zZWQgdGltZSB1bml0IGR1cmF0aW9ucykgaXMgbm90IGltcGxlbWVudGVkLlxuICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zNS90cjM1LWdlbmVyYWwuaHRtbCNkdXJhdGlvblVuaXRcbiAqL1xudmFyIHVuaXRGb3JtYXQgPSBmdW5jdGlvbiggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCB1bml0UHJvcGVydGllcyApIHtcblx0dmFyIGNvbXBvdW5kVW5pdFBhdHRlcm4gPSB1bml0UHJvcGVydGllcy5jb21wb3VuZFVuaXRQYXR0ZXJuLCBkaXZpZGVuZCwgZGl2aWRlbmRQcm9wZXJ0aWVzLFxuXHRcdGZvcm1hdHRlZFZhbHVlLCBkaXZpc29yLCBkaXZpc29yUHJvcGVydGllcywgbWVzc2FnZSwgcGx1cmFsVmFsdWU7XG5cblx0dW5pdFByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllcy51bml0UHJvcGVydGllcztcblx0Zm9ybWF0dGVkVmFsdWUgPSBudW1iZXJGb3JtYXR0ZXIoIHZhbHVlICk7XG5cdHBsdXJhbFZhbHVlID0gcGx1cmFsR2VuZXJhdG9yKCB2YWx1ZSApO1xuXG5cdC8vIGNvbXB1dGVkIGNvbXBvdW5kIHVuaXQsIGVnLiBcIm1lZ2FieXRlLXBlci1zZWNvbmRcIi5cblx0aWYgKCB1bml0UHJvcGVydGllcyBpbnN0YW5jZW9mIEFycmF5ICkge1xuXHRcdGRpdmlkZW5kUHJvcGVydGllcyA9IHVuaXRQcm9wZXJ0aWVzWyAwIF07XG5cdFx0ZGl2aXNvclByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllc1sgMSBdO1xuXG5cdFx0ZGl2aWRlbmQgPSBmb3JtYXRNZXNzYWdlKCBkaXZpZGVuZFByb3BlcnRpZXNbIHBsdXJhbFZhbHVlIF0sIFsgdmFsdWUgXSApO1xuXHRcdGRpdmlzb3IgPSBmb3JtYXRNZXNzYWdlKCBkaXZpc29yUHJvcGVydGllcy5vbmUsIFsgXCJcIiBdICkudHJpbSgpO1xuXG5cdFx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIGNvbXBvdW5kVW5pdFBhdHRlcm4sIFsgZGl2aWRlbmQsIGRpdmlzb3IgXSApO1xuXHR9XG5cblx0bWVzc2FnZSA9IHVuaXRQcm9wZXJ0aWVzWyBwbHVyYWxWYWx1ZSBdO1xuXG5cdHJldHVybiBmb3JtYXRNZXNzYWdlKCBtZXNzYWdlLCBbIGZvcm1hdHRlZFZhbHVlIF0gKTtcbn07XG5cblxuXG5cbnZhciB1bml0Rm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHVuaXRQcm9wZXJ0aWVzICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gdW5pdEZvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0cmV0dXJuIHVuaXRGb3JtYXQoIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgdW5pdFByb3BlcnRpZXMgKTtcblx0fTtcblxufTtcblxuXG5cblxuLyoqXG4gKiBjYXRlZ29yaWVzKClcbiAqXG4gKiBSZXR1cm4gYWxsIHVuaXQgY2F0ZWdvcmllcy5cbiAqL1xudmFyIHVuaXRDYXRlZ29yaWVzID0gWyBcImFjY2VsZXJhdGlvblwiLCBcImFuZ2xlXCIsIFwiYXJlYVwiLCBcImRpZ2l0YWxcIiwgXCJkdXJhdGlvblwiLCBcImxlbmd0aFwiLCBcIm1hc3NcIiwgXCJwb3dlclwiLFxuXCJwcmVzc3VyZVwiLCBcInNwZWVkXCIsIFwidGVtcGVyYXR1cmVcIiwgXCJ2b2x1bWVcIiBdO1xuXG5cblxuXG5mdW5jdGlvbiBzdHJpcFBsdXJhbEdhcmJhZ2UoIGRhdGEgKSB7XG5cdHZhciBhdXgsIHBsdXJhbENvdW50O1xuXG5cdGlmICggZGF0YSApIHtcblx0XHRhdXggPSB7fTtcblx0XHRmb3IgKCBwbHVyYWxDb3VudCBpbiBkYXRhICkge1xuXHRcdFx0YXV4WyBwbHVyYWxDb3VudC5yZXBsYWNlKCAvdW5pdFBhdHRlcm4tY291bnQtLywgXCJcIiApIF0gPSBkYXRhWyBwbHVyYWxDb3VudCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhdXg7XG59XG5cbi8qKlxuICogZ2V0KCB1bml0LCBmb3JtLCBjbGRyIClcbiAqXG4gKiBAdW5pdCBbU3RyaW5nXSBUaGUgZnVsbCB0eXBlLXVuaXQgbmFtZSAoZWcuIGR1cmF0aW9uLXNlY29uZCksIG9yIHRoZSBzaG9ydCB1bml0IG5hbWVcbiAqIChlZy4gc2Vjb25kKS5cbiAqXG4gKiBAZm9ybSBbU3RyaW5nXSBBIHN0cmluZyBkZXNjcmliaW5nIHRoZSBmb3JtIG9mIHRoZSB1bml0IHJlcHJlc2VudGF0aW9uIChlZy4gbG9uZyxcbiAqIHNob3J0LCBuYXJyb3cpLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gdGhlIHBsdXJhbCBtYXAgb2YgYSB1bml0LCBlZzogXCJzZWNvbmRcIlxuICogeyBcIm9uZVwiOiBcInswfSBzZWNvbmRcIixcbiAqICAgXCJvdGhlclwiOiBcInswfSBzZWNvbmRzXCIgfVxuICogfVxuICpcbiAqIE9yIHRoZSBBcnJheSBvZiBwbHVyYWwgbWFwcyBvZiBhIGNvbXBvdW5kLXVuaXQsIGVnOiBcImZvb3QtcGVyLXNlY29uZFwiXG4gKiBbIHsgXCJvbmVcIjogXCJ7MH0gZm9vdFwiLFxuICogICAgIFwib3RoZXJcIjogXCJ7MH0gZmVldFwiIH0sXG4gKiAgIHsgXCJvbmVcIjogXCJ7MH0gc2Vjb25kXCIsXG4gKiAgICAgXCJvdGhlclwiOiBcInswfSBzZWNvbmRzXCIgfSBdXG4gKlxuICogVXNlcyB0aGUgcHJlY29tcHV0ZWQgZm9ybSBvZiBhIGNvbXBvdW5kLXVuaXQgaWYgYXZhaWxhYmxlLCBlZzogXCJtaWxlLXBlci1ob3VyXCJcbiAqIHsgXCJkaXNwbGF5TmFtZVwiOiBcIm1pbGVzIHBlciBob3VyXCIsXG4gKiAgICBcInVuaXRQYXR0ZXJuLWNvdW50LW9uZVwiOiBcInswfSBtaWxlIHBlciBob3VyXCIsXG4gKiAgICBcInVuaXRQYXR0ZXJuLWNvdW50LW90aGVyXCI6IFwiezB9IG1pbGVzIHBlciBob3VyXCJcbiAqIH0sXG4gKlxuICogQWxzbyBzdXBwb3J0cyBcIi9cIiBpbnN0ZWFkIG9mIFwiLXBlci1cIiwgZWcuIFwiZm9vdC9zZWNvbmRcIiwgdXNpbmcgdGhlIHByZWNvbXB1dGVkIGZvcm0gaWZcbiAqIGF2YWlsYWJsZS5cbiAqXG4gKiBPciB0aGUgQXJyYXkgb2YgcGx1cmFsIG1hcHMgb2YgYSBjb21wb3VuZC11bml0LCBlZzogXCJmb290LXBlci1zZWNvbmRcIlxuICogWyB7IFwib25lXCI6IFwiezB9IGZvb3RcIixcbiAqICAgICBcIm90aGVyXCI6IFwiezB9IGZlZXRcIiB9LFxuICogICB7IFwib25lXCI6IFwiezB9IHNlY29uZFwiLFxuICogICAgIFwib3RoZXJcIjogXCJ7MH0gc2Vjb25kc1wiIH0gXVxuICpcbiAqIE9yIHVuZGVmaW5lZCBpbiBjYXNlIHRoZSB1bml0IChvciBhIHVuaXQgb2YgdGhlIGNvbXBvdW5kLXVuaXQpIGRvZXNuJ3QgZXhpc3QuXG4gKi9cbnZhciBnZXQgPSBmdW5jdGlvbiggdW5pdCwgZm9ybSwgY2xkciApIHtcblx0dmFyIHJldDtcblxuXHQvLyBFbnN1cmUgdGhhdCB3ZSBnZXQgdGhlICdwcmVjb21wdXRlZCcgZm9ybSwgaWYgcHJlc2VudC5cblx0dW5pdCA9IHVuaXQucmVwbGFjZSggL1xcLy8sIFwiLXBlci1cIiApO1xuXG5cdC8vIEdldCB1bml0IG9yIDxjYXRlZ29yeT4tdW5pdCAoZWcuIFwiZHVyYXRpb24tc2Vjb25kXCIpLlxuXHRbIFwiXCIgXS5jb25jYXQoIHVuaXRDYXRlZ29yaWVzICkuc29tZShmdW5jdGlvbiggY2F0ZWdvcnkgKSB7XG5cdFx0cmV0dXJuIHJldCA9IGNsZHIubWFpbihbXG5cdFx0XHRcInVuaXRzXCIsXG5cdFx0XHRmb3JtLFxuXHRcdFx0Y2F0ZWdvcnkubGVuZ3RoID8gY2F0ZWdvcnkgKyBcIi1cIiArIHVuaXQgOiB1bml0XG5cdFx0XSk7XG5cdH0pO1xuXG5cdC8vIFJlbmFtZSBrZXlzIHMvdW5pdFBhdHRlcm4tY291bnQtLy9nLlxuXHRyZXQgPSBzdHJpcFBsdXJhbEdhcmJhZ2UoIHJldCApO1xuXG5cdC8vIENvbXBvdW5kIFVuaXQsIGVnLiBcImZvb3QtcGVyLXNlY29uZFwiIG9yIFwiZm9vdC9zZWNvbmRcIi5cblx0aWYgKCAhcmV0ICYmICggLy1wZXItLyApLnRlc3QoIHVuaXQgKSApIHtcblxuXHRcdC8vIFwiU29tZSB1bml0cyBhbHJlYWR5IGhhdmUgJ3ByZWNvbXB1dGVkJyBmb3Jtcywgc3VjaCBhcyBraWxvbWV0ZXItcGVyLWhvdXI7XG5cdFx0Ly8gd2hlcmUgc3VjaCB1bml0cyBleGlzdCwgdGhleSBzaG91bGQgYmUgdXNlZCBpbiBwcmVmZXJlbmNlXCIgVVRTIzM1LlxuXHRcdC8vIE5vdGUgdGhhdCBwcmVjb21wdXRlZCBmb3JtIGhhcyBhbHJlYWR5IGJlZW4gaGFuZGxlZCBhYm92ZSAoIXJldCkuXG5cblx0XHQvLyBHZXQgYm90aCByZWN1cnNpdmVseS5cblx0XHR1bml0ID0gdW5pdC5zcGxpdCggXCItcGVyLVwiICk7XG5cdFx0cmV0ID0gdW5pdC5tYXAoZnVuY3Rpb24oIHVuaXQgKSB7XG5cdFx0XHRyZXR1cm4gZ2V0KCB1bml0LCBmb3JtLCBjbGRyICk7XG5cdFx0fSk7XG5cdFx0aWYgKCAhcmV0WyAwIF0gfHwgIXJldFsgMSBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG52YXIgdW5pdEdldCA9IGdldDtcblxuXG5cblxuLyoqXG4gKiBwcm9wZXJ0aWVzKCB1bml0LCBmb3JtLCBjbGRyIClcbiAqXG4gKiBAdW5pdCBbU3RyaW5nXSBUaGUgZnVsbCB0eXBlLXVuaXQgbmFtZSAoZWcuIGR1cmF0aW9uLXNlY29uZCksIG9yIHRoZSBzaG9ydCB1bml0IG5hbWVcbiAqIChlZy4gc2Vjb25kKS5cbiAqXG4gKiBAZm9ybSBbU3RyaW5nXSBBIHN0cmluZyBkZXNjcmliaW5nIHRoZSBmb3JtIG9mIHRoZSB1bml0IHJlcHJlc2VudGF0aW9uIChlZy4gbG9uZyxcbiAqIHNob3J0LCBuYXJyb3cpLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqL1xudmFyIHVuaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHVuaXQsIGZvcm0sIGNsZHIgKSB7XG5cdHZhciBjb21wb3VuZFVuaXRQYXR0ZXJuLCB1bml0UHJvcGVydGllcztcblxuXHRjb21wb3VuZFVuaXRQYXR0ZXJuID0gY2xkci5tYWluKCBbIFwidW5pdHNcIiwgZm9ybSwgXCJwZXIvY29tcG91bmRVbml0UGF0dGVyblwiIF0gKTtcblx0dW5pdFByb3BlcnRpZXMgPSB1bml0R2V0KCB1bml0LCBmb3JtLCBjbGRyICk7XG5cblx0cmV0dXJuIHtcblx0XHRjb21wb3VuZFVuaXRQYXR0ZXJuOiBjb21wb3VuZFVuaXRQYXR0ZXJuLFxuXHRcdHVuaXRQcm9wZXJ0aWVzOiB1bml0UHJvcGVydGllc1xuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiBHbG9iYWxpemUuZm9ybWF0VW5pdCggdmFsdWUsIHVuaXQsIG9wdGlvbnMgKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXVxuICpcbiAqIEB1bml0IFtTdHJpbmddOiBUaGUgdW5pdCAoZS5nIFwic2Vjb25kXCIsIFwiZGF5XCIsIFwieWVhclwiKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdXG4gKiAtIGZvcm06IFtTdHJpbmddIFwibG9uZ1wiLCBcInNob3J0XCIgKGRlZmF1bHQpLCBvciBcIm5hcnJvd1wiLlxuICpcbiAqIEZvcm1hdCB1bml0cyBzdWNoIGFzIHNlY29uZHMsIG1pbnV0ZXMsIGRheXMsIHdlZWtzLCBldGMuXG4gKi9cbkdsb2JhbGl6ZS5mb3JtYXRVbml0ID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0VW5pdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgdW5pdCwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy51bml0Rm9ybWF0dGVyKCB1bml0LCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIEdsb2JhbGl6ZS51bml0Rm9ybWF0dGVyKCB1bml0LCBvcHRpb25zIClcbiAqXG4gKiBAdW5pdCBbU3RyaW5nXTogVGhlIHVuaXQgKGUuZyBcInNlY29uZFwiLCBcImRheVwiLCBcInllYXJcIilcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XVxuICogLSBmb3JtOiBbU3RyaW5nXSBcImxvbmdcIiwgXCJzaG9ydFwiIChkZWZhdWx0KSwgb3IgXCJuYXJyb3dcIi5cbiAqXG4gKiAtIG51bWJlckZvcm1hdHRlcjogW0Z1bmN0aW9uXSBhIG51bWJlciBmb3JtYXR0ZXIgZnVuY3Rpb24uIERlZmF1bHRzIHRvIEdsb2JhbGl6ZVxuICogICBgLm51bWJlckZvcm1hdHRlcigpYCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlIHVzaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gKi9cbkdsb2JhbGl6ZS51bml0Rm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUudW5pdEZvcm1hdHRlciA9IGZ1bmN0aW9uKCB1bml0LCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgZm9ybSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHJldHVybkZuLCBwcm9wZXJ0aWVzO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHVuaXQsIFwidW5pdFwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdW5pdCwgXCJ1bml0XCIgKTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRhcmdzID0gWyB1bml0LCBvcHRpb25zIF07XG5cdGZvcm0gPSBvcHRpb25zLmZvcm0gfHwgXCJsb25nXCI7XG5cdHByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllcyggdW5pdCwgZm9ybSwgdGhpcy5jbGRyICk7XG5cblx0bnVtYmVyRm9ybWF0dGVyID0gb3B0aW9ucy5udW1iZXJGb3JtYXR0ZXIgfHwgdGhpcy5udW1iZXJGb3JtYXR0ZXIoKTtcblx0cGx1cmFsR2VuZXJhdG9yID0gdGhpcy5wbHVyYWxHZW5lcmF0b3IoKTtcblx0cmV0dXJuRm4gPSB1bml0Rm9ybWF0dGVyRm4oIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIHRoaXMuY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3VuaXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS91bml0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG5cbi8vIENvcmVcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggXCIuL2dsb2JhbGl6ZVwiICk7XG5cbi8vIEV4dGVudCBjb3JlIHdpdGggdGhlIGZvbGxvd2luZyBtb2R1bGVzXG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL21lc3NhZ2VcIiApO1xucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS9udW1iZXJcIiApO1xucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS9wbHVyYWxcIiApO1xuXG4vLyBMb2FkIGFmdGVyIGdsb2JhbGl6ZS9udW1iZXJcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvY3VycmVuY3lcIiApO1xucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS9kYXRlXCIgKTtcblxuLy8gTG9hZCBhZnRlciBnbG9iYWxpemUvbnVtYmVyIGFuZCBnbG9iYWxpemUvcGx1cmFsXG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWVcIiApO1xucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS91bml0XCIgKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3Qvbm9kZS1tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9ub2RlLW1haW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVpZGF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXG5cdFx0ZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsImltcG9ydCAqIGFzIGNzcyBmcm9tICcuL2FwcC5tLmNzcyc7XG5cbmNvbnN0IEFwcCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuXHRjb25zdCBGb28gPSBhd2FpdCBpbXBvcnQoJy4vRm9vJyk7XG5cdHJldHVybiBGb28uZGVmYXVsdDtcbn07XG5cbmNvbnN0IEJhciA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuXHRjb25zdCBCYXIgPSBhd2FpdCBpbXBvcnQoJy4vQmFyJyk7XG5cdHJldHVybiBCYXIuZGVmYXVsdDtcbn07XG5cbmNvbnN0IEJheiA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuXHRjb25zdCBCYXogPSBhd2FpdCBpbXBvcnQoJy4vQmF6Jyk7XG5cdHJldHVybiBCYXouZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZyhjc3MpO1xuXHRjb25zdCBiYXIgPSBhd2FpdCBCYXIoKTtcblx0Y29uc3QgYmF6ID0gYXdhaXQgQmF6KCk7XG5cdGJhcigpO1xuXHRiYXooKTtcblx0cmV0dXJuIEFwcCgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9jc3MtbW9kdWxlLWR0cy1sb2FkZXI/dHlwZT10cyZpbnN0YW5jZU5hbWU9MF9kb2pvIS4vc3JjL0FwcC50cyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcIiBfa2V5XCI6XCJhcHBcIixcInJvb3RcIjpcIll4dHRQRXgtXCJ9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC5tLmNzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvYXBwLm0uY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcIiBfa2V5XCI6XCJtYWluLmNzc1wiLFwiYXBwXCI6XCJRSEVGZ1NlSVwifTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluLmNzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvbWFpbi5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5pbXBvcnQgKiBhcyBjc3MgZnJvbSAnLi9hcHAubS5jc3MnO1xuaW1wb3J0IGhhcyBmcm9tICdAZG9qby9oYXMvaGFzJztcbichaGFzKFwiYmFyXCIpJztcbmltcG9ydCAnLi9CYXInO1xuXG5pZiAoaGFzKCdmb28nKSkge1xuXHRjb25zb2xlLmxvZygnZm9vJyk7XG59XG5cbkFwcCgpLnRoZW4ocmVzdWx0ID0+IHtcblx0Y29uc29sZS5sb2cocmVzdWx0KCkpO1xuXHRjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZGl2LmNsYXNzTGlzdC5hZGQoY3NzLnJvb3QpO1xuXHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvY3NzLW1vZHVsZS1kdHMtbG9hZGVyP3R5cGU9dHMmaW5zdGFuY2VOYW1lPTBfZG9qbyEuL3NyYy9tYWluLnRzIl0sInNvdXJjZVJvb3QiOiIifQ==